<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/builded_projects/age/src/backend/utils/adt/agtype.c"><comment type="block">/*
 * For PostgreSQL Database Management System:
 * (formerly known as Postgres, then as Postgres95)
 *
 * Portions Copyright (c) 1996-2010, The PostgreSQL Global Development Group
 *
 * Portions Copyright (c) 1994, The Regents of the University of California
 *
 * Permission to use, copy, modify, and distribute this software and its documentation for any purpose,
 * without fee, and without a written agreement is hereby granted, provided that the above copyright notice
 * and this paragraph and the following two paragraphs appear in all copies.
 *
 * IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR DIRECT,
 * INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS,
 * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF THE UNIVERSITY
 * OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
 * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 *
 * THE SOFTWARE PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND THE UNIVERSITY OF CALIFORNIA
 * HAS NO OBLIGATIONS TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
 */</comment>

<comment type="block">/*
 * I/O routines for agtype type
 *
 * Portions Copyright (c) 2014-2018, PostgreSQL Global Development Group
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;math.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/namespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_aggregate_d.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_collation_d.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_operator_d.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeAgg.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"funcapi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq/pqformat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_coerce.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/pg_list.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/fmgroids.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/int8.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/snapmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/typcache.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/age_vle.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/agtype.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/agtype_parser.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/ag_float8_supp.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/ag_graph.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/ag_label.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/graphid.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/numeric.h"</cpp:file></cpp:include>

<comment type="block">/* State structure for Percentile aggregate functions */</comment>
<typedef>typedef <type><struct>struct <name>PercentileGroupAggState</name>
<block>{
    <comment type="block">/* percentile value */</comment>
    <decl_stmt><decl><type><name>float8</name></type> <name>percentile</name></decl>;</decl_stmt>
    <comment type="block">/* Sort object we're accumulating data in: */</comment>
    <decl_stmt><decl><type><name>Tuplesortstate</name> <modifier>*</modifier></type><name>sortstate</name></decl>;</decl_stmt>
    <comment type="block">/* Number of normal rows inserted into sortstate: */</comment>
    <decl_stmt><decl><type><name>int64</name></type> <name>number_of_rows</name></decl>;</decl_stmt>
    <comment type="block">/* Have we already done tuplesort_performsort? */</comment>
    <decl_stmt><decl><type><name>bool</name></type> <name>sort_done</name></decl>;</decl_stmt>
}</block></struct></type> <name>PercentileGroupAggState</name>;</typedef>

<typedef>typedef <type><enum>enum <comment type="block">/* type categories for datum_to_agtype */</comment>
<block>{
    <decl><name>AGT_TYPE_NULL</name></decl>, <comment type="block">/* null, so we didn't bother to identify */</comment>
    <decl><name>AGT_TYPE_BOOL</name></decl>, <comment type="block">/* boolean (built-in types only) */</comment>
    <decl><name>AGT_TYPE_INTEGER</name></decl>, <comment type="block">/* Cypher Integer type */</comment>
    <decl><name>AGT_TYPE_FLOAT</name></decl>, <comment type="block">/* Cypher Float type */</comment>
    <decl><name>AGT_TYPE_NUMERIC</name></decl>, <comment type="block">/* numeric (ditto) */</comment>
    <decl><name>AGT_TYPE_DATE</name></decl>, <comment type="block">/* we use special formatting for datetimes */</comment>
    <decl><name>AGT_TYPE_TIMESTAMP</name></decl>, <comment type="block">/* we use special formatting for timestamp */</comment>
    <decl><name>AGT_TYPE_TIMESTAMPTZ</name></decl>, <comment type="block">/* ... and timestamptz */</comment>
    <decl><name>AGT_TYPE_AGTYPE</name></decl>, <comment type="block">/* AGTYPE */</comment>
    <decl><name>AGT_TYPE_JSON</name></decl>, <comment type="block">/* JSON */</comment>
    <decl><name>AGT_TYPE_JSONB</name></decl>, <comment type="block">/* JSONB */</comment>
    <decl><name>AGT_TYPE_ARRAY</name></decl>, <comment type="block">/* array */</comment>
    <decl><name>AGT_TYPE_COMPOSITE</name></decl>, <comment type="block">/* composite */</comment>
    <decl><name>AGT_TYPE_JSONCAST</name></decl>, <comment type="block">/* something with an explicit cast to JSON */</comment>
    <decl><name>AGT_TYPE_VERTEX</name></decl>,
    <decl><name>AGT_TYPE_OTHER</name></decl> <comment type="block">/* all else */</comment>
}</block></enum></type> <name>agt_type_category</name>;</typedef>

<function_decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>Datum</name></type> <name>agtype_from_cstring</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>size_t</name></type> <name>check_string_length</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>agtype_in_agtype_annotation</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>annotation</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>agtype_in_object_start</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>agtype_in_object_end</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>agtype_in_array_start</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>agtype_in_array_end</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>agtype_in_object_field_start</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>fname</name></decl></parameter>,
                                         <parameter><decl><type><name>bool</name></type> <name>isnull</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>agtype_put_escaped_value</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>out</name></decl></parameter>, <parameter><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>scalar_val</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>escape_agtype</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>is_decimal_needed</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>numstr</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>agtype_in_scalar</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>token</name></decl></parameter>,
                             <parameter><decl><type><name>agtype_token_type</name></type> <name>tokentype</name></decl></parameter>,
                             <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>annotation</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>agtype_categorize_type</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>typoid</name></decl></parameter>, <parameter><decl><type><name>agt_type_category</name> <modifier>*</modifier></type><name>tcategory</name></decl></parameter>,
                                   <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>outfuncoid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>composite_to_agtype</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>composite</name></decl></parameter>, <parameter><decl><type><name>agtype_in_state</name> <modifier>*</modifier></type><name>result</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>array_dim_to_agtype</name><parameter_list>(<parameter><decl><type><name>agtype_in_state</name> <modifier>*</modifier></type><name>result</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>dim</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ndims</name></decl></parameter>,
                                <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>dims</name></decl></parameter>, <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>vals</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>nulls</name></decl></parameter>,
                                <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>valcount</name></decl></parameter>, <parameter><decl><type><name>agt_type_category</name></type> <name>tcategory</name></decl></parameter>,
                                <parameter><decl><type><name>Oid</name></type> <name>outfuncoid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>array_to_agtype_internal</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>array</name></decl></parameter>, <parameter><decl><type><name>agtype_in_state</name> <modifier>*</modifier></type><name>result</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>datum_to_agtype</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>val</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_null</name></decl></parameter>, <parameter><decl><type><name>agtype_in_state</name> <modifier>*</modifier></type><name>result</name></decl></parameter>,
                            <parameter><decl><type><name>agt_type_category</name></type> <name>tcategory</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>outfuncoid</name></decl></parameter>,
                            <parameter><decl><type><name>bool</name></type> <name>key_scalar</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>agtype_to_cstring_worker</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>out</name></decl></parameter>, <parameter><decl><type><name>agtype_container</name> <modifier>*</modifier></type><name>in</name></decl></parameter>,
                                      <parameter><decl><type><name>int</name></type> <name>estimated_len</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>indent</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>text</name> <modifier>*</modifier></type><name>agtype_value_to_text</name><parameter_list>(<parameter><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>scalar_val</name></decl></parameter>,
                                  <parameter><decl><type><name>bool</name></type> <name>err_not_scalar</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>add_indent</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>out</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>indent</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>level</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>cannot_cast_agtype_value</name><parameter_list>(<parameter><decl><type><name><name>enum</name> <name>agtype_value_type</name></name></type> <name>type</name></decl></parameter>,
                                     <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sqltype</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>agtype_extract_scalar</name><parameter_list>(<parameter><decl><type><name>agtype_container</name> <modifier>*</modifier></type><name>agtc</name></decl></parameter>, <parameter><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>res</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>agtype_value</name> <modifier>*</modifier></type><name>execute_array_access_operator</name><parameter_list>(<parameter><decl><type><name>agtype</name> <modifier>*</modifier></type><name>array</name></decl></parameter>,
                                                   <parameter><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>array_value</name></decl></parameter>,
                                                   <parameter><decl><type><name>agtype</name> <modifier>*</modifier></type><name>array_index</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>agtype_value</name> <modifier>*</modifier></type><name>execute_array_access_operator_internal</name><parameter_list>(<parameter><decl><type><name>agtype</name> <modifier>*</modifier></type><name>array</name></decl></parameter>,
                                                            <parameter><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>array_value</name></decl></parameter>,
                                                            <parameter><decl><type><name>int64</name></type> <name>array_index</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>agtype_value</name> <modifier>*</modifier></type><name>execute_map_access_operator</name><parameter_list>(<parameter><decl><type><name>agtype</name> <modifier>*</modifier></type><name>map</name></decl></parameter>,
                                                 <parameter><decl><type><name>agtype_value</name><modifier>*</modifier></type> <name>map_value</name></decl></parameter>,
                                                 <parameter><decl><type><name>agtype</name> <modifier>*</modifier></type><name>key</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>agtype_value</name> <modifier>*</modifier></type><name>execute_map_access_operator_internal</name><parameter_list>(
    <parameter><decl><type><name>agtype</name> <modifier>*</modifier></type><name>map</name></decl></parameter>, <parameter><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>map_value</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>key_len</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>Datum</name></type> <name>agtype_object_field_impl</name><parameter_list>(<parameter><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>as_text</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>Datum</name></type> <name>agtype_array_element_impl</name><parameter_list>(<parameter><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>as_text</name></decl></parameter>)</parameter_list>;</function_decl>
<comment type="block">/* typecast functions */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>agtype_typecast_object</name><parameter_list>(<parameter><decl><type><name>agtype_in_state</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>annotation</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>agtype_typecast_array</name><parameter_list>(<parameter><decl><type><name>agtype_in_state</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>annotation</name></decl></parameter>)</parameter_list>;</function_decl>
<comment type="block">/* validation functions */</comment>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>is_object_vertex</name><parameter_list>(<parameter><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>agtv</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>is_object_edge</name><parameter_list>(<parameter><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>agtv</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>is_array_path</name><parameter_list>(<parameter><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>agtv</name></decl></parameter>)</parameter_list>;</function_decl>
<comment type="block">/* graph entity retrieval */</comment>
<function_decl><type><specifier>static</specifier> <name>Datum</name></type> <name>get_vertex</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>graph</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>vertex_label</name></decl></parameter>,
                        <parameter><decl><type><name>int64</name></type> <name>graphid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>get_label_name</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>graph_name</name></decl></parameter>, <parameter><decl><type><name>int64</name></type> <name>graph_id</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>float8</name></type> <name>get_float_compatible_arg</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>arg</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>funcname</name></decl></parameter>,
                                       <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>is_null</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Numeric</name></type> <name>get_numeric_compatible_arg</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>arg</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>funcname</name></decl></parameter>,
                                       <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>is_null</name></decl></parameter>,
                                       <parameter><decl><type><name><name>enum</name> <name>agtype_value_type</name></name> <modifier>*</modifier></type><name>ag_type</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>agtype</name> <modifier>*</modifier></type><name>get_one_agtype_from_variadic_args</name><parameter_list>(<parameter><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name></decl></parameter>,
                                                 <parameter><decl><type><name>int</name></type> <name>variadic_offset</name></decl></parameter>,
                                                 <parameter><decl><type><name>int</name></type> <name>expected_nargs</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>int64</name></type> <name>get_int64_from_int_datums</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>d</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>funcname</name></decl></parameter>,
                                       <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>is_agnull</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>agtype_iterator</name> <modifier>*</modifier></type><name>get_next_object_key</name><parameter_list>(<parameter><decl><type><name>agtype_iterator</name> <modifier>*</modifier></type><name>it</name></decl></parameter>,
                                             <parameter><decl><type><name>agtype_container</name> <modifier>*</modifier></type><name>agtc</name></decl></parameter>,
                                             <parameter><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>key</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>agtype_iterator</name> <modifier>*</modifier></type><name>get_next_list_element</name><parameter_list>(<parameter><decl><type><name>agtype_iterator</name> <modifier>*</modifier></type><name>it</name></decl></parameter>,
                                             <parameter><decl><type><name>agtype_container</name> <modifier>*</modifier></type><name>agtc</name></decl></parameter>,
                                             <parameter><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>elem</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>extract_variadic_args_min</name><parameter_list>(<parameter><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name></decl></parameter>,
                                     <parameter><decl><type><name>int</name></type> <name>variadic_start</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>convert_unknown</name></decl></parameter>,
                                     <parameter><decl><type><name>Datum</name> <modifier>*</modifier><modifier>*</modifier></type><name>args</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier><modifier>*</modifier></type><name>types</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier><modifier>*</modifier></type><name>nulls</name></decl></parameter>,
                                     <parameter><decl><type><name>int</name></type> <name>min_num_args</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>agtype_composite_to_agtype_value_binary</name><parameter_list>(<parameter><decl><type><name>agtype</name> <modifier>*</modifier></type><name>a</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* global storage of  OID for agtype and _agtype */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>Oid</name></type> <name>g_AGTYPEOID</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>Oid</name></type> <name>g_AGTYPEARRAYOID</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* helper function to quickly set, if necessary, and retrieve AGTYPEOID */</comment>
<function><type><name>Oid</name></type> <name>get_AGTYPEOID</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>g_AGTYPEOID</name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>g_AGTYPEOID</name> <operator>=</operator> <call><name>GetSysCacheOid2</name><argument_list>(<argument><expr><name>TYPENAMENSP</name></expr></argument>, <argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><literal type="string">"agtype"</literal></expr></argument>)</argument_list></call></expr></argument>,
                                      <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><call><name>ag_catalog_namespace_id</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>g_AGTYPEOID</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* helper function to quickly set, if necessary, and retrieve AGTYPEARRAYOID */</comment>
<function><type><name>Oid</name></type> <name>get_AGTYPEARRAYOID</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>g_AGTYPEARRAYOID</name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>g_AGTYPEARRAYOID</name> <operator>=</operator> <call><name>GetSysCacheOid2</name><argument_list>(<argument><expr><name>TYPENAMENSP</name></expr></argument>,
                                           <argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><literal type="string">"_agtype"</literal></expr></argument>)</argument_list></call></expr></argument>,
                                           <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><call><name>ag_catalog_namespace_id</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>g_AGTYPEARRAYOID</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* helper function to clear the AGTYPEOIDs after a drop extension */</comment>
<function><type><name>void</name></type> <name>clear_global_Oids_AGTYPE</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><name>g_AGTYPEOID</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>g_AGTYPEARRAYOID</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* fast helper function to test for AGTV_NULL in an agtype */</comment>
<function><type><name>bool</name></type> <name>is_agtype_null</name><parameter_list>(<parameter><decl><type><name>agtype</name> <modifier>*</modifier></type><name>agt_arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>agtype_container</name> <modifier>*</modifier></type><name>agtc</name> <init>= <expr><operator>&amp;</operator><name><name>agt_arg</name><operator>-&gt;</operator><name>root</name></name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>AGTYPE_CONTAINER_IS_SCALAR</name><argument_list>(<argument><expr><name>agtc</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
            <call><name>AGTE_IS_NULL</name><argument_list>(<argument><expr><name><name>agtc</name><operator>-&gt;</operator><name>children</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <return>return <expr><name>true</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * graphid_recv - converts external binary format to a graphid.
 *
 * Copied from PGs int8recv as a graphid is an int64.
 */</comment>

<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>graphid_recv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><name>Datum</name></type> <name>graphid_recv</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>StringInfo</name></type> <name>buf</name> <init>= <expr><operator>(</operator><name>StringInfo</name><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_INT64</name><argument_list>(<argument><expr><call><name>pq_getmsgint64</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * graphid_send - converts a graphid to binary format.
 *
 * Copied from PGs int8send as a graphid is an int64.
 */</comment>

<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>graphid_send</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><name>Datum</name></type> <name>graphid_send</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int64</name></type> <name>arg1</name> <init>= <expr><call><name>PG_GETARG_INT64</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>pq_begintypsend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pq_sendint64</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>arg1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PG_RETURN_BYTEA_P</name><argument_list>(<argument><expr><call><name>pq_endtypsend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * agtype recv function copied from PGs jsonb_recv as agtype is based
 * off of jsonb
 *
 * The type is sent as text in binary mode, so this is almost the same
 * as the input function, but it's prefixed with a version number so we
 * can change the binary format sent in future if necessary. For now,
 * only version 1 is supported.
 */</comment>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>agtype_recv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><name>Datum</name></type> <name>agtype_recv</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>StringInfo</name></type> <name>buf</name> <init>= <expr><operator>(</operator><name>StringInfo</name><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>version</name> <init>= <expr><call><name>pq_getmsgint</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nbytes</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>version</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>pq_getmsgtext</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>len</name></name> <operator>-</operator> <name><name>buf</name><operator>-&gt;</operator><name>cursor</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nbytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unsupported agtype version number %d"</literal></expr></argument>, <argument><expr><name>version</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <return>return <expr><call><name>agtype_from_cstring</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>nbytes</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * agtype send function copied from PGs jsonb_send as agtype is based
 * off of jsonb
 *
 * Just send agtype as a version number, then a string of text
 */</comment>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>agtype_send</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><name>Datum</name></type> <name>agtype_send</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>agtype</name> <modifier>*</modifier></type><name>agt</name> <init>= <expr><call><name>AG_GET_ARG_AGTYPE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>StringInfo</name></type> <name>agtype_text</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>version</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>agtype_to_cstring</name><argument_list>(<argument><expr><name>agtype_text</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>agt</name><operator>-&gt;</operator><name>root</name></name></expr></argument>, <argument><expr><call><name>VARSIZE</name><argument_list>(<argument><expr><name>agt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>pq_begintypsend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pq_sendint8</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>version</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pq_sendtext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>agtype_text</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>agtype_text</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>agtype_text</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>agtype_text</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_BYTEA_P</name><argument_list>(<argument><expr><call><name>pq_endtypsend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>agtype_in</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/*
 * agtype type input function
 */</comment>
<function><type><name>Datum</name></type> <name>agtype_in</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name> <init>= <expr><call><name>PG_GETARG_CSTRING</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <return>return <expr><call><name>agtype_from_cstring</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>agtype_out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/*
 * agtype type output function
 */</comment>
<function><type><name>Datum</name></type> <name>agtype_out</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>agtype</name> <modifier>*</modifier></type><name>agt</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>out</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>agt</name> <operator>=</operator> <call><name>AG_GET_ARG_AGTYPE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>out</name> <operator>=</operator> <call><name>agtype_to_cstring</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>agt</name><operator>-&gt;</operator><name>root</name></name></expr></argument>, <argument><expr><call><name>VARSIZE</name><argument_list>(<argument><expr><name>agt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_CSTRING</name><argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * agtype_from_cstring
 *
 * Turns agtype string into an agtype Datum.
 *
 * Uses the agtype parser (with hooks) to construct an agtype.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>Datum</name></type> <name>agtype_from_cstring</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>agtype_lex_context</name> <modifier>*</modifier></type><name>lex</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_in_state</name></type> <name>state</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_sem_action</name></type> <name>sem</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sem</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sem</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>lex</name> <operator>=</operator> <call><name>make_agtype_lex_context_cstring_len</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>sem</name><operator>.</operator><name>semstate</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>state</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>sem</name><operator>.</operator><name>object_start</name></name> <operator>=</operator> <name>agtype_in_object_start</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sem</name><operator>.</operator><name>array_start</name></name> <operator>=</operator> <name>agtype_in_array_start</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sem</name><operator>.</operator><name>object_end</name></name> <operator>=</operator> <name>agtype_in_object_end</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sem</name><operator>.</operator><name>array_end</name></name> <operator>=</operator> <name>agtype_in_array_end</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sem</name><operator>.</operator><name>scalar</name></name> <operator>=</operator> <name>agtype_in_scalar</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sem</name><operator>.</operator><name>object_field_start</name></name> <operator>=</operator> <name>agtype_in_object_field_start</name></expr>;</expr_stmt>
    <comment type="block">/* callback for annotation (typecasts) */</comment>
    <expr_stmt><expr><name><name>sem</name><operator>.</operator><name>agtype_annotation</name></name> <operator>=</operator> <name>agtype_in_agtype_annotation</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>parse_agtype</name><argument_list>(<argument><expr><name>lex</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* after parsing, the item member has the composed agtype structure */</comment>
    <expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><call><name>agtype_value_to_agtype</name><argument_list>(<argument><expr><name><name>state</name><operator>.</operator><name>res</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>size_t</name></type> <name>check_string_length</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <name>AGTENTRY_OFFLENMASK</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROGRAM_LIMIT_EXCEEDED</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"string too long to represent as agtype string"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Due to an implementation restriction, agtype strings cannot exceed %d bytes."</literal></expr></argument>,
                           <argument><expr><name>AGTENTRY_OFFLENMASK</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>len</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>agtype_in_object_start</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>agtype_in_state</name> <modifier>*</modifier></type><name>_state</name> <init>= <expr><operator>(</operator><name>agtype_in_state</name> <operator>*</operator><operator>)</operator><name>pstate</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>_state</name><operator>-&gt;</operator><name>res</name></name> <operator>=</operator> <call><name>push_agtype_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>_state</name><operator>-&gt;</operator><name>parse_state</name></name></expr></argument>, <argument><expr><name>WAGT_BEGIN_OBJECT</name></expr></argument>,
                                    <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>agtype_in_object_end</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>agtype_in_state</name> <modifier>*</modifier></type><name>_state</name> <init>= <expr><operator>(</operator><name>agtype_in_state</name> <operator>*</operator><operator>)</operator><name>pstate</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>_state</name><operator>-&gt;</operator><name>res</name></name> <operator>=</operator> <call><name>push_agtype_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>_state</name><operator>-&gt;</operator><name>parse_state</name></name></expr></argument>, <argument><expr><name>WAGT_END_OBJECT</name></expr></argument>,
                                    <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>agtype_in_array_start</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>agtype_in_state</name> <modifier>*</modifier></type><name>_state</name> <init>= <expr><operator>(</operator><name>agtype_in_state</name> <operator>*</operator><operator>)</operator><name>pstate</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>_state</name><operator>-&gt;</operator><name>res</name></name> <operator>=</operator> <call><name>push_agtype_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>_state</name><operator>-&gt;</operator><name>parse_state</name></name></expr></argument>, <argument><expr><name>WAGT_BEGIN_ARRAY</name></expr></argument>,
                                    <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>agtype_in_array_end</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>agtype_in_state</name> <modifier>*</modifier></type><name>_state</name> <init>= <expr><operator>(</operator><name>agtype_in_state</name> <operator>*</operator><operator>)</operator><name>pstate</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>_state</name><operator>-&gt;</operator><name>res</name></name> <operator>=</operator> <call><name>push_agtype_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>_state</name><operator>-&gt;</operator><name>parse_state</name></name></expr></argument>, <argument><expr><name>WAGT_END_ARRAY</name></expr></argument>,
                                    <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>agtype_in_object_field_start</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>fname</name></decl></parameter>,
                                         <parameter><decl><type><name>bool</name></type> <name>isnull</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>agtype_in_state</name> <modifier>*</modifier></type><name>_state</name> <init>= <expr><operator>(</operator><name>agtype_in_state</name> <operator>*</operator><operator>)</operator><name>pstate</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_value</name></type> <name>v</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>fname</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>v</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>AGTV_STRING</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>v</name><operator>.</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>len</name></name> <operator>=</operator> <call><name>check_string_length</name><argument_list>(<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>v</name><operator>.</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>val</name></name> <operator>=</operator> <name>fname</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>_state</name><operator>-&gt;</operator><name>res</name></name> <operator>=</operator> <call><name>push_agtype_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>_state</name><operator>-&gt;</operator><name>parse_state</name></name></expr></argument>, <argument><expr><name>WAGT_KEY</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* main in function to process annotations */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>agtype_in_agtype_annotation</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>annotation</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>agtype_in_state</name> <modifier>*</modifier></type><name>_state</name> <init>= <expr><operator>(</operator><name>agtype_in_state</name> <operator>*</operator><operator>)</operator><name>pstate</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* verify that our required params are not null */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>pstate</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>annotation</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* pass to the appropriate typecast routine */</comment>
    <switch>switch <condition>(<expr><name><name>_state</name><operator>-&gt;</operator><name>res</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition>
    <block>{<block_content>
    <case>case <expr><name>AGTV_OBJECT</name></expr>:</case>
        <expr_stmt><expr><call><name>agtype_typecast_object</name><argument_list>(<argument><expr><name>_state</name></expr></argument>, <argument><expr><name>annotation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
    <case>case <expr><name>AGTV_ARRAY</name></expr>:</case>
        <expr_stmt><expr><call><name>agtype_typecast_array</name><argument_list>(<argument><expr><name>_state</name></expr></argument>, <argument><expr><name>annotation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>

    <comment type="block">/*
     * Maybe we need to eventually move scalar annotations here. However,
     * we need to think about how an actual scalar value may be incorporated
     * into another object. Remember, the scalar is copied in on close, before
     * we would apply the annotation.
     */</comment>
    <default>default:</default>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unsupported type to annotate"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
    </block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/* function to handle object typecasts */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>agtype_typecast_object</name><parameter_list>(<parameter><decl><type><name>agtype_in_state</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>annotation</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>agtv</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>last_updated_value</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>top</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* verify that our required params are not null */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>annotation</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>state</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>annotation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>agtv</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>res</name></name></expr>;</expr_stmt>

    <comment type="block">/*
     * If the parse_state is not NULL, then we are not at the top level
     * and the following must be valid for a nested object with a typecast
     * at the end.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>parse_state</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>top</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>last_updated_value</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>parse_state</name><operator>-&gt;</operator><name>last_updated_value</name></name></expr>;</expr_stmt>
        <comment type="block">/* make sure there is a value just copied in */</comment>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>last_updated_value</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* and that it is of type object */</comment>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>last_updated_value</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AGTV_OBJECT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* check for a cast to a vertex */</comment>
    <if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">6</literal> <operator>&amp;&amp;</operator> <call><name>pg_strncasecmp</name><argument_list>(<argument><expr><name>annotation</name></expr></argument>, <argument><expr><literal type="string">"vertex"</literal></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* verify that the structure conforms to a valid vertex */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>is_object_vertex</name><argument_list>(<argument><expr><name>agtv</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>agtv</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>AGTV_VERTEX</name></expr>;</expr_stmt>
            <comment type="block">/* if it isn't the top, we need to adjust the copied value */</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>top</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>last_updated_value</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>AGTV_VERTEX</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"object is not a vertex"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

    </block_content>}</block></if>
    <comment type="block">/* check for a cast to an edge */</comment>
    <if type="elseif">else if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">4</literal> <operator>&amp;&amp;</operator> <call><name>pg_strncasecmp</name><argument_list>(<argument><expr><name>annotation</name></expr></argument>, <argument><expr><literal type="string">"edge"</literal></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* verify that the structure conforms to a valid edge */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>is_object_edge</name><argument_list>(<argument><expr><name>agtv</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>agtv</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>AGTV_EDGE</name></expr>;</expr_stmt>
            <comment type="block">/* if it isn't the top, we need to adjust the copied value */</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>top</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>last_updated_value</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>AGTV_EDGE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"object is not a edge"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if>
    <comment type="block">/* otherwise this isn't a supported typecast */</comment>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid annotation value for object"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* function to handle array typecasts */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>agtype_typecast_array</name><parameter_list>(<parameter><decl><type><name>agtype_in_state</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>annotation</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>agtv</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>last_updated_value</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>top</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* verify that our required params are not null */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>annotation</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>state</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>annotation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>agtv</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>res</name></name></expr>;</expr_stmt>

    <comment type="block">/*
     * If the parse_state is not NULL, then we are not at the top level
     * and the following must be valid for a nested array with a typecast
     * at the end.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>parse_state</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>top</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>last_updated_value</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>parse_state</name><operator>-&gt;</operator><name>last_updated_value</name></name></expr>;</expr_stmt>
        <comment type="block">/* make sure there is a value just copied in */</comment>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>last_updated_value</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* and that it is of type object */</comment>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>last_updated_value</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AGTV_ARRAY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* check for a cast to a path */</comment>
    <if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">4</literal> <operator>&amp;&amp;</operator> <call><name>pg_strncasecmp</name><argument_list>(<argument><expr><name>annotation</name></expr></argument>, <argument><expr><literal type="string">"path"</literal></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* verify that the array conforms to a valid path */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>is_array_path</name><argument_list>(<argument><expr><name>agtv</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>agtv</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>AGTV_PATH</name></expr>;</expr_stmt>
            <comment type="block">/* if it isn't the top, we need to adjust the copied value */</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>top</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>last_updated_value</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>AGTV_PATH</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"array is not a valid path"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if>
    <comment type="block">/* otherwise this isn't a supported typecast */</comment>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid annotation value for object"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* helper function to check if an object fits a vertex */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type> <name>is_object_vertex</name><parameter_list>(<parameter><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>agtv</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>bool</name></type> <name>has_id</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>has_label</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>has_properties</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

    <comment type="block">/* we require a valid object */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>agtv</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>agtv</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AGTV_OBJECT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* we need 3 pairs for a vertex */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>agtv</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>object</name><operator>.</operator><name>num_pairs</name></name> <operator>!=</operator> <literal type="number">3</literal></expr>)</condition>
    <block>{<block_content>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* iterate through all pairs */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>agtv</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>object</name><operator>.</operator><name>num_pairs</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>key</name> <init>= <expr><operator>&amp;</operator><name><name>agtv</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>object</name><operator>.</operator><name>pairs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>key</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>value</name> <init>= <expr><operator>&amp;</operator><name><name>agtv</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>object</name><operator>.</operator><name>pairs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>value</name></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>key_val</name> <init>= <expr><name><name>key</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>val</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>key_len</name> <init>= <expr><name><name>key</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>len</name></name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AGTV_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* check for an id of type integer */</comment>
        <if_stmt><if>if <condition>(<expr><name>key_len</name> <operator>==</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator>
            <call><name>pg_strncasecmp</name><argument_list>(<argument><expr><name>key_val</name></expr></argument>, <argument><expr><literal type="string">"id"</literal></expr></argument>, <argument><expr><name>key_len</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
            <name><name>value</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AGTV_INTEGER</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>has_id</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <comment type="block">/* check for a label of type string */</comment>
        <if type="elseif">else if <condition>(<expr><name>key_len</name> <operator>==</operator> <literal type="number">5</literal> <operator>&amp;&amp;</operator>
                 <call><name>pg_strncasecmp</name><argument_list>(<argument><expr><name>key_val</name></expr></argument>, <argument><expr><literal type="string">"label"</literal></expr></argument>, <argument><expr><name>key_len</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
                 <name><name>value</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AGTV_STRING</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>has_label</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <comment type="block">/* check for properties of type object */</comment>
        <if type="elseif">else if <condition>(<expr><name>key_len</name> <operator>==</operator> <literal type="number">10</literal> <operator>&amp;&amp;</operator>
                 <call><name>pg_strncasecmp</name><argument_list>(<argument><expr><name>key_val</name></expr></argument>, <argument><expr><literal type="string">"properties"</literal></expr></argument>, <argument><expr><name>key_len</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
                 <name><name>value</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AGTV_OBJECT</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>has_properties</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <comment type="block">/* if it gets to this point, it can't be a vertex */</comment>
        <else>else
        <block>{<block_content>
            <return>return <expr><name>false</name></expr>;</return>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>
    <return>return <expr><operator>(</operator><name>has_id</name> <operator>&amp;&amp;</operator> <name>has_label</name> <operator>&amp;&amp;</operator> <name>has_properties</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* helper function to check if an object fits an edge */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type> <name>is_object_edge</name><parameter_list>(<parameter><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>agtv</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>bool</name></type> <name>has_id</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>has_label</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>has_properties</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>has_start_id</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>has_end_id</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

    <comment type="block">/* we require a valid object */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>agtv</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>agtv</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AGTV_OBJECT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* we need 5 pairs for an edge */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>agtv</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>object</name><operator>.</operator><name>num_pairs</name></name> <operator>!=</operator> <literal type="number">5</literal></expr>)</condition>
    <block>{<block_content>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* iterate through the pairs */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>agtv</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>object</name><operator>.</operator><name>num_pairs</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>key</name> <init>= <expr><operator>&amp;</operator><name><name>agtv</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>object</name><operator>.</operator><name>pairs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>key</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>value</name> <init>= <expr><operator>&amp;</operator><name><name>agtv</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>object</name><operator>.</operator><name>pairs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>value</name></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>key_val</name> <init>= <expr><name><name>key</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>val</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>key_len</name> <init>= <expr><name><name>key</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>len</name></name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AGTV_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* check for an id of type integer */</comment>
        <if_stmt><if>if <condition>(<expr><name>key_len</name> <operator>==</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator>
            <call><name>pg_strncasecmp</name><argument_list>(<argument><expr><name>key_val</name></expr></argument>, <argument><expr><literal type="string">"id"</literal></expr></argument>, <argument><expr><name>key_len</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
            <name><name>value</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AGTV_INTEGER</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>has_id</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <comment type="block">/* check for a label of type string */</comment>
        <if type="elseif">else if <condition>(<expr><name>key_len</name> <operator>==</operator> <literal type="number">5</literal> <operator>&amp;&amp;</operator>
                 <call><name>pg_strncasecmp</name><argument_list>(<argument><expr><name>key_val</name></expr></argument>, <argument><expr><literal type="string">"label"</literal></expr></argument>, <argument><expr><name>key_len</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
                 <name><name>value</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AGTV_STRING</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>has_label</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <comment type="block">/* check for properties of type object */</comment>
        <if type="elseif">else if <condition>(<expr><name>key_len</name> <operator>==</operator> <literal type="number">10</literal> <operator>&amp;&amp;</operator>
                 <call><name>pg_strncasecmp</name><argument_list>(<argument><expr><name>key_val</name></expr></argument>, <argument><expr><literal type="string">"properties"</literal></expr></argument>, <argument><expr><name>key_len</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
                 <name><name>value</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AGTV_OBJECT</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>has_properties</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <comment type="block">/* check for a start_id of type integer */</comment>
        <if type="elseif">else if <condition>(<expr><name>key_len</name> <operator>==</operator> <literal type="number">8</literal> <operator>&amp;&amp;</operator>
                 <call><name>pg_strncasecmp</name><argument_list>(<argument><expr><name>key_val</name></expr></argument>, <argument><expr><literal type="string">"start_id"</literal></expr></argument>, <argument><expr><name>key_len</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
                 <name><name>value</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AGTV_INTEGER</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>has_start_id</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <comment type="block">/* check for an end_id of type integer */</comment>
        <if type="elseif">else if <condition>(<expr><name>key_len</name> <operator>==</operator> <literal type="number">6</literal> <operator>&amp;&amp;</operator>
                 <call><name>pg_strncasecmp</name><argument_list>(<argument><expr><name>key_val</name></expr></argument>, <argument><expr><literal type="string">"end_id"</literal></expr></argument>, <argument><expr><name>key_len</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
                 <name><name>value</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AGTV_INTEGER</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>has_end_id</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <comment type="block">/* if it gets to this point, it can't be an edge */</comment>
        <else>else
        <block>{<block_content>
            <return>return <expr><name>false</name></expr>;</return>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>
    <return>return <expr><operator>(</operator><name>has_id</name> <operator>&amp;&amp;</operator> <name>has_label</name> <operator>&amp;&amp;</operator> <name>has_properties</name> <operator>&amp;&amp;</operator>
            <name>has_start_id</name> <operator>&amp;&amp;</operator> <name>has_end_id</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* helper function to check if an array fits a path */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type> <name>is_array_path</name><parameter_list>(<parameter><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>agtv</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>element</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

    <comment type="block">/* we require a valid array */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>agtv</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>agtv</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AGTV_ARRAY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* the array needs to have an odd number of elements */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>agtv</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>array</name><operator>.</operator><name>num_elems</name></name> <operator>&lt;</operator> <literal type="number">1</literal> <operator>||</operator>
        <operator>(</operator><name><name>agtv</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>array</name><operator>.</operator><name>num_elems</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>%</operator> <literal type="number">2</literal> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* iterate through all elements */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><operator>(</operator><name>i</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>&lt;</operator> <name><name>agtv</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>array</name><operator>.</operator><name>num_elems</name></name></expr>;</condition> <incr><expr><name>i</name><operator>+=</operator><literal type="number">2</literal></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name>element</name> <operator>=</operator> <operator>&amp;</operator><name><name>agtv</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>array</name><operator>.</operator><name>elems</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>element</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>AGTV_VERTEX</name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>element</name> <operator>=</operator> <operator>&amp;</operator><name><name>agtv</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>array</name><operator>.</operator><name>elems</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>element</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>AGTV_EDGE</name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/* check the last element */</comment>
    <expr_stmt><expr><name>element</name> <operator>=</operator> <operator>&amp;</operator><name><name>agtv</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>array</name><operator>.</operator><name>elems</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>element</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>AGTV_VERTEX</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>agtype_put_escaped_value</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>out</name></decl></parameter>, <parameter><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>scalar_val</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>numstr</name></decl>;</decl_stmt>

    <switch>switch <condition>(<expr><name><name>scalar_val</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition>
    <block>{<block_content>
    <case>case <expr><name>AGTV_NULL</name></expr>:</case>
        <expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"null"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
    <case>case <expr><name>AGTV_STRING</name></expr>:</case>
        <expr_stmt><expr><call><name>escape_agtype</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><call><name>pnstrdup</name><argument_list>(<argument><expr><name><name>scalar_val</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>val</name></name></expr></argument>,
                                    <argument><expr><name><name>scalar_val</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
    <case>case <expr><name>AGTV_NUMERIC</name></expr>:</case>
        <expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(
            <argument><expr><name>out</name></expr></argument>, <argument><expr><call><name>DatumGetCString</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(
                     <argument><expr><name>numeric_out</name></expr></argument>, <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name><name>scalar_val</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>numeric</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"::numeric"</literal></expr></argument>, <argument><expr><literal type="number">9</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
    <case>case <expr><name>AGTV_INTEGER</name></expr>:</case>
        <expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(
            <argument><expr><name>out</name></expr></argument>, <argument><expr><call><name>DatumGetCString</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(
                     <argument><expr><name>int8out</name></expr></argument>, <argument><expr><call><name>Int64GetDatum</name><argument_list>(<argument><expr><name><name>scalar_val</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>int_value</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
    <case>case <expr><name>AGTV_FLOAT</name></expr>:</case>
        <expr_stmt><expr><name>numstr</name> <operator>=</operator> <call><name>DatumGetCString</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(
            <argument><expr><name>float8out</name></expr></argument>, <argument><expr><call><name>Float8GetDatum</name><argument_list>(<argument><expr><name><name>scalar_val</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>float_value</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>numstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>is_decimal_needed</name><argument_list>(<argument><expr><name>numstr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">".0"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <break>break;</break>
    <case>case <expr><name>AGTV_BOOL</name></expr>:</case>
        <if_stmt><if>if <condition>(<expr><name><name>scalar_val</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>boolean</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"true"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"false"</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        <break>break;</break>
    <case>case <expr><name>AGTV_VERTEX</name></expr>:</case>
    <block>{<block_content>
        <decl_stmt><decl><type><name>agtype</name> <modifier>*</modifier></type><name>prop</name></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>scalar_val</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>AGTV_OBJECT</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>prop</name> <operator>=</operator> <call><name>agtype_value_to_agtype</name><argument_list>(<argument><expr><name>scalar_val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>agtype_to_cstring_worker</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>prop</name><operator>-&gt;</operator><name>root</name></name></expr></argument>, <argument><expr><name><name>prop</name><operator>-&gt;</operator><name>vl_len_</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"::vertex"</literal></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>AGTV_EDGE</name></expr>:</case>
    <block>{<block_content>
        <decl_stmt><decl><type><name>agtype</name> <modifier>*</modifier></type><name>prop</name></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>scalar_val</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>AGTV_OBJECT</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>prop</name> <operator>=</operator> <call><name>agtype_value_to_agtype</name><argument_list>(<argument><expr><name>scalar_val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>agtype_to_cstring_worker</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>prop</name><operator>-&gt;</operator><name>root</name></name></expr></argument>, <argument><expr><name><name>prop</name><operator>-&gt;</operator><name>vl_len_</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"::edge"</literal></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>AGTV_PATH</name></expr>:</case>
    <block>{<block_content>
        <decl_stmt><decl><type><name>agtype</name> <modifier>*</modifier></type><name>prop</name></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>scalar_val</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>AGTV_ARRAY</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>prop</name> <operator>=</operator> <call><name>agtype_value_to_agtype</name><argument_list>(<argument><expr><name>scalar_val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>agtype_to_cstring_worker</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>prop</name><operator>-&gt;</operator><name>root</name></name></expr></argument>, <argument><expr><name><name>prop</name><operator>-&gt;</operator><name>vl_len_</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"::path"</literal></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
    </block_content>}</block>

    <default>default:</default>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unknown agtype scalar type"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 * Produce an agtype string literal, properly escaping characters in the text.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>escape_agtype</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>appendStringInfoCharMacro</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'"'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name>str</name></expr>;</init> <condition><expr><operator>*</operator><name>p</name></expr>;</condition> <incr><expr><name>p</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <switch>switch <condition>(<expr><operator>*</operator><name>p</name></expr>)</condition>
        <block>{<block_content>
        <case>case <expr><literal type="char">'\b'</literal></expr>:</case>
            <expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"\\b"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><literal type="char">'\f'</literal></expr>:</case>
            <expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"\\f"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><literal type="char">'\n'</literal></expr>:</case>
            <expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"\\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><literal type="char">'\r'</literal></expr>:</case>
            <expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"\\r"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><literal type="char">'\t'</literal></expr>:</case>
            <expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"\\t"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><literal type="char">'"'</literal></expr>:</case>
            <expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"\\\""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><literal type="char">'\\'</literal></expr>:</case>
            <expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"\\\\"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <default>default:</default>
            <if_stmt><if>if <condition>(<expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><operator>*</operator><name>p</name> <operator>&lt;</operator> <literal type="char">' '</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"\\u%04x"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>appendStringInfoCharMacro</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
            <break>break;</break>
        </block_content>}</block></switch>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>appendStringInfoCharMacro</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'"'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name>is_decimal_needed</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>numstr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>numstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>i</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>numstr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'-'</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>

    <while>while <condition>(<expr><name><name>numstr</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>numstr</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&lt;</operator> <literal type="char">'0'</literal> <operator>||</operator> <name><name>numstr</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;</operator> <literal type="char">'9'</literal></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></while>

    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * For agtype we always want the de-escaped value - that's what's in token
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>agtype_in_scalar</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>token</name></decl></parameter>,
                             <parameter><decl><type><name>agtype_token_type</name></type> <name>tokentype</name></decl></parameter>,
                             <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>annotation</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>agtype_in_state</name> <modifier>*</modifier></type><name>_state</name> <init>= <expr><operator>(</operator><name>agtype_in_state</name> <operator>*</operator><operator>)</operator><name>pstate</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_value</name></type> <name>v</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type> <name>numd</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Process the scalar typecast annotations, if present, but not if the
     * argument is a null. Typecasting a null is a null.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>annotation</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>tokentype</name> <operator>!=</operator> <name>AGTYPE_TOKEN_NULL</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>annotation</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">7</literal> <operator>&amp;&amp;</operator> <call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>annotation</name></expr></argument>, <argument><expr><literal type="string">"numeric"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>tokentype</name> <operator>=</operator> <name>AGTYPE_TOKEN_NUMERIC</name></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">7</literal> <operator>&amp;&amp;</operator> <call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>annotation</name></expr></argument>, <argument><expr><literal type="string">"integer"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>tokentype</name> <operator>=</operator> <name>AGTYPE_TOKEN_INTEGER</name></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">5</literal> <operator>&amp;&amp;</operator> <call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>annotation</name></expr></argument>, <argument><expr><literal type="string">"float"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>tokentype</name> <operator>=</operator> <name>AGTYPE_TOKEN_FLOAT</name></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid annotation value for scalar"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <switch>switch <condition>(<expr><name>tokentype</name></expr>)</condition>
    <block>{<block_content>
    <case>case <expr><name>AGTYPE_TOKEN_STRING</name></expr>:</case>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>token</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>v</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>AGTV_STRING</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>v</name><operator>.</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>len</name></name> <operator>=</operator> <call><name>check_string_length</name><argument_list>(<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>token</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>v</name><operator>.</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>val</name></name> <operator>=</operator> <name>token</name></expr>;</expr_stmt>
        <break>break;</break>
    <case>case <expr><name>AGTYPE_TOKEN_INTEGER</name></expr>:</case>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>token</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>v</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>AGTV_INTEGER</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>scanint8</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>v</name><operator>.</operator><name>val</name><operator>.</operator><name>int_value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
    <case>case <expr><name>AGTYPE_TOKEN_FLOAT</name></expr>:</case>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>token</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>v</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>AGTV_FLOAT</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>v</name><operator>.</operator><name>val</name><operator>.</operator><name>float_value</name></name> <operator>=</operator> <call><name>float8in_internal</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"double precision"</literal></expr></argument>,
                                              <argument><expr><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
    <case>case <expr><name>AGTYPE_TOKEN_NUMERIC</name></expr>:</case>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>token</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>v</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>AGTV_NUMERIC</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>numd</name> <operator>=</operator> <call><name>DirectFunctionCall3</name><argument_list>(<argument><expr><name>numeric_in</name></expr></argument>,
                                   <argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name>token</name></expr></argument>)</argument_list></call></expr></argument>,
                                   <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>InvalidOid</name></expr></argument>)</argument_list></call></expr></argument>,
                                   <argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>v</name><operator>.</operator><name>val</name><operator>.</operator><name>numeric</name></name> <operator>=</operator> <call><name>DatumGetNumeric</name><argument_list>(<argument><expr><name>numd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>

    <case>case <expr><name>AGTYPE_TOKEN_TRUE</name></expr>:</case>
        <expr_stmt><expr><name><name>v</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>AGTV_BOOL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>v</name><operator>.</operator><name>val</name><operator>.</operator><name>boolean</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        <break>break;</break>
    <case>case <expr><name>AGTYPE_TOKEN_FALSE</name></expr>:</case>
        <expr_stmt><expr><name><name>v</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>AGTV_BOOL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>v</name><operator>.</operator><name>val</name><operator>.</operator><name>boolean</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
        <break>break;</break>
    <case>case <expr><name>AGTYPE_TOKEN_NULL</name></expr>:</case>
        <expr_stmt><expr><name><name>v</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>AGTV_NULL</name></expr>;</expr_stmt>
        <break>break;</break>
    <default>default:</default>
        <comment type="block">/* should not be possible */</comment>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid agtype token type"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
    </block_content>}</block></switch>

    <if_stmt><if>if <condition>(<expr><name><name>_state</name><operator>-&gt;</operator><name>parse_state</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* single scalar */</comment>
        <decl_stmt><decl><type><name>agtype_value</name></type> <name>va</name></decl>;</decl_stmt>

        <expr_stmt><expr><name><name>va</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>AGTV_ARRAY</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>va</name><operator>.</operator><name>val</name><operator>.</operator><name>array</name><operator>.</operator><name>raw_scalar</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>va</name><operator>.</operator><name>val</name><operator>.</operator><name>array</name><operator>.</operator><name>num_elems</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>_state</name><operator>-&gt;</operator><name>res</name></name> <operator>=</operator> <call><name>push_agtype_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>_state</name><operator>-&gt;</operator><name>parse_state</name></name></expr></argument>, <argument><expr><name>WAGT_BEGIN_ARRAY</name></expr></argument>,
                                        <argument><expr><operator>&amp;</operator><name>va</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>_state</name><operator>-&gt;</operator><name>res</name></name> <operator>=</operator> <call><name>push_agtype_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>_state</name><operator>-&gt;</operator><name>parse_state</name></name></expr></argument>, <argument><expr><name>WAGT_ELEM</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>_state</name><operator>-&gt;</operator><name>res</name></name> <operator>=</operator> <call><name>push_agtype_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>_state</name><operator>-&gt;</operator><name>parse_state</name></name></expr></argument>, <argument><expr><name>WAGT_END_ARRAY</name></expr></argument>,
                                        <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <decl_stmt><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>o</name> <init>= <expr><operator>&amp;</operator><name><name>_state</name><operator>-&gt;</operator><name>parse_state</name><operator>-&gt;</operator><name>cont_val</name></name></expr></init></decl>;</decl_stmt>

        <switch>switch <condition>(<expr><name><name>o</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition>
        <block>{<block_content>
        <case>case <expr><name>AGTV_ARRAY</name></expr>:</case>
            <expr_stmt><expr><name><name>_state</name><operator>-&gt;</operator><name>res</name></name> <operator>=</operator> <call><name>push_agtype_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>_state</name><operator>-&gt;</operator><name>parse_state</name></name></expr></argument>, <argument><expr><name>WAGT_ELEM</name></expr></argument>,
                                            <argument><expr><operator>&amp;</operator><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>AGTV_OBJECT</name></expr>:</case>
            <expr_stmt><expr><name><name>_state</name><operator>-&gt;</operator><name>res</name></name> <operator>=</operator> <call><name>push_agtype_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>_state</name><operator>-&gt;</operator><name>parse_state</name></name></expr></argument>, <argument><expr><name>WAGT_VALUE</name></expr></argument>,
                                            <argument><expr><operator>&amp;</operator><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <default>default:</default>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected parent of nested structure"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></switch>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * agtype_to_cstring
 *     Converts agtype value to a C-string.
 *
 * If 'out' argument is non-null, the resulting C-string is stored inside the
 * StringBuffer.  The resulting string is always returned.
 *
 * A typical case for passing the StringInfo in rather than NULL is where the
 * caller wants access to the len attribute without having to call strlen, e.g.
 * if they are converting it to a text* object.
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type><name>agtype_to_cstring</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>out</name></decl></parameter>, <parameter><decl><type><name>agtype_container</name> <modifier>*</modifier></type><name>in</name></decl></parameter>,
                        <parameter><decl><type><name>int</name></type> <name>estimated_len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>agtype_to_cstring_worker</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>in</name></expr></argument>, <argument><expr><name>estimated_len</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * same thing but with indentation turned on
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type><name>agtype_to_cstring_indent</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>out</name></decl></parameter>, <parameter><decl><type><name>agtype_container</name> <modifier>*</modifier></type><name>in</name></decl></parameter>,
                               <parameter><decl><type><name>int</name></type> <name>estimated_len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>agtype_to_cstring_worker</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>in</name></expr></argument>, <argument><expr><name>estimated_len</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * common worker for above two functions
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>agtype_to_cstring_worker</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>out</name></decl></parameter>, <parameter><decl><type><name>agtype_container</name> <modifier>*</modifier></type><name>in</name></decl></parameter>,
                                      <parameter><decl><type><name>int</name></type> <name>estimated_len</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>indent</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>bool</name></type> <name>first</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_iterator</name> <modifier>*</modifier></type><name>it</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_value</name></type> <name>v</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_iterator_token</name></type> <name>type</name> <init>= <expr><name>WAGT_DONE</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>level</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>redo_switch</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* If we are indenting, don't add a space after a comma */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>ispaces</name> <init>= <expr><ternary><condition><expr><name>indent</name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">2</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

    <comment type="block">/*
     * Don't indent the very first item. This gets set to the indent flag at
     * the bottom of the loop.
     */</comment>
    <decl_stmt><decl><type><name>bool</name></type> <name>use_indent</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>raw_scalar</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>last_was_key</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>out</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>out</name> <operator>=</operator> <call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>enlargeStringInfo</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><ternary><condition><expr><operator>(</operator><name>estimated_len</name> <operator>&gt;=</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><name>estimated_len</name></expr> </then><else>: <expr><literal type="number">64</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>it</name> <operator>=</operator> <call><name>agtype_iterator_init</name><argument_list>(<argument><expr><name>in</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <while>while <condition>(<expr><name>redo_switch</name> <operator>||</operator>
           <operator>(</operator><operator>(</operator><name>type</name> <operator>=</operator> <call><name>agtype_iterator_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name>it</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>v</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>WAGT_DONE</name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>redo_switch</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
        <switch>switch <condition>(<expr><name>type</name></expr>)</condition>
        <block>{<block_content>
        <case>case <expr><name>WAGT_BEGIN_ARRAY</name></expr>:</case>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>first</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>, <argument><expr><name>ispaces</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>v</name><operator>.</operator><name>val</name><operator>.</operator><name>array</name><operator>.</operator><name>raw_scalar</name></name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>add_indent</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>use_indent</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>last_was_key</name></expr></argument>, <argument><expr><name>level</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>appendStringInfoCharMacro</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="char">'['</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><name>raw_scalar</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>

            <expr_stmt><expr><name>first</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>level</name><operator>++</operator></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>WAGT_BEGIN_OBJECT</name></expr>:</case>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>first</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>, <argument><expr><name>ispaces</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <expr_stmt><expr><call><name>add_indent</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>use_indent</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>last_was_key</name></expr></argument>, <argument><expr><name>level</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>appendStringInfoCharMacro</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="char">'{'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name>first</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>level</name><operator>++</operator></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>WAGT_KEY</name></expr>:</case>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>first</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>, <argument><expr><name>ispaces</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>first</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>add_indent</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>use_indent</name></expr></argument>, <argument><expr><name>level</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* agtype rules guarantee this is a string */</comment>
            <expr_stmt><expr><call><name>agtype_put_escaped_value</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">": "</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>agtype_iterator_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name>it</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>v</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>WAGT_VALUE</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>first</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>agtype_put_escaped_value</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>type</name> <operator>==</operator> <name>WAGT_BEGIN_OBJECT</name> <operator>||</operator> <name>type</name> <operator>==</operator> <name>WAGT_BEGIN_ARRAY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/*
                 * We need to rerun the current switch() since we need to
                 * output the object which we just got from the iterator
                 * before calling the iterator again.
                 */</comment>
                <expr_stmt><expr><name>redo_switch</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
            <break>break;</break>
        <case>case <expr><name>WAGT_ELEM</name></expr>:</case>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>first</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>, <argument><expr><name>ispaces</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><name>first</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>raw_scalar</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>add_indent</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>use_indent</name></expr></argument>, <argument><expr><name>level</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <expr_stmt><expr><call><name>agtype_put_escaped_value</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>WAGT_END_ARRAY</name></expr>:</case>
            <expr_stmt><expr><name>level</name><operator>--</operator></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>raw_scalar</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>add_indent</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>use_indent</name></expr></argument>, <argument><expr><name>level</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>appendStringInfoCharMacro</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="char">']'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name>first</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>WAGT_END_OBJECT</name></expr>:</case>
            <expr_stmt><expr><name>level</name><operator>--</operator></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>add_indent</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>use_indent</name></expr></argument>, <argument><expr><name>level</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>appendStringInfoCharMacro</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="char">'}'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>first</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            <break>break;</break>
        <default>default:</default>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unknown agtype iterator token type"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></switch>
        <expr_stmt><expr><name>use_indent</name> <operator>=</operator> <name>indent</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>last_was_key</name> <operator>=</operator> <name>redo_switch</name></expr>;</expr_stmt>
    </block_content>}</block></while>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>level</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name><name>out</name><operator>-&gt;</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Convert agtype_value(scalar) to text
 */</comment>
<function><type><specifier>static</specifier> <name>text</name> <modifier>*</modifier></type><name>agtype_value_to_text</name><parameter_list>(<parameter><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>scalar_val</name></decl></parameter>,
                                  <parameter><decl><type><name>bool</name></type> <name>err_not_scalar</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>text</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <switch>switch <condition>(<expr><name><name>scalar_val</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition>
    <block>{<block_content>
    <case>case <expr><name>AGTV_INTEGER</name></expr>:</case>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>cstring_to_text</name><argument_list>(<argument><expr><call><name>DatumGetCString</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(
            <argument><expr><name>int8out</name></expr></argument>, <argument><expr><call><name>Int64GetDatum</name><argument_list>(<argument><expr><name><name>scalar_val</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>int_value</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
    <case>case <expr><name>AGTV_FLOAT</name></expr>:</case>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>cstring_to_text</name><argument_list>(<argument><expr><call><name>DatumGetCString</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(
            <argument><expr><name>float8out</name></expr></argument>, <argument><expr><call><name>Float8GetDatum</name><argument_list>(<argument><expr><name><name>scalar_val</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>float_value</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
    <case>case <expr><name>AGTV_STRING</name></expr>:</case>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>cstring_to_text_with_len</name><argument_list>(<argument><expr><name><name>scalar_val</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>val</name></name></expr></argument>,
                                          <argument><expr><name><name>scalar_val</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
    <case>case <expr><name>AGTV_NUMERIC</name></expr>:</case>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>cstring_to_text</name><argument_list>(<argument><expr><call><name>DatumGetCString</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(
            <argument><expr><name>numeric_out</name></expr></argument>, <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name><name>scalar_val</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>numeric</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
    <case>case <expr><name>AGTV_BOOL</name></expr>:</case>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>cstring_to_text</name><argument_list>(<argument><expr><ternary><condition><expr><operator>(</operator><name><name>scalar_val</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>boolean</name></name><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">"true"</literal></expr> </then><else>: <expr><literal type="string">"false"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
    <case>case <expr><name>AGTV_NULL</name></expr>:</case>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <break>break;</break>
    <default>default:</default>
        <if_stmt><if>if <condition>(<expr><name>err_not_scalar</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(
                <argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"agtype_value_to_text: unsupported argument agtype %d"</literal></expr></argument>,
                        <argument><expr><name><name>scalar_val</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></switch>
    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>add_indent</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>out</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>indent</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>level</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>indent</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>appendStringInfoCharMacro</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>level</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="string">"    "</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type> <name>integer_to_agtype</name><parameter_list>(<parameter><decl><type><name>int64</name></type> <name>i</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>agtype_value</name></type> <name>agtv</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype</name> <modifier>*</modifier></type><name>agt</name></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>agtv</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>AGTV_INTEGER</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>agtv</name><operator>.</operator><name>val</name><operator>.</operator><name>int_value</name></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>agt</name> <operator>=</operator> <call><name>agtype_value_to_agtype</name><argument_list>(<argument><expr><operator>&amp;</operator><name>agtv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><call><name>AGTYPE_P_GET_DATUM</name><argument_list>(<argument><expr><name>agt</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>Datum</name></type> <name>float_to_agtype</name><parameter_list>(<parameter><decl><type><name>float8</name></type> <name>f</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>agtype_value</name></type> <name>agtv</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype</name> <modifier>*</modifier></type><name>agt</name></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>agtv</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>AGTV_FLOAT</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>agtv</name><operator>.</operator><name>val</name><operator>.</operator><name>float_value</name></name> <operator>=</operator> <name>f</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>agt</name> <operator>=</operator> <call><name>agtype_value_to_agtype</name><argument_list>(<argument><expr><operator>&amp;</operator><name>agtv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><call><name>AGTYPE_P_GET_DATUM</name><argument_list>(<argument><expr><name>agt</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * s must be a UTF-8 encoded, unescaped, and null-terminated string which is
 * a valid string for internal storage of agtype.
 */</comment>
<function><type><name>Datum</name></type> <name>string_to_agtype</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>agtype_value</name></type> <name>agtv</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype</name> <modifier>*</modifier></type><name>agt</name></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>agtv</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>AGTV_STRING</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>agtv</name><operator>.</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>len</name></name> <operator>=</operator> <call><name>check_string_length</name><argument_list>(<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>agtv</name><operator>.</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>val</name></name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>agt</name> <operator>=</operator> <call><name>agtype_value_to_agtype</name><argument_list>(<argument><expr><operator>&amp;</operator><name>agtv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><call><name>AGTYPE_P_GET_DATUM</name><argument_list>(<argument><expr><name>agt</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>Datum</name></type> <name>boolean_to_agtype</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>agtype_value</name></type> <name>agtv</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype</name> <modifier>*</modifier></type><name>agt</name></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>agtv</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>AGTV_BOOL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>agtv</name><operator>.</operator><name>val</name><operator>.</operator><name>boolean</name></name> <operator>=</operator> <name>b</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>agt</name> <operator>=</operator> <call><name>agtype_value_to_agtype</name><argument_list>(<argument><expr><operator>&amp;</operator><name>agtv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><call><name>AGTYPE_P_GET_DATUM</name><argument_list>(<argument><expr><name>agt</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Determine how we want to render values of a given type in datum_to_agtype.
 *
 * Given the datatype OID, return its agt_type_category, as well as the type's
 * output function OID.  If the returned category is AGT_TYPE_JSONCAST,
 * we return the OID of the relevant cast function instead.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>agtype_categorize_type</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>typoid</name></decl></parameter>, <parameter><decl><type><name>agt_type_category</name> <modifier>*</modifier></type><name>tcategory</name></decl></parameter>,
                                   <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>outfuncoid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>bool</name></type> <name>typisvarlena</name></decl>;</decl_stmt>

    <comment type="block">/* Look through any domain */</comment>
    <expr_stmt><expr><name>typoid</name> <operator>=</operator> <call><name>getBaseType</name><argument_list>(<argument><expr><name>typoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><operator>*</operator><name>outfuncoid</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>

    <comment type="block">/*
     * We need to get the output function for everything except date and
     * timestamp types, booleans, array and composite types, json and jsonb,
     * and non-builtin types where there's a cast to json. In this last case
     * we return the oid of the cast function instead.
     */</comment>

    <switch>switch <condition>(<expr><name>typoid</name></expr>)</condition>
    <block>{<block_content>
    <case>case <expr><name>BOOLOID</name></expr>:</case>
        <expr_stmt><expr><operator>*</operator><name>tcategory</name> <operator>=</operator> <name>AGT_TYPE_BOOL</name></expr>;</expr_stmt>
        <break>break;</break>

    <case>case <expr><name>INT2OID</name></expr>:</case>
    <case>case <expr><name>INT4OID</name></expr>:</case>
    <case>case <expr><name>INT8OID</name></expr>:</case>
        <expr_stmt><expr><call><name>getTypeOutputInfo</name><argument_list>(<argument><expr><name>typoid</name></expr></argument>, <argument><expr><name>outfuncoid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typisvarlena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>tcategory</name> <operator>=</operator> <name>AGT_TYPE_INTEGER</name></expr>;</expr_stmt>
        <break>break;</break>

    <case>case <expr><name>FLOAT8OID</name></expr>:</case>
        <expr_stmt><expr><call><name>getTypeOutputInfo</name><argument_list>(<argument><expr><name>typoid</name></expr></argument>, <argument><expr><name>outfuncoid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typisvarlena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>tcategory</name> <operator>=</operator> <name>AGT_TYPE_FLOAT</name></expr>;</expr_stmt>
        <break>break;</break>

    <case>case <expr><name>FLOAT4OID</name></expr>:</case>
    <case>case <expr><name>NUMERICOID</name></expr>:</case>
        <expr_stmt><expr><call><name>getTypeOutputInfo</name><argument_list>(<argument><expr><name>typoid</name></expr></argument>, <argument><expr><name>outfuncoid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typisvarlena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>tcategory</name> <operator>=</operator> <name>AGT_TYPE_NUMERIC</name></expr>;</expr_stmt>
        <break>break;</break>

    <case>case <expr><name>DATEOID</name></expr>:</case>
        <expr_stmt><expr><operator>*</operator><name>tcategory</name> <operator>=</operator> <name>AGT_TYPE_DATE</name></expr>;</expr_stmt>
        <break>break;</break>

    <case>case <expr><name>TIMESTAMPOID</name></expr>:</case>
        <expr_stmt><expr><operator>*</operator><name>tcategory</name> <operator>=</operator> <name>AGT_TYPE_TIMESTAMP</name></expr>;</expr_stmt>
        <break>break;</break>

    <case>case <expr><name>TIMESTAMPTZOID</name></expr>:</case>
        <expr_stmt><expr><operator>*</operator><name>tcategory</name> <operator>=</operator> <name>AGT_TYPE_TIMESTAMPTZ</name></expr>;</expr_stmt>
        <break>break;</break>

    <case>case <expr><name>JSONBOID</name></expr>:</case>
        <expr_stmt><expr><operator>*</operator><name>tcategory</name> <operator>=</operator> <name>AGT_TYPE_JSONB</name></expr>;</expr_stmt>
        <break>break;</break>

    <case>case <expr><name>JSONOID</name></expr>:</case>
        <expr_stmt><expr><operator>*</operator><name>tcategory</name> <operator>=</operator> <name>AGT_TYPE_JSON</name></expr>;</expr_stmt>
        <break>break;</break>

    <default>default:</default>
        <comment type="block">/* Check for arrays and composites */</comment>
        <if_stmt><if>if <condition>(<expr><name>typoid</name> <operator>==</operator> <name>AGTYPEOID</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><operator>*</operator><name>tcategory</name> <operator>=</operator> <name>AGT_TYPE_AGTYPE</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><call><name>get_element_type</name><argument_list>(<argument><expr><name>typoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>||</operator>
                 <name>typoid</name> <operator>==</operator> <name>ANYARRAYOID</name> <operator>||</operator> <name>typoid</name> <operator>==</operator> <name>RECORDARRAYOID</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><operator>*</operator><name>tcategory</name> <operator>=</operator> <name>AGT_TYPE_ARRAY</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><call><name>type_is_rowtype</name><argument_list>(<argument><expr><name>typoid</name></expr></argument>)</argument_list></call></expr>)</condition> <comment type="block">/* includes RECORDOID */</comment>
        <block>{<block_content>
            <expr_stmt><expr><operator>*</operator><name>tcategory</name> <operator>=</operator> <name>AGT_TYPE_COMPOSITE</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>typoid</name> <operator>==</operator> <name>GRAPHIDOID</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>getTypeOutputInfo</name><argument_list>(<argument><expr><name>typoid</name></expr></argument>, <argument><expr><name>outfuncoid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typisvarlena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><operator>*</operator><name>tcategory</name> <operator>=</operator> <name>AGT_TYPE_INTEGER</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="block">/* It's probably the general case ... */</comment>
            <expr_stmt><expr><operator>*</operator><name>tcategory</name> <operator>=</operator> <name>AGT_TYPE_OTHER</name></expr>;</expr_stmt>

            <comment type="block">/*
             * but first let's look for a cast to json (note: not to
             * jsonb) if it's not built-in.
             */</comment>
            <if_stmt><if>if <condition>(<expr><name>typoid</name> <operator>&gt;=</operator> <name>FirstNormalObjectId</name></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>Oid</name></type> <name>castfunc</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>CoercionPathType</name></type> <name>ctype</name></decl>;</decl_stmt>

                <expr_stmt><expr><name>ctype</name> <operator>=</operator> <call><name>find_coercion_pathway</name><argument_list>(<argument><expr><name>JSONOID</name></expr></argument>, <argument><expr><name>typoid</name></expr></argument>,
                                              <argument><expr><name>COERCION_EXPLICIT</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>castfunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>ctype</name> <operator>==</operator> <name>COERCION_PATH_FUNC</name> <operator>&amp;&amp;</operator> <call><name>OidIsValid</name><argument_list>(<argument><expr><name>castfunc</name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><operator>*</operator><name>tcategory</name> <operator>=</operator> <name>AGT_TYPE_JSONCAST</name></expr>;</expr_stmt>
                    <expr_stmt><expr><operator>*</operator><name>outfuncoid</name> <operator>=</operator> <name>castfunc</name></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <comment type="block">/* not a cast type, so just get the usual output func */</comment>
                    <expr_stmt><expr><call><name>getTypeOutputInfo</name><argument_list>(<argument><expr><name>typoid</name></expr></argument>, <argument><expr><name>outfuncoid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typisvarlena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <comment type="block">/* any other builtin type */</comment>
                <expr_stmt><expr><call><name>getTypeOutputInfo</name><argument_list>(<argument><expr><name>typoid</name></expr></argument>, <argument><expr><name>outfuncoid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typisvarlena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
            <break>break;</break>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 * Turn a Datum into agtype, adding it to the result agtype_in_state.
 *
 * tcategory and outfuncoid are from a previous call to agtype_categorize_type,
 * except that if is_null is true then they can be invalid.
 *
 * If key_scalar is true, the value is stored as a key, so insist
 * it's of an acceptable type, and force it to be a AGTV_STRING.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>datum_to_agtype</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>val</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_null</name></decl></parameter>, <parameter><decl><type><name>agtype_in_state</name> <modifier>*</modifier></type><name>result</name></decl></parameter>,
                            <parameter><decl><type><name>agt_type_category</name></type> <name>tcategory</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>outfuncoid</name></decl></parameter>,
                            <parameter><decl><type><name>bool</name></type> <name>key_scalar</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>outputstr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>numeric_error</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_value</name></type> <name>agtv</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>scalar_agtype</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>check_stack_depth</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Convert val to an agtype_value in agtv (in most cases) */</comment>
    <if_stmt><if>if <condition>(<expr><name>is_null</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>key_scalar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>agtv</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>AGTV_NULL</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>key_scalar</name> <operator>&amp;&amp;</operator>
             <operator>(</operator><name>tcategory</name> <operator>==</operator> <name>AGT_TYPE_ARRAY</name> <operator>||</operator> <name>tcategory</name> <operator>==</operator> <name>AGT_TYPE_COMPOSITE</name> <operator>||</operator>
              <name>tcategory</name> <operator>==</operator> <name>AGT_TYPE_JSON</name> <operator>||</operator> <name>tcategory</name> <operator>==</operator> <name>AGT_TYPE_JSONB</name> <operator>||</operator>
              <name>tcategory</name> <operator>==</operator> <name>AGT_TYPE_AGTYPE</name> <operator>||</operator> <name>tcategory</name> <operator>==</operator> <name>AGT_TYPE_JSONCAST</name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(
            <argument><expr><name>ERROR</name></expr></argument>,
            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
             <call><name>errmsg</name><argument_list>(
                 <argument><expr><literal type="string">"key value must be scalar, not array, composite, or json"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>tcategory</name> <operator>==</operator> <name>AGT_TYPE_JSONCAST</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>OidFunctionCall1</name><argument_list>(<argument><expr><name>outfuncoid</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <switch>switch <condition>(<expr><name>tcategory</name></expr>)</condition>
        <block>{<block_content>
        <case>case <expr><name>AGT_TYPE_ARRAY</name></expr>:</case>
            <expr_stmt><expr><call><name>array_to_agtype_internal</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>AGT_TYPE_COMPOSITE</name></expr>:</case>
            <expr_stmt><expr><call><name>composite_to_agtype</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>AGT_TYPE_BOOL</name></expr>:</case>
            <if_stmt><if>if <condition>(<expr><name>key_scalar</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>outputstr</name> <operator>=</operator> <ternary><condition><expr><call><name>DatumGetBool</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="string">"true"</literal></expr> </then><else>: <expr><literal type="string">"false"</literal></expr></else></ternary></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>agtv</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>AGTV_STRING</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>agtv</name><operator>.</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>len</name></name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>outputstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>agtv</name><operator>.</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>val</name></name> <operator>=</operator> <name>outputstr</name></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><name><name>agtv</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>AGTV_BOOL</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>agtv</name><operator>.</operator><name>val</name><operator>.</operator><name>boolean</name></name> <operator>=</operator> <call><name>DatumGetBool</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
            <break>break;</break>
        <case>case <expr><name>AGT_TYPE_INTEGER</name></expr>:</case>
            <expr_stmt><expr><name>outputstr</name> <operator>=</operator> <call><name>OidOutputFunctionCall</name><argument_list>(<argument><expr><name>outfuncoid</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>key_scalar</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name><name>agtv</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>AGTV_STRING</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>agtv</name><operator>.</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>len</name></name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>outputstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>agtv</name><operator>.</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>val</name></name> <operator>=</operator> <name>outputstr</name></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <decl_stmt><decl><type><name>Datum</name></type> <name>intd</name></decl>;</decl_stmt>

                <expr_stmt><expr><name>intd</name> <operator>=</operator> <call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>int8in</name></expr></argument>, <argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name>outputstr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>agtv</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>AGTV_INTEGER</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>agtv</name><operator>.</operator><name>val</name><operator>.</operator><name>int_value</name></name> <operator>=</operator> <call><name>DatumGetInt64</name><argument_list>(<argument><expr><name>intd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>outputstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
            <break>break;</break>
        <case>case <expr><name>AGT_TYPE_FLOAT</name></expr>:</case>
            <expr_stmt><expr><name>outputstr</name> <operator>=</operator> <call><name>OidOutputFunctionCall</name><argument_list>(<argument><expr><name>outfuncoid</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>key_scalar</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name><name>agtv</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>AGTV_STRING</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>agtv</name><operator>.</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>len</name></name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>outputstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>agtv</name><operator>.</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>val</name></name> <operator>=</operator> <name>outputstr</name></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><name><name>agtv</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>AGTV_FLOAT</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>agtv</name><operator>.</operator><name>val</name><operator>.</operator><name>float_value</name></name> <operator>=</operator> <call><name>DatumGetFloat8</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
            <break>break;</break>
        <case>case <expr><name>AGT_TYPE_NUMERIC</name></expr>:</case>
            <expr_stmt><expr><name>outputstr</name> <operator>=</operator> <call><name>OidOutputFunctionCall</name><argument_list>(<argument><expr><name>outfuncoid</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>key_scalar</name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* always quote keys */</comment>
                <expr_stmt><expr><name><name>agtv</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>AGTV_STRING</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>agtv</name><operator>.</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>len</name></name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>outputstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>agtv</name><operator>.</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>val</name></name> <operator>=</operator> <name>outputstr</name></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <comment type="block">/*
                 * Make it numeric if it's a valid agtype number, otherwise
                 * a string. Invalid numeric output will always have an
                 * 'N' or 'n' in it (I think).
                 */</comment>
                <expr_stmt><expr><name>numeric_error</name> <operator>=</operator> <operator>(</operator><call><name>strchr</name><argument_list>(<argument><expr><name>outputstr</name></expr></argument>, <argument><expr><literal type="char">'N'</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name> <operator>||</operator>
                                 <call><name>strchr</name><argument_list>(<argument><expr><name>outputstr</name></expr></argument>, <argument><expr><literal type="char">'n'</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><name>numeric_error</name></expr>)</condition>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>Datum</name></type> <name>numd</name></decl>;</decl_stmt>

                    <expr_stmt><expr><name><name>agtv</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>AGTV_NUMERIC</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>numd</name> <operator>=</operator> <call><name>DirectFunctionCall3</name><argument_list>(<argument><expr><name>numeric_in</name></expr></argument>,
                                               <argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name>outputstr</name></expr></argument>)</argument_list></call></expr></argument>,
                                               <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>InvalidOid</name></expr></argument>)</argument_list></call></expr></argument>,
                                               <argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>agtv</name><operator>.</operator><name>val</name><operator>.</operator><name>numeric</name></name> <operator>=</operator> <call><name>DatumGetNumeric</name><argument_list>(<argument><expr><name>numd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>outputstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <expr_stmt><expr><name><name>agtv</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>AGTV_STRING</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>agtv</name><operator>.</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>len</name></name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>outputstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>agtv</name><operator>.</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>val</name></name> <operator>=</operator> <name>outputstr</name></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></else></if_stmt>
            <break>break;</break>
        <case>case <expr><name>AGT_TYPE_DATE</name></expr>:</case>
            <expr_stmt><expr><name><name>agtv</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>AGTV_STRING</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>agtv</name><operator>.</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>val</name></name> <operator>=</operator> <call><name>agtype_encode_date_time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>val</name></expr></argument>, <argument><expr><name>DATEOID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>agtv</name><operator>.</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>len</name></name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>agtv</name><operator>.</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>val</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>AGT_TYPE_TIMESTAMP</name></expr>:</case>
            <expr_stmt><expr><name><name>agtv</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>AGTV_STRING</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>agtv</name><operator>.</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>val</name></name> <operator>=</operator> <call><name>agtype_encode_date_time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>val</name></expr></argument>,
                                                          <argument><expr><name>TIMESTAMPOID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>agtv</name><operator>.</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>len</name></name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>agtv</name><operator>.</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>val</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>AGT_TYPE_TIMESTAMPTZ</name></expr>:</case>
            <expr_stmt><expr><name><name>agtv</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>AGTV_STRING</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>agtv</name><operator>.</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>val</name></name> <operator>=</operator> <call><name>agtype_encode_date_time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>val</name></expr></argument>,
                                                          <argument><expr><name>TIMESTAMPTZOID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>agtv</name><operator>.</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>len</name></name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>agtv</name><operator>.</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>val</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>AGT_TYPE_JSONCAST</name></expr>:</case>
        <case>case <expr><name>AGT_TYPE_JSON</name></expr>:</case>
        <block>{<block_content>
            <comment type="block">/*
             * Parse the json right into the existing result object.
             * We can handle it as an agtype because agtype is currently an
             * extension of json.
             * Unlike AGT_TYPE_JSONB, numbers will be stored as either
             * an integer or a float, not a numeric.
             */</comment>
            <decl_stmt><decl><type><name>agtype_lex_context</name> <modifier>*</modifier></type><name>lex</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>agtype_sem_action</name></type> <name>sem</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>text</name> <modifier>*</modifier></type><name>json</name> <init>= <expr><call><name>DatumGetTextPP</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><name>lex</name> <operator>=</operator> <call><name>make_agtype_lex_context</name><argument_list>(<argument><expr><name>json</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sem</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sem</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name><name>sem</name><operator>.</operator><name>semstate</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>result</name></expr>;</expr_stmt>

            <expr_stmt><expr><name><name>sem</name><operator>.</operator><name>object_start</name></name> <operator>=</operator> <name>agtype_in_object_start</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>sem</name><operator>.</operator><name>array_start</name></name> <operator>=</operator> <name>agtype_in_array_start</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>sem</name><operator>.</operator><name>object_end</name></name> <operator>=</operator> <name>agtype_in_object_end</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>sem</name><operator>.</operator><name>array_end</name></name> <operator>=</operator> <name>agtype_in_array_end</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>sem</name><operator>.</operator><name>scalar</name></name> <operator>=</operator> <name>agtype_in_scalar</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>sem</name><operator>.</operator><name>object_field_start</name></name> <operator>=</operator> <name>agtype_in_object_field_start</name></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>parse_agtype</name><argument_list>(<argument><expr><name>lex</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
        <break>break;</break>
        <case>case <expr><name>AGT_TYPE_AGTYPE</name></expr>:</case>
        <case>case <expr><name>AGT_TYPE_JSONB</name></expr>:</case>
        <block>{<block_content>
            <decl_stmt><decl><type><name>agtype</name> <modifier>*</modifier></type><name>jsonb</name> <init>= <expr><call><name>DATUM_GET_AGTYPE_P</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>agtype_iterator</name> <modifier>*</modifier></type><name>it</name></decl>;</decl_stmt>

            <comment type="block">/*
             * val is actually jsonb datum but we can handle it as an agtype
             * datum because agtype is currently an extension of jsonb.
             */</comment>

            <expr_stmt><expr><name>it</name> <operator>=</operator> <call><name>agtype_iterator_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>jsonb</name><operator>-&gt;</operator><name>root</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><call><name>AGT_ROOT_IS_SCALAR</name><argument_list>(<argument><expr><name>jsonb</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>agtype_iterator_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name>it</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>agtv</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>agtv</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>AGTV_ARRAY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>agtype_iterator_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name>it</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>agtv</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>scalar_agtype</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <decl_stmt><decl><type><name>agtype_iterator_token</name></type> <name>type</name></decl>;</decl_stmt>

                <while>while <condition>(<expr><operator>(</operator><name>type</name> <operator>=</operator> <call><name>agtype_iterator_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name>it</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>agtv</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator>
                       <name>WAGT_DONE</name></expr>)</condition>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>WAGT_END_ARRAY</name> <operator>||</operator> <name>type</name> <operator>==</operator> <name>WAGT_END_OBJECT</name> <operator>||</operator>
                        <name>type</name> <operator>==</operator> <name>WAGT_BEGIN_ARRAY</name> <operator>||</operator> <name>type</name> <operator>==</operator> <name>WAGT_BEGIN_OBJECT</name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>res</name></name> <operator>=</operator> <call><name>push_agtype_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>result</name><operator>-&gt;</operator><name>parse_state</name></name></expr></argument>,
                                                        <argument><expr><name>type</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if>
                    <else>else
                    <block>{<block_content>
                        <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>res</name></name> <operator>=</operator> <call><name>push_agtype_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>result</name><operator>-&gt;</operator><name>parse_state</name></name></expr></argument>,
                                                        <argument><expr><name>type</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>agtv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></else></if_stmt>
                </block_content>}</block></while>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block>
        <break>break;</break>
        <default>default:</default>
            <expr_stmt><expr><name>outputstr</name> <operator>=</operator> <call><name>OidOutputFunctionCall</name><argument_list>(<argument><expr><name>outfuncoid</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>agtv</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>AGTV_STRING</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>agtv</name><operator>.</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>len</name></name> <operator>=</operator> <call><name>check_string_length</name><argument_list>(<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>outputstr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>agtv</name><operator>.</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>val</name></name> <operator>=</operator> <name>outputstr</name></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block></switch>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* Now insert agtv into result, unless we did it recursively */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_null</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>scalar_agtype</name> <operator>&amp;&amp;</operator> <name>tcategory</name> <operator>&gt;=</operator> <name>AGT_TYPE_AGTYPE</name> <operator>&amp;&amp;</operator>
        <name>tcategory</name> <operator>&lt;=</operator> <name>AGT_TYPE_JSONCAST</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* work has been done recursively */</comment>
        <return>return;</return>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name><name>result</name><operator>-&gt;</operator><name>parse_state</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* single root scalar */</comment>
        <decl_stmt><decl><type><name>agtype_value</name></type> <name>va</name></decl>;</decl_stmt>

        <expr_stmt><expr><name><name>va</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>AGTV_ARRAY</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>va</name><operator>.</operator><name>val</name><operator>.</operator><name>array</name><operator>.</operator><name>raw_scalar</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>va</name><operator>.</operator><name>val</name><operator>.</operator><name>array</name><operator>.</operator><name>num_elems</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>res</name></name> <operator>=</operator> <call><name>push_agtype_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>result</name><operator>-&gt;</operator><name>parse_state</name></name></expr></argument>, <argument><expr><name>WAGT_BEGIN_ARRAY</name></expr></argument>,
                                        <argument><expr><operator>&amp;</operator><name>va</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>res</name></name> <operator>=</operator> <call><name>push_agtype_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>result</name><operator>-&gt;</operator><name>parse_state</name></name></expr></argument>, <argument><expr><name>WAGT_ELEM</name></expr></argument>,
                                        <argument><expr><operator>&amp;</operator><name>agtv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>res</name></name> <operator>=</operator> <call><name>push_agtype_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>result</name><operator>-&gt;</operator><name>parse_state</name></name></expr></argument>, <argument><expr><name>WAGT_END_ARRAY</name></expr></argument>,
                                        <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <decl_stmt><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>o</name> <init>= <expr><operator>&amp;</operator><name><name>result</name><operator>-&gt;</operator><name>parse_state</name><operator>-&gt;</operator><name>cont_val</name></name></expr></init></decl>;</decl_stmt>

        <switch>switch <condition>(<expr><name><name>o</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition>
        <block>{<block_content>
        <case>case <expr><name>AGTV_ARRAY</name></expr>:</case>
            <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>res</name></name> <operator>=</operator> <call><name>push_agtype_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>result</name><operator>-&gt;</operator><name>parse_state</name></name></expr></argument>, <argument><expr><name>WAGT_ELEM</name></expr></argument>,
                                            <argument><expr><operator>&amp;</operator><name>agtv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>AGTV_OBJECT</name></expr>:</case>
            <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>res</name></name> <operator>=</operator> <call><name>push_agtype_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>result</name><operator>-&gt;</operator><name>parse_state</name></name></expr></argument>,
                                            <argument><expr><ternary><condition><expr><name>key_scalar</name></expr> ?</condition><then> <expr><name>WAGT_KEY</name></expr> </then><else>: <expr><name>WAGT_VALUE</name></expr></else></ternary></expr></argument>,
                                            <argument><expr><operator>&amp;</operator><name>agtv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <default>default:</default>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected parent of nested structure"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></switch>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Process a single dimension of an array.
 * If it's the innermost dimension, output the values, otherwise call
 * ourselves recursively to process the next dimension.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>array_dim_to_agtype</name><parameter_list>(<parameter><decl><type><name>agtype_in_state</name> <modifier>*</modifier></type><name>result</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>dim</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ndims</name></decl></parameter>,
                                <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>dims</name></decl></parameter>, <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>vals</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>nulls</name></decl></parameter>,
                                <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>valcount</name></decl></parameter>, <parameter><decl><type><name>agt_type_category</name></type> <name>tcategory</name></decl></parameter>,
                                <parameter><decl><type><name>Oid</name></type> <name>outfuncoid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>dim</name> <operator>&lt;</operator> <name>ndims</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>res</name></name> <operator>=</operator> <call><name>push_agtype_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>result</name><operator>-&gt;</operator><name>parse_state</name></name></expr></argument>, <argument><expr><name>WAGT_BEGIN_ARRAY</name></expr></argument>,
                                    <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name><name>dims</name><index>[<expr><name>dim</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>dim</name> <operator>+</operator> <literal type="number">1</literal> <operator>==</operator> <name>ndims</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>datum_to_agtype</name><argument_list>(<argument><expr><name><name>vals</name><index>[<expr><operator>*</operator><name>valcount</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>nulls</name><index>[<expr><operator>*</operator><name>valcount</name></expr>]</index></name></expr></argument>, <argument><expr><name>result</name></expr></argument>,
                            <argument><expr><name>tcategory</name></expr></argument>, <argument><expr><name>outfuncoid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><operator>(</operator><operator>*</operator><name>valcount</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><call><name>array_dim_to_agtype</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>dim</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>ndims</name></expr></argument>, <argument><expr><name>dims</name></expr></argument>, <argument><expr><name>vals</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>,
                                <argument><expr><name>valcount</name></expr></argument>, <argument><expr><name>tcategory</name></expr></argument>, <argument><expr><name>outfuncoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>res</name></name> <operator>=</operator> <call><name>push_agtype_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>result</name><operator>-&gt;</operator><name>parse_state</name></name></expr></argument>, <argument><expr><name>WAGT_END_ARRAY</name></expr></argument>,
                                    <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Turn an array into agtype.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>array_to_agtype_internal</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>array</name></decl></parameter>, <parameter><decl><type><name>agtype_in_state</name> <modifier>*</modifier></type><name>result</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ArrayType</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><call><name>DatumGetArrayTypeP</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type> <name>element_type</name> <init>= <expr><call><name>ARR_ELEMTYPE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>dim</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>ndim</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nitems</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name> <modifier>*</modifier></type><name>elements</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name> <modifier>*</modifier></type><name>nulls</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int16</name></type> <name>typlen</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>typbyval</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name>typalign</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agt_type_category</name></type> <name>tcategory</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type> <name>outfuncoid</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>ndim</name> <operator>=</operator> <call><name>ARR_NDIM</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>dim</name> <operator>=</operator> <call><name>ARR_DIMS</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>nitems</name> <operator>=</operator> <call><name>ArrayGetNItems</name><argument_list>(<argument><expr><name>ndim</name></expr></argument>, <argument><expr><name>dim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>nitems</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>res</name></name> <operator>=</operator> <call><name>push_agtype_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>result</name><operator>-&gt;</operator><name>parse_state</name></name></expr></argument>, <argument><expr><name>WAGT_BEGIN_ARRAY</name></expr></argument>,
                                        <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>res</name></name> <operator>=</operator> <call><name>push_agtype_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>result</name><operator>-&gt;</operator><name>parse_state</name></name></expr></argument>, <argument><expr><name>WAGT_END_ARRAY</name></expr></argument>,
                                        <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>get_typlenbyvalalign</name><argument_list>(<argument><expr><name>element_type</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typlen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typbyval</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typalign</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>agtype_categorize_type</name><argument_list>(<argument><expr><name>element_type</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tcategory</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>outfuncoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>deconstruct_array</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>element_type</name></expr></argument>, <argument><expr><name>typlen</name></expr></argument>, <argument><expr><name>typbyval</name></expr></argument>, <argument><expr><name>typalign</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>elements</name></expr></argument>,
                      <argument><expr><operator>&amp;</operator><name>nulls</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nitems</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>array_dim_to_agtype</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>ndim</name></expr></argument>, <argument><expr><name>dim</name></expr></argument>, <argument><expr><name>elements</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>count</name></expr></argument>,
                        <argument><expr><name>tcategory</name></expr></argument>, <argument><expr><name>outfuncoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>elements</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Turn a composite / record into agtype.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>composite_to_agtype</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>composite</name></decl></parameter>, <parameter><decl><type><name>agtype_in_state</name> <modifier>*</modifier></type><name>result</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HeapTupleHeader</name></type> <name>td</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type> <name>tup_type</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type> <name>tup_typmod</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TupleDesc</name></type> <name>tupdesc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTupleData</name></type> <name>tmptup</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>tuple</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>td</name> <operator>=</operator> <call><name>DatumGetHeapTupleHeader</name><argument_list>(<argument><expr><name>composite</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Extract rowtype info and find a tupdesc */</comment>
    <expr_stmt><expr><name>tup_type</name> <operator>=</operator> <call><name>HeapTupleHeaderGetTypeId</name><argument_list>(<argument><expr><name>td</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>tup_typmod</name> <operator>=</operator> <call><name>HeapTupleHeaderGetTypMod</name><argument_list>(<argument><expr><name>td</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <call><name>lookup_rowtype_tupdesc</name><argument_list>(<argument><expr><name>tup_type</name></expr></argument>, <argument><expr><name>tup_typmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Build a temporary HeapTuple control structure */</comment>
    <expr_stmt><expr><name><name>tmptup</name><operator>.</operator><name>t_len</name></name> <operator>=</operator> <call><name>HeapTupleHeaderGetDatumLength</name><argument_list>(<argument><expr><name>td</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>tmptup</name><operator>.</operator><name>t_data</name></name> <operator>=</operator> <name>td</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>tuple</name> <operator>=</operator> <operator>&amp;</operator><name>tmptup</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>res</name></name> <operator>=</operator> <call><name>push_agtype_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>result</name><operator>-&gt;</operator><name>parse_state</name></name></expr></argument>, <argument><expr><name>WAGT_BEGIN_OBJECT</name></expr></argument>,
                                    <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Datum</name></type> <name>val</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type> <name>isnull</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>attname</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>agt_type_category</name></type> <name>tcategory</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Oid</name></type> <name>outfuncoid</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>agtype_value</name></type> <name>v</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>att</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>att</name><operator>-&gt;</operator><name>attisdropped</name></name></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>attname</name> <operator>=</operator> <call><name>NameStr</name><argument_list>(<argument><expr><name><name>att</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>v</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>AGTV_STRING</name></expr>;</expr_stmt>
        <comment type="block">/*
         * don't need check_string_length here
         * - can't exceed maximum name length
         */</comment>
        <expr_stmt><expr><name><name>v</name><operator>.</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>len</name></name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>attname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>v</name><operator>.</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>val</name></name> <operator>=</operator> <name>attname</name></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>res</name></name> <operator>=</operator> <call><name>push_agtype_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>result</name><operator>-&gt;</operator><name>parse_state</name></name></expr></argument>, <argument><expr><name>WAGT_KEY</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>heap_getattr</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>tcategory</name> <operator>=</operator> <name>AGT_TYPE_NULL</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>outfuncoid</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><call><name>agtype_categorize_type</name><argument_list>(<argument><expr><name><name>att</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tcategory</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>outfuncoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <expr_stmt><expr><call><name>datum_to_agtype</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><name>tcategory</name></expr></argument>, <argument><expr><name>outfuncoid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>res</name></name> <operator>=</operator> <call><name>push_agtype_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>result</name><operator>-&gt;</operator><name>parse_state</name></name></expr></argument>, <argument><expr><name>WAGT_END_OBJECT</name></expr></argument>,
                                    <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ReleaseTupleDesc</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Append agtype text for "val" to "result".
 *
 * This is just a thin wrapper around datum_to_agtype.  If the same type
 * will be printed many times, avoid using this; better to do the
 * agtype_categorize_type lookups only once.
 */</comment>
<function><type><name>void</name></type> <name>add_agtype</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>val</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_null</name></decl></parameter>, <parameter><decl><type><name>agtype_in_state</name> <modifier>*</modifier></type><name>result</name></decl></parameter>,
                       <parameter><decl><type><name>Oid</name></type> <name>val_type</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>key_scalar</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>agt_type_category</name></type> <name>tcategory</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type> <name>outfuncoid</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>val_type</name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                        <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not determine input data type"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>is_null</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>tcategory</name> <operator>=</operator> <name>AGT_TYPE_NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>outfuncoid</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><call><name>agtype_categorize_type</name><argument_list>(<argument><expr><name>val_type</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tcategory</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>outfuncoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><call><name>datum_to_agtype</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name>is_null</name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><name>tcategory</name></expr></argument>, <argument><expr><name>outfuncoid</name></expr></argument>, <argument><expr><name>key_scalar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>agtype_value</name> <modifier>*</modifier></type><name>string_to_agtype_value</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>agtv</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>agtype_value</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>agtv</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>AGTV_STRING</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>agtv</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>len</name></name> <operator>=</operator> <call><name>check_string_length</name><argument_list>(<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>agtv</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>val</name></name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>

    <return>return <expr><name>agtv</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* helper function to create an agtype_value integer from an integer */</comment>
<function><type><name>agtype_value</name> <modifier>*</modifier></type><name>integer_to_agtype_value</name><parameter_list>(<parameter><decl><type><name>int64</name></type> <name>int_value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>agtv</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>agtype_value</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>agtv</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>AGTV_INTEGER</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>agtv</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>int_value</name></name> <operator>=</operator> <name>int_value</name></expr>;</expr_stmt>

    <return>return <expr><name>agtv</name></expr>;</return>
</block_content>}</block></function>

<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>_agtype_build_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/*
 * SQL function agtype_build_path(VARIADIC agtype)
 */</comment>
<function><type><name>Datum</name></type> <name>_agtype_build_path</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>agtype_in_state</name></type> <name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name> <modifier>*</modifier></type><name>args</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name> <modifier>*</modifier></type><name>nulls</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name> <modifier>*</modifier></type><name>types</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nargs</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>is_zero_boundary_case</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* build argument values to build the object */</comment>
    <expr_stmt><expr><name>nargs</name> <operator>=</operator> <call><name>extract_variadic_args</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>args</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>types</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>nargs</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"paths require at least 1 vertex"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * If this path is only 1 to 3 elements in length, check to see if the
     * contained edge is actually a path (made by the VLE). If so, just
     * materialize the vle path because it already contains the two outside
     * vertices.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>nargs</name> <operator>&gt;=</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>nargs</name> <operator>&lt;=</operator> <literal type="number">3</literal></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nargs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>agtype</name> <modifier>*</modifier></type><name>agt</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>nulls</name><index>[<expr><name>i</name></expr>]</index></name> <operator>||</operator> <name><name>types</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name>AGTYPEOID</name></expr>)</condition>
            <block>{<block_content>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>

            <expr_stmt><expr><name>agt</name> <operator>=</operator> <call><name>DATUM_GET_AGTYPE_P</name><argument_list>(<argument><expr><name><name>args</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><call><name>AGT_ROOT_IS_BINARY</name><argument_list>(<argument><expr><name>agt</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
                <call><name>AGT_ROOT_BINARY_FLAGS</name><argument_list>(<argument><expr><name>agt</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>AGT_FBINARY_TYPE_VLE_PATH</name></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>agtype</name> <modifier>*</modifier></type><name>path</name> <init>= <expr><call><name>agt_materialize_vle_path</name><argument_list>(<argument><expr><name>agt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>nargs</name> <operator>%</operator> <literal type="number">2</literal> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"a path is of the form: [vertex, (edge, vertex)*i] where i &gt;= 0"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* initialize the result */</comment>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>agtype_in_state</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* push in the begining of the agtype array */</comment>
    <expr_stmt><expr><name><name>result</name><operator>.</operator><name>res</name></name> <operator>=</operator> <call><name>push_agtype_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>result</name><operator>.</operator><name>parse_state</name></name></expr></argument>, <argument><expr><name>WAGT_BEGIN_ARRAY</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* loop through the path components */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nargs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>agtype</name> <modifier>*</modifier></type><name>agt</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>nulls</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"argument %d must not be null"</literal></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name><name>types</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name>AGTYPEOID</name></expr>)</condition>
        <block>{<block_content>

            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"argument %d must be an agtype"</literal></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* get the agtype pointer */</comment>
        <expr_stmt><expr><name>agt</name> <operator>=</operator> <call><name>DATUM_GET_AGTYPE_P</name><argument_list>(<argument><expr><name><name>args</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* is this a VLE path edge */</comment>
        <if_stmt><if>if <condition>(<expr><name>i</name> <operator>%</operator> <literal type="number">2</literal> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator>
            <call><name>AGT_ROOT_IS_BINARY</name><argument_list>(<argument><expr><name>agt</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
            <call><name>AGT_ROOT_BINARY_FLAGS</name><argument_list>(<argument><expr><name>agt</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>AGT_FBINARY_TYPE_VLE_PATH</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>agtv_path</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

            <comment type="block">/* get the VLE path from the container as an agtype_value */</comment>
            <expr_stmt><expr><name>agtv_path</name> <operator>=</operator> <call><name>agtv_materialize_vle_path</name><argument_list>(<argument><expr><name>agt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* it better be an AGTV_PATH */</comment>
            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>agtv_path</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AGTV_PATH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/*
             * If the VLE path is the zero boundary case, there isn't an edge to
             * process. Additionally, the start and end vertices are the same.
             * We need to flag this condition so that we can skip processing the
             * following vertex.
             */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>agtv_path</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>array</name><operator>.</operator><name>num_elems</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>is_zero_boundary_case</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <continue>continue;</continue>
            </block_content>}</block></if></if_stmt>

            <comment type="block">/*
             * Add in the interior path - excluding the start and end vertices.
             * The other iterations of the for loop has handled start and will
             * handle end.
             */</comment>
            <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;=</operator> <name><name>agtv_path</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>array</name><operator>.</operator><name>num_elems</name></name> <operator>-</operator> <literal type="number">2</literal></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <expr_stmt><expr><name><name>result</name><operator>.</operator><name>res</name></name> <operator>=</operator> <call><name>push_agtype_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>result</name><operator>.</operator><name>parse_state</name></name></expr></argument>, <argument><expr><name>WAGT_ELEM</name></expr></argument>,
                                               <argument><expr><operator>&amp;</operator><name><name>agtv_path</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>array</name><operator>.</operator><name>elems</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></for>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>i</name> <operator>%</operator> <literal type="number">2</literal> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><call><name>AGTE_IS_AGTYPE</name><argument_list>(<argument><expr><name><name>agt</name><operator>-&gt;</operator><name>root</name><operator>.</operator><name>children</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>||</operator>
                                <name><name>agt</name><operator>-&gt;</operator><name>root</name><operator>.</operator><name>children</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <name>AGT_HEADER_EDGE</name><operator>)</operator></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"paths consist of alternating vertices and edges"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"argument %d must be an edge"</literal></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>i</name> <operator>%</operator> <literal type="number">2</literal> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><call><name>AGTE_IS_AGTYPE</name><argument_list>(<argument><expr><name><name>agt</name><operator>-&gt;</operator><name>root</name><operator>.</operator><name>children</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>||</operator>
                                <name><name>agt</name><operator>-&gt;</operator><name>root</name><operator>.</operator><name>children</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <name>AGT_HEADER_VERTEX</name><operator>)</operator></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"paths consist of alternating vertices and edges"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"argument %d must be an vertex"</literal></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <comment type="block">/*
         * This will always add in vertices or edges depending on the loop
         * iteration. However, when it is a vertex, there is the possibility
         * that the previous iteration flagged a zero boundary case. We can only
         * add it if this is not the case. If this is an edge, it is not
         * possible to be a zero boundary case.
         */</comment>
        <if type="elseif">else if <condition>(<expr><name>is_zero_boundary_case</name> <operator>==</operator> <name>false</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>add_agtype</name><argument_list>(<argument><expr><call><name>AGTYPE_P_GET_DATUM</name><argument_list>(<argument><expr><name>agt</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>result</name></expr></argument>, <argument><expr><name><name>types</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
                       <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <comment type="block">/* If we got here, we had a zero boundary case. So, clear it */</comment>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><name>is_zero_boundary_case</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/* push the end of the array */</comment>
    <expr_stmt><expr><name><name>result</name><operator>.</operator><name>res</name></name> <operator>=</operator> <call><name>push_agtype_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>result</name><operator>.</operator><name>parse_state</name></name></expr></argument>, <argument><expr><name>WAGT_END_ARRAY</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* set it to a path type */</comment>
    <expr_stmt><expr><name><name>result</name><operator>.</operator><name>res</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>AGTV_PATH</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><call><name>agtype_value_to_agtype</name><argument_list>(<argument><expr><name><name>result</name><operator>.</operator><name>res</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type> <name>make_path</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_in_state</name></type> <name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>agtype_in_state</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>result</name><operator>.</operator><name>res</name></name> <operator>=</operator> <call><name>push_agtype_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>result</name><operator>.</operator><name>parse_state</name></name></expr></argument>, <argument><expr><name>WAGT_BEGIN_ARRAY</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"paths require at least 1 vertex"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call> <operator>%</operator> <literal type="number">2</literal> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"a path is of the form: [vertex, (edge, vertex)*i] where i &gt;= 0"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>


    <macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>path</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>agtype</name> <modifier>*</modifier></type><name>agt</name><init>= <expr><call><name>DATUM_GET_AGTYPE_P</name><argument_list>(<argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>elem</name></decl>;</decl_stmt>
        <expr_stmt><expr><name>elem</name> <operator>=</operator> <call><name>get_ith_agtype_value_from_container</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>agt</name><operator>-&gt;</operator><name>root</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>agt</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"argument must not be null"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>i</name> <operator>%</operator> <literal type="number">2</literal> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>elem</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>AGTV_VERTEX</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"argument %i must be a vertex"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>i</name> <operator>%</operator> <literal type="number">2</literal> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>elem</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>AGTV_EDGE</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"argument %i must be an edge"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>add_agtype</name><argument_list>(<argument><expr><operator>(</operator><name>Datum</name><operator>)</operator><name>agt</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>result</name></expr></argument>, <argument><expr><name>AGTYPEOID</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block>

    <expr_stmt><expr><name><name>result</name><operator>.</operator><name>res</name></name> <operator>=</operator> <call><name>push_agtype_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>result</name><operator>.</operator><name>parse_state</name></name></expr></argument>, <argument><expr><name>WAGT_END_ARRAY</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>result</name><operator>.</operator><name>res</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>AGTV_PATH</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><call><name>agtype_value_to_agtype</name><argument_list>(<argument><expr><name><name>result</name><operator>.</operator><name>res</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>_agtype_build_vertex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/*
 * SQL function agtype_build_vertex(graphid, cstring, agtype)
 */</comment>
<function><type><name>Datum</name></type> <name>_agtype_build_vertex</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>agtype_in_state</name></type> <name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>graphid</name></type> <name>id</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>agtype_in_state</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>result</name><operator>.</operator><name>res</name></name> <operator>=</operator> <call><name>push_agtype_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>result</name><operator>.</operator><name>parse_state</name></name></expr></argument>, <argument><expr><name>WAGT_BEGIN_OBJECT</name></expr></argument>,
                                   <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* process graphid */</comment>
    <expr_stmt><expr><name><name>result</name><operator>.</operator><name>res</name></name> <operator>=</operator> <call><name>push_agtype_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>result</name><operator>.</operator><name>parse_state</name></name></expr></argument>, <argument><expr><name>WAGT_KEY</name></expr></argument>,
                                   <argument><expr><call><name>string_to_agtype_value</name><argument_list>(<argument><expr><literal type="string">"id"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>fcinfo</name><operator>-&gt;</operator><name>argnull</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"_agtype_build_vertex() graphid cannot be NULL"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>id</name> <operator>=</operator> <call><name>AG_GETARG_GRAPHID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><operator>.</operator><name>res</name></name> <operator>=</operator> <call><name>push_agtype_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>result</name><operator>.</operator><name>parse_state</name></name></expr></argument>, <argument><expr><name>WAGT_VALUE</name></expr></argument>,
                                   <argument><expr><call><name>integer_to_agtype_value</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* process label */</comment>
    <expr_stmt><expr><name><name>result</name><operator>.</operator><name>res</name></name> <operator>=</operator> <call><name>push_agtype_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>result</name><operator>.</operator><name>parse_state</name></name></expr></argument>, <argument><expr><name>WAGT_KEY</name></expr></argument>,
                                   <argument><expr><call><name>string_to_agtype_value</name><argument_list>(<argument><expr><literal type="string">"label"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>fcinfo</name><operator>-&gt;</operator><name>argnull</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                        <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"_agtype_build_vertex() label cannot be NULL"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name><name>result</name><operator>.</operator><name>res</name></name> <operator>=</operator>
        <call><name>push_agtype_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>result</name><operator>.</operator><name>parse_state</name></name></expr></argument>, <argument><expr><name>WAGT_VALUE</name></expr></argument>,
                          <argument><expr><call><name>string_to_agtype_value</name><argument_list>(<argument><expr><call><name>PG_GETARG_CSTRING</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* process properties */</comment>
    <expr_stmt><expr><name><name>result</name><operator>.</operator><name>res</name></name> <operator>=</operator> <call><name>push_agtype_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>result</name><operator>.</operator><name>parse_state</name></name></expr></argument>, <argument><expr><name>WAGT_KEY</name></expr></argument>,
                                   <argument><expr><call><name>string_to_agtype_value</name><argument_list>(<argument><expr><literal type="string">"properties"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">//if the properties object is null, push an empty object</comment>
    <if_stmt><if>if <condition>(<expr><name><name>fcinfo</name><operator>-&gt;</operator><name>argnull</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>result</name><operator>.</operator><name>res</name></name> <operator>=</operator> <call><name>push_agtype_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>result</name><operator>.</operator><name>parse_state</name></name></expr></argument>, <argument><expr><name>WAGT_BEGIN_OBJECT</name></expr></argument>,
                                       <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>result</name><operator>.</operator><name>res</name></name> <operator>=</operator> <call><name>push_agtype_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>result</name><operator>.</operator><name>parse_state</name></name></expr></argument>, <argument><expr><name>WAGT_END_OBJECT</name></expr></argument>,
                                       <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <decl_stmt><decl><type><name>agtype</name> <modifier>*</modifier></type><name>properties</name> <init>= <expr><call><name>AG_GET_ARG_AGTYPE_P</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AGT_ROOT_IS_OBJECT</name><argument_list>(<argument><expr><name>properties</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(
                <argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(
                     <argument><expr><literal type="string">"_agtype_build_vertex() properties argument must be an object"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><call><name>add_agtype</name><argument_list>(<argument><expr><operator>(</operator><name>Datum</name><operator>)</operator><name>properties</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>result</name></expr></argument>, <argument><expr><name>AGTYPEOID</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><name><name>result</name><operator>.</operator><name>res</name></name> <operator>=</operator> <call><name>push_agtype_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>result</name><operator>.</operator><name>parse_state</name></name></expr></argument>, <argument><expr><name>WAGT_END_OBJECT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>result</name><operator>.</operator><name>res</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>AGTV_VERTEX</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><call><name>agtype_value_to_agtype</name><argument_list>(<argument><expr><name><name>result</name><operator>.</operator><name>res</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type> <name>make_vertex</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>id</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>label</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>properties</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>DirectFunctionCall3</name><argument_list>(<argument><expr><name>_agtype_build_vertex</name></expr></argument>,
                     <argument><expr><name>id</name></expr></argument>,
                     <argument><expr><name>label</name></expr></argument>,
                     <argument><expr><name>properties</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>_agtype_build_edge</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/*
 * SQL function agtype_build_edge(graphid, graphid, graphid, cstring, agtype)
 */</comment>
<function><type><name>Datum</name></type> <name>_agtype_build_edge</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>agtype_in_state</name></type> <name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>graphid</name></type> <name>id</name></decl>, <decl><type ref="prev"/><name>start_id</name></decl>, <decl><type ref="prev"/><name>end_id</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>agtype_in_state</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>result</name><operator>.</operator><name>res</name></name> <operator>=</operator> <call><name>push_agtype_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>result</name><operator>.</operator><name>parse_state</name></name></expr></argument>, <argument><expr><name>WAGT_BEGIN_OBJECT</name></expr></argument>,
                                   <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* process graph id */</comment>
    <expr_stmt><expr><name><name>result</name><operator>.</operator><name>res</name></name> <operator>=</operator> <call><name>push_agtype_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>result</name><operator>.</operator><name>parse_state</name></name></expr></argument>, <argument><expr><name>WAGT_KEY</name></expr></argument>,
                                   <argument><expr><call><name>string_to_agtype_value</name><argument_list>(<argument><expr><literal type="string">"id"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>fcinfo</name><operator>-&gt;</operator><name>argnull</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"_agtype_build_edge() graphid cannot be NULL"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>id</name> <operator>=</operator> <call><name>AG_GETARG_GRAPHID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><operator>.</operator><name>res</name></name> <operator>=</operator> <call><name>push_agtype_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>result</name><operator>.</operator><name>parse_state</name></name></expr></argument>, <argument><expr><name>WAGT_VALUE</name></expr></argument>,
                                   <argument><expr><call><name>integer_to_agtype_value</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* process label */</comment>
    <expr_stmt><expr><name><name>result</name><operator>.</operator><name>res</name></name> <operator>=</operator> <call><name>push_agtype_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>result</name><operator>.</operator><name>parse_state</name></name></expr></argument>, <argument><expr><name>WAGT_KEY</name></expr></argument>,
                                   <argument><expr><call><name>string_to_agtype_value</name><argument_list>(<argument><expr><literal type="string">"label"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>fcinfo</name><operator>-&gt;</operator><name>argnull</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                        <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"_agtype_build_vertex() label cannot be NULL"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name><name>result</name><operator>.</operator><name>res</name></name> <operator>=</operator>
        <call><name>push_agtype_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>result</name><operator>.</operator><name>parse_state</name></name></expr></argument>, <argument><expr><name>WAGT_VALUE</name></expr></argument>,
                          <argument><expr><call><name>string_to_agtype_value</name><argument_list>(<argument><expr><call><name>PG_GETARG_CSTRING</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* process end_id */</comment>
    <expr_stmt><expr><name><name>result</name><operator>.</operator><name>res</name></name> <operator>=</operator> <call><name>push_agtype_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>result</name><operator>.</operator><name>parse_state</name></name></expr></argument>, <argument><expr><name>WAGT_KEY</name></expr></argument>,
                                   <argument><expr><call><name>string_to_agtype_value</name><argument_list>(<argument><expr><literal type="string">"end_id"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>fcinfo</name><operator>-&gt;</operator><name>argnull</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"_agtype_build_edge() endid cannot be NULL"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>end_id</name> <operator>=</operator> <call><name>AG_GETARG_GRAPHID</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><operator>.</operator><name>res</name></name> <operator>=</operator> <call><name>push_agtype_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>result</name><operator>.</operator><name>parse_state</name></name></expr></argument>, <argument><expr><name>WAGT_VALUE</name></expr></argument>,
                                   <argument><expr><call><name>integer_to_agtype_value</name><argument_list>(<argument><expr><name>end_id</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* process start_id */</comment>
    <expr_stmt><expr><name><name>result</name><operator>.</operator><name>res</name></name> <operator>=</operator> <call><name>push_agtype_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>result</name><operator>.</operator><name>parse_state</name></name></expr></argument>, <argument><expr><name>WAGT_KEY</name></expr></argument>,
                                   <argument><expr><call><name>string_to_agtype_value</name><argument_list>(<argument><expr><literal type="string">"start_id"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>fcinfo</name><operator>-&gt;</operator><name>argnull</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"_agtype_build_edge() startid cannot be NULL"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>start_id</name> <operator>=</operator> <call><name>AG_GETARG_GRAPHID</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><operator>.</operator><name>res</name></name> <operator>=</operator> <call><name>push_agtype_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>result</name><operator>.</operator><name>parse_state</name></name></expr></argument>, <argument><expr><name>WAGT_VALUE</name></expr></argument>,
                                   <argument><expr><call><name>integer_to_agtype_value</name><argument_list>(<argument><expr><name>start_id</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* process properties */</comment>
    <expr_stmt><expr><name><name>result</name><operator>.</operator><name>res</name></name> <operator>=</operator> <call><name>push_agtype_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>result</name><operator>.</operator><name>parse_state</name></name></expr></argument>, <argument><expr><name>WAGT_KEY</name></expr></argument>,
                                   <argument><expr><call><name>string_to_agtype_value</name><argument_list>(<argument><expr><literal type="string">"properties"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* if the properties object is null, push an empty object */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>fcinfo</name><operator>-&gt;</operator><name>argnull</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>result</name><operator>.</operator><name>res</name></name> <operator>=</operator> <call><name>push_agtype_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>result</name><operator>.</operator><name>parse_state</name></name></expr></argument>, <argument><expr><name>WAGT_BEGIN_OBJECT</name></expr></argument>,
                                       <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>result</name><operator>.</operator><name>res</name></name> <operator>=</operator> <call><name>push_agtype_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>result</name><operator>.</operator><name>parse_state</name></name></expr></argument>, <argument><expr><name>WAGT_END_OBJECT</name></expr></argument>,
                                       <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <decl_stmt><decl><type><name>agtype</name> <modifier>*</modifier></type><name>properties</name> <init>= <expr><call><name>AG_GET_ARG_AGTYPE_P</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AGT_ROOT_IS_OBJECT</name><argument_list>(<argument><expr><name>properties</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(
                <argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(
                     <argument><expr><literal type="string">"_agtype_build_edge() properties argument must be an object"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><call><name>add_agtype</name><argument_list>(<argument><expr><operator>(</operator><name>Datum</name><operator>)</operator><name>properties</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>result</name></expr></argument>, <argument><expr><name>AGTYPEOID</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><name><name>result</name><operator>.</operator><name>res</name></name> <operator>=</operator> <call><name>push_agtype_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>result</name><operator>.</operator><name>parse_state</name></name></expr></argument>, <argument><expr><name>WAGT_END_OBJECT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>result</name><operator>.</operator><name>res</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>AGTV_EDGE</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><call><name>agtype_value_to_agtype</name><argument_list>(<argument><expr><name><name>result</name><operator>.</operator><name>res</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type> <name>make_edge</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>id</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>startid</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>endid</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>label</name></decl></parameter>,
                <parameter><decl><type><name>Datum</name></type> <name>properties</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>DirectFunctionCall5</name><argument_list>(<argument><expr><name>_agtype_build_edge</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>startid</name></expr></argument>, <argument><expr><name>endid</name></expr></argument>, <argument><expr><name>label</name></expr></argument>,
                               <argument><expr><name>properties</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>agtype_build_map</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/*
 * SQL function agtype_build_map(variadic "any")
 */</comment>
<function><type><name>Datum</name></type> <name>agtype_build_map</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>nargs</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_in_state</name></type> <name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name> <modifier>*</modifier></type><name>args</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name> <modifier>*</modifier></type><name>nulls</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name> <modifier>*</modifier></type><name>types</name></decl>;</decl_stmt>

    <comment type="block">/* build argument values to build the object */</comment>
    <expr_stmt><expr><name>nargs</name> <operator>=</operator> <call><name>extract_variadic_args</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>args</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>types</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>nargs</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>nargs</name> <operator>%</operator> <literal type="number">2</literal> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(
            <argument><expr><name>ERROR</name></expr></argument>,
            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"argument list must have been even number of elements"</literal></expr></argument>)</argument_list></call><operator>,</operator>
             <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"The arguments of agtype_build_map() must consist of alternating keys and values."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>agtype_in_state</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>result</name><operator>.</operator><name>res</name></name> <operator>=</operator> <call><name>push_agtype_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>result</name><operator>.</operator><name>parse_state</name></name></expr></argument>, <argument><expr><name>WAGT_BEGIN_OBJECT</name></expr></argument>,
                                   <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nargs</name></expr>;</condition> <incr><expr><name>i</name> <operator>+=</operator> <literal type="number">2</literal></expr></incr>)</control>
    <block>{<block_content>
        <comment type="block">/* process key */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>nulls</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"argument %d: key must not be null"</literal></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>add_agtype</name><argument_list>(<argument><expr><name><name>args</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>result</name></expr></argument>, <argument><expr><name><name>types</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* process value */</comment>
        <expr_stmt><expr><call><name>add_agtype</name><argument_list>(<argument><expr><name><name>args</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>nulls</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>result</name></expr></argument>, <argument><expr><name><name>types</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><name><name>result</name><operator>.</operator><name>res</name></name> <operator>=</operator> <call><name>push_agtype_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>result</name><operator>.</operator><name>parse_state</name></name></expr></argument>, <argument><expr><name>WAGT_END_OBJECT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><call><name>agtype_value_to_agtype</name><argument_list>(<argument><expr><name><name>result</name><operator>.</operator><name>res</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>agtype_build_map_noargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/*
 * degenerate case of agtype_build_map where it gets 0 arguments.
 */</comment>
<function><type><name>Datum</name></type> <name>agtype_build_map_noargs</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>agtype_in_state</name></type> <name>result</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>agtype_in_state</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>push_agtype_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>result</name><operator>.</operator><name>parse_state</name></name></expr></argument>, <argument><expr><name>WAGT_BEGIN_OBJECT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><operator>.</operator><name>res</name></name> <operator>=</operator> <call><name>push_agtype_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>result</name><operator>.</operator><name>parse_state</name></name></expr></argument>, <argument><expr><name>WAGT_END_OBJECT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><call><name>agtype_value_to_agtype</name><argument_list>(<argument><expr><name><name>result</name><operator>.</operator><name>res</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>agtype_build_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/*
 * SQL function agtype_build_list(variadic "any")
 */</comment>
<function><type><name>Datum</name></type> <name>agtype_build_list</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>nargs</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_in_state</name></type> <name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name> <modifier>*</modifier></type><name>args</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name> <modifier>*</modifier></type><name>nulls</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name> <modifier>*</modifier></type><name>types</name></decl>;</decl_stmt>

    <comment type="block">/*build argument values to build the array */</comment>
    <expr_stmt><expr><name>nargs</name> <operator>=</operator> <call><name>extract_variadic_args</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>args</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>types</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>nargs</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>agtype_in_state</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>result</name><operator>.</operator><name>res</name></name> <operator>=</operator> <call><name>push_agtype_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>result</name><operator>.</operator><name>parse_state</name></name></expr></argument>, <argument><expr><name>WAGT_BEGIN_ARRAY</name></expr></argument>,
                                   <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nargs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>add_agtype</name><argument_list>(<argument><expr><name><name>args</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>nulls</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>result</name></expr></argument>, <argument><expr><name><name>types</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

    <expr_stmt><expr><name><name>result</name><operator>.</operator><name>res</name></name> <operator>=</operator> <call><name>push_agtype_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>result</name><operator>.</operator><name>parse_state</name></name></expr></argument>, <argument><expr><name>WAGT_END_ARRAY</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><call><name>agtype_value_to_agtype</name><argument_list>(<argument><expr><name><name>result</name><operator>.</operator><name>res</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>agtype_build_list_noargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/*
 * degenerate case of agtype_build_list where it gets 0 arguments.
 */</comment>
<function><type><name>Datum</name></type> <name>agtype_build_list_noargs</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>agtype_in_state</name></type> <name>result</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>agtype_in_state</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>push_agtype_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>result</name><operator>.</operator><name>parse_state</name></name></expr></argument>, <argument><expr><name>WAGT_BEGIN_ARRAY</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><operator>.</operator><name>res</name></name> <operator>=</operator> <call><name>push_agtype_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>result</name><operator>.</operator><name>parse_state</name></name></expr></argument>, <argument><expr><name>WAGT_END_ARRAY</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><call><name>agtype_value_to_agtype</name><argument_list>(<argument><expr><name><name>result</name><operator>.</operator><name>res</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Extract scalar value from raw-scalar pseudo-array agtype.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type> <name>agtype_extract_scalar</name><parameter_list>(<parameter><decl><type><name>agtype_container</name> <modifier>*</modifier></type><name>agtc</name></decl></parameter>, <parameter><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>res</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>agtype_iterator</name> <modifier>*</modifier></type><name>it</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_iterator_token</name> <name>tok</name></type> <name>PG_USED_FOR_ASSERTS_ONLY</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_value</name></type> <name>tmp</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AGTYPE_CONTAINER_IS_ARRAY</name><argument_list>(<argument><expr><name>agtc</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>AGTYPE_CONTAINER_IS_SCALAR</name><argument_list>(<argument><expr><name>agtc</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* inform caller about actual type of container */</comment>
        <expr_stmt><expr><name><name>res</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <ternary><condition><expr><call><name>AGTYPE_CONTAINER_IS_ARRAY</name><argument_list>(<argument><expr><name>agtc</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>AGTV_ARRAY</name></expr> </then><else>: <expr><name>AGTV_OBJECT</name></expr></else></ternary></expr>;</expr_stmt>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * A root scalar is stored as an array of one element, so we get the array
     * and then its first (and only) member.
     */</comment>
    <expr_stmt><expr><name>it</name> <operator>=</operator> <call><name>agtype_iterator_init</name><argument_list>(<argument><expr><name>agtc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>tok</name> <operator>=</operator> <call><name>agtype_iterator_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name>it</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmp</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>tok</name> <operator>==</operator> <name>WAGT_BEGIN_ARRAY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>tmp</name><operator>.</operator><name>val</name><operator>.</operator><name>array</name><operator>.</operator><name>num_elems</name></name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>tmp</name><operator>.</operator><name>val</name><operator>.</operator><name>array</name><operator>.</operator><name>raw_scalar</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>tok</name> <operator>=</operator> <call><name>agtype_iterator_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name>it</name></expr></argument>, <argument><expr><name>res</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>tok</name> <operator>==</operator> <name>WAGT_ELEM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IS_A_AGTYPE_SCALAR</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>tok</name> <operator>=</operator> <call><name>agtype_iterator_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name>it</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmp</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>tok</name> <operator>==</operator> <name>WAGT_END_ARRAY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>tok</name> <operator>=</operator> <call><name>agtype_iterator_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name>it</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmp</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>tok</name> <operator>==</operator> <name>WAGT_DONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Emit correct, translatable cast error message
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>cannot_cast_agtype_value</name><parameter_list>(<parameter><decl><type><name><name>enum</name> <name>agtype_value_type</name></name></type> <name>type</name></decl></parameter>,
                                     <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sqltype</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <struct><specifier>static</specifier> <specifier>const</specifier> struct
    <block>{
        <decl_stmt><decl><type><name><name>enum</name> <name>agtype_value_type</name></name></type> <name>type</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>msg</name></decl>;</decl_stmt>
    }</block> <decl><name><name>messages</name><index>[]</index></name> <init>= <expr><block>{
        <expr><block>{<expr><name>AGTV_NULL</name></expr>, <macro><name>gettext_noop</name><argument_list>(<argument><literal type="string">"cannot cast agtype null to type %s"</literal></argument>)</argument_list></macro>}</block></expr>,
        <expr><block>{<expr><name>AGTV_STRING</name></expr>, <macro><name>gettext_noop</name><argument_list>(<argument><literal type="string">"cannot cast agtype string to type %s"</literal></argument>)</argument_list></macro>}</block></expr>,
        <expr><block>{<expr><name>AGTV_NUMERIC</name></expr>, <macro><name>gettext_noop</name><argument_list>(<argument><literal type="string">"cannot cast agtype numeric to type %s"</literal></argument>)</argument_list></macro>}</block></expr>,
        <expr><block>{<expr><name>AGTV_INTEGER</name></expr>, <macro><name>gettext_noop</name><argument_list>(<argument><literal type="string">"cannot cast agtype integer to type %s"</literal></argument>)</argument_list></macro>}</block></expr>,
        <expr><block>{<expr><name>AGTV_FLOAT</name></expr>, <macro><name>gettext_noop</name><argument_list>(<argument><literal type="string">"cannot cast agtype float to type %s"</literal></argument>)</argument_list></macro>}</block></expr>,
        <expr><block>{<expr><name>AGTV_BOOL</name></expr>, <macro><name>gettext_noop</name><argument_list>(<argument><literal type="string">"cannot cast agtype boolean to type %s"</literal></argument>)</argument_list></macro>}</block></expr>,
        <expr><block>{<expr><name>AGTV_ARRAY</name></expr>, <macro><name>gettext_noop</name><argument_list>(<argument><literal type="string">"cannot cast agtype array to type %s"</literal></argument>)</argument_list></macro>}</block></expr>,
        <expr><block>{<expr><name>AGTV_OBJECT</name></expr>, <macro><name>gettext_noop</name><argument_list>(<argument><literal type="string">"cannot cast agtype object to type %s"</literal></argument>)</argument_list></macro>}</block></expr>,
        <expr><block>{<expr><name>AGTV_VERTEX</name></expr>, <macro><name>gettext_noop</name><argument_list>(<argument><literal type="string">"cannot cast agtype vertex to type %s"</literal></argument>)</argument_list></macro>}</block></expr>,
        <expr><block>{<expr><name>AGTV_EDGE</name></expr>, <macro><name>gettext_noop</name><argument_list>(<argument><literal type="string">"cannot cast agtype edge to type %s"</literal></argument>)</argument_list></macro>}</block></expr>,
        <expr><block>{<expr><name>AGTV_PATH</name></expr>, <macro><name>gettext_noop</name><argument_list>(<argument><literal type="string">"cannot cast agtype path to type %s"</literal></argument>)</argument_list></macro>}</block></expr>,
        <expr><block>{<expr><name>AGTV_BINARY</name></expr>,
         <macro><name>gettext_noop</name><argument_list>(<argument><literal type="string">"cannot cast agtype array or object to type %s"</literal></argument>)</argument_list></macro>}</block></expr>}</block></expr></init></decl>;</struct>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>lengthof</name><argument_list>(<argument><expr><name>messages</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>messages</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>type</name> <operator>==</operator> <name>type</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                            <call><name>errmsg</name><argument_list>(<argument><expr><name><name>messages</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>msg</name></expr></argument>, <argument><expr><name>sqltype</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/* should be unreachable */</comment>
    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unknown agtype type: %d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>agtype_to_bool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/*
 * Cast agtype to boolean. From jsonb_bool().
 */</comment>
<function><type><name>Datum</name></type> <name>agtype_to_bool</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>agtype</name> <modifier>*</modifier></type><name>agtype_in</name> <init>= <expr><call><name>AG_GET_ARG_AGTYPE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_value</name></type> <name>agtv</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>agtype_extract_scalar</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>agtype_in</name><operator>-&gt;</operator><name>root</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>agtv</name></expr></argument>)</argument_list></call> <operator>||</operator>
        <name><name>agtv</name><operator>.</operator><name>type</name></name> <operator>!=</operator> <name>AGTV_BOOL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>cannot_cast_agtype_value</name><argument_list>(<argument><expr><name><name>agtv</name><operator>.</operator><name>type</name></name></expr></argument>, <argument><expr><literal type="string">"boolean"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>agtype_in</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name><name>agtv</name><operator>.</operator><name>val</name><operator>.</operator><name>boolean</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>agtype_to_int8</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<comment type="block">/*
 * Cast agtype to int8.
 */</comment>
<function><type><name>Datum</name></type> <name>agtype_to_int8</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>agtype</name> <modifier>*</modifier></type><name>agtype_in</name> <init>= <expr><call><name>AG_GET_ARG_AGTYPE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_value</name></type> <name>agtv</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int64</name></type> <name>result</name> <init>= <expr><literal type="number">0x0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype</name> <modifier>*</modifier></type><name>arg_agt</name></decl>;</decl_stmt>

    <comment type="block">/* get the agtype equivalence of any convertable input type */</comment>
    <expr_stmt><expr><name>arg_agt</name> <operator>=</operator> <call><name>get_one_agtype_from_variadic_args</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Return null if arg_agt is null. This covers SQL and Agtype NULLS */</comment>
    <if_stmt><if>if <condition>(<expr><name>arg_agt</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>agtype_extract_scalar</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>arg_agt</name><operator>-&gt;</operator><name>root</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>agtv</name></expr></argument>)</argument_list></call> <operator>||</operator>
        <operator>(</operator><name><name>agtv</name><operator>.</operator><name>type</name></name> <operator>!=</operator> <name>AGTV_FLOAT</name> <operator>&amp;&amp;</operator>
         <name><name>agtv</name><operator>.</operator><name>type</name></name> <operator>!=</operator> <name>AGTV_INTEGER</name> <operator>&amp;&amp;</operator>
         <name><name>agtv</name><operator>.</operator><name>type</name></name> <operator>!=</operator> <name>AGTV_NUMERIC</name> <operator>&amp;&amp;</operator>
         <name><name>agtv</name><operator>.</operator><name>type</name></name> <operator>!=</operator> <name>AGTV_STRING</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>cannot_cast_agtype_value</name><argument_list>(<argument><expr><name><name>agtv</name><operator>.</operator><name>type</name></name></expr></argument>, <argument><expr><literal type="string">"int"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>agtype_in</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>agtv</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>AGTV_INTEGER</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>agtv</name><operator>.</operator><name>val</name><operator>.</operator><name>int_value</name></name></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><name><name>agtv</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>AGTV_FLOAT</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>DatumGetInt64</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>dtoi8</name></expr></argument>,
                                <argument><expr><call><name>Float8GetDatum</name><argument_list>(<argument><expr><name><name>agtv</name><operator>.</operator><name>val</name><operator>.</operator><name>float_value</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><name><name>agtv</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>AGTV_NUMERIC</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>DatumGetInt64</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>numeric_int8</name></expr></argument>,
                     <argument><expr><call><name>NumericGetDatum</name><argument_list>(<argument><expr><name><name>agtv</name><operator>.</operator><name>val</name><operator>.</operator><name>numeric</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><name><name>agtv</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>AGTV_STRING</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>DatumGetInt64</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>int8in</name></expr></argument>,
                           <argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name><name>agtv</name><operator>.</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>val</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid agtype type: %d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>agtv</name><operator>.</operator><name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_INT64</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>agtype_to_int4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/*
 * Cast agtype to int4.
 */</comment>
<function><type><name>Datum</name></type> <name>agtype_to_int4</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>agtype</name> <modifier>*</modifier></type><name>agtype_in</name> <init>= <expr><call><name>AG_GET_ARG_AGTYPE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_value</name></type> <name>agtv</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type> <name>result</name> <init>= <expr><literal type="number">0x0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype</name> <modifier>*</modifier></type><name>arg_agt</name></decl>;</decl_stmt>

    <comment type="block">/* get the agtype equivalence of any convertable input type */</comment>
    <expr_stmt><expr><name>arg_agt</name> <operator>=</operator> <call><name>get_one_agtype_from_variadic_args</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Return null if arg_agt is null. This covers SQL and Agtype NULLS */</comment>
    <if_stmt><if>if <condition>(<expr><name>arg_agt</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>agtype_extract_scalar</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>arg_agt</name><operator>-&gt;</operator><name>root</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>agtv</name></expr></argument>)</argument_list></call> <operator>||</operator>
        <operator>(</operator><name><name>agtv</name><operator>.</operator><name>type</name></name> <operator>!=</operator> <name>AGTV_FLOAT</name> <operator>&amp;&amp;</operator>
         <name><name>agtv</name><operator>.</operator><name>type</name></name> <operator>!=</operator> <name>AGTV_INTEGER</name> <operator>&amp;&amp;</operator>
         <name><name>agtv</name><operator>.</operator><name>type</name></name> <operator>!=</operator> <name>AGTV_NUMERIC</name> <operator>&amp;&amp;</operator>
         <name><name>agtv</name><operator>.</operator><name>type</name></name> <operator>!=</operator> <name>AGTV_STRING</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>cannot_cast_agtype_value</name><argument_list>(<argument><expr><name><name>agtv</name><operator>.</operator><name>type</name></name></expr></argument>, <argument><expr><literal type="string">"int"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>agtype_in</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>agtv</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>AGTV_INTEGER</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>DatumGetInt32</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>int84</name></expr></argument>,
                    <argument><expr><call><name>Int64GetDatum</name><argument_list>(<argument><expr><name><name>agtv</name><operator>.</operator><name>val</name><operator>.</operator><name>int_value</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><name><name>agtv</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>AGTV_FLOAT</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>DatumGetInt32</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>dtoi4</name></expr></argument>,
                                <argument><expr><call><name>Float8GetDatum</name><argument_list>(<argument><expr><name><name>agtv</name><operator>.</operator><name>val</name><operator>.</operator><name>float_value</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><name><name>agtv</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>AGTV_NUMERIC</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>DatumGetInt32</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>numeric_int4</name></expr></argument>,
                     <argument><expr><call><name>NumericGetDatum</name><argument_list>(<argument><expr><name><name>agtv</name><operator>.</operator><name>val</name><operator>.</operator><name>numeric</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><name><name>agtv</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>AGTV_STRING</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>DatumGetInt32</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>int4in</name></expr></argument>,
                           <argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name><name>agtv</name><operator>.</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>val</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid agtype type: %d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>agtv</name><operator>.</operator><name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_INT32</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>agtype_to_int2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/*
 * Cast agtype to int2.
 */</comment>
<function><type><name>Datum</name></type> <name>agtype_to_int2</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>agtype</name> <modifier>*</modifier></type><name>agtype_in</name> <init>= <expr><call><name>AG_GET_ARG_AGTYPE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_value</name></type> <name>agtv</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int16</name></type> <name>result</name> <init>= <expr><literal type="number">0x0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype</name> <modifier>*</modifier></type><name>arg_agt</name></decl>;</decl_stmt>

    <comment type="block">/* get the agtype equivalence of any convertable input type */</comment>
    <expr_stmt><expr><name>arg_agt</name> <operator>=</operator> <call><name>get_one_agtype_from_variadic_args</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Return null if arg_agt is null. This covers SQL and Agtype NULLS */</comment>
    <if_stmt><if>if <condition>(<expr><name>arg_agt</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>agtype_extract_scalar</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>arg_agt</name><operator>-&gt;</operator><name>root</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>agtv</name></expr></argument>)</argument_list></call> <operator>||</operator>
        <operator>(</operator><name><name>agtv</name><operator>.</operator><name>type</name></name> <operator>!=</operator> <name>AGTV_FLOAT</name> <operator>&amp;&amp;</operator>
         <name><name>agtv</name><operator>.</operator><name>type</name></name> <operator>!=</operator> <name>AGTV_INTEGER</name> <operator>&amp;&amp;</operator>
         <name><name>agtv</name><operator>.</operator><name>type</name></name> <operator>!=</operator> <name>AGTV_NUMERIC</name> <operator>&amp;&amp;</operator>
         <name><name>agtv</name><operator>.</operator><name>type</name></name> <operator>!=</operator> <name>AGTV_STRING</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>cannot_cast_agtype_value</name><argument_list>(<argument><expr><name><name>agtv</name><operator>.</operator><name>type</name></name></expr></argument>, <argument><expr><literal type="string">"int"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>agtype_in</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>agtv</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>AGTV_INTEGER</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>DatumGetInt16</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>int82</name></expr></argument>,
                    <argument><expr><call><name>Int64GetDatum</name><argument_list>(<argument><expr><name><name>agtv</name><operator>.</operator><name>val</name><operator>.</operator><name>int_value</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><name><name>agtv</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>AGTV_FLOAT</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>DatumGetInt32</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>dtoi2</name></expr></argument>,
                                <argument><expr><call><name>Float8GetDatum</name><argument_list>(<argument><expr><name><name>agtv</name><operator>.</operator><name>val</name><operator>.</operator><name>float_value</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><name><name>agtv</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>AGTV_NUMERIC</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>DatumGetInt16</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>numeric_int2</name></expr></argument>,
                     <argument><expr><call><name>NumericGetDatum</name><argument_list>(<argument><expr><name><name>agtv</name><operator>.</operator><name>val</name><operator>.</operator><name>numeric</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><name><name>agtv</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>AGTV_STRING</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>DatumGetInt16</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>int2in</name></expr></argument>,
                           <argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name><name>agtv</name><operator>.</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>val</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid agtype type: %d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>agtv</name><operator>.</operator><name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_INT16</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>agtype_to_float8</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/*
 * Cast agtype to float8.
 */</comment>
<function><type><name>Datum</name></type> <name>agtype_to_float8</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>agtype</name> <modifier>*</modifier></type><name>agtype_in</name> <init>= <expr><call><name>AG_GET_ARG_AGTYPE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_value</name></type> <name>agtv</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>float8</name></type> <name>result</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>agtype_extract_scalar</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>agtype_in</name><operator>-&gt;</operator><name>root</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>agtv</name></expr></argument>)</argument_list></call> <operator>||</operator>
        <operator>(</operator><name><name>agtv</name><operator>.</operator><name>type</name></name> <operator>!=</operator> <name>AGTV_FLOAT</name> <operator>&amp;&amp;</operator>
         <name><name>agtv</name><operator>.</operator><name>type</name></name> <operator>!=</operator> <name>AGTV_INTEGER</name> <operator>&amp;&amp;</operator>
         <name><name>agtv</name><operator>.</operator><name>type</name></name> <operator>!=</operator> <name>AGTV_NUMERIC</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>cannot_cast_agtype_value</name><argument_list>(<argument><expr><name><name>agtv</name><operator>.</operator><name>type</name></name></expr></argument>, <argument><expr><literal type="string">"float"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>agtype_in</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>agtv</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>AGTV_FLOAT</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>agtv</name><operator>.</operator><name>val</name><operator>.</operator><name>float_value</name></name></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><name><name>agtv</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>AGTV_INTEGER</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * Get the string representation of the integer because it could be
         * too large to fit in a float. Let the float routine determine
         * what to do with it.
         */</comment>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>string</name> <init>= <expr><call><name>DatumGetCString</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>int8out</name></expr></argument>,
                           <argument><expr><call><name>Int64GetDatum</name><argument_list>(<argument><expr><name><name>agtv</name><operator>.</operator><name>val</name><operator>.</operator><name>int_value</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type> <name>is_valid</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
        <comment type="block">/* turn it into a float */</comment>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>float8in_internal_null</name><argument_list>(<argument><expr><name>string</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"double precision"</literal></expr></argument>,
                                     <argument><expr><name>string</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>is_valid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* return null if it was not a invalid float */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_valid</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
                            <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot cast to float8, integer value out of range"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name><name>agtv</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>AGTV_NUMERIC</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>DatumGetFloat8</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>numeric_float8</name></expr></argument>,
                     <argument><expr><call><name>NumericGetDatum</name><argument_list>(<argument><expr><name><name>agtv</name><operator>.</operator><name>val</name><operator>.</operator><name>numeric</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid agtype type: %d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>agtv</name><operator>.</operator><name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>agtype_to_text</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/*
 * Cast agtype to text.
 */</comment>
<function><type><name>Datum</name></type> <name>agtype_to_text</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>agtype</name> <modifier>*</modifier></type><name>arg_agt</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>arg_value</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>text</name> <modifier>*</modifier></type><name>text_value</name></decl>;</decl_stmt>

    <comment type="block">/* get the agtype equivalence of any convertable input type */</comment>
    <expr_stmt><expr><name>arg_agt</name> <operator>=</operator> <call><name>get_one_agtype_from_variadic_args</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Return null if arg_agt is null. This covers SQL and Agtype NULLS */</comment>
    <if_stmt><if>if <condition>(<expr><name>arg_agt</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* check that we have a scalar value */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AGT_ROOT_IS_SCALAR</name><argument_list>(<argument><expr><name>arg_agt</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"agtype argument must resolve to a scalar value"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* get the arg parameter */</comment>
    <expr_stmt><expr><name>arg_value</name> <operator>=</operator> <call><name>get_ith_agtype_value_from_container</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>arg_agt</name><operator>-&gt;</operator><name>root</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>text_value</name> <operator>=</operator> <call><name>agtype_value_to_text</name><argument_list>(<argument><expr><name>arg_value</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>text_value</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_TEXT_P</name><argument_list>(<argument><expr><name>text_value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>bool_to_agtype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/*
 * Cast boolean to agtype.
 */</comment>
<function><type><name>Datum</name></type> <name>bool_to_agtype</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>boolean_to_agtype</name><argument_list>(<argument><expr><call><name>PG_GETARG_BOOL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>float8_to_agtype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/*
 * Cast float8 to agtype.
 */</comment>
<function><type><name>Datum</name></type> <name>float8_to_agtype</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>float_to_agtype</name><argument_list>(<argument><expr><call><name>PG_GETARG_FLOAT8</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>int8_to_agtype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/*
 * Cast float8 to agtype.
 */</comment>
<function><type><name>Datum</name></type> <name>int8_to_agtype</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>integer_to_agtype</name><argument_list>(<argument><expr><call><name>PG_GETARG_INT64</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>agtype_to_int4_array</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/*
 * Cast agtype to int4[].
 */</comment>
<function><type><name>Datum</name></type> <name>agtype_to_int4_array</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>agtype</name> <modifier>*</modifier></type><name>agtype_in</name> <init>= <expr><call><name>AG_GET_ARG_AGTYPE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_value</name></type> <name>agtv</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_iterator_token</name></type> <name>agtv_token</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name> <modifier>*</modifier></type><name>array_value</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ArrayType</name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>element_size</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>agtype_iterator</name> <modifier>*</modifier></type><name>agtype_iterator</name> <init>= <expr><call><name>agtype_iterator_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>agtype_in</name><operator>-&gt;</operator><name>root</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>agtv_token</name> <operator>=</operator> <call><name>agtype_iterator_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name>agtype_iterator</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>agtv</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>agtv</name><operator>.</operator><name>type</name></name> <operator>!=</operator> <name>AGTV_ARRAY</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>cannot_cast_agtype_value</name><argument_list>(<argument><expr><name><name>agtv</name><operator>.</operator><name>type</name></name></expr></argument>, <argument><expr><literal type="string">"int4[]"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>element_size</name> <operator>=</operator> <name><name>agtv</name><operator>.</operator><name>val</name><operator>.</operator><name>array</name><operator>.</operator><name>num_elems</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>array_value</name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>element_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <while>while <condition>(<expr><operator>(</operator><name>agtv_token</name> <operator>=</operator> <call><name>agtype_iterator_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name>agtype_iterator</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>agtv</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>WAGT_END_ARRAY</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int32</name></type> <name>element_value</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>agtv</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>AGTV_INTEGER</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>element_value</name> <operator>=</operator> <call><name>DatumGetInt32</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>int84</name></expr></argument>,
                                                              <argument><expr><call><name>Int64GetDatum</name><argument_list>(<argument><expr><name><name>agtv</name><operator>.</operator><name>val</name><operator>.</operator><name>int_value</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><name><name>agtv</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>AGTV_FLOAT</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>element_value</name> <operator>=</operator> <call><name>DatumGetInt32</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>dtoi4</name></expr></argument>,
                                                              <argument><expr><call><name>Float8GetDatum</name><argument_list>(<argument><expr><name><name>agtv</name><operator>.</operator><name>val</name><operator>.</operator><name>float_value</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><name><name>agtv</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>AGTV_NUMERIC</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>element_value</name> <operator>=</operator> <call><name>DatumGetInt32</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>numeric_int4</name></expr></argument>,
                                                              <argument><expr><call><name>NumericGetDatum</name><argument_list>(<argument><expr><name><name>agtv</name><operator>.</operator><name>val</name><operator>.</operator><name>numeric</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><name><name>agtv</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>AGTV_STRING</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>element_value</name> <operator>=</operator> <call><name>DatumGetInt32</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>int4in</name></expr></argument>,
                                                              <argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name><name>agtv</name><operator>.</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>val</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name><name>array_value</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>element_value</name></expr>;</expr_stmt>
    </block_content>}</block></while>

    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>construct_array</name><argument_list>(<argument><expr><name>array_value</name></expr></argument>, <argument><expr><name>element_size</name></expr></argument>, <argument><expr><name>INT4OID</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><literal type="char">'i'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_ARRAYTYPE_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Helper function for agtype_access_operator map access.
 * Note: This function expects that a map and a scalar key are being passed.
 */</comment>
<function><type><specifier>static</specifier> <name>agtype_value</name> <modifier>*</modifier></type><name>execute_map_access_operator</name><parameter_list>(<parameter><decl><type><name>agtype</name> <modifier>*</modifier></type><name>map</name></decl></parameter>,
                                                 <parameter><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>map_value</name></decl></parameter>,
                                                 <parameter><decl><type><name>agtype</name> <modifier>*</modifier></type><name>key</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>key_value</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>key_str</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>key_len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <comment type="block">/* get the key from the container */</comment>
    <expr_stmt><expr><name>key_value</name> <operator>=</operator> <call><name>get_ith_agtype_value_from_container</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><operator>-&gt;</operator><name>root</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <switch>switch <condition>(<expr><name><name>key_value</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition>
    <block>{<block_content>
    <case>case <expr><name>AGTV_NULL</name></expr>:</case>
        <return>return <expr><name>NULL</name></expr>;</return>

    <case>case <expr><name>AGTV_INTEGER</name></expr>:</case>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                        <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"AGTV_INTEGER is not a valid key type"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <case>case <expr><name>AGTV_FLOAT</name></expr>:</case>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                        <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"AGTV_FLOAT is not a valid key type"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <case>case <expr><name>AGTV_NUMERIC</name></expr>:</case>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                        <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"AGTV_NUMERIC is not a valid key type"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <case>case <expr><name>AGTV_BOOL</name></expr>:</case>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                        <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"AGTV_BOOL is not a valid key type"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <case>case <expr><name>AGTV_STRING</name></expr>:</case>
        <expr_stmt><expr><name>key_str</name> <operator>=</operator> <name><name>key_value</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>val</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>key_len</name> <operator>=</operator> <name><name>key_value</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>len</name></name></expr>;</expr_stmt>
        <break>break;</break>
    <default>default:</default>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unknown agtype scalar type"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
    </block_content>}</block></switch>

    <return>return <expr><call><name>execute_map_access_operator_internal</name><argument_list>(<argument><expr><name>map</name></expr></argument>, <argument><expr><name>map_value</name></expr></argument>, <argument><expr><name>key_str</name></expr></argument>,
                                                <argument><expr><name>key_len</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>agtype_value</name> <modifier>*</modifier></type><name>execute_map_access_operator_internal</name><parameter_list>(
    <parameter><decl><type><name>agtype</name> <modifier>*</modifier></type><name>map</name></decl></parameter>, <parameter><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>map_value</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>key_len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>agtype_value</name></type> <name>new_key_value</name></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>new_key_value</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>AGTV_STRING</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>new_key_value</name><operator>.</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>val</name></name> <operator>=</operator> <name>key</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>new_key_value</name><operator>.</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>len</name></name> <operator>=</operator> <name>key_len</name></expr>;</expr_stmt>
    <comment type="block">/* if we were passed an agtype */</comment>
    <if_stmt><if>if <condition>(<expr><name>map_value</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>map_value</name> <operator>=</operator> <call><name>find_agtype_value_from_container</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>map</name><operator>-&gt;</operator><name>root</name></name></expr></argument>, <argument><expr><name>AGT_FOBJECT</name></expr></argument>,
                                                     <argument><expr><operator>&amp;</operator><name>new_key_value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <comment type="block">/* if we were passed an agtype_value OBJECT (BINARY) */</comment>
    <if type="elseif">else if <condition>(<expr><name>map_value</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>map_value</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AGTV_BINARY</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>map_value</name> <operator>=</operator> <call><name>find_agtype_value_from_container</name><argument_list>(<argument><expr><name><name>map_value</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>binary</name><operator>.</operator><name>data</name></name></expr></argument>,
                                                     <argument><expr><name>AGT_FOBJECT</name></expr></argument>,
                                                     <argument><expr><operator>&amp;</operator><name>new_key_value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <comment type="block">/* if we were passed an agtype_value OBJECT */</comment>
    <if type="elseif">else if <condition>(<expr><name>map_value</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>map_value</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AGTV_OBJECT</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>map_value</name> <operator>=</operator> <call><name>get_agtype_value_object_value</name><argument_list>(<argument><expr><name>map_value</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>key_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <comment type="block">/* otherwise, we don't know how to process it */</comment>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unknown map_value type"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* return the agtype_value */</comment>
    <return>return <expr><name>map_value</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Helper function for agtype_access_operator array access.
 * Note: This function expects that an array and a scalar int are being passed.
 */</comment>
<function><type><specifier>static</specifier> <name>agtype_value</name> <modifier>*</modifier></type><name>execute_array_access_operator</name><parameter_list>(<parameter><decl><type><name>agtype</name> <modifier>*</modifier></type><name>array</name></decl></parameter>,
                                                   <parameter><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>array_value</name></decl></parameter>,
                                                   <parameter><decl><type><name>agtype</name> <modifier>*</modifier></type><name>array_index</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>array_index_value</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* unpack the array index value */</comment>
    <expr_stmt><expr><name>array_index_value</name> <operator>=</operator> <call><name>get_ith_agtype_value_from_container</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>array_index</name><operator>-&gt;</operator><name>root</name></name></expr></argument>,
                                                            <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* if AGTV_NULL return NULL */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>array_index_value</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AGTV_NULL</name></expr>)</condition>
    <block>{<block_content>
        <return>return <expr><name>NULL</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* index must be an integer */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>array_index_value</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>AGTV_INTEGER</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"array index must resolve to an integer value"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><call><name>execute_array_access_operator_internal</name><argument_list>(
        <argument><expr><name>array</name></expr></argument>, <argument><expr><name>array_value</name></expr></argument>, <argument><expr><name><name>array_index_value</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>int_value</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>agtype_value</name> <modifier>*</modifier></type><name>execute_array_access_operator_internal</name><parameter_list>(<parameter><decl><type><name>agtype</name> <modifier>*</modifier></type><name>array</name></decl></parameter>,
                                                            <parameter><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>array_value</name></decl></parameter>,
                                                            <parameter><decl><type><name>int64</name></type> <name>array_index</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>array_element_value</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type> <name>size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <comment type="block">/* get the size of the array, given the type of the input */</comment>
    <if_stmt><if>if <condition>(<expr><name>array_value</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>AGT_ROOT_COUNT</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name><name>array_value</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AGTV_ARRAY</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>size</name> <operator>=</operator> <name><name>array_value</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>array</name><operator>.</operator><name>num_elems</name></name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name><name>array_value</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AGTV_BINARY</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>AGTYPE_CONTAINER_SIZE</name><argument_list>(<argument><expr><name><name>array_value</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>binary</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"execute_array_access_operator_internal: unexpected type"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* adjust for negative index values */</comment>
    <if_stmt><if>if <condition>(<expr><name>array_index</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>array_index</name> <operator>=</operator> <name>size</name> <operator>+</operator> <name>array_index</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* check array bounds */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>array_index</name> <operator>&gt;=</operator> <name>size</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>array_index</name> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <return>return <expr><name>NULL</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* if we were passed an agtype */</comment>
    <if_stmt><if>if <condition>(<expr><name>array_value</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>array_element_value</name> <operator>=</operator> <call><name>get_ith_agtype_value_from_container</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>array</name><operator>-&gt;</operator><name>root</name></name></expr></argument>,
                                                                  <argument><expr><name>array_index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <comment type="block">/* if we were passed an agtype_value ARRAY (BINARY) */</comment>
    <if type="elseif">else if <condition>(<expr><name>array_value</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>array_value</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AGTV_BINARY</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>array_element_value</name> <operator>=</operator> <call><name>get_ith_agtype_value_from_container</name><argument_list>(
            <argument><expr><name><name>array_value</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>binary</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name>array_index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <comment type="block">/* if we were passed an agtype_value ARRAY */</comment>
    <if type="elseif">else if <condition>(<expr><name>array_value</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>array_value</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AGTV_ARRAY</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>array_element_value</name> <operator>=</operator> <operator>&amp;</operator><name><name>array_value</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>array</name><operator>.</operator><name>elems</name><index>[<expr><name>array_index</name></expr>]</index></name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <comment type="block">/* otherwise, we don't know how to process it */</comment>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unknown array_value type"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <return>return <expr><name>array_element_value</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Helper function to do a binary search through an object's key/value pairs,
 * looking for a specific key. It will return the key or NULL if not found.
 */</comment>
<function><type><name>agtype_value</name> <modifier>*</modifier></type><name>get_agtype_value_object_value</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>agtype_value</name> <modifier>*</modifier></type><name>agtv_object</name></decl></parameter>,
                                            <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>search_key</name></decl></parameter>,
                                            <parameter><decl><type><name>int</name></type> <name>search_key_length</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>agtv_key</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>current_key_length</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>middle</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>num_pairs</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>left</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>right</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>result</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>agtv_object</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>search_key</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>search_key_length</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <return>return <expr><name>NULL</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* get the number of object pairs */</comment>
    <expr_stmt><expr><name>num_pairs</name> <operator>=</operator> <name><name>agtv_object</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>object</name><operator>.</operator><name>num_pairs</name></name></expr>;</expr_stmt>

    <comment type="block">/* do a binary search through the pairs */</comment>
    <expr_stmt><expr><name>right</name> <operator>=</operator> <name>num_pairs</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>middle</name> <operator>=</operator> <name>num_pairs</name> <operator>/</operator> <literal type="number">2</literal></expr>;</expr_stmt>

    <comment type="block">/* while middle is within the constraints */</comment>
    <while>while <condition>(<expr><name>middle</name> <operator>&gt;=</operator> <name>left</name> <operator>&amp;&amp;</operator> <name>middle</name> <operator>&lt;=</operator> <name>right</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* get the current key length */</comment>
        <expr_stmt><expr><name>agtv_key</name> <operator>=</operator> <operator>&amp;</operator><name><name>agtv_object</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>object</name><operator>.</operator><name>pairs</name><index>[<expr><name>middle</name></expr>]</index></name><operator>.</operator><name>key</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>current_key_length</name> <operator>=</operator> <name><name>agtv_key</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>len</name></name></expr>;</expr_stmt>

        <comment type="block">/* if not the same length, divide the search space and continue */</comment>
        <if_stmt><if>if <condition>(<expr><name>current_key_length</name> <operator>!=</operator> <name>search_key_length</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* if we need to search in the lower half */</comment>
            <if_stmt><if>if <condition>(<expr><name>search_key_length</name> <operator>&lt;</operator> <name>current_key_length</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>middle</name> <operator>-=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name>right</name> <operator>=</operator> <name>middle</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>middle</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>middle</name> <operator>-</operator> <name>left</name><operator>)</operator> <operator>/</operator> <literal type="number">2</literal><operator>)</operator> <operator>+</operator> <name>left</name></expr>;</expr_stmt>
            </block_content>}</block></if>
            <comment type="block">/* else we need to search in the upper half */</comment>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><name>middle</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name>left</name> <operator>=</operator> <name>middle</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>middle</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>right</name> <operator>-</operator> <name>middle</name><operator>)</operator> <operator>/</operator> <literal type="number">2</literal><operator>)</operator> <operator>+</operator> <name>left</name></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
            <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* they are the same length so compare the keys */</comment>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>strncmp</name><argument_list>(<argument><expr><name>search_key</name></expr></argument>, <argument><expr><name><name>agtv_key</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>val</name></name></expr></argument>,
                         <argument><expr><name>search_key_length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* if they don't match */</comment>
        <if_stmt><if>if <condition>(<expr><name>result</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* if smaller */</comment>
            <if_stmt><if>if <condition>(<expr><name>result</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>middle</name> <operator>-=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name>right</name> <operator>=</operator> <name>middle</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>middle</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>middle</name> <operator>-</operator> <name>left</name><operator>)</operator> <operator>/</operator> <literal type="number">2</literal><operator>)</operator> <operator>+</operator> <name>left</name></expr>;</expr_stmt>
            </block_content>}</block></if>
            <comment type="block">/* if larger */</comment>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><name>middle</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name>left</name> <operator>=</operator> <name>middle</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>middle</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>right</name> <operator>-</operator> <name>middle</name><operator>)</operator> <operator>/</operator> <literal type="number">2</literal><operator>)</operator> <operator>+</operator> <name>left</name></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
            <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* they match */</comment>
        <return>return <expr><operator>(</operator><operator>&amp;</operator><name><name>agtv_object</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>object</name><operator>.</operator><name>pairs</name><index>[<expr><name>middle</name></expr>]</index></name><operator>.</operator><name>value</name><operator>)</operator></expr>;</return>
    </block_content>}</block></while>

    <comment type="block">/* they don't match */</comment>
    <return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * From PG's extract_variadic_args
 *
 * This function allows you to pass the minimum number of required arguments
 * so that you can have it bail out early (without allocating and building
 * the output arrays). In this case, the returned number of args will be 0
 * and the args array will be NULL.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>extract_variadic_args_min</name><parameter_list>(<parameter><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name></decl></parameter>,
                                     <parameter><decl><type><name>int</name></type> <name>variadic_start</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>convert_unknown</name></decl></parameter>,
                                     <parameter><decl><type><name>Datum</name> <modifier>*</modifier><modifier>*</modifier></type><name>args</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier><modifier>*</modifier></type><name>types</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier><modifier>*</modifier></type><name>nulls</name></decl></parameter>,
                                     <parameter><decl><type><name>int</name></type> <name>min_num_args</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>bool</name></type> <name>variadic</name> <init>= <expr><call><name>get_fn_expr_variadic</name><argument_list>(<argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name> <modifier>*</modifier></type><name>args_res</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name> <modifier>*</modifier></type><name>nulls_res</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name> <modifier>*</modifier></type><name>types_res</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nargs</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><operator>*</operator><name>args</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>types</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>nulls</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>variadic</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ArrayType</name> <modifier>*</modifier></type><name>array_in</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Oid</name></type> <name>element_type</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type> <name>typbyval</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name></type> <name>typalign</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int16</name></type> <name>typlen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>PG_NARGS</name><argument_list>()</argument_list></call> <operator>==</operator> <name>variadic_start</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><name>variadic_start</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* get the array */</comment>
        <expr_stmt><expr><name>array_in</name> <operator>=</operator> <call><name>PG_GETARG_ARRAYTYPE_P</name><argument_list>(<argument><expr><name>variadic_start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* verify that we have the minimum number of args */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>ArrayGetNItems</name><argument_list>(<argument><expr><call><name>ARR_NDIM</name><argument_list>(<argument><expr><name>array_in</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>ARR_DIMS</name><argument_list>(<argument><expr><name>array_in</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>&lt;</operator>
            <name>min_num_args</name></expr>)</condition>
        <block>{<block_content>
            <return>return <expr><literal type="number">0</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* get the element type */</comment>
        <expr_stmt><expr><name>element_type</name> <operator>=</operator> <call><name>ARR_ELEMTYPE</name><argument_list>(<argument><expr><name>array_in</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>get_typlenbyvalalign</name><argument_list>(<argument><expr><name>element_type</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typlen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typbyval</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typalign</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>deconstruct_array</name><argument_list>(<argument><expr><name>array_in</name></expr></argument>, <argument><expr><name>element_type</name></expr></argument>, <argument><expr><name>typlen</name></expr></argument>, <argument><expr><name>typbyval</name></expr></argument>, <argument><expr><name>typalign</name></expr></argument>,
                          <argument><expr><operator>&amp;</operator><name>args_res</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nulls_res</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* All the elements of the array have the same type */</comment>
        <expr_stmt><expr><name>types_res</name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>nargs</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nargs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <expr_stmt><expr><name><name>types_res</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>element_type</name></expr>;</expr_stmt>
        </block_content>}</block></for>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/* get the number of arguments */</comment>
        <expr_stmt><expr><name>nargs</name> <operator>=</operator> <call><name>PG_NARGS</name><argument_list>()</argument_list></call> <operator>-</operator> <name>variadic_start</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nargs</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* verify that we have the minimum number of args */</comment>
        <if_stmt><if>if <condition>(<expr><name>nargs</name> <operator>&lt;</operator> <name>min_num_args</name></expr>)</condition>
        <block>{<block_content>
            <return>return <expr><literal type="number">0</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* allocate result memory */</comment>
        <expr_stmt><expr><name>nulls_res</name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>nargs</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>args_res</name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>nargs</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>types_res</name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>nargs</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nargs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <expr_stmt><expr><name><name>nulls_res</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><name>i</name> <operator>+</operator> <name>variadic_start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>types_res</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>get_fn_expr_argtype</name><argument_list>(<argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name></name></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <name>variadic_start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/*
             * Turn a constant (more or less literal) value that's of unknown
             * type into text if required. Unknowns come in as a cstring
             * pointer. Note: for functions declared as taking type "any", the
             * parser will not do any type conversion on unknown-type literals
             * (that is, undecorated strings or NULLs).
             */</comment>
            <if_stmt><if>if <condition>(<expr><name>convert_unknown</name> <operator>&amp;&amp;</operator>
                <name><name>types_res</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>UNKNOWNOID</name> <operator>&amp;&amp;</operator>
                <call><name>get_fn_expr_arg_stable</name><argument_list>(<argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name></name></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <name>variadic_start</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name><name>types_res</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>TEXTOID</name></expr>;</expr_stmt>

                <if_stmt><if>if <condition>(<expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><name>i</name> <operator>+</operator> <name>variadic_start</name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name><name>args_res</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <expr_stmt><expr><name><name>args_res</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><name>i</name> <operator>+</operator> <name>variadic_start</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <comment type="block">/* no conversion needed, just take the datum as given */</comment>
                <expr_stmt><expr><name><name>args_res</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><name>i</name> <operator>+</operator> <name>variadic_start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>

            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>types_res</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>||</operator>
                <operator>(</operator><name>convert_unknown</name> <operator>&amp;&amp;</operator> <name><name>types_res</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>UNKNOWNOID</name><operator>)</operator></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not determine data type for argument %d"</literal></expr></argument>,
                                <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* Fill in results */</comment>
    <expr_stmt><expr><operator>*</operator><name>args</name> <operator>=</operator> <name>args_res</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>nulls</name> <operator>=</operator> <name>nulls_res</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>types</name> <operator>=</operator> <name>types_res</name></expr>;</expr_stmt>

    <return>return <expr><name>nargs</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get agtype object field
 */</comment>
<function><type><name>Datum</name></type> <name>agtype_object_field_impl</name><parameter_list>(<parameter><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>as_text</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>agtype</name> <modifier>*</modifier></type><name>agtype_in</name> <init>= <expr><call><name>AG_GET_ARG_AGTYPE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>text</name> <modifier>*</modifier></type><name>key</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>v</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AGT_ROOT_IS_OBJECT</name><argument_list>(<argument><expr><name>agtype_in</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>execute_map_access_operator_internal</name><argument_list>(<argument><expr><name>agtype_in</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>,
                                             <argument><expr><call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>v</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>as_text</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>text</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><call><name>agtype_value_to_text</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name>result</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>PG_RETURN_TEXT_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><call><name>AG_RETURN_AGTYPE_P</name><argument_list>(<argument><expr><call><name>agtype_value_to_agtype</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * get agtype array element
 */</comment>
<function><type><name>Datum</name></type> <name>agtype_array_element_impl</name><parameter_list>(<parameter><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>as_text</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>agtype</name> <modifier>*</modifier></type><name>agtype_in</name> <init>= <expr><call><name>AG_GET_ARG_AGTYPE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>element</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>v</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AGT_ROOT_IS_ARRAY</name><argument_list>(<argument><expr><name>agtype_in</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>element</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>execute_array_access_operator_internal</name><argument_list>(<argument><expr><name>agtype_in</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>element</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>v</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>as_text</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>text</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><call><name>agtype_value_to_text</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name>result</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>PG_RETURN_TEXT_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><call><name>AG_RETURN_AGTYPE_P</name><argument_list>(<argument><expr><call><name>agtype_value_to_agtype</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>agtype_object_field</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><name>Datum</name></type> <name>agtype_object_field</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>agtype_object_field_impl</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>agtype_object_field_text</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><name>Datum</name></type> <name>agtype_object_field_text</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>agtype_object_field_impl</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>agtype_array_element</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><name>Datum</name></type> <name>agtype_array_element</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>agtype_array_element_impl</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>agtype_array_element_text</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><name>Datum</name></type> <name>agtype_array_element_text</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>agtype_array_element_impl</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>agtype_access_operator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<comment type="block">/*
 * Execution function for object.property, object["property"],
 * and array[element]
 */</comment>
<function><type><name>Datum</name></type> <name>agtype_access_operator</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Datum</name> <modifier>*</modifier></type><name>args</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name> <modifier>*</modifier></type><name>nulls</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name> <modifier>*</modifier></type><name>types</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nargs</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype</name> <modifier>*</modifier></type><name>object</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>object_value</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <comment type="block">/* extract our args, we need at least 2 */</comment>
    <expr_stmt><expr><name>nargs</name> <operator>=</operator> <call><name>extract_variadic_args_min</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>args</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>types</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nulls</name></expr></argument>,
                                      <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* return NULL if we don't have the minimum number of args */</comment>
    <if_stmt><if>if <condition>(<expr><name>args</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>nargs</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>nulls</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>true</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* get the object argument */</comment>
    <expr_stmt><expr><name>object</name> <operator>=</operator> <call><name>DATUM_GET_AGTYPE_P</name><argument_list>(<argument><expr><name><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* if the object is a scalar, it must be a vertex or edge */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>AGT_ROOT_IS_SCALAR</name><argument_list>(<argument><expr><name>object</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>scalar_value</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>property_value</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

        <comment type="block">/* unpack the scalar */</comment>
        <expr_stmt><expr><name>scalar_value</name> <operator>=</operator> <call><name>get_ith_agtype_value_from_container</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>object</name><operator>-&gt;</operator><name>root</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* get the properties depending on the type or fail */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>scalar_value</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AGTV_VERTEX</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>property_value</name> <operator>=</operator> <operator>&amp;</operator><name><name>scalar_value</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>object</name><operator>.</operator><name>pairs</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>.</operator><name>value</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name><name>scalar_value</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AGTV_EDGE</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>property_value</name> <operator>=</operator> <operator>&amp;</operator><name><name>scalar_value</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>object</name><operator>.</operator><name>pairs</name><index>[<expr><literal type="number">4</literal></expr>]</index></name><operator>.</operator><name>value</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                           <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"scalar object must be a vertex or edge"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <comment type="block">/* if the properties are NULL, return NULL */</comment>
        <if_stmt><if>if <condition>(<expr><name>property_value</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>property_value</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AGTV_NULL</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* set the object_value to the property_value. */</comment>
        <expr_stmt><expr><name>object_value</name> <operator>=</operator> <name>property_value</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* check for NULL keys */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nargs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <comment type="block">/* if we have a NULL, return NULL */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>nulls</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>true</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/* iterate through the keys */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nargs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>agtype</name> <modifier>*</modifier></type><name>key</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

        <comment type="block">/* get the key */</comment>
        <expr_stmt><expr><name>key</name> <operator>=</operator> <call><name>DATUM_GET_AGTYPE_P</name><argument_list>(<argument><expr><name><name>args</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* the key must be a scalar */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><call><name>AGT_ROOT_IS_SCALAR</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                            <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"key must resolve to a scalar value"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/*
         * If we are dealing with a type of object, which can be an -
         * agtype OBJECT, an agtype_value OBJECT serialized (BINARY), or an
         * agtype_value OBJECT deserialized.
         */</comment>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>object_value</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
             <operator>(</operator><name><name>object_value</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AGTV_OBJECT</name> <operator>||</operator>
             <operator>(</operator><name><name>object_value</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AGTV_BINARY</name> <operator>&amp;&amp;</operator>
              <call><name>AGTYPE_CONTAINER_IS_OBJECT</name><argument_list>(<argument><expr><name><name>object_value</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>binary</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator><operator>)</operator> <operator>||</operator>
            <operator>(</operator><name>object</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>AGT_ROOT_IS_OBJECT</name><argument_list>(<argument><expr><name>object</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>object_value</name> <operator>=</operator> <call><name>execute_map_access_operator</name><argument_list>(<argument><expr><name>object</name></expr></argument>, <argument><expr><name>object_value</name></expr></argument>,
                                                       <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <comment type="block">/*
         * If we are dealing with a type of array, which can be an -
         * agtype ARRAY, an agtype_value ARRAY serialized (BINARY), or an
         * agtype_value ARRAY deserialized.
         */</comment>
        <if type="elseif">else if <condition>(<expr><operator>(</operator><name>object_value</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
                  <operator>(</operator><name><name>object_value</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AGTV_ARRAY</name> <operator>||</operator>
                  <operator>(</operator><name><name>object_value</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AGTV_BINARY</name> <operator>&amp;&amp;</operator>
                   <call><name>AGTYPE_CONTAINER_IS_ARRAY</name><argument_list>(<argument><expr><name><name>object_value</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>binary</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator><operator>)</operator> <operator>||</operator>
                 <operator>(</operator><name>object</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>AGT_ROOT_IS_ARRAY</name><argument_list>(<argument><expr><name>object</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>object_value</name> <operator>=</operator> <call><name>execute_array_access_operator</name><argument_list>(<argument><expr><name>object</name></expr></argument>, <argument><expr><name>object_value</name></expr></argument>,
                                                         <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <comment type="block">/* this is unexpected */</comment>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                            <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"container must be an array or object"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <comment type="block">/* for NULL values return NULL */</comment>
        <if_stmt><if>if <condition>(<expr><name>object_value</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>object_value</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AGTV_NULL</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* clear the object reference */</comment>
        <expr_stmt><expr><name>object</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

    </block_content>}</block></for>

    <comment type="block">/* serialize and return the result */</comment>
    <return>return <expr><call><name>AGTYPE_P_GET_DATUM</name><argument_list>(<argument><expr><call><name>agtype_value_to_agtype</name><argument_list>(<argument><expr><name>object_value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>agtype_access_slice</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<comment type="block">/*
 * Execution function for list slices
 */</comment>
<function><type><name>Datum</name></type> <name>agtype_access_slice</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>lidx_value</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>uidx_value</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_in_state</name></type> <name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype</name> <modifier>*</modifier></type><name>array</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int64</name></type> <name>upper_index</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int64</name></type> <name>lower_index</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type> <name>array_size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int64</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <comment type="block">/* return null if the array to slice is null */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* return an error if both indices are NULL */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                        <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"slice start and/or end is required"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* get the array parameter and verify that it is a list */</comment>
    <expr_stmt><expr><name>array</name> <operator>=</operator> <call><name>AG_GET_ARG_AGTYPE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AGT_ROOT_IS_ARRAY</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>AGT_ROOT_IS_SCALAR</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                        <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"slice must access a list"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* get its size */</comment>
    <expr_stmt><expr><name>array_size</name> <operator>=</operator> <call><name>AGT_ROOT_COUNT</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* if we don't have a lower bound, make it 0 */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>lower_index</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name>lidx_value</name> <operator>=</operator> <call><name>get_ith_agtype_value_from_container</name><argument_list>(
            <argument><expr><operator>&amp;</operator><operator>(</operator><call><name>AG_GET_ARG_AGTYPE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>root</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* adjust for AGTV_NULL */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>lidx_value</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AGTV_NULL</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>lower_index</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>lidx_value</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* if we don't have an upper bound, make it the size of the array */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>upper_index</name> <operator>=</operator> <name>array_size</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name>uidx_value</name> <operator>=</operator> <call><name>get_ith_agtype_value_from_container</name><argument_list>(
            <argument><expr><operator>&amp;</operator><operator>(</operator><call><name>AG_GET_ARG_AGTYPE_P</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>root</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* adjust for AGTV_NULL */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>uidx_value</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AGTV_NULL</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>upper_index</name> <operator>=</operator> <name>array_size</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>uidx_value</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* if both indices are NULL (AGTV_NULL) return an error */</comment>
    <if_stmt><if>if <condition>(<expr><name>lidx_value</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>uidx_value</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                        <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"slice start and/or end is required"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* key must be an integer or NULL */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>lidx_value</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>lidx_value</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>AGTV_INTEGER</name><operator>)</operator> <operator>||</operator>
        <operator>(</operator><name>uidx_value</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>uidx_value</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>AGTV_INTEGER</name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"array slices must resolve to an integer value"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* set indices if not already set */</comment>
    <if_stmt><if>if <condition>(<expr><name>lidx_value</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>lower_index</name> <operator>=</operator> <name><name>lidx_value</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>int_value</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>uidx_value</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>upper_index</name> <operator>=</operator> <name><name>uidx_value</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>int_value</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* adjust for negative and out of bounds index values */</comment>
    <if_stmt><if>if <condition>(<expr><name>lower_index</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>lower_index</name> <operator>=</operator> <name>array_size</name> <operator>+</operator> <name>lower_index</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>lower_index</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>lower_index</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>lower_index</name> <operator>&gt;</operator> <name>array_size</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>lower_index</name> <operator>=</operator> <name>array_size</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>upper_index</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>upper_index</name> <operator>=</operator> <name>array_size</name> <operator>+</operator> <name>upper_index</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>upper_index</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>upper_index</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>upper_index</name> <operator>&gt;</operator> <name>array_size</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>upper_index</name> <operator>=</operator> <name>array_size</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* build our result array */</comment>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>agtype_in_state</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>result</name><operator>.</operator><name>res</name></name> <operator>=</operator> <call><name>push_agtype_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>result</name><operator>.</operator><name>parse_state</name></name></expr></argument>, <argument><expr><name>WAGT_BEGIN_ARRAY</name></expr></argument>,
                                   <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* get array elements */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>lower_index</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>upper_index</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name><name>result</name><operator>.</operator><name>res</name></name> <operator>=</operator> <call><name>push_agtype_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>result</name><operator>.</operator><name>parse_state</name></name></expr></argument>, <argument><expr><name>WAGT_ELEM</name></expr></argument>,
            <argument><expr><call><name>get_ith_agtype_value_from_container</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>array</name><operator>-&gt;</operator><name>root</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><name><name>result</name><operator>.</operator><name>res</name></name> <operator>=</operator> <call><name>push_agtype_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>result</name><operator>.</operator><name>parse_state</name></name></expr></argument>, <argument><expr><name>WAGT_END_ARRAY</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><call><name>agtype_value_to_agtype</name><argument_list>(<argument><expr><name><name>result</name><operator>.</operator><name>res</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>agtype_in_operator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<comment type="block">/*
 * Execute function for IN operator
 */</comment>
<function><type><name>Datum</name></type> <name>agtype_in_operator</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>agtype</name> <modifier>*</modifier></type><name>agt_array</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>agt_item</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_iterator</name> <modifier>*</modifier></type><name>it_array</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>it_item</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_value</name></type> <name>agtv_item</name></decl>, <decl><type ref="prev"/><name>agtv_elem</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type> <name>array_size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>result</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <comment type="block">/* return null if the array is null */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* get the array parameter and verify that it is a list */</comment>
    <expr_stmt><expr><name>agt_array</name> <operator>=</operator> <call><name>AG_GET_ARG_AGTYPE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AGT_ROOT_IS_ARRAY</name><argument_list>(<argument><expr><name>agt_array</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                        <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"object of IN must be a list"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* init array iterator */</comment>
    <expr_stmt><expr><name>it_array</name> <operator>=</operator> <call><name>agtype_iterator_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>agt_array</name><operator>-&gt;</operator><name>root</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* open array container */</comment>
    <expr_stmt><expr><call><name>agtype_iterator_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name>it_array</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>agtv_elem</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* check for an array scalar value */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>agtv_elem</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>AGTV_ARRAY</name> <operator>&amp;&amp;</operator> <name><name>agtv_elem</name><operator>.</operator><name>val</name><operator>.</operator><name>array</name><operator>.</operator><name>raw_scalar</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>agtype_iterator_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name>it_array</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>agtv_elem</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* check for AGTYPE NULL */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>agtv_elem</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>AGTV_NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <comment type="block">/* if it is a scalar, but not AGTV_NULL, error out */</comment>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                        <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"object of IN must be a list"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>array_size</name> <operator>=</operator> <call><name>AGT_ROOT_COUNT</name><argument_list>(<argument><expr><name>agt_array</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* return null if the item to find is null */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <comment type="block">/* get the item to search for */</comment>
    <expr_stmt><expr><name>agt_item</name> <operator>=</operator> <call><name>AG_GET_ARG_AGTYPE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* init item iterator */</comment>
    <expr_stmt><expr><name>it_item</name> <operator>=</operator> <call><name>agtype_iterator_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>agt_item</name><operator>-&gt;</operator><name>root</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* get value of item */</comment>
    <expr_stmt><expr><call><name>agtype_iterator_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name>it_item</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>agtv_item</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>agtv_item</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>AGTV_ARRAY</name> <operator>&amp;&amp;</operator> <name><name>agtv_item</name><operator>.</operator><name>val</name><operator>.</operator><name>array</name><operator>.</operator><name>raw_scalar</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>agtype_iterator_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name>it_item</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>agtv_item</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* check for AGTYPE NULL */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>agtv_item</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>AGTV_NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* iterate through the array, but stop if we find it */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>array_size</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>result</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <comment type="block">/* get next element */</comment>
        <expr_stmt><expr><call><name>agtype_iterator_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name>it_array</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>agtv_elem</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* if both are containers, compare containers */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IS_A_AGTYPE_SCALAR</name><argument_list>(<argument><expr><operator>&amp;</operator><name>agtv_item</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>IS_A_AGTYPE_SCALAR</name><argument_list>(<argument><expr><operator>&amp;</operator><name>agtv_elem</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><call><name>compare_agtype_containers_orderability</name><argument_list>(
                          <argument><expr><operator>&amp;</operator><name><name>agt_item</name><operator>-&gt;</operator><name>root</name></name></expr></argument>, <argument><expr><name><name>agtv_elem</name><operator>.</operator><name>val</name><operator>.</operator><name>binary</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
        </block_content>}</block></if>
        <comment type="block">/* if both are scalars and of the same type, compare scalars */</comment>
        <if type="elseif">else if <condition>(<expr><call><name>IS_A_AGTYPE_SCALAR</name><argument_list>(<argument><expr><operator>&amp;</operator><name>agtv_item</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
                 <call><name>IS_A_AGTYPE_SCALAR</name><argument_list>(<argument><expr><operator>&amp;</operator><name>agtv_elem</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
                 <name><name>agtv_item</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name><name>agtv_elem</name><operator>.</operator><name>type</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><call><name>compare_agtype_scalar_values</name><argument_list>(<argument><expr><operator>&amp;</operator><name>agtv_item</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>agtv_elem</name></expr></argument>)</argument_list></call> <operator>==</operator>
                      <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>
    <return>return <expr><call><name>boolean_to_agtype</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>agtype_string_match_starts_with</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<comment type="block">/*
 * Execution function for STARTS WITH
 */</comment>
<function><type><name>Datum</name></type> <name>agtype_string_match_starts_with</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>agtype</name> <modifier>*</modifier></type><name>lhs</name> <init>= <expr><call><name>AG_GET_ARG_AGTYPE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype</name> <modifier>*</modifier></type><name>rhs</name> <init>= <expr><call><name>AG_GET_ARG_AGTYPE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>AGT_ROOT_IS_SCALAR</name><argument_list>(<argument><expr><name>lhs</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>AGT_ROOT_IS_SCALAR</name><argument_list>(<argument><expr><name>rhs</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>lhs_value</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>rhs_value</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>lhs_value</name> <operator>=</operator> <call><name>get_ith_agtype_value_from_container</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lhs</name><operator>-&gt;</operator><name>root</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rhs_value</name> <operator>=</operator> <call><name>get_ith_agtype_value_from_container</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>rhs</name><operator>-&gt;</operator><name>root</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>lhs_value</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AGTV_STRING</name> <operator>&amp;&amp;</operator> <name><name>rhs_value</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AGTV_STRING</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>lhs_value</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>len</name></name> <operator>&lt;</operator> <name><name>rhs_value</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>len</name></name></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><call><name>boolean_to_agtype</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name><name>lhs_value</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>val</name></name></expr></argument>, <argument><expr><name><name>rhs_value</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>val</name></name></expr></argument>,
                        <argument><expr><name><name>rhs_value</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><call><name>boolean_to_agtype</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <return>return <expr><call><name>boolean_to_agtype</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                    <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"agtype string values expected"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>agtype_string_match_ends_with</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<comment type="block">/*
 * Execution function for ENDS WITH
 */</comment>
<function><type><name>Datum</name></type> <name>agtype_string_match_ends_with</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>agtype</name> <modifier>*</modifier></type><name>lhs</name> <init>= <expr><call><name>AG_GET_ARG_AGTYPE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype</name> <modifier>*</modifier></type><name>rhs</name> <init>= <expr><call><name>AG_GET_ARG_AGTYPE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>AGT_ROOT_IS_SCALAR</name><argument_list>(<argument><expr><name>lhs</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>AGT_ROOT_IS_SCALAR</name><argument_list>(<argument><expr><name>rhs</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>lhs_value</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>rhs_value</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>lhs_value</name> <operator>=</operator> <call><name>get_ith_agtype_value_from_container</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lhs</name><operator>-&gt;</operator><name>root</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rhs_value</name> <operator>=</operator> <call><name>get_ith_agtype_value_from_container</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>rhs</name><operator>-&gt;</operator><name>root</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>lhs_value</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AGTV_STRING</name> <operator>&amp;&amp;</operator> <name><name>rhs_value</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AGTV_STRING</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>lhs_value</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>len</name></name> <operator>&lt;</operator> <name><name>rhs_value</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>len</name></name></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><call><name>boolean_to_agtype</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name><name>lhs_value</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>val</name></name> <operator>+</operator> <name><name>lhs_value</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>len</name></name> <operator>-</operator>
                            <name><name>rhs_value</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>len</name></name></expr></argument>,
                        <argument><expr><name><name>rhs_value</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>val</name></name></expr></argument>,
                        <argument><expr><name><name>rhs_value</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><call><name>boolean_to_agtype</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <return>return <expr><call><name>boolean_to_agtype</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                    <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"agtype string values expected"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>agtype_string_match_contains</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<comment type="block">/*
 * Execution function for CONTAINS
 */</comment>
<function><type><name>Datum</name></type> <name>agtype_string_match_contains</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>agtype</name> <modifier>*</modifier></type><name>lhs</name> <init>= <expr><call><name>AG_GET_ARG_AGTYPE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype</name> <modifier>*</modifier></type><name>rhs</name> <init>= <expr><call><name>AG_GET_ARG_AGTYPE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>AGT_ROOT_IS_SCALAR</name><argument_list>(<argument><expr><name>lhs</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>AGT_ROOT_IS_SCALAR</name><argument_list>(<argument><expr><name>rhs</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>lhs_value</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>rhs_value</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>lhs_value</name> <operator>=</operator> <call><name>get_ith_agtype_value_from_container</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lhs</name><operator>-&gt;</operator><name>root</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rhs_value</name> <operator>=</operator> <call><name>get_ith_agtype_value_from_container</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>rhs</name><operator>-&gt;</operator><name>root</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>lhs_value</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AGTV_STRING</name> <operator>&amp;&amp;</operator> <name><name>rhs_value</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AGTV_STRING</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>r</name></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>lhs_value</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>len</name></name> <operator>&lt;</operator> <name><name>rhs_value</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>len</name></name></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><call><name>boolean_to_agtype</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

            <expr_stmt><expr><name>l</name> <operator>=</operator> <call><name>pnstrdup</name><argument_list>(<argument><expr><name><name>lhs_value</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>val</name></name></expr></argument>, <argument><expr><name><name>lhs_value</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>pnstrdup</name><argument_list>(<argument><expr><name><name>rhs_value</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>val</name></name></expr></argument>, <argument><expr><name><name>rhs_value</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><call><name>strstr</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><call><name>boolean_to_agtype</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <return>return <expr><call><name>boolean_to_agtype</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                    <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"agtype string values expected"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LEFT_ROTATE</name><parameter_list>(<parameter><type><name>n</name></type></parameter>, <parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((n &lt;&lt; i) | (n &gt;&gt; (64 - i)))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RIGHT_ROTATE</name><parameter_list>(<parameter><type><name>n</name></type></parameter>, <parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro>  <cpp:value>((n &gt;&gt; i) | (n &lt;&lt; (64 - i)))</cpp:value></cpp:define>

<comment type="line">//Hashing Function for Hash Indexes</comment>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>agtype_hash_cmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><name>Datum</name></type> <name>agtype_hash_cmp</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>uint64</name></type> <name>hash</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype</name> <modifier>*</modifier></type><name>agt</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_iterator</name> <modifier>*</modifier></type><name>it</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_iterator_token</name></type> <name>tok</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>r</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint64</name></type> <name>seed</name> <init>= <expr><literal type="number">0xF0F0F0F0</literal></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_INT16</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>agt</name> <operator>=</operator> <call><name>AG_GET_ARG_AGTYPE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>agtype_value</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>it</name> <operator>=</operator> <call><name>agtype_iterator_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>agt</name><operator>-&gt;</operator><name>root</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while <condition>(<expr><operator>(</operator><name>tok</name> <operator>=</operator> <call><name>agtype_iterator_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name>it</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>WAGT_DONE</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>IS_A_AGTYPE_SCALAR</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>AGTYPE_ITERATOR_TOKEN_IS_HASHABLE</name><argument_list>(<argument><expr><name>tok</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>agtype_hash_scalar_value_extended</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hash</name></expr></argument>, <argument><expr><name>seed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><name>tok</name> <operator>==</operator> <name>WAGT_BEGIN_ARRAY</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>r</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>array</name><operator>.</operator><name>raw_scalar</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>seed</name> <operator>=</operator> <call><name>LEFT_ROTATE</name><argument_list>(<argument><expr><name>seed</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><name>tok</name> <operator>==</operator> <name>WAGT_BEGIN_OBJECT</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>seed</name> <operator>=</operator> <call><name>LEFT_ROTATE</name><argument_list>(<argument><expr><name>seed</name></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><name>tok</name> <operator>==</operator> <name>WAGT_END_ARRAY</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>r</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>array</name><operator>.</operator><name>raw_scalar</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>seed</name> <operator>=</operator> <call><name>RIGHT_ROTATE</name><argument_list>(<argument><expr><name>seed</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><name>tok</name> <operator>==</operator> <name>WAGT_END_OBJECT</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>seed</name> <operator>=</operator> <call><name>RIGHT_ROTATE</name><argument_list>(<argument><expr><name>seed</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>seed</name> <operator>=</operator> <call><name>LEFT_ROTATE</name><argument_list>(<argument><expr><name>seed</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>

    <expr_stmt><expr><call><name>PG_RETURN_INT16</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="line">// Comparision function for btree Indexes</comment>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>agtype_btree_cmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><name>Datum</name></type> <name>agtype_btree_cmp</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>agtype</name> <modifier>*</modifier></type><name>agtype_lhs</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype</name> <modifier>*</modifier></type><name>agtype_rhs</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_INT16</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_INT16</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_INT16</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>agtype_lhs</name> <operator>=</operator> <call><name>AG_GET_ARG_AGTYPE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>agtype_rhs</name> <operator>=</operator> <call><name>AG_GET_ARG_AGTYPE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_INT16</name><argument_list>(<argument><expr><call><name>compare_agtype_containers_orderability</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>agtype_lhs</name><operator>-&gt;</operator><name>root</name></name></expr></argument>,
                                                     <argument><expr><operator>&amp;</operator><name><name>agtype_rhs</name><operator>-&gt;</operator><name>root</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>agtype_typecast_numeric</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<comment type="block">/*
 * Execute function to typecast an agtype to an agtype numeric
 */</comment>
<function><type><name>Datum</name></type> <name>agtype_typecast_numeric</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>agtype</name> <modifier>*</modifier></type><name>arg_agt</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>arg_value</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_value</name></type> <name>result_value</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type> <name>numd</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>string</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* get the agtype equivalence of any convertable input type */</comment>
    <expr_stmt><expr><name>arg_agt</name> <operator>=</operator> <call><name>get_one_agtype_from_variadic_args</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Return null if arg_agt is null. This covers SQL and Agtype NULLS */</comment>
    <if_stmt><if>if <condition>(<expr><name>arg_agt</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* check that we have a scalar value */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AGT_ROOT_IS_SCALAR</name><argument_list>(<argument><expr><name>arg_agt</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"typecast argument must resolve to a scalar value"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* get the arg parameter */</comment>
    <expr_stmt><expr><name>arg_value</name> <operator>=</operator> <call><name>get_ith_agtype_value_from_container</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>arg_agt</name><operator>-&gt;</operator><name>root</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* the input type drives the casting */</comment>
    <switch>switch<condition>(<expr><name><name>arg_value</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition>
    <block>{<block_content>
    <case>case <expr><name>AGTV_INTEGER</name></expr>:</case>
        <expr_stmt><expr><name>numd</name> <operator>=</operator> <call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>int8_numeric</name></expr></argument>,
                                   <argument><expr><call><name>Int64GetDatum</name><argument_list>(<argument><expr><name><name>arg_value</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>int_value</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
    <case>case <expr><name>AGTV_FLOAT</name></expr>:</case>
        <expr_stmt><expr><name>numd</name> <operator>=</operator> <call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>float8_numeric</name></expr></argument>,
                                   <argument><expr><call><name>Float8GetDatum</name><argument_list>(<argument><expr><name><name>arg_value</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>float_value</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
    <case>case <expr><name>AGTV_NUMERIC</name></expr>:</case>
        <comment type="block">/* it is already a numeric so just return it */</comment>
        <expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><call><name>agtype_value_to_agtype</name><argument_list>(<argument><expr><name>arg_value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
    <comment type="block">/* this allows string numbers and NaN */</comment>
    <case>case <expr><name>AGTV_STRING</name></expr>:</case>
        <comment type="block">/* we need a null terminated string */</comment>
        <expr_stmt><expr><name>string</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof><operator>*</operator><name><name>arg_value</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>len</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>string</name> <operator>=</operator> <call><name>strncpy</name><argument_list>(<argument><expr><name>string</name></expr></argument>, <argument><expr><name><name>arg_value</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>val</name></name></expr></argument>,
                         <argument><expr><name><name>arg_value</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>string</name><index>[<expr><name><name>arg_value</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>len</name></name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
        <comment type="block">/* pass the string to the numeric in function for conversion */</comment>
        <expr_stmt><expr><name>numd</name> <operator>=</operator> <call><name>DirectFunctionCall3</name><argument_list>(<argument><expr><name>numeric_in</name></expr></argument>,
                                   <argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name>string</name></expr></argument>)</argument_list></call></expr></argument>,
                                   <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>InvalidOid</name></expr></argument>)</argument_list></call></expr></argument>,
                                   <argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* free the string */</comment>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>string</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <break>break;</break>
    <comment type="block">/* what was given doesn't cast to a numeric */</comment>
    <default>default:</default>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"typecast expression must be a number or a string"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
    </block_content>}</block></switch>

    <comment type="block">/* fill in and return our result */</comment>
    <expr_stmt><expr><name><name>result_value</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>AGTV_NUMERIC</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result_value</name><operator>.</operator><name>val</name><operator>.</operator><name>numeric</name></name> <operator>=</operator> <call><name>DatumGetNumeric</name><argument_list>(<argument><expr><name>numd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><call><name>agtype_value_to_agtype</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result_value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>agtype_typecast_int</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<comment type="block">/*
 * Execute function to typecast an agtype to an agtype int
 */</comment>
<function><type><name>Datum</name></type> <name>agtype_typecast_int</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>agtype</name> <modifier>*</modifier></type><name>arg_agt</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>arg_value</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_value</name></type> <name>result_value</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type> <name>d</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>string</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* get the agtype equivalence of any convertable input type */</comment>
    <expr_stmt><expr><name>arg_agt</name> <operator>=</operator> <call><name>get_one_agtype_from_variadic_args</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Return null if arg_agt is null. This covers SQL and Agtype NULLS */</comment>
    <if_stmt><if>if <condition>(<expr><name>arg_agt</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* check that we have a scalar value */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AGT_ROOT_IS_SCALAR</name><argument_list>(<argument><expr><name>arg_agt</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"typecast argument must be a scalar value"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* get the arg parameter */</comment>
    <expr_stmt><expr><name>arg_value</name> <operator>=</operator> <call><name>get_ith_agtype_value_from_container</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>arg_agt</name><operator>-&gt;</operator><name>root</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* check for agtype null */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>arg_value</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AGTV_NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* the input type drives the casting */</comment>
    <switch>switch<condition>(<expr><name><name>arg_value</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition>
    <block>{<block_content>
    <case>case <expr><name>AGTV_INTEGER</name></expr>:</case>
        <expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><call><name>agtype_value_to_agtype</name><argument_list>(<argument><expr><name>arg_value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
    <case>case <expr><name>AGTV_FLOAT</name></expr>:</case>
        <expr_stmt><expr><name>d</name> <operator>=</operator> <call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>dtoi8</name></expr></argument>,
                                <argument><expr><call><name>Float8GetDatum</name><argument_list>(<argument><expr><name><name>arg_value</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>float_value</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
    <case>case <expr><name>AGTV_NUMERIC</name></expr>:</case>
        <expr_stmt><expr><name>d</name> <operator>=</operator> <call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>numeric_int8</name></expr></argument>,
                                <argument><expr><call><name>NumericGetDatum</name><argument_list>(<argument><expr><name><name>arg_value</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>numeric</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
    <case>case <expr><name>AGTV_STRING</name></expr>:</case>
        <comment type="block">/* we need a null terminated string */</comment>
        <expr_stmt><expr><name>string</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof><operator>*</operator><name><name>arg_value</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>len</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>string</name> <operator>=</operator> <call><name>strncpy</name><argument_list>(<argument><expr><name>string</name></expr></argument>, <argument><expr><name><name>arg_value</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>val</name></name></expr></argument>,
                         <argument><expr><name><name>arg_value</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>string</name><index>[<expr><name><name>arg_value</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>len</name></name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

        <expr_stmt><expr><name>d</name> <operator>=</operator> <call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>int8in</name></expr></argument>, <argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name>string</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* free the string */</comment>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>string</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <break>break;</break>
    <comment type="block">/* what was given doesn't cast to an int */</comment>
    <default>default:</default>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"typecast expression must be a number or a string"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
    </block_content>}</block></switch>

    <comment type="block">/* set the result type and return our result */</comment>
    <expr_stmt><expr><name><name>result_value</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>AGTV_INTEGER</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result_value</name><operator>.</operator><name>val</name><operator>.</operator><name>int_value</name></name> <operator>=</operator> <call><name>DatumGetInt64</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><call><name>agtype_value_to_agtype</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result_value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>agtype_typecast_float</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<comment type="block">/*
 * Execute function to typecast an agtype to an agtype float
 */</comment>
<function><type><name>Datum</name></type> <name>agtype_typecast_float</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>agtype</name> <modifier>*</modifier></type><name>arg_agt</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>arg_value</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_value</name></type> <name>result_value</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type> <name>d</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>string</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* get the agtype equivalence of any convertable input type */</comment>
    <expr_stmt><expr><name>arg_agt</name> <operator>=</operator> <call><name>get_one_agtype_from_variadic_args</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Return null if arg_agt is null. This covers SQL and Agtype NULLS */</comment>
    <if_stmt><if>if <condition>(<expr><name>arg_agt</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* check that we have a scalar value */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AGT_ROOT_IS_SCALAR</name><argument_list>(<argument><expr><name>arg_agt</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"typecast argument must be a scalar value"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* get the arg parameter */</comment>
    <expr_stmt><expr><name>arg_value</name> <operator>=</operator> <call><name>get_ith_agtype_value_from_container</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>arg_agt</name><operator>-&gt;</operator><name>root</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* check for agtype null */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>arg_value</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AGTV_NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* the input type drives the casting */</comment>
    <switch>switch<condition>(<expr><name><name>arg_value</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition>
    <block>{<block_content>
    <case>case <expr><name>AGTV_INTEGER</name></expr>:</case>
        <expr_stmt><expr><name>d</name> <operator>=</operator> <call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>int8out</name></expr></argument>,
                                <argument><expr><call><name>Int64GetDatum</name><argument_list>(<argument><expr><name><name>arg_value</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>int_value</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>d</name> <operator>=</operator> <call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>float8in</name></expr></argument>, <argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
    <case>case <expr><name>AGTV_FLOAT</name></expr>:</case>
        <comment type="block">/* it is already a float so just return it */</comment>
        <expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><call><name>agtype_value_to_agtype</name><argument_list>(<argument><expr><name>arg_value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
    <case>case <expr><name>AGTV_NUMERIC</name></expr>:</case>
        <expr_stmt><expr><name>d</name> <operator>=</operator> <call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>numeric_float8</name></expr></argument>,
                                <argument><expr><call><name>NumericGetDatum</name><argument_list>(<argument><expr><name><name>arg_value</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>numeric</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
    <comment type="block">/* this allows string numbers, NaN, Infinity, and -Infinity */</comment>
    <case>case <expr><name>AGTV_STRING</name></expr>:</case>
        <comment type="block">/* we need a null terminated string */</comment>
        <expr_stmt><expr><name>string</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof><operator>*</operator><name><name>arg_value</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>len</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>string</name> <operator>=</operator> <call><name>strncpy</name><argument_list>(<argument><expr><name>string</name></expr></argument>, <argument><expr><name><name>arg_value</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>val</name></name></expr></argument>,
                         <argument><expr><name><name>arg_value</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>string</name><index>[<expr><name><name>arg_value</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>len</name></name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

        <expr_stmt><expr><name>d</name> <operator>=</operator> <call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>float8in</name></expr></argument>, <argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name>string</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* free the string */</comment>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>string</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <break>break;</break>
    <comment type="block">/* what was given doesn't cast to a float */</comment>
    <default>default:</default>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"typecast expression must be a number or a string"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
    </block_content>}</block></switch>

    <comment type="block">/* set the result type and return our result */</comment>
    <expr_stmt><expr><name><name>result_value</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>AGTV_FLOAT</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result_value</name><operator>.</operator><name>val</name><operator>.</operator><name>float_value</name></name> <operator>=</operator> <call><name>DatumGetFloat8</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><call><name>agtype_value_to_agtype</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result_value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>agtype_typecast_vertex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<comment type="block">/*
 * Execute function for typecast to vertex
 */</comment>
<function><type><name>Datum</name></type> <name>agtype_typecast_vertex</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>agtype</name> <modifier>*</modifier></type><name>arg_agt</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_value</name></type> <name>agtv_key</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>agtv_graphid</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>agtv_label</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>agtv_properties</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type> <name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>count</name></decl>;</decl_stmt>

    <comment type="block">/* get the agtype equivalence of any convertable input type */</comment>
    <expr_stmt><expr><name>arg_agt</name> <operator>=</operator> <call><name>get_one_agtype_from_variadic_args</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Return null if arg_agt is null. This covers SQL and Agtype NULLS */</comment>
    <if_stmt><if>if <condition>(<expr><name>arg_agt</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* A vertex is an object so the arg needs to be one too */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AGT_ROOT_IS_OBJECT</name><argument_list>(<argument><expr><name>arg_agt</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"vertex typecast argument must resolve to an object"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* A vertex object has 3 key/value pairs */</comment>
    <expr_stmt><expr><name>count</name> <operator>=</operator> <call><name>AGTYPE_CONTAINER_SIZE</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>arg_agt</name><operator>-&gt;</operator><name>root</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>count</name> <operator>!=</operator> <literal type="number">3</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"typecast object is not a vertex"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * The 3 key/value pairs need to each exist and their names need to match
     * the names used for a vertex.
     */</comment>
    <expr_stmt><expr><name><name>agtv_key</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>AGTV_STRING</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>agtv_key</name><operator>.</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>val</name></name> <operator>=</operator> <literal type="string">"id"</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>agtv_key</name><operator>.</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>len</name></name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>agtv_graphid</name> <operator>=</operator> <call><name>find_agtype_value_from_container</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>arg_agt</name><operator>-&gt;</operator><name>root</name></name></expr></argument>,
                                                    <argument><expr><name>AGT_FOBJECT</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>agtv_key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>agtv_graphid</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>agtv_graphid</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>AGTV_INTEGER</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"vertex typecast object has invalid or missing id"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name><name>agtv_key</name><operator>.</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>val</name></name> <operator>=</operator> <literal type="string">"label"</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>agtv_key</name><operator>.</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>len</name></name> <operator>=</operator> <literal type="number">5</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>agtv_label</name> <operator>=</operator> <call><name>find_agtype_value_from_container</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>arg_agt</name><operator>-&gt;</operator><name>root</name></name></expr></argument>,
                                                  <argument><expr><name>AGT_FOBJECT</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>agtv_key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>agtv_label</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>agtv_label</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>AGTV_STRING</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"vertex typecast object has invalid or missing label"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name><name>agtv_key</name><operator>.</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>val</name></name> <operator>=</operator> <literal type="string">"properties"</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>agtv_key</name><operator>.</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>len</name></name> <operator>=</operator> <literal type="number">10</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>agtv_properties</name> <operator>=</operator> <call><name>find_agtype_value_from_container</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>arg_agt</name><operator>-&gt;</operator><name>root</name></name></expr></argument>,
                                                       <argument><expr><name>AGT_FOBJECT</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>agtv_key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>agtv_properties</name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
        <operator>(</operator><name><name>agtv_properties</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>AGTV_OBJECT</name> <operator>&amp;&amp;</operator>
         <name><name>agtv_properties</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>AGTV_BINARY</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"vertex typecast object has invalid or missing properties"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Hand it off to the build vertex routine */</comment>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>DirectFunctionCall3</name><argument_list>(<argument><expr><name>_agtype_build_vertex</name></expr></argument>,
                 <argument><expr><call><name>Int64GetDatum</name><argument_list>(<argument><expr><name><name>agtv_graphid</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>int_value</name></name></expr></argument>)</argument_list></call></expr></argument>,
                 <argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name><name>agtv_label</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>val</name></name></expr></argument>)</argument_list></call></expr></argument>,
                 <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><call><name>agtype_value_to_agtype</name><argument_list>(<argument><expr><name>agtv_properties</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>agtype_typecast_edge</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<comment type="block">/*
 * Execute function for typecast to edge
 */</comment>
<function><type><name>Datum</name></type> <name>agtype_typecast_edge</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>agtype</name> <modifier>*</modifier></type><name>arg_agt</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_value</name></type> <name>agtv_key</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>agtv_graphid</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>agtv_label</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>agtv_properties</name></decl>,
                 <decl><type ref="prev"><modifier>*</modifier></type><name>agtv_startid</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>agtv_endid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type> <name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>count</name></decl>;</decl_stmt>

    <comment type="block">/* get the agtype equivalence of any convertable input type */</comment>
    <expr_stmt><expr><name>arg_agt</name> <operator>=</operator> <call><name>get_one_agtype_from_variadic_args</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Return null if arg_agt is null. This covers SQL and Agtype NULLS */</comment>
    <if_stmt><if>if <condition>(<expr><name>arg_agt</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* An edge is an object, so the arg needs to be one too */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AGT_ROOT_IS_OBJECT</name><argument_list>(<argument><expr><name>arg_agt</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"edge typecast argument must resolve to an object"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* An edge has 5 key/value pairs */</comment>
    <expr_stmt><expr><name>count</name> <operator>=</operator> <call><name>AGTYPE_CONTAINER_SIZE</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>arg_agt</name><operator>-&gt;</operator><name>root</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>count</name> <operator>!=</operator> <literal type="number">5</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"typecast object is not an edge"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * The 5 key/value pairs need to each exist and their names need to match
     * the names used for an edge.
     */</comment>
    <expr_stmt><expr><name><name>agtv_key</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>AGTV_STRING</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>agtv_key</name><operator>.</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>val</name></name> <operator>=</operator> <literal type="string">"id"</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>agtv_key</name><operator>.</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>len</name></name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>agtv_graphid</name> <operator>=</operator> <call><name>find_agtype_value_from_container</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>arg_agt</name><operator>-&gt;</operator><name>root</name></name></expr></argument>,
                                                    <argument><expr><name>AGT_FOBJECT</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>agtv_key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>agtv_graphid</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>agtv_graphid</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>AGTV_INTEGER</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"edge typecast object has an invalid or missing id"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name><name>agtv_key</name><operator>.</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>val</name></name> <operator>=</operator> <literal type="string">"label"</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>agtv_key</name><operator>.</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>len</name></name> <operator>=</operator> <literal type="number">5</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>agtv_label</name> <operator>=</operator> <call><name>find_agtype_value_from_container</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>arg_agt</name><operator>-&gt;</operator><name>root</name></name></expr></argument>,
                                                  <argument><expr><name>AGT_FOBJECT</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>agtv_key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>agtv_label</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>agtv_label</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>AGTV_STRING</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"edge typecast object has an invalid or missing label"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name><name>agtv_key</name><operator>.</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>val</name></name> <operator>=</operator> <literal type="string">"properties"</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>agtv_key</name><operator>.</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>len</name></name> <operator>=</operator> <literal type="number">10</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>agtv_properties</name> <operator>=</operator> <call><name>find_agtype_value_from_container</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>arg_agt</name><operator>-&gt;</operator><name>root</name></name></expr></argument>,
                                                 <argument><expr><name>AGT_FOBJECT</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>agtv_key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>agtv_properties</name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
        <operator>(</operator><name><name>agtv_properties</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>AGTV_OBJECT</name> <operator>&amp;&amp;</operator>
         <name><name>agtv_properties</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>AGTV_BINARY</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"edge typecast object has invalid or missing properties"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name><name>agtv_key</name><operator>.</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>val</name></name> <operator>=</operator> <literal type="string">"start_id"</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>agtv_key</name><operator>.</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>len</name></name> <operator>=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>agtv_startid</name> <operator>=</operator> <call><name>find_agtype_value_from_container</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>arg_agt</name><operator>-&gt;</operator><name>root</name></name></expr></argument>,
                                                    <argument><expr><name>AGT_FOBJECT</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>agtv_key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>agtv_startid</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>agtv_startid</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>AGTV_INTEGER</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"edge typecast object has an invalid or missing start_id"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name><name>agtv_key</name><operator>.</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>val</name></name> <operator>=</operator> <literal type="string">"end_id"</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>agtv_key</name><operator>.</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>len</name></name> <operator>=</operator> <literal type="number">6</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>agtv_endid</name> <operator>=</operator> <call><name>find_agtype_value_from_container</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>arg_agt</name><operator>-&gt;</operator><name>root</name></name></expr></argument>,
                                                    <argument><expr><name>AGT_FOBJECT</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>agtv_key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>agtv_endid</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>agtv_endid</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>AGTV_INTEGER</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"edge typecast object has an invalid or missing end_id"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Hand it off to the build edge routine */</comment>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>DirectFunctionCall5</name><argument_list>(<argument><expr><name>_agtype_build_edge</name></expr></argument>,
                 <argument><expr><call><name>Int64GetDatum</name><argument_list>(<argument><expr><name><name>agtv_graphid</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>int_value</name></name></expr></argument>)</argument_list></call></expr></argument>,
                 <argument><expr><call><name>Int64GetDatum</name><argument_list>(<argument><expr><name><name>agtv_startid</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>int_value</name></name></expr></argument>)</argument_list></call></expr></argument>,
                 <argument><expr><call><name>Int64GetDatum</name><argument_list>(<argument><expr><name><name>agtv_endid</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>int_value</name></name></expr></argument>)</argument_list></call></expr></argument>,
                 <argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name><name>agtv_label</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>val</name></name></expr></argument>)</argument_list></call></expr></argument>,
                 <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><call><name>agtype_value_to_agtype</name><argument_list>(<argument><expr><name>agtv_properties</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>agtype_typecast_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<comment type="block">/*
 * Execute function for typecast to path
 */</comment>
<function><type><name>Datum</name></type> <name>agtype_typecast_path</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>agtype</name> <modifier>*</modifier></type><name>arg_agt</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_in_state</name></type> <name>path</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>agtv_element</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <comment type="block">/* get the agtype equivalence of any convertable input type */</comment>
    <expr_stmt><expr><name>arg_agt</name> <operator>=</operator> <call><name>get_one_agtype_from_variadic_args</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Return null if arg_agt is null. This covers SQL and Agtype NULLS */</comment>
    <if_stmt><if>if <condition>(<expr><name>arg_agt</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* path needs to be an array */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AGT_ROOT_IS_ARRAY</name><argument_list>(<argument><expr><name>arg_agt</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"path typecast argument must resolve to an array"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>count</name> <operator>=</operator> <call><name>AGT_ROOT_COUNT</name><argument_list>(<argument><expr><name>arg_agt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* quick check for valid path lengths */</comment>
    <if_stmt><if>if <condition>(<expr><name>count</name> <operator>&lt;</operator> <literal type="number">3</literal> <operator>||</operator> <operator>(</operator><name>count</name><operator>-</operator><literal type="number">1</literal><operator>)</operator> <operator>%</operator> <literal type="number">2</literal> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"typecast argument is not a valid path"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* create an agtype array */</comment>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>path</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>agtype_in_state</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>path</name><operator>.</operator><name>res</name></name> <operator>=</operator> <call><name>push_agtype_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>path</name><operator>.</operator><name>parse_state</name></name></expr></argument>, <argument><expr><name>WAGT_BEGIN_ARRAY</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Iterate through the provided list, check that each value conforms, and
     * then add it if it does. Otherwise error out.
     */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>+</operator><literal type="number">1</literal> <operator>&lt;</operator> <name>count</name></expr>;</condition> <incr><expr><name>i</name><operator>+=</operator><literal type="number">2</literal></expr></incr>)</control>
    <block>{<block_content>
        <comment type="block">/* get a potential vertex, check it, then add it */</comment>
        <expr_stmt><expr><name>agtv_element</name> <operator>=</operator> <call><name>get_ith_agtype_value_from_container</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>arg_agt</name><operator>-&gt;</operator><name>root</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>agtv_element</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>agtv_element</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>AGTV_VERTEX</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"typecast argument is not a valid path"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>push_agtype_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>path</name><operator>.</operator><name>parse_state</name></name></expr></argument>, <argument><expr><name>WAGT_ELEM</name></expr></argument>, <argument><expr><name>agtv_element</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* get a potential edge, check it, then add it */</comment>
        <expr_stmt><expr><name>agtv_element</name> <operator>=</operator> <call><name>get_ith_agtype_value_from_container</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>arg_agt</name><operator>-&gt;</operator><name>root</name></name></expr></argument>, <argument><expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>agtv_element</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>agtv_element</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>AGTV_EDGE</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"typecast argument is not a valid path"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>push_agtype_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>path</name><operator>.</operator><name>parse_state</name></name></expr></argument>, <argument><expr><name>WAGT_ELEM</name></expr></argument>, <argument><expr><name>agtv_element</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <comment type="block">/* validate the last element is a vertex, add it if it is, fail otherwise */</comment>
    <expr_stmt><expr><name>agtv_element</name> <operator>=</operator> <call><name>get_ith_agtype_value_from_container</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>arg_agt</name><operator>-&gt;</operator><name>root</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>agtv_element</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>agtv_element</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>AGTV_VERTEX</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"typecast argument is not a valid path"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>push_agtype_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>path</name><operator>.</operator><name>parse_state</name></name></expr></argument>, <argument><expr><name>WAGT_ELEM</name></expr></argument>, <argument><expr><name>agtv_element</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* close the array */</comment>
    <expr_stmt><expr><name><name>path</name><operator>.</operator><name>res</name></name> <operator>=</operator> <call><name>push_agtype_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>path</name><operator>.</operator><name>parse_state</name></name></expr></argument>, <argument><expr><name>WAGT_END_ARRAY</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* set it to a path */</comment>
    <expr_stmt><expr><name><name>path</name><operator>.</operator><name>res</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>AGTV_PATH</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><call><name>agtype_value_to_agtype</name><argument_list>(<argument><expr><name><name>path</name><operator>.</operator><name>res</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>age_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><name>Datum</name></type> <name>age_id</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>agtype</name> <modifier>*</modifier></type><name>agt_arg</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>agtv_object</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>agtv_result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* check for null */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>agt_arg</name> <operator>=</operator> <call><name>AG_GET_ARG_AGTYPE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* check for a scalar object */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AGT_ROOT_IS_SCALAR</name><argument_list>(<argument><expr><name>agt_arg</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                        <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"id() argument must resolve to a scalar value"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* get the object out of the array */</comment>
    <expr_stmt><expr><name>agtv_object</name> <operator>=</operator> <call><name>get_ith_agtype_value_from_container</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>agt_arg</name><operator>-&gt;</operator><name>root</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* is it an agtype null? */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>agtv_object</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AGTV_NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* check for proper agtype */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>agtv_object</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>AGTV_VERTEX</name> <operator>&amp;&amp;</operator> <name><name>agtv_object</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>AGTV_EDGE</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                        <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"id() argument must be a vertex, an edge or null"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>agtv_result</name> <operator>=</operator> <call><name>GET_AGTYPE_VALUE_OBJECT_VALUE</name><argument_list>(<argument><expr><name>agtv_object</name></expr></argument>, <argument><expr><literal type="string">"id"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>agtv_result</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>agtv_result</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>AGTV_INTEGER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><call><name>agtype_value_to_agtype</name><argument_list>(<argument><expr><name>agtv_result</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>age_start_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><name>Datum</name></type> <name>age_start_id</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>agtype</name> <modifier>*</modifier></type><name>agt_arg</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>agtv_object</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>agtv_result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* check for null */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>agt_arg</name> <operator>=</operator> <call><name>AG_GET_ARG_AGTYPE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* check for a scalar object */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AGT_ROOT_IS_SCALAR</name><argument_list>(<argument><expr><name>agt_arg</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                        <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"start_id() argument must resolve to a scalar value"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* get the object out of the array */</comment>
    <expr_stmt><expr><name>agtv_object</name> <operator>=</operator> <call><name>get_ith_agtype_value_from_container</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>agt_arg</name><operator>-&gt;</operator><name>root</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* is it an agtype null? */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>agtv_object</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AGTV_NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* check for proper agtype */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>agtv_object</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>AGTV_EDGE</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                        <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"start_id() argument must be an edge or null"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>agtv_result</name> <operator>=</operator> <call><name>GET_AGTYPE_VALUE_OBJECT_VALUE</name><argument_list>(<argument><expr><name>agtv_object</name></expr></argument>, <argument><expr><literal type="string">"start_id"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>agtv_result</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>agtv_result</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>AGTV_INTEGER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><call><name>agtype_value_to_agtype</name><argument_list>(<argument><expr><name>agtv_result</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>age_end_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><name>Datum</name></type> <name>age_end_id</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>agtype</name> <modifier>*</modifier></type><name>agt_arg</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>agtv_object</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>agtv_result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* check for null */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>agt_arg</name> <operator>=</operator> <call><name>AG_GET_ARG_AGTYPE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* check for a scalar object */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AGT_ROOT_IS_SCALAR</name><argument_list>(<argument><expr><name>agt_arg</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                        <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"end_id() argument must resolve to a scalar value"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* get the object out of the array */</comment>
    <expr_stmt><expr><name>agtv_object</name> <operator>=</operator> <call><name>get_ith_agtype_value_from_container</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>agt_arg</name><operator>-&gt;</operator><name>root</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* is it an agtype null? */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>agtv_object</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AGTV_NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* check for proper agtype */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>agtv_object</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>AGTV_EDGE</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                        <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"end_id() argument must be an edge or null"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>agtv_result</name> <operator>=</operator> <call><name>GET_AGTYPE_VALUE_OBJECT_VALUE</name><argument_list>(<argument><expr><name>agtv_object</name></expr></argument>, <argument><expr><literal type="string">"end_id"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>agtv_result</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>agtv_result</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>AGTV_INTEGER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><call><name>agtype_value_to_agtype</name><argument_list>(<argument><expr><name>agtv_result</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Helper function to return the Datum value of a column (attribute) in a heap
 * tuple (row) given the column number (starting from 0), attribute name, typid,
 * and whether it can be null. The function is designed to extract and validate
 * that the data (attribute) is what is expected. The function will error on any
 * issues.
 */</comment>
<function><type><name>Datum</name></type> <name>column_get_datum</name><parameter_list>(<parameter><decl><type><name>TupleDesc</name></type> <name>tupdesc</name></decl></parameter>, <parameter><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>column</name></decl></parameter>,
                       <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>attname</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>typid</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isnull</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>att</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTupleHeader</name></type> <name>hth</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTupleData</name></type> <name>tmptup</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>htd</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type> <name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>_isnull</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* build the heap tuple data */</comment>
    <expr_stmt><expr><name>hth</name> <operator>=</operator> <name><name>tuple</name><operator>-&gt;</operator><name>t_data</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>tmptup</name><operator>.</operator><name>t_len</name></name> <operator>=</operator> <call><name>HeapTupleHeaderGetDatumLength</name><argument_list>(<argument><expr><name>hth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>tmptup</name><operator>.</operator><name>t_data</name></name> <operator>=</operator> <name>hth</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>htd</name> <operator>=</operator> <operator>&amp;</operator><name>tmptup</name></expr>;</expr_stmt>

    <comment type="block">/* get the description for the column from the tuple descriptor */</comment>
    <expr_stmt><expr><name>att</name> <operator>=</operator> <call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>column</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* get the datum (attribute) for that column*/</comment>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>heap_getattr</name><argument_list>(<argument><expr><name>htd</name></expr></argument>, <argument><expr><name>column</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>_isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* verify that the attribute typid is as expected */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>att</name><operator>-&gt;</operator><name>atttypid</name></name> <operator>!=</operator> <name>typid</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_TABLE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Invalid attribute typid. Expected %d, found %d"</literal></expr></argument>, <argument><expr><name>typid</name></expr></argument>,
                        <argument><expr><name><name>att</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <comment type="block">/* verify that the attribute name is as expected */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>att</name><operator>-&gt;</operator><name>attname</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name>attname</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_TABLE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Invalid attribute name. Expected %s, found %s"</literal></expr></argument>,
                        <argument><expr><name>attname</name></expr></argument>, <argument><expr><name><name>att</name><operator>-&gt;</operator><name>attname</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <comment type="block">/* verify that if it is null, it is allowed to be null */</comment>
    <if_stmt><if>if <condition>(<expr><name>isnull</name> <operator>==</operator> <name>false</name> <operator>&amp;&amp;</operator> <name>_isnull</name> <operator>==</operator> <name>true</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_TABLE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Attribute was found to be null when null is not allowed."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Function to retrieve a label name, given the graph name and graphid. The
 * function returns a pointer to a duplicated string that needs to be freed
 * when you are finished using it.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>get_label_name</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>graph_name</name></decl></parameter>, <parameter><decl><type><name>int64</name></type> <name>graphid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>scan_keys</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name></type> <name>ag_label</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scan_desc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TupleDesc</name></type> <name>tupdesc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>Oid</name></type> <name>graphoid</name> <init>= <expr><call><name>get_graph_oid</name><argument_list>(<argument><expr><name>graph_name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block">/* scankey for first match in ag_label, column 2, graphoid, BTEQ, OidEQ */</comment>
    <expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scan_keys</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>Anum_ag_label_graph</name></expr></argument>, <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>,
                <argument><expr><name>F_OIDEQ</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>graphoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* scankey for second match in ag_label, column 3, label id, BTEQ, Int4EQ */</comment>
    <expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scan_keys</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>Anum_ag_label_id</name></expr></argument>, <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>,
                <argument><expr><name>F_INT4EQ</name></expr></argument>, <argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><call><name>get_graphid_label_id</name><argument_list>(<argument><expr><name>graphid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>ag_label</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><call><name>ag_relation_id</name><argument_list>(<argument><expr><literal type="string">"ag_label"</literal></expr></argument>, <argument><expr><literal type="string">"table"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>scan_desc</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>ag_label</name></expr></argument>,
                                   <argument><expr><call><name>ag_relation_id</name><argument_list>(<argument><expr><literal type="string">"ag_label_graph_id_index"</literal></expr></argument>,
                                                  <argument><expr><literal type="string">"index"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>,
                                   <argument><expr><name>scan_keys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan_desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_SCHEMA</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"graphid %lu does not exist"</literal></expr></argument>, <argument><expr><name>graphid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* get the tupdesc - we don't need to release this one */</comment>
    <expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>ag_label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* bail if the number of columns differs */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name> <operator>!=</operator> <literal type="number">6</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_TABLE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Invalid number of attributes for ag_catalog.ag_label"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* get the label name */</comment>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>NameStr</name><argument_list>(<argument><expr><operator>*</operator><call><name>DatumGetName</name><argument_list>(<argument><expr><call><name>column_get_datum</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"name"</literal></expr></argument>,
                                                    <argument><expr><name>NAMEOID</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* duplicate it */</comment>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* end the scan and close the relation */</comment>
    <expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan_desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>ag_label</name></expr></argument>, <argument><expr><name>ShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Datum</name></type> <name>get_vertex</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>graph</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>vertex_label</name></decl></parameter>,
                        <parameter><decl><type><name>int64</name></type> <name>graphid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>scan_keys</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name></type> <name>graph_vertex_label</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapScanDesc</name></type> <name>scan_desc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TupleDesc</name></type> <name>tupdesc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type> <name>id</name></decl>, <decl><type ref="prev"/><name>properties</name></decl>, <decl><type ref="prev"/><name>result</name></decl>;</decl_stmt>

    <comment type="block">/* get the specific graph namespace (schema) */</comment>
    <decl_stmt><decl><type><name>Oid</name></type> <name>graph_namespace_oid</name> <init>= <expr><call><name>get_namespace_oid</name><argument_list>(<argument><expr><name>graph</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <comment type="block">/* get the specific vertex label table (schema.vertex_label) */</comment>
    <decl_stmt><decl><type><name>Oid</name></type> <name>vertex_label_table_oid</name> <init>= <expr><call><name>get_relname_relid</name><argument_list>(<argument><expr><name>vertex_label</name></expr></argument>,
                                                 <argument><expr><name>graph_namespace_oid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <comment type="block">/* get the active snapshot */</comment>
    <decl_stmt><decl><type><name>Snapshot</name></type> <name>snapshot</name> <init>= <expr><call><name>GetActiveSnapshot</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block">/* initialize the scan key */</comment>
    <expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scan_keys</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
                <argument><expr><call><name>Int64GetDatum</name><argument_list>(<argument><expr><name>graphid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* open the relation (table), begin the scan, and get the tuple  */</comment>
    <expr_stmt><expr><name>graph_vertex_label</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>vertex_label_table_oid</name></expr></argument>, <argument><expr><name>ShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>scan_desc</name> <operator>=</operator> <call><name>heap_beginscan</name><argument_list>(<argument><expr><name>graph_vertex_label</name></expr></argument>, <argument><expr><name>snapshot</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>scan_keys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>heap_getnext</name><argument_list>(<argument><expr><name>scan_desc</name></expr></argument>, <argument><expr><name>ForwardScanDirection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* bail if the tuple isn't valid */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_TABLE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"graphid %lu does not exist"</literal></expr></argument>, <argument><expr><name>graphid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* get the tupdesc - we don't need to release this one */</comment>
    <expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>graph_vertex_label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* bail if the number of columns differs */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name> <operator>!=</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_TABLE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Invalid number of attributes for %s.%s"</literal></expr></argument>, <argument><expr><name>graph</name></expr></argument>,
                        <argument><expr><name>vertex_label</name></expr></argument> )</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* get the id */</comment>
    <expr_stmt><expr><name>id</name> <operator>=</operator> <call><name>column_get_datum</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"id"</literal></expr></argument>, <argument><expr><name>GRAPHIDOID</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* get the properties */</comment>
    <expr_stmt><expr><name>properties</name> <operator>=</operator> <call><name>column_get_datum</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"properties"</literal></expr></argument>,
                                  <argument><expr><name>AGTYPEOID</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* reconstruct the vertex */</comment>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>DirectFunctionCall3</name><argument_list>(<argument><expr><name>_agtype_build_vertex</name></expr></argument>, <argument><expr><name>id</name></expr></argument>,
                                 <argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name>vertex_label</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>properties</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* end the scan and close the relation */</comment>
    <expr_stmt><expr><call><name>heap_endscan</name><argument_list>(<argument><expr><name>scan_desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>graph_vertex_label</name></expr></argument>, <argument><expr><name>ShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* return the vertex datum */</comment>
    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>age_startnode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><name>Datum</name></type> <name>age_startnode</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>agtype</name> <modifier>*</modifier></type><name>agt_arg</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>agtv_object</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>agtv_value</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>graph_name</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>label_name</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>graphid</name></type> <name>graph_id</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type> <name>result</name></decl>;</decl_stmt>

    <comment type="block">/* we need the graph name */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* check for null */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* get the graph name */</comment>
    <expr_stmt><expr><name>agt_arg</name> <operator>=</operator> <call><name>AG_GET_ARG_AGTYPE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* it must be a scalar and must be a string */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>AGT_ROOT_IS_SCALAR</name><argument_list>(<argument><expr><name>agt_arg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>agtv_object</name> <operator>=</operator> <call><name>get_ith_agtype_value_from_container</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>agt_arg</name><operator>-&gt;</operator><name>root</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>agtv_object</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AGTV_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>graph_name</name> <operator>=</operator> <call><name>strndup</name><argument_list>(<argument><expr><name><name>agtv_object</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>val</name></name></expr></argument>,
                         <argument><expr><name><name>agtv_object</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* get the edge */</comment>
    <expr_stmt><expr><name>agt_arg</name> <operator>=</operator> <call><name>AG_GET_ARG_AGTYPE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* check for a scalar object */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AGT_ROOT_IS_SCALAR</name><argument_list>(<argument><expr><name>agt_arg</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                        <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"startNode() argument must resolve to a scalar value"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <comment type="block">/* get the object */</comment>
    <expr_stmt><expr><name>agtv_object</name> <operator>=</operator> <call><name>get_ith_agtype_value_from_container</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>agt_arg</name><operator>-&gt;</operator><name>root</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* is it an agtype null, return null if it is */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>agtv_object</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AGTV_NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* check for proper agtype */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>agtv_object</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>AGTV_EDGE</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                        <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"startNode() argument must be an edge or null"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* get the graphid for start_id */</comment>
    <expr_stmt><expr><name>agtv_value</name> <operator>=</operator> <call><name>GET_AGTYPE_VALUE_OBJECT_VALUE</name><argument_list>(<argument><expr><name>agtv_object</name></expr></argument>, <argument><expr><literal type="string">"start_id"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* it must not be null and must be an integer */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>agtv_value</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>agtv_value</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>AGTV_INTEGER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>graph_id</name> <operator>=</operator> <name><name>agtv_value</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>int_value</name></name></expr>;</expr_stmt>

    <comment type="block">/* get the label */</comment>
    <expr_stmt><expr><name>label_name</name> <operator>=</operator> <call><name>get_label_name</name><argument_list>(<argument><expr><name>graph_name</name></expr></argument>, <argument><expr><name>graph_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* it must not be null and must be a string */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>label_name</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>get_vertex</name><argument_list>(<argument><expr><name>graph_name</name></expr></argument>, <argument><expr><name>label_name</name></expr></argument>, <argument><expr><name>graph_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>label_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>age_endnode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><name>Datum</name></type> <name>age_endnode</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>agtype</name> <modifier>*</modifier></type><name>agt_arg</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>agtv_object</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>agtv_value</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>graph_name</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>label_name</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>graphid</name></type> <name>graph_id</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type> <name>result</name></decl>;</decl_stmt>

    <comment type="block">/* we need the graph name */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* check for null */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* get the graph name */</comment>
    <expr_stmt><expr><name>agt_arg</name> <operator>=</operator> <call><name>AG_GET_ARG_AGTYPE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* it must be a scalar and must be a string */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>AGT_ROOT_IS_SCALAR</name><argument_list>(<argument><expr><name>agt_arg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>agtv_object</name> <operator>=</operator> <call><name>get_ith_agtype_value_from_container</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>agt_arg</name><operator>-&gt;</operator><name>root</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>agtv_object</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AGTV_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>graph_name</name> <operator>=</operator> <call><name>strndup</name><argument_list>(<argument><expr><name><name>agtv_object</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>val</name></name></expr></argument>,
                         <argument><expr><name><name>agtv_object</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* get the edge */</comment>
    <expr_stmt><expr><name>agt_arg</name> <operator>=</operator> <call><name>AG_GET_ARG_AGTYPE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* check for a scalar object */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AGT_ROOT_IS_SCALAR</name><argument_list>(<argument><expr><name>agt_arg</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                        <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"endNode() argument must resolve to a scalar value"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <comment type="block">/* get the object */</comment>
    <expr_stmt><expr><name>agtv_object</name> <operator>=</operator> <call><name>get_ith_agtype_value_from_container</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>agt_arg</name><operator>-&gt;</operator><name>root</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* is it an agtype null, return null if it is */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>agtv_object</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AGTV_NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* check for proper agtype */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>agtv_object</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>AGTV_EDGE</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                        <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"endNode() argument must be an edge or null"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* get the graphid for the end_id */</comment>
    <expr_stmt><expr><name>agtv_value</name> <operator>=</operator> <call><name>GET_AGTYPE_VALUE_OBJECT_VALUE</name><argument_list>(<argument><expr><name>agtv_object</name></expr></argument>, <argument><expr><literal type="string">"end_id"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* it must not be null and must be an integer */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>agtv_value</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>agtv_value</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>AGTV_INTEGER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>graph_id</name> <operator>=</operator> <name><name>agtv_value</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>int_value</name></name></expr>;</expr_stmt>

    <comment type="block">/* get the label */</comment>
    <expr_stmt><expr><name>label_name</name> <operator>=</operator> <call><name>get_label_name</name><argument_list>(<argument><expr><name>graph_name</name></expr></argument>, <argument><expr><name>graph_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* it must not be null and must be a string */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>label_name</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>get_vertex</name><argument_list>(<argument><expr><name>graph_name</name></expr></argument>, <argument><expr><name>label_name</name></expr></argument>, <argument><expr><name>graph_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>label_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>age_head</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><name>Datum</name></type> <name>age_head</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>agtype</name> <modifier>*</modifier></type><name>agt_arg</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>agtv_result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>count</name></decl>;</decl_stmt>

    <comment type="block">/* check for null */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>agt_arg</name> <operator>=</operator> <call><name>AG_GET_ARG_AGTYPE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* check for an array */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AGT_ROOT_IS_ARRAY</name><argument_list>(<argument><expr><name>agt_arg</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>AGT_ROOT_IS_SCALAR</name><argument_list>(<argument><expr><name>agt_arg</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                        <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"head() argument must resolve to a list or null"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>count</name> <operator>=</operator> <call><name>AGT_ROOT_COUNT</name><argument_list>(<argument><expr><name>agt_arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* if we have an empty list, return a null */</comment>
    <if_stmt><if>if <condition>(<expr><name>count</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* get the first element of the array */</comment>
    <expr_stmt><expr><name>agtv_result</name> <operator>=</operator> <call><name>get_ith_agtype_value_from_container</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>agt_arg</name><operator>-&gt;</operator><name>root</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* if it is AGTV_NULL, return null */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>agtv_result</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AGTV_NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><call><name>agtype_value_to_agtype</name><argument_list>(<argument><expr><name>agtv_result</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>age_last</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><name>Datum</name></type> <name>age_last</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>agtype</name> <modifier>*</modifier></type><name>agt_arg</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>agtv_result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>count</name></decl>;</decl_stmt>

    <comment type="block">/* check for null */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>agt_arg</name> <operator>=</operator> <call><name>AG_GET_ARG_AGTYPE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* check for an array */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AGT_ROOT_IS_ARRAY</name><argument_list>(<argument><expr><name>agt_arg</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>AGT_ROOT_IS_SCALAR</name><argument_list>(<argument><expr><name>agt_arg</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                        <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"last() argument must resolve to a list or null"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>count</name> <operator>=</operator> <call><name>AGT_ROOT_COUNT</name><argument_list>(<argument><expr><name>agt_arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* if we have an empty list, return null */</comment>
    <if_stmt><if>if <condition>(<expr><name>count</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* get the last element of the array */</comment>
    <expr_stmt><expr><name>agtv_result</name> <operator>=</operator> <call><name>get_ith_agtype_value_from_container</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>agt_arg</name><operator>-&gt;</operator><name>root</name></name></expr></argument>, <argument><expr><name>count</name> <operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* if it is AGTV_NULL, return null */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>agtv_result</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AGTV_NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><call><name>agtype_value_to_agtype</name><argument_list>(<argument><expr><name>agtv_result</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>age_properties</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><name>Datum</name></type> <name>age_properties</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>agtype</name> <modifier>*</modifier></type><name>agt_arg</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>agtv_object</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>agtv_result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* check for null */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>agt_arg</name> <operator>=</operator> <call><name>AG_GET_ARG_AGTYPE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* check for a scalar object */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AGT_ROOT_IS_SCALAR</name><argument_list>(<argument><expr><name>agt_arg</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                        <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"properties() argument must resolve to a scalar value"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* get the object out of the array */</comment>
    <expr_stmt><expr><name>agtv_object</name> <operator>=</operator> <call><name>get_ith_agtype_value_from_container</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>agt_arg</name><operator>-&gt;</operator><name>root</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* is it an agtype null? */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>agtv_object</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AGTV_NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* check for proper agtype */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>agtv_object</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>AGTV_VERTEX</name> <operator>&amp;&amp;</operator> <name><name>agtv_object</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>AGTV_EDGE</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                        <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"properties() argument must be a vertex, an edge or null"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>agtv_result</name> <operator>=</operator> <call><name>GET_AGTYPE_VALUE_OBJECT_VALUE</name><argument_list>(<argument><expr><name>agtv_object</name></expr></argument>, <argument><expr><literal type="string">"properties"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>agtv_result</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>agtv_result</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>AGTV_OBJECT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><call><name>agtype_value_to_agtype</name><argument_list>(<argument><expr><name>agtv_result</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>age_length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><name>Datum</name></type> <name>age_length</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>agtype</name> <modifier>*</modifier></type><name>agt_arg</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>agtv_path</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_value</name></type> <name>agtv_result</name></decl>;</decl_stmt>

    <comment type="block">/* check for null */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>agt_arg</name> <operator>=</operator> <call><name>AG_GET_ARG_AGTYPE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* check for a scalar */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AGT_ROOT_IS_SCALAR</name><argument_list>(<argument><expr><name>agt_arg</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                        <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"length() argument must resolve to a scalar"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* get the path array */</comment>
    <expr_stmt><expr><name>agtv_path</name> <operator>=</operator> <call><name>get_ith_agtype_value_from_container</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>agt_arg</name><operator>-&gt;</operator><name>root</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* if it is AGTV_NULL, return null */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>agtv_path</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AGTV_NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* check for a path */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>agtv_path</name> <operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>AGTV_PATH</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                        <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"length() argument must resolve to a path or null"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name><name>agtv_result</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>AGTV_INTEGER</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>agtv_result</name><operator>.</operator><name>val</name><operator>.</operator><name>int_value</name></name> <operator>=</operator> <operator>(</operator><name><name>agtv_path</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>array</name><operator>.</operator><name>num_elems</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator><literal type="number">2</literal></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><call><name>agtype_value_to_agtype</name><argument_list>(<argument><expr><operator>&amp;</operator><name>agtv_result</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>age_toboolean</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><name>Datum</name></type> <name>age_toboolean</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>nargs</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name> <modifier>*</modifier></type><name>args</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type> <name>arg</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name> <modifier>*</modifier></type><name>nulls</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name> <modifier>*</modifier></type><name>types</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type> <name>type</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_value</name></type> <name>agtv_result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>string</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>result</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* extract argument values */</comment>
    <expr_stmt><expr><name>nargs</name> <operator>=</operator> <call><name>extract_variadic_args</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>args</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>types</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* check number of args */</comment>
    <if_stmt><if>if <condition>(<expr><name>nargs</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                        <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"toBoolean() only supports one argument"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* check for null */</comment>
    <if_stmt><if>if <condition>(<expr><name>nargs</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>nulls</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * toBoolean() supports bool, text, cstring, or the agtype bool, and string
     * input.
     */</comment>
    <expr_stmt><expr><name>arg</name> <operator>=</operator> <name><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>type</name> <operator>=</operator> <name><name>types</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>type</name> <operator>!=</operator> <name>AGTYPEOID</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>BOOLOID</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>DatumGetBool</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><name>type</name> <operator>==</operator> <name>CSTRINGOID</name> <operator>||</operator> <name>type</name> <operator>==</operator> <name>TEXTOID</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>CSTRINGOID</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>string</name> <operator>=</operator> <call><name>DatumGetCString</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><name>string</name> <operator>=</operator> <call><name>text_to_cstring</name><argument_list>(<argument><expr><call><name>DatumGetTextPP</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

            <if_stmt><if>if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>string</name></expr></argument>, <argument><expr><literal type="string">"true"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
            <if type="elseif">else if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>string</name></expr></argument>, <argument><expr><literal type="string">"false"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>result</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                            <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"toBoolean() unsupported argument type %d"</literal></expr></argument>,
                                   <argument><expr><name>type</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <decl_stmt><decl><type><name>agtype</name> <modifier>*</modifier></type><name>agt_arg</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>agtv_value</name></decl>;</decl_stmt>

        <comment type="block">/* get the agtype argument */</comment>
        <expr_stmt><expr><name>agt_arg</name> <operator>=</operator> <call><name>DATUM_GET_AGTYPE_P</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AGT_ROOT_IS_SCALAR</name><argument_list>(<argument><expr><name>agt_arg</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                            <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"toBoolean() only supports scalar arguments"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>agtv_value</name> <operator>=</operator> <call><name>get_ith_agtype_value_from_container</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>agt_arg</name><operator>-&gt;</operator><name>root</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>agtv_value</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AGTV_BOOL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>agtv_value</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>boolean</name></name></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><name><name>agtv_value</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AGTV_STRING</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><name><name>agtv_value</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>len</name></name></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><name>string</name> <operator>=</operator> <name><name>agtv_value</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>val</name></name></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">4</literal> <operator>&amp;&amp;</operator> <call><name>pg_strncasecmp</name><argument_list>(<argument><expr><name>string</name></expr></argument>, <argument><expr><literal type="string">"true"</literal></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
            <if type="elseif">else if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">5</literal> <operator>&amp;&amp;</operator> <call><name>pg_strncasecmp</name><argument_list>(<argument><expr><name>string</name></expr></argument>, <argument><expr><literal type="string">"false"</literal></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>result</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                            <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"toBoolean() unsupported argument agtype %d"</literal></expr></argument>,
                                   <argument><expr><name><name>agtv_value</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* build the result */</comment>
    <expr_stmt><expr><name><name>agtv_result</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>AGTV_BOOL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>agtv_result</name><operator>.</operator><name>val</name><operator>.</operator><name>boolean</name></name> <operator>=</operator> <name>result</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><call><name>agtype_value_to_agtype</name><argument_list>(<argument><expr><operator>&amp;</operator><name>agtv_result</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>age_tofloat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><name>Datum</name></type> <name>age_tofloat</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>nargs</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name> <modifier>*</modifier></type><name>args</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type> <name>arg</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name> <modifier>*</modifier></type><name>nulls</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name> <modifier>*</modifier></type><name>types</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_value</name></type> <name>agtv_result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>string</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>is_valid</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type> <name>type</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>float8</name></type> <name>result</name></decl>;</decl_stmt>

    <comment type="block">/* extract argument values */</comment>
    <expr_stmt><expr><name>nargs</name> <operator>=</operator> <call><name>extract_variadic_args</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>args</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>types</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* check number of args */</comment>
    <if_stmt><if>if <condition>(<expr><name>nargs</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                        <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"toFloat() only supports one argument"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* check for null */</comment>
    <if_stmt><if>if <condition>(<expr><name>nargs</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>nulls</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * toFloat() supports integer, float, numeric, text, cstring, or the
     * agtype integer, float, numeric, and string input
     */</comment>
    <expr_stmt><expr><name>arg</name> <operator>=</operator> <name><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>type</name> <operator>=</operator> <name><name>types</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>type</name> <operator>!=</operator> <name>AGTYPEOID</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>INT2OID</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>float8</name><operator>)</operator> <call><name>DatumGetInt16</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><name>type</name> <operator>==</operator> <name>INT4OID</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>float8</name><operator>)</operator> <call><name>DatumGetInt32</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><name>type</name> <operator>==</operator> <name>INT8OID</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * Get the string representation of the integer because it could be
             * too large to fit in a float. Let the float routine determine
             * what to do with it.
             */</comment>
            <expr_stmt><expr><name>string</name> <operator>=</operator> <call><name>DatumGetCString</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>int8out</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* turn it into a float */</comment>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>float8in_internal_null</name><argument_list>(<argument><expr><name>string</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"double precision"</literal></expr></argument>,
                                            <argument><expr><name>string</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>is_valid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* return null if it was not a invalid float */</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_valid</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>type</name> <operator>==</operator> <name>FLOAT4OID</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>float8</name><operator>)</operator> <call><name>DatumGetFloat4</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><name>type</name> <operator>==</operator> <name>FLOAT8OID</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>DatumGetFloat8</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><name>type</name> <operator>==</operator> <name>NUMERICOID</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>DatumGetFloat8</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(
                <argument><expr><name>numeric_float8_no_overflow</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><name>type</name> <operator>==</operator> <name>CSTRINGOID</name> <operator>||</operator> <name>type</name> <operator>==</operator> <name>TEXTOID</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>CSTRINGOID</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>string</name> <operator>=</operator> <call><name>DatumGetCString</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><name>string</name> <operator>=</operator> <call><name>text_to_cstring</name><argument_list>(<argument><expr><call><name>DatumGetTextPP</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>float8in_internal_null</name><argument_list>(<argument><expr><name>string</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"double precision"</literal></expr></argument>,
                                            <argument><expr><name>string</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>is_valid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_valid</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                            <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"toFloat() unsupported argument type %d"</literal></expr></argument>,
                                   <argument><expr><name>type</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <decl_stmt><decl><type><name>agtype</name> <modifier>*</modifier></type><name>agt_arg</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>agtv_value</name></decl>;</decl_stmt>

        <comment type="block">/* get the agtype argument */</comment>
        <expr_stmt><expr><name>agt_arg</name> <operator>=</operator> <call><name>DATUM_GET_AGTYPE_P</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AGT_ROOT_IS_SCALAR</name><argument_list>(<argument><expr><name>agt_arg</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                            <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"toFloat() only supports scalar arguments"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>agtv_value</name> <operator>=</operator> <call><name>get_ith_agtype_value_from_container</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>agt_arg</name><operator>-&gt;</operator><name>root</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>agtv_value</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AGTV_INTEGER</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* get the string representation of the integer */</comment>
            <expr_stmt><expr><name>string</name> <operator>=</operator> <call><name>DatumGetCString</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>int8out</name></expr></argument>,
                         <argument><expr><call><name>Int64GetDatum</name><argument_list>(<argument><expr><name><name>agtv_value</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>int_value</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* turn it into a float */</comment>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>float8in_internal_null</name><argument_list>(<argument><expr><name>string</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"double precision"</literal></expr></argument>,
                                            <argument><expr><name>string</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>is_valid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* return null if it was an invalid float */</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_valid</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name><name>agtv_value</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AGTV_FLOAT</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>agtv_value</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>float_value</name></name></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><name><name>agtv_value</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AGTV_NUMERIC</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>DatumGetFloat8</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(
                <argument><expr><name>numeric_float8_no_overflow</name></expr></argument>,
                <argument><expr><call><name>NumericGetDatum</name><argument_list>(<argument><expr><name><name>agtv_value</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>numeric</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><name><name>agtv_value</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AGTV_STRING</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>string</name> <operator>=</operator> <call><name>strndup</name><argument_list>(<argument><expr><name><name>agtv_value</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>val</name></name></expr></argument>,
                             <argument><expr><name><name>agtv_value</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>float8in_internal_null</name><argument_list>(<argument><expr><name>string</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"double precision"</literal></expr></argument>,
                                            <argument><expr><name>string</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>is_valid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_valid</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                            <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"toFloat() unsupported argument agtype %d"</literal></expr></argument>,
                                   <argument><expr><name><name>agtv_value</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* build the result */</comment>
    <expr_stmt><expr><name><name>agtv_result</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>AGTV_FLOAT</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>agtv_result</name><operator>.</operator><name>val</name><operator>.</operator><name>float_value</name></name> <operator>=</operator> <name>result</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><call><name>agtype_value_to_agtype</name><argument_list>(<argument><expr><operator>&amp;</operator><name>agtv_result</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>age_tointeger</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><name>Datum</name></type> <name>age_tointeger</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>nargs</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name> <modifier>*</modifier></type><name>args</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type> <name>arg</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name> <modifier>*</modifier></type><name>nulls</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name> <modifier>*</modifier></type><name>types</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_value</name></type> <name>agtv_result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>string</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>is_valid</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type> <name>type</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int64</name></type> <name>result</name></decl>;</decl_stmt>

    <comment type="block">/* extract argument values */</comment>
    <expr_stmt><expr><name>nargs</name> <operator>=</operator> <call><name>extract_variadic_args</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>args</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>types</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* check number of args */</comment>
    <if_stmt><if>if <condition>(<expr><name>nargs</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                        <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"toInteger() only supports one argument"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* check for null */</comment>
    <if_stmt><if>if <condition>(<expr><name>nargs</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>nulls</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * toInteger() supports integer, float, numeric, text, cstring, or the
     * agtype integer, float, numeric, and string input
     */</comment>
    <expr_stmt><expr><name>arg</name> <operator>=</operator> <name><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>type</name> <operator>=</operator> <name><name>types</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>type</name> <operator>!=</operator> <name>AGTYPEOID</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>INT2OID</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>int64</name><operator>)</operator> <call><name>DatumGetInt16</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><name>type</name> <operator>==</operator> <name>INT4OID</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>int64</name><operator>)</operator> <call><name>DatumGetInt32</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><name>type</name> <operator>==</operator> <name>INT8OID</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>int64</name><operator>)</operator> <call><name>DatumGetInt64</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><name>type</name> <operator>==</operator> <name>FLOAT4OID</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>float4</name></type> <name>f</name> <init>= <expr><call><name>DatumGetFloat4</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><call><name>isnan</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>isinf</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call> <operator>||</operator>
                <name><name>f</name> <argument_list type="generic">&lt; <argument><expr><name>PG_INT64_MIN</name> <operator>||</operator> <name>f</name></expr></argument> &gt;</argument_list></name> <name>PG_INT64_MAX</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>int64</name><operator>)</operator> <name>f</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>type</name> <operator>==</operator> <name>FLOAT8OID</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>float8</name></type> <name>f</name> <init>= <expr><call><name>DatumGetFloat8</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><call><name>isnan</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>isinf</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call> <operator>||</operator>
                <name><name>f</name> <argument_list type="generic">&lt; <argument><expr><name>PG_INT64_MIN</name> <operator>||</operator> <name>f</name></expr></argument> &gt;</argument_list></name> <name>PG_INT64_MAX</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>int64</name><operator>)</operator> <name>f</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>type</name> <operator>==</operator> <name>NUMERICOID</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>float8</name></type> <name>f</name></decl>;</decl_stmt>

            <expr_stmt><expr><name>f</name> <operator>=</operator> <call><name>DatumGetFloat8</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(
                <argument><expr><name>numeric_float8_no_overflow</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><call><name>isnan</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>isinf</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call> <operator>||</operator>
                <name><name>f</name> <argument_list type="generic">&lt; <argument><expr><name>PG_INT64_MIN</name> <operator>||</operator> <name>f</name></expr></argument> &gt;</argument_list></name> <name>PG_INT64_MAX</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>int64</name><operator>)</operator> <name>f</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>type</name> <operator>==</operator> <name>CSTRINGOID</name> <operator>||</operator> <name>type</name> <operator>==</operator> <name>TEXTOID</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>CSTRINGOID</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>string</name> <operator>=</operator> <call><name>DatumGetCString</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><name>string</name> <operator>=</operator> <call><name>text_to_cstring</name><argument_list>(<argument><expr><call><name>DatumGetTextPP</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

            <comment type="block">/* convert it if it is a regular integer string */</comment>
            <expr_stmt><expr><name>is_valid</name> <operator>=</operator> <call><name>scanint8</name><argument_list>(<argument><expr><name>string</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/*
             * If it isn't an integer string, try converting it as a float
             * string.
             */</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_valid</name></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>float</name></type> <name>f</name></decl>;</decl_stmt>

                <expr_stmt><expr><name>f</name> <operator>=</operator> <call><name>float8in_internal_null</name><argument_list>(<argument><expr><name>string</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"double precision"</literal></expr></argument>,
                                           <argument><expr><name>string</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>is_valid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <comment type="block">/*
                 * If the conversions failed or it's a special float value,
                 * return null.
                 */</comment>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_valid</name> <operator>||</operator> <call><name>isnan</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>isinf</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call> <operator>||</operator>
                    <name><name>f</name> <argument_list type="generic">&lt; <argument><expr><name>PG_INT64_MIN</name> <operator>||</operator> <name>f</name></expr></argument> &gt;</argument_list></name> <name>PG_INT64_MAX</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>int64</name><operator>)</operator> <name>f</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                            <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"toInteger() unsupported argument type %d"</literal></expr></argument>,
                                   <argument><expr><name>type</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <decl_stmt><decl><type><name>agtype</name> <modifier>*</modifier></type><name>agt_arg</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>agtv_value</name></decl>;</decl_stmt>

        <comment type="block">/* get the agtype argument */</comment>
        <expr_stmt><expr><name>agt_arg</name> <operator>=</operator> <call><name>DATUM_GET_AGTYPE_P</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AGT_ROOT_IS_SCALAR</name><argument_list>(<argument><expr><name>agt_arg</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                            <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"toInteger() only supports scalar arguments"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>agtv_value</name> <operator>=</operator> <call><name>get_ith_agtype_value_from_container</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>agt_arg</name><operator>-&gt;</operator><name>root</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>agtv_value</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AGTV_INTEGER</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>agtv_value</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>int_value</name></name></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><name><name>agtv_value</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AGTV_FLOAT</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>float</name></type> <name>f</name> <init>= <expr><name><name>agtv_value</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>float_value</name></name></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><call><name>isnan</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>isinf</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call> <operator>||</operator>
                <name><name>f</name> <argument_list type="generic">&lt; <argument><expr><name>PG_INT64_MIN</name> <operator>||</operator> <name>f</name></expr></argument> &gt;</argument_list></name> <name>PG_INT64_MAX</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>int64</name><operator>)</operator> <name>f</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name><name>agtv_value</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AGTV_NUMERIC</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>float8</name></type> <name>f</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Datum</name></type> <name>num</name> <init>= <expr><call><name>NumericGetDatum</name><argument_list>(<argument><expr><name><name>agtv_value</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>numeric</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><name>f</name> <operator>=</operator> <call><name>DatumGetFloat8</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(
                <argument><expr><name>numeric_float8_no_overflow</name></expr></argument>, <argument><expr><name>num</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><call><name>isnan</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>isinf</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call> <operator>||</operator>
                <name><name>f</name> <argument_list type="generic">&lt; <argument><expr><name>PG_INT64_MIN</name> <operator>||</operator> <name>f</name></expr></argument> &gt;</argument_list></name> <name>PG_INT64_MAX</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>int64</name><operator>)</operator> <name>f</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name><name>agtv_value</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AGTV_STRING</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* we need a null terminated cstring */</comment>
            <expr_stmt><expr><name>string</name> <operator>=</operator> <call><name>strndup</name><argument_list>(<argument><expr><name><name>agtv_value</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>val</name></name></expr></argument>,
                             <argument><expr><name><name>agtv_value</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* convert it if it is a regular integer string */</comment>
            <expr_stmt><expr><name>is_valid</name> <operator>=</operator> <call><name>scanint8</name><argument_list>(<argument><expr><name>string</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/*
             * If it isn't an integer string, try converting it as a float
             * string.
             */</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_valid</name></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>float</name></type> <name>f</name></decl>;</decl_stmt>

                <expr_stmt><expr><name>f</name> <operator>=</operator> <call><name>float8in_internal_null</name><argument_list>(<argument><expr><name>string</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"double precision"</literal></expr></argument>,
                                           <argument><expr><name>string</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>is_valid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <comment type="block">/*
                 * If the conversions failed or it's a special float value,
                 * return null.
                 */</comment>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_valid</name> <operator>||</operator> <call><name>isnan</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>isinf</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call> <operator>||</operator>
                    <name><name>f</name> <argument_list type="generic">&lt; <argument><expr><name>PG_INT64_MIN</name> <operator>||</operator> <name>f</name></expr></argument> &gt;</argument_list></name> <name>PG_INT64_MAX</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>int64</name><operator>)</operator> <name>f</name></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                            <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"toInteger() unsupported argument agtype %d"</literal></expr></argument>,
                                   <argument><expr><name><name>agtv_value</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* build the result */</comment>
    <expr_stmt><expr><name><name>agtv_result</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>AGTV_INTEGER</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>agtv_result</name><operator>.</operator><name>val</name><operator>.</operator><name>int_value</name></name> <operator>=</operator> <name>result</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><call><name>agtype_value_to_agtype</name><argument_list>(<argument><expr><operator>&amp;</operator><name>agtv_result</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>age_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><name>Datum</name></type> <name>age_size</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>nargs</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name> <modifier>*</modifier></type><name>args</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type> <name>arg</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name> <modifier>*</modifier></type><name>nulls</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name> <modifier>*</modifier></type><name>types</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_value</name></type> <name>agtv_result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>string</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type> <name>type</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int64</name></type> <name>result</name></decl>;</decl_stmt>

    <comment type="block">/* extract argument values */</comment>
    <expr_stmt><expr><name>nargs</name> <operator>=</operator> <call><name>extract_variadic_args</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>args</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>types</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* check number of args */</comment>
    <if_stmt><if>if <condition>(<expr><name>nargs</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                        <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"size() only supports one argument"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* check for null */</comment>
    <if_stmt><if>if <condition>(<expr><name>nargs</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>nulls</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * size() supports cstring, text, or the agtype string or list input
     */</comment>
    <expr_stmt><expr><name>arg</name> <operator>=</operator> <name><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>type</name> <operator>=</operator> <name><name>types</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>CSTRINGOID</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>string</name> <operator>=</operator> <call><name>DatumGetCString</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>type</name> <operator>==</operator> <name>TEXTOID</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>string</name> <operator>=</operator> <call><name>text_to_cstring</name><argument_list>(<argument><expr><call><name>DatumGetTextPP</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>type</name> <operator>==</operator> <name>AGTYPEOID</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>agtype</name> <modifier>*</modifier></type><name>agt_arg</name></decl>;</decl_stmt>

        <comment type="block">/* get the agtype argument */</comment>
        <expr_stmt><expr><name>agt_arg</name> <operator>=</operator> <call><name>DATUM_GET_AGTYPE_P</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>AGT_ROOT_IS_SCALAR</name><argument_list>(<argument><expr><name>agt_arg</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>agtv_value</name></decl>;</decl_stmt>

            <expr_stmt><expr><name>agtv_value</name> <operator>=</operator> <call><name>get_ith_agtype_value_from_container</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>agt_arg</name><operator>-&gt;</operator><name>root</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>agtv_value</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AGTV_STRING</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>agtv_value</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>len</name></name></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                                        <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"size() unsupported argument"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><call><name>AGT_ROOT_IS_ARRAY</name><argument_list>(<argument><expr><name>agt_arg</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>AGT_ROOT_COUNT</name><argument_list>(<argument><expr><name>agt_arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                            <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"size() unsupported argument"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                        <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"size() unsupported argument"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <comment type="block">/* build the result */</comment>
    <expr_stmt><expr><name><name>agtv_result</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>AGTV_INTEGER</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>agtv_result</name><operator>.</operator><name>val</name><operator>.</operator><name>int_value</name></name> <operator>=</operator> <name>result</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><call><name>agtype_value_to_agtype</name><argument_list>(<argument><expr><operator>&amp;</operator><name>agtv_result</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>graphid_to_agtype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><name>Datum</name></type> <name>graphid_to_agtype</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><call><name>integer_to_agtype</name><argument_list>(<argument><expr><call><name>AG_GETARG_GRAPHID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>agtype_to_graphid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><name>Datum</name></type> <name>agtype_to_graphid</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>agtype</name> <modifier>*</modifier></type><name>agtype_in</name> <init>= <expr><call><name>AG_GET_ARG_AGTYPE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_value</name></type> <name>agtv</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>agtype_extract_scalar</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>agtype_in</name><operator>-&gt;</operator><name>root</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>agtv</name></expr></argument>)</argument_list></call> <operator>||</operator>
        <name><name>agtv</name><operator>.</operator><name>type</name></name> <operator>!=</operator> <name>AGTV_INTEGER</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>cannot_cast_agtype_value</name><argument_list>(<argument><expr><name><name>agtv</name><operator>.</operator><name>type</name></name></expr></argument>, <argument><expr><literal type="string">"graphid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>agtype_in</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_INT16</name><argument_list>(<argument><expr><name><name>agtv</name><operator>.</operator><name>val</name><operator>.</operator><name>int_value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>age_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><name>Datum</name></type> <name>age_type</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>agtype</name> <modifier>*</modifier></type><name>agt_arg</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>agtv_object</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>agtv_result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* check for null */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>agt_arg</name> <operator>=</operator> <call><name>AG_GET_ARG_AGTYPE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* check for a scalar object */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AGT_ROOT_IS_SCALAR</name><argument_list>(<argument><expr><name>agt_arg</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                        <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"type() argument must resolve to a scalar value"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* get the object out of the array */</comment>
    <expr_stmt><expr><name>agtv_object</name> <operator>=</operator> <call><name>get_ith_agtype_value_from_container</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>agt_arg</name><operator>-&gt;</operator><name>root</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* is it an agtype null? */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>agtv_object</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AGTV_NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* check for proper agtype */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>agtv_object</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>AGTV_EDGE</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                        <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"type() argument must be an edge or null"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>agtv_result</name> <operator>=</operator> <call><name>GET_AGTYPE_VALUE_OBJECT_VALUE</name><argument_list>(<argument><expr><name>agtv_object</name></expr></argument>, <argument><expr><literal type="string">"label"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>agtv_result</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>agtv_result</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>AGTV_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><call><name>agtype_value_to_agtype</name><argument_list>(<argument><expr><name>agtv_result</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>age_exists</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<comment type="block">/*
 * Executor function for EXISTS(property).
 *
 * Note: For most executor functions we want to return SQL NULL for NULL input.
 *       However, in this case, NULL means false - it was not found.
 */</comment>
<function><type><name>Datum</name></type> <name>age_exists</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>agtype</name> <modifier>*</modifier></type><name>agt_arg</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>agtv_value</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* check for NULL, NULL is FALSE */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* get the argument */</comment>
    <expr_stmt><expr><name>agt_arg</name> <operator>=</operator> <call><name>AG_GET_ARG_AGTYPE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* check for a scalar AGTV_NULL */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>AGT_ROOT_IS_SCALAR</name><argument_list>(<argument><expr><name>agt_arg</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>agtv_value</name> <operator>=</operator> <call><name>get_ith_agtype_value_from_container</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>agt_arg</name><operator>-&gt;</operator><name>root</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* again, if NULL, NULL is FALSE */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>agtv_value</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AGTV_NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* otherwise, we have something, and something is TRUE */</comment>
    <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>age_label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<comment type="block">/*
 * Executor function for label(edge/vertex).
 */</comment>
<function><type><name>Datum</name></type> <name>age_label</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>agtype</name> <modifier>*</modifier></type><name>agt_arg</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>agtv_value</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>label</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* check for NULL, NULL is FALSE */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* get the argument */</comment>
    <expr_stmt><expr><name>agt_arg</name> <operator>=</operator> <call><name>AG_GET_ARG_AGTYPE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// edges and vertices are considered scalars</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AGT_ROOT_IS_SCALAR</name><argument_list>(<argument><expr><name>agt_arg</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>AGTE_IS_NULL</name><argument_list>(<argument><expr><name><name>agt_arg</name><operator>-&gt;</operator><name>root</name><operator>.</operator><name>children</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                        <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"label() argument must resolve to an edge or vertex"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>agtv_value</name> <operator>=</operator> <call><name>get_ith_agtype_value_from_container</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>agt_arg</name><operator>-&gt;</operator><name>root</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// fail if agtype value isn't an edge or vertex</comment>
    <if_stmt><if>if <condition>(<expr><name><name>agtv_value</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>AGTV_VERTEX</name> <operator>&amp;&amp;</operator> <name><name>agtv_value</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>AGTV_EDGE</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                        <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"label() argument must resolve to an edge or vertex"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    </block_content>}</block></if></if_stmt>

    <comment type="line">// extract the label agtype value from the vertex or edge</comment>
    <expr_stmt><expr><name>label</name> <operator>=</operator> <call><name>GET_AGTYPE_VALUE_OBJECT_VALUE</name><argument_list>(<argument><expr><name>agtv_value</name></expr></argument>, <argument><expr><literal type="string">"label"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><call><name>agtype_value_to_agtype</name><argument_list>(<argument><expr><name>label</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>age_tostring</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><name>Datum</name></type> <name>age_tostring</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>nargs</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name> <modifier>*</modifier></type><name>args</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type> <name>arg</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name> <modifier>*</modifier></type><name>nulls</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name> <modifier>*</modifier></type><name>types</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_value</name></type> <name>agtv_result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>string</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type> <name>type</name></decl>;</decl_stmt>

    <comment type="block">/* extract argument values */</comment>
    <expr_stmt><expr><name>nargs</name> <operator>=</operator> <call><name>extract_variadic_args</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>args</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>types</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* check number of args */</comment>
    <if_stmt><if>if <condition>(<expr><name>nargs</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                        <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"toString() only supports one argument"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <comment type="block">/* check for null */</comment>
    <if_stmt><if>if <condition>(<expr><name>nargs</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>nulls</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * toString() supports integer, float, numeric, text, cstring, boolean or
     * the agtype integer, float, numeric, string, boolean input
     */</comment>
    <expr_stmt><expr><name>arg</name> <operator>=</operator> <name><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>type</name> <operator>=</operator> <name><name>types</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>type</name> <operator>!=</operator> <name>AGTYPEOID</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>INT2OID</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>string</name> <operator>=</operator> <call><name>DatumGetCString</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>int8out</name></expr></argument>,
                <argument><expr><call><name>Int64GetDatum</name><argument_list>(<argument><expr><operator>(</operator><name>int64</name><operator>)</operator> <call><name>DatumGetInt16</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><name>type</name> <operator>==</operator> <name>INT4OID</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>string</name> <operator>=</operator> <call><name>DatumGetCString</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>int8out</name></expr></argument>,
                <argument><expr><call><name>Int64GetDatum</name><argument_list>(<argument><expr><operator>(</operator><name>int64</name><operator>)</operator> <call><name>DatumGetInt32</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><name>type</name> <operator>==</operator> <name>INT8OID</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>string</name> <operator>=</operator> <call><name>DatumGetCString</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>int8out</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><name>type</name> <operator>==</operator> <name>FLOAT4OID</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>string</name> <operator>=</operator> <call><name>DatumGetCString</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>float8out</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><name>type</name> <operator>==</operator> <name>FLOAT8OID</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>string</name> <operator>=</operator> <call><name>DatumGetCString</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>float8out</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><name>type</name> <operator>==</operator> <name>NUMERICOID</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>string</name> <operator>=</operator> <call><name>DatumGetCString</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>numeric_out</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><name>type</name> <operator>==</operator> <name>CSTRINGOID</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>string</name> <operator>=</operator> <call><name>DatumGetCString</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><name>type</name> <operator>==</operator> <name>TEXTOID</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>string</name> <operator>=</operator> <call><name>text_to_cstring</name><argument_list>(<argument><expr><call><name>DatumGetTextPP</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><name>type</name> <operator>==</operator> <name>BOOLOID</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>string</name> <operator>=</operator> <ternary><condition><expr><call><name>DatumGetBool</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="string">"true"</literal></expr> </then><else>: <expr><literal type="string">"false"</literal></expr></else></ternary></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                            <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"toString() unsupported argument type %d"</literal></expr></argument>,
                                   <argument><expr><name>type</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <decl_stmt><decl><type><name>agtype</name> <modifier>*</modifier></type><name>agt_arg</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>agtv_value</name></decl>;</decl_stmt>

        <comment type="block">/* get the agtype argument */</comment>
        <expr_stmt><expr><name>agt_arg</name> <operator>=</operator> <call><name>DATUM_GET_AGTYPE_P</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AGT_ROOT_IS_SCALAR</name><argument_list>(<argument><expr><name>agt_arg</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                            <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"toString() only supports scalar arguments"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>agtv_value</name> <operator>=</operator> <call><name>get_ith_agtype_value_from_container</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>agt_arg</name><operator>-&gt;</operator><name>root</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>agtv_value</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AGTV_NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><name><name>agtv_value</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AGTV_INTEGER</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>string</name> <operator>=</operator> <call><name>DatumGetCString</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>int8out</name></expr></argument>,
                <argument><expr><call><name>Int64GetDatum</name><argument_list>(<argument><expr><name><name>agtv_value</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>int_value</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><name><name>agtv_value</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AGTV_FLOAT</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>string</name> <operator>=</operator> <call><name>DatumGetCString</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>float8out</name></expr></argument>,
                <argument><expr><call><name>Float8GetDatum</name><argument_list>(<argument><expr><name><name>agtv_value</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>float_value</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><name><name>agtv_value</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AGTV_STRING</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>string</name> <operator>=</operator> <call><name>pnstrdup</name><argument_list>(<argument><expr><name><name>agtv_value</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>val</name></name></expr></argument>,
                              <argument><expr><name><name>agtv_value</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><name><name>agtv_value</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AGTV_NUMERIC</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>string</name> <operator>=</operator> <call><name>DatumGetCString</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>numeric_out</name></expr></argument>,
                <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name><name>agtv_value</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>numeric</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><name><name>agtv_value</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AGTV_BOOL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>string</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>agtv_value</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>boolean</name></name><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">"true"</literal></expr> </then><else>: <expr><literal type="string">"false"</literal></expr></else></ternary></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                            <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"toString() unsupported argument agtype %d"</literal></expr></argument>,
                                   <argument><expr><name><name>agtv_value</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* build the result */</comment>
    <expr_stmt><expr><name><name>agtv_result</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>AGTV_STRING</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>agtv_result</name><operator>.</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>val</name></name> <operator>=</operator> <name>string</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>agtv_result</name><operator>.</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>len</name></name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><call><name>agtype_value_to_agtype</name><argument_list>(<argument><expr><operator>&amp;</operator><name>agtv_result</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>agtype_iterator</name> <modifier>*</modifier></type><name>get_next_list_element</name><parameter_list>(<parameter><decl><type><name>agtype_iterator</name> <modifier>*</modifier></type><name>it</name></decl></parameter>,
                           <parameter><decl><type><name>agtype_container</name> <modifier>*</modifier></type><name>agtc</name></decl></parameter>, <parameter><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>elem</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>agtype_iterator_token</name></type> <name>itok</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_value</name></type> <name>tmp</name></decl>;</decl_stmt>

    <comment type="block">/* verify input params */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>agtc</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>elem</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* check to see if the container is empty */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>AGTYPE_CONTAINER_SIZE</name><argument_list>(<argument><expr><name>agtc</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
       <return>return <expr><name>NULL</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* if the passed iterator is NULL, this is the first time, create it */</comment>
    <if_stmt><if>if <condition>(<expr><name>it</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* initial the iterator */</comment>
        <expr_stmt><expr><name>it</name> <operator>=</operator> <call><name>agtype_iterator_init</name><argument_list>(<argument><expr><name>agtc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* get the first token */</comment>
        <expr_stmt><expr><name>itok</name> <operator>=</operator> <call><name>agtype_iterator_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name>it</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmp</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* it should be WAGT_BEGIN_ARRAY */</comment>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>itok</name> <operator>==</operator> <name>WAGT_BEGIN_ARRAY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* the next token should be an element or the end of the array */</comment>
    <expr_stmt><expr><name>itok</name> <operator>=</operator> <call><name>agtype_iterator_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name>it</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmp</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>itok</name> <operator>==</operator> <name>WAGT_ELEM</name> <operator>||</operator> <name>WAGT_END_ARRAY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* if this is the end of the array return NULL */</comment>
    <if_stmt><if>if <condition>(<expr><name>itok</name> <operator>==</operator> <name>WAGT_END_ARRAY</name></expr>)</condition> <block>{<block_content>
        <return>return <expr><name>NULL</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* this should be the element, copy it */</comment>
    <if_stmt><if>if <condition>(<expr><name>itok</name> <operator>==</operator> <name>WAGT_ELEM</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>elem</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmp</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>agtype_value</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>it</name></expr>;</return>
</block_content>}</block></function>

<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>age_reverse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><name>Datum</name></type> <name>age_reverse</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>nargs</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name> <modifier>*</modifier></type><name>args</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type> <name>arg</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name> <modifier>*</modifier></type><name>nulls</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name> <modifier>*</modifier></type><name>types</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_value</name></type> <name>agtv_result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>text</name> <modifier>*</modifier></type><name>text_string</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>string</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>string_len</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type> <name>type</name></decl>;</decl_stmt>

    <comment type="block">/* extract argument values */</comment>
    <expr_stmt><expr><name>nargs</name> <operator>=</operator> <call><name>extract_variadic_args</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>args</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>types</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* check number of args */</comment>
    <if_stmt><if>if <condition>(<expr><name>nargs</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                        <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"reverse() only supports one argument"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* check for null */</comment>
    <if_stmt><if>if <condition>(<expr><name>nargs</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>nulls</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* reverse() supports text, cstring, or the agtype string input */</comment>
    <expr_stmt><expr><name>arg</name> <operator>=</operator> <name><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>type</name> <operator>=</operator> <name><name>types</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>type</name> <operator>!=</operator> <name>AGTYPEOID</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>CSTRINGOID</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>text_string</name> <operator>=</operator> <call><name>cstring_to_text</name><argument_list>(<argument><expr><call><name>DatumGetCString</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><name>type</name> <operator>==</operator> <name>TEXTOID</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>text_string</name> <operator>=</operator> <call><name>DatumGetTextPP</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                            <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"reverse() unsupported argument type %d"</literal></expr></argument>,
                                   <argument><expr><name>type</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <decl_stmt><decl><type><name>agtype</name> <modifier>*</modifier></type><name>agt_arg</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>agtv_value</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>agtype_parse_state</name> <modifier>*</modifier></type><name>parse_state</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>agtype_value</name></type> <name>elem</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>agtype_iterator</name> <modifier>*</modifier></type><name>it</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>agtype_value</name></type> <name>tmp</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>elems</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>num_elems</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

        <comment type="block">/* get the agtype argument */</comment>
        <expr_stmt><expr><name>agt_arg</name> <operator>=</operator> <call><name>DATUM_GET_AGTYPE_P</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AGT_ROOT_IS_SCALAR</name><argument_list>(<argument><expr><name>agt_arg</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>agtv_value</name> <operator>=</operator> <call><name>push_agtype_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name>parse_state</name></expr></argument>, <argument><expr><name>WAGT_BEGIN_ARRAY</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <while>while <condition>(<expr><operator>(</operator><name>it</name> <operator>=</operator> <call><name>get_next_list_element</name><argument_list>(<argument><expr><name>it</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>agt_arg</name><operator>-&gt;</operator><name>root</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>elem</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>agtv_value</name> <operator>=</operator> <call><name>push_agtype_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name>parse_state</name></expr></argument>, <argument><expr><name>WAGT_ELEM</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>elem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></while>

            <comment type="block">/* now reverse the list */</comment>
            <expr_stmt><expr><name>elems</name> <operator>=</operator> <name><name>parse_state</name><operator>-&gt;</operator><name>cont_val</name><operator>.</operator><name>val</name><operator>.</operator><name>array</name><operator>.</operator><name>elems</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>num_elems</name> <operator>=</operator> <name><name>parse_state</name><operator>-&gt;</operator><name>cont_val</name><operator>.</operator><name>val</name><operator>.</operator><name>array</name><operator>.</operator><name>num_elems</name></name></expr>;</expr_stmt>

            <for>for<control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_elems</name><operator>/</operator><literal type="number">2</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <expr_stmt><expr><name>tmp</name> <operator>=</operator> <name><name>elems</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>elems</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>elems</name><index>[<expr><name>num_elems</name> <operator>-</operator> <literal type="number">1</literal> <operator>-</operator> <name>i</name></expr>]</index></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>elems</name><index>[<expr><name>num_elems</name> <operator>-</operator> <literal type="number">1</literal> <operator>-</operator> <name>i</name></expr>]</index></name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>
            </block_content>}</block></for>
            <comment type="block">/* reverse done*/</comment>

            <expr_stmt><expr><name>elems</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

            <expr_stmt><expr><name>agtv_value</name> <operator>=</operator> <call><name>push_agtype_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name>parse_state</name></expr></argument>, <argument><expr><name>WAGT_END_ARRAY</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>agtv_value</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>agtv_value</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>AGTV_ARRAY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><call><name>agtype_value_to_agtype</name><argument_list>(<argument><expr><name>agtv_value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>agtv_value</name> <operator>=</operator> <call><name>get_ith_agtype_value_from_container</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>agt_arg</name><operator>-&gt;</operator><name>root</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* check for agtype null */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>agtv_value</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AGTV_NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>agtv_value</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AGTV_STRING</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>text_string</name> <operator>=</operator> <call><name>cstring_to_text_with_len</name><argument_list>(<argument><expr><name><name>agtv_value</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>val</name></name></expr></argument>,
                                                   <argument><expr><name><name>agtv_value</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                            <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"reverse() unsupported argument agtype %d"</literal></expr></argument>,
                                   <argument><expr><name><name>agtv_value</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/*
     * We need the string as a text string so that we can let PG deal with
     * multibyte characters in reversing the string.
     */</comment>
    <expr_stmt><expr><name>text_string</name> <operator>=</operator> <call><name>DatumGetTextPP</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>text_reverse</name></expr></argument>,
                                                     <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>text_string</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* convert it back to a cstring */</comment>
    <expr_stmt><expr><name>string</name> <operator>=</operator> <call><name>text_to_cstring</name><argument_list>(<argument><expr><name>text_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>string_len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* if we have an empty string, return null */</comment>
    <if_stmt><if>if <condition>(<expr><name>string_len</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* build the result */</comment>
    <expr_stmt><expr><name><name>agtv_result</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>AGTV_STRING</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>agtv_result</name><operator>.</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>val</name></name> <operator>=</operator> <name>string</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>agtv_result</name><operator>.</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>len</name></name> <operator>=</operator> <name>string_len</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><call><name>agtype_value_to_agtype</name><argument_list>(<argument><expr><operator>&amp;</operator><name>agtv_result</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>age_toupper</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><name>Datum</name></type> <name>age_toupper</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>nargs</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name> <modifier>*</modifier></type><name>args</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type> <name>arg</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name> <modifier>*</modifier></type><name>nulls</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name> <modifier>*</modifier></type><name>types</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_value</name></type> <name>agtv_result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>string</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>string_len</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type> <name>type</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

    <comment type="block">/* extract argument values */</comment>
    <expr_stmt><expr><name>nargs</name> <operator>=</operator> <call><name>extract_variadic_args</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>args</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>types</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* check number of args */</comment>
    <if_stmt><if>if <condition>(<expr><name>nargs</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                        <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"toUpper() only supports one argument"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* check for null */</comment>
    <if_stmt><if>if <condition>(<expr><name>nargs</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>nulls</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* toUpper() supports text, cstring, or the agtype string input */</comment>
    <expr_stmt><expr><name>arg</name> <operator>=</operator> <name><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>type</name> <operator>=</operator> <name><name>types</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>type</name> <operator>!=</operator> <name>AGTYPEOID</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>CSTRINGOID</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>string</name> <operator>=</operator> <call><name>DatumGetCString</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><name>type</name> <operator>==</operator> <name>TEXTOID</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>string</name> <operator>=</operator> <call><name>text_to_cstring</name><argument_list>(<argument><expr><call><name>DatumGetTextPP</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                            <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"toUpper() unsupported argument type %d"</literal></expr></argument>,
                                   <argument><expr><name>type</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        <expr_stmt><expr><name>string_len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <decl_stmt><decl><type><name>agtype</name> <modifier>*</modifier></type><name>agt_arg</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>agtv_value</name></decl>;</decl_stmt>

        <comment type="block">/* get the agtype argument */</comment>
        <expr_stmt><expr><name>agt_arg</name> <operator>=</operator> <call><name>DATUM_GET_AGTYPE_P</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AGT_ROOT_IS_SCALAR</name><argument_list>(<argument><expr><name>agt_arg</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                            <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"toUpper() only supports scalar arguments"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>agtv_value</name> <operator>=</operator> <call><name>get_ith_agtype_value_from_container</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>agt_arg</name><operator>-&gt;</operator><name>root</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* check for agtype null */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>agtv_value</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AGTV_NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>agtv_value</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AGTV_STRING</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>string</name> <operator>=</operator> <name><name>agtv_value</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>val</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>string_len</name> <operator>=</operator> <name><name>agtv_value</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>len</name></name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                            <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"toUpper() unsupported argument agtype %d"</literal></expr></argument>,
                                   <argument><expr><name><name>agtv_value</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* if we have an empty string, return null */</comment>
    <if_stmt><if>if <condition>(<expr><name>string_len</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* allocate the new string */</comment>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>string_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* upcase the string */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>string_len</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>result</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>pg_toupper</name><argument_list>(<argument><expr><name><name>string</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

    <comment type="block">/* build the result */</comment>
    <expr_stmt><expr><name><name>agtv_result</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>AGTV_STRING</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>agtv_result</name><operator>.</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>val</name></name> <operator>=</operator> <name>result</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>agtv_result</name><operator>.</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>len</name></name> <operator>=</operator> <name>string_len</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><call><name>agtype_value_to_agtype</name><argument_list>(<argument><expr><operator>&amp;</operator><name>agtv_result</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>age_tolower</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><name>Datum</name></type> <name>age_tolower</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>nargs</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name> <modifier>*</modifier></type><name>args</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type> <name>arg</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name> <modifier>*</modifier></type><name>nulls</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name> <modifier>*</modifier></type><name>types</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_value</name></type> <name>agtv_result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>string</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>string_len</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type> <name>type</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

    <comment type="block">/* extract argument values */</comment>
    <expr_stmt><expr><name>nargs</name> <operator>=</operator> <call><name>extract_variadic_args</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>args</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>types</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* check number of args */</comment>
    <if_stmt><if>if <condition>(<expr><name>nargs</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                        <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"toLower() only supports one argument"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* check for null */</comment>
    <if_stmt><if>if <condition>(<expr><name>nargs</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>nulls</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* toLower() supports text, cstring, or the agtype string input */</comment>
    <expr_stmt><expr><name>arg</name> <operator>=</operator> <name><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>type</name> <operator>=</operator> <name><name>types</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>type</name> <operator>!=</operator> <name>AGTYPEOID</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>CSTRINGOID</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>string</name> <operator>=</operator> <call><name>DatumGetCString</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><name>type</name> <operator>==</operator> <name>TEXTOID</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>string</name> <operator>=</operator> <call><name>text_to_cstring</name><argument_list>(<argument><expr><call><name>DatumGetTextPP</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                            <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"toLower() unsupported argument type %d"</literal></expr></argument>,
                                   <argument><expr><name>type</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        <expr_stmt><expr><name>string_len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <decl_stmt><decl><type><name>agtype</name> <modifier>*</modifier></type><name>agt_arg</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>agtv_value</name></decl>;</decl_stmt>

        <comment type="block">/* get the agtype argument */</comment>
        <expr_stmt><expr><name>agt_arg</name> <operator>=</operator> <call><name>DATUM_GET_AGTYPE_P</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AGT_ROOT_IS_SCALAR</name><argument_list>(<argument><expr><name>agt_arg</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                            <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"toLower() only supports scalar arguments"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>agtv_value</name> <operator>=</operator> <call><name>get_ith_agtype_value_from_container</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>agt_arg</name><operator>-&gt;</operator><name>root</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* check for agtype null */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>agtv_value</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AGTV_NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>agtv_value</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AGTV_STRING</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>string</name> <operator>=</operator> <name><name>agtv_value</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>val</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>string_len</name> <operator>=</operator> <name><name>agtv_value</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>len</name></name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                            <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"toLower() unsupported argument agtype %d"</literal></expr></argument>,
                                   <argument><expr><name><name>agtv_value</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* if we have an empty string, return null */</comment>
    <if_stmt><if>if <condition>(<expr><name>string_len</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* allocate the new string */</comment>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>string_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* downcase the string */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>string_len</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>result</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>pg_tolower</name><argument_list>(<argument><expr><name><name>string</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

    <comment type="block">/* build the result */</comment>
    <expr_stmt><expr><name><name>agtv_result</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>AGTV_STRING</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>agtv_result</name><operator>.</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>val</name></name> <operator>=</operator> <name>result</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>agtv_result</name><operator>.</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>len</name></name> <operator>=</operator> <name>string_len</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><call><name>agtype_value_to_agtype</name><argument_list>(<argument><expr><operator>&amp;</operator><name>agtv_result</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>age_rtrim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><name>Datum</name></type> <name>age_rtrim</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>nargs</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name> <modifier>*</modifier></type><name>args</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type> <name>arg</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name> <modifier>*</modifier></type><name>nulls</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name> <modifier>*</modifier></type><name>types</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_value</name></type> <name>agtv_result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>text</name> <modifier>*</modifier></type><name>text_string</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>string</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>string_len</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type> <name>type</name></decl>;</decl_stmt>

    <comment type="block">/* extract argument values */</comment>
    <expr_stmt><expr><name>nargs</name> <operator>=</operator> <call><name>extract_variadic_args</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>args</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>types</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* check number of args */</comment>
    <if_stmt><if>if <condition>(<expr><name>nargs</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                        <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"rTrim() only supports one argument"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* check for null */</comment>
    <if_stmt><if>if <condition>(<expr><name>nargs</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>nulls</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* rTrim() supports text, cstring, or the agtype string input */</comment>
    <expr_stmt><expr><name>arg</name> <operator>=</operator> <name><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>type</name> <operator>=</operator> <name><name>types</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>type</name> <operator>!=</operator> <name>AGTYPEOID</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>CSTRINGOID</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>text_string</name> <operator>=</operator> <call><name>cstring_to_text</name><argument_list>(<argument><expr><call><name>DatumGetCString</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><name>type</name> <operator>==</operator> <name>TEXTOID</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>text_string</name> <operator>=</operator> <call><name>DatumGetTextPP</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                            <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"rTrim() unsupported argument type %d"</literal></expr></argument>,
                                   <argument><expr><name>type</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <decl_stmt><decl><type><name>agtype</name> <modifier>*</modifier></type><name>agt_arg</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>agtv_value</name></decl>;</decl_stmt>

        <comment type="block">/* get the agtype argument */</comment>
        <expr_stmt><expr><name>agt_arg</name> <operator>=</operator> <call><name>DATUM_GET_AGTYPE_P</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AGT_ROOT_IS_SCALAR</name><argument_list>(<argument><expr><name>agt_arg</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                            <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"rTrim() only supports scalar arguments"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>agtv_value</name> <operator>=</operator> <call><name>get_ith_agtype_value_from_container</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>agt_arg</name><operator>-&gt;</operator><name>root</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* check for agtype null */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>agtv_value</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AGTV_NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>agtv_value</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AGTV_STRING</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>text_string</name> <operator>=</operator> <call><name>cstring_to_text_with_len</name><argument_list>(<argument><expr><name><name>agtv_value</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>val</name></name></expr></argument>,
                                                   <argument><expr><name><name>agtv_value</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                            <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"rTrim() unsupported argument agtype %d"</literal></expr></argument>,
                                   <argument><expr><name><name>agtv_value</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/*
     * We need the string as a text string so that we can let PG deal with
     * multibyte characters in trimming the string.
     */</comment>
    <expr_stmt><expr><name>text_string</name> <operator>=</operator> <call><name>DatumGetTextPP</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>rtrim1</name></expr></argument>,
                                                     <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>text_string</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* convert it back to a cstring */</comment>
    <expr_stmt><expr><name>string</name> <operator>=</operator> <call><name>text_to_cstring</name><argument_list>(<argument><expr><name>text_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>string_len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* if we have an empty string, return null */</comment>
    <if_stmt><if>if <condition>(<expr><name>string_len</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* build the result */</comment>
    <expr_stmt><expr><name><name>agtv_result</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>AGTV_STRING</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>agtv_result</name><operator>.</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>val</name></name> <operator>=</operator> <name>string</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>agtv_result</name><operator>.</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>len</name></name> <operator>=</operator> <name>string_len</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><call><name>agtype_value_to_agtype</name><argument_list>(<argument><expr><operator>&amp;</operator><name>agtv_result</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>age_ltrim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><name>Datum</name></type> <name>age_ltrim</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>nargs</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name> <modifier>*</modifier></type><name>args</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type> <name>arg</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name> <modifier>*</modifier></type><name>nulls</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name> <modifier>*</modifier></type><name>types</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_value</name></type> <name>agtv_result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>text</name> <modifier>*</modifier></type><name>text_string</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>string</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>string_len</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type> <name>type</name></decl>;</decl_stmt>

    <comment type="block">/* extract argument values */</comment>
    <expr_stmt><expr><name>nargs</name> <operator>=</operator> <call><name>extract_variadic_args</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>args</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>types</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* check number of args */</comment>
    <if_stmt><if>if <condition>(<expr><name>nargs</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                        <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"lTrim() only supports one argument"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* check for null */</comment>
    <if_stmt><if>if <condition>(<expr><name>nargs</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>nulls</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* rTrim() supports text, cstring, or the agtype string input */</comment>
    <expr_stmt><expr><name>arg</name> <operator>=</operator> <name><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>type</name> <operator>=</operator> <name><name>types</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>type</name> <operator>!=</operator> <name>AGTYPEOID</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>CSTRINGOID</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>text_string</name> <operator>=</operator> <call><name>cstring_to_text</name><argument_list>(<argument><expr><call><name>DatumGetCString</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><name>type</name> <operator>==</operator> <name>TEXTOID</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>text_string</name> <operator>=</operator> <call><name>DatumGetTextPP</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                            <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"lTrim() unsupported argument type %d"</literal></expr></argument>,
                                   <argument><expr><name>type</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <decl_stmt><decl><type><name>agtype</name> <modifier>*</modifier></type><name>agt_arg</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>agtv_value</name></decl>;</decl_stmt>

        <comment type="block">/* get the agtype argument */</comment>
        <expr_stmt><expr><name>agt_arg</name> <operator>=</operator> <call><name>DATUM_GET_AGTYPE_P</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AGT_ROOT_IS_SCALAR</name><argument_list>(<argument><expr><name>agt_arg</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                            <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"lTrim() only supports scalar arguments"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>agtv_value</name> <operator>=</operator> <call><name>get_ith_agtype_value_from_container</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>agt_arg</name><operator>-&gt;</operator><name>root</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* check for agtype null */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>agtv_value</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AGTV_NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>agtv_value</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AGTV_STRING</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>text_string</name> <operator>=</operator> <call><name>cstring_to_text_with_len</name><argument_list>(<argument><expr><name><name>agtv_value</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>val</name></name></expr></argument>,
                                                   <argument><expr><name><name>agtv_value</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                            <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"lTrim() unsupported argument agtype %d"</literal></expr></argument>,
                                   <argument><expr><name><name>agtv_value</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/*
     * We need the string as a text string so that we can let PG deal with
     * multibyte characters in trimming the string.
     */</comment>
    <expr_stmt><expr><name>text_string</name> <operator>=</operator> <call><name>DatumGetTextPP</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>ltrim1</name></expr></argument>,
                                                     <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>text_string</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* convert it back to a cstring */</comment>
    <expr_stmt><expr><name>string</name> <operator>=</operator> <call><name>text_to_cstring</name><argument_list>(<argument><expr><name>text_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>string_len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* if we have an empty string, return null */</comment>
    <if_stmt><if>if <condition>(<expr><name>string_len</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* build the result */</comment>
    <expr_stmt><expr><name><name>agtv_result</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>AGTV_STRING</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>agtv_result</name><operator>.</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>val</name></name> <operator>=</operator> <name>string</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>agtv_result</name><operator>.</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>len</name></name> <operator>=</operator> <name>string_len</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><call><name>agtype_value_to_agtype</name><argument_list>(<argument><expr><operator>&amp;</operator><name>agtv_result</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>age_trim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><name>Datum</name></type> <name>age_trim</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>nargs</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name> <modifier>*</modifier></type><name>args</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type> <name>arg</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name> <modifier>*</modifier></type><name>nulls</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name> <modifier>*</modifier></type><name>types</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_value</name></type> <name>agtv_result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>text</name> <modifier>*</modifier></type><name>text_string</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>string</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>string_len</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type> <name>type</name></decl>;</decl_stmt>

    <comment type="block">/* extract argument values */</comment>
    <expr_stmt><expr><name>nargs</name> <operator>=</operator> <call><name>extract_variadic_args</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>args</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>types</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* check number of args */</comment>
    <if_stmt><if>if <condition>(<expr><name>nargs</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                        <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"trim() only supports one argument"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* check for null */</comment>
    <if_stmt><if>if <condition>(<expr><name>nargs</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>nulls</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* trim() supports text, cstring, or the agtype string input */</comment>
    <expr_stmt><expr><name>arg</name> <operator>=</operator> <name><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>type</name> <operator>=</operator> <name><name>types</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>type</name> <operator>!=</operator> <name>AGTYPEOID</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>CSTRINGOID</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>text_string</name> <operator>=</operator> <call><name>cstring_to_text</name><argument_list>(<argument><expr><call><name>DatumGetCString</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><name>type</name> <operator>==</operator> <name>TEXTOID</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>text_string</name> <operator>=</operator> <call><name>DatumGetTextPP</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                            <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"trim() unsupported argument type %d"</literal></expr></argument>,
                                   <argument><expr><name>type</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <decl_stmt><decl><type><name>agtype</name> <modifier>*</modifier></type><name>agt_arg</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>agtv_value</name></decl>;</decl_stmt>

        <comment type="block">/* get the agtype argument */</comment>
        <expr_stmt><expr><name>agt_arg</name> <operator>=</operator> <call><name>DATUM_GET_AGTYPE_P</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AGT_ROOT_IS_SCALAR</name><argument_list>(<argument><expr><name>agt_arg</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                            <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"trim() only supports scalar arguments"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>agtv_value</name> <operator>=</operator> <call><name>get_ith_agtype_value_from_container</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>agt_arg</name><operator>-&gt;</operator><name>root</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* check for agtype null */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>agtv_value</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AGTV_NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>agtv_value</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AGTV_STRING</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>text_string</name> <operator>=</operator> <call><name>cstring_to_text_with_len</name><argument_list>(<argument><expr><name><name>agtv_value</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>val</name></name></expr></argument>,
                                                   <argument><expr><name><name>agtv_value</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                            <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"trim() unsupported argument agtype %d"</literal></expr></argument>,
                                   <argument><expr><name><name>agtv_value</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/*
     * We need the string as a text string so that we can let PG deal with
     * multibyte characters in trimming the string.
     */</comment>
    <expr_stmt><expr><name>text_string</name> <operator>=</operator> <call><name>DatumGetTextPP</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>btrim1</name></expr></argument>,
                                                     <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>text_string</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* convert it back to a cstring */</comment>
    <expr_stmt><expr><name>string</name> <operator>=</operator> <call><name>text_to_cstring</name><argument_list>(<argument><expr><name>text_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>string_len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* if we have an empty string, return null */</comment>
    <if_stmt><if>if <condition>(<expr><name>string_len</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* build the result */</comment>
    <expr_stmt><expr><name><name>agtv_result</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>AGTV_STRING</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>agtv_result</name><operator>.</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>val</name></name> <operator>=</operator> <name>string</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>agtv_result</name><operator>.</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>len</name></name> <operator>=</operator> <name>string_len</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><call><name>agtype_value_to_agtype</name><argument_list>(<argument><expr><operator>&amp;</operator><name>agtv_result</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>age_right</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><name>Datum</name></type> <name>age_right</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>nargs</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name> <modifier>*</modifier></type><name>args</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type> <name>arg</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name> <modifier>*</modifier></type><name>nulls</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name> <modifier>*</modifier></type><name>types</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_value</name></type> <name>agtv_result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>text</name> <modifier>*</modifier></type><name>text_string</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>string</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>string_len</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type> <name>type</name></decl>;</decl_stmt>

    <comment type="block">/* extract argument values */</comment>
    <expr_stmt><expr><name>nargs</name> <operator>=</operator> <call><name>extract_variadic_args</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>args</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>types</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* check number of args */</comment>
    <if_stmt><if>if <condition>(<expr><name>nargs</name> <operator>!=</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                        <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"right() invalid number of arguments"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* check for a null string */</comment>
    <if_stmt><if>if <condition>(<expr><name>nargs</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>nulls</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* check for a null length */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>nulls</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                            <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"right() length parameter cannot be null"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* right() supports text, cstring, or the agtype string input */</comment>
    <expr_stmt><expr><name>arg</name> <operator>=</operator> <name><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>type</name> <operator>=</operator> <name><name>types</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>type</name> <operator>!=</operator> <name>AGTYPEOID</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>CSTRINGOID</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>text_string</name> <operator>=</operator> <call><name>cstring_to_text</name><argument_list>(<argument><expr><call><name>DatumGetCString</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><name>type</name> <operator>==</operator> <name>TEXTOID</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>text_string</name> <operator>=</operator> <call><name>DatumGetTextPP</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                            <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"right() unsupported argument type %d"</literal></expr></argument>,
                                   <argument><expr><name>type</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <decl_stmt><decl><type><name>agtype</name> <modifier>*</modifier></type><name>agt_arg</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>agtv_value</name></decl>;</decl_stmt>

        <comment type="block">/* get the agtype argument */</comment>
        <expr_stmt><expr><name>agt_arg</name> <operator>=</operator> <call><name>DATUM_GET_AGTYPE_P</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AGT_ROOT_IS_SCALAR</name><argument_list>(<argument><expr><name>agt_arg</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                            <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"right() only supports scalar arguments"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>agtv_value</name> <operator>=</operator> <call><name>get_ith_agtype_value_from_container</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>agt_arg</name><operator>-&gt;</operator><name>root</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* check for agtype null */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>agtv_value</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AGTV_NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>agtv_value</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AGTV_STRING</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>text_string</name> <operator>=</operator> <call><name>cstring_to_text_with_len</name><argument_list>(<argument><expr><name><name>agtv_value</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>val</name></name></expr></argument>,
                                                   <argument><expr><name><name>agtv_value</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                            <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"right() unsupported argument agtype %d"</literal></expr></argument>,
                                   <argument><expr><name><name>agtv_value</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* right() only supports integer and agtype integer for the second parameter. */</comment>
    <expr_stmt><expr><name>arg</name> <operator>=</operator> <name><name>args</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>type</name> <operator>=</operator> <name><name>types</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>type</name> <operator>!=</operator> <name>AGTYPEOID</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>INT2OID</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>string_len</name> <operator>=</operator> <operator>(</operator><name>int64</name><operator>)</operator> <call><name>DatumGetInt16</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><name>type</name> <operator>==</operator> <name>INT4OID</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>string_len</name> <operator>=</operator> <operator>(</operator><name>int64</name><operator>)</operator> <call><name>DatumGetInt32</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><name>type</name> <operator>==</operator> <name>INT8OID</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>string_len</name> <operator>=</operator> <operator>(</operator><name>int64</name><operator>)</operator> <call><name>DatumGetInt64</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                            <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"right() unsupported argument type %d"</literal></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <decl_stmt><decl><type><name>agtype</name> <modifier>*</modifier></type><name>agt_arg</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>agtv_value</name></decl>;</decl_stmt>

        <comment type="block">/* get the agtype argument */</comment>
        <expr_stmt><expr><name>agt_arg</name> <operator>=</operator> <call><name>DATUM_GET_AGTYPE_P</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AGT_ROOT_IS_SCALAR</name><argument_list>(<argument><expr><name>agt_arg</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                            <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"right() only supports scalar arguments"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>agtv_value</name> <operator>=</operator> <call><name>get_ith_agtype_value_from_container</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>agt_arg</name><operator>-&gt;</operator><name>root</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* no need to check for agtype null because it is an error if found */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>agtv_value</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>AGTV_INTEGER</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                            <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"right() unsupported argument agtype %d"</literal></expr></argument>,
                                   <argument><expr><name><name>agtv_value</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>string_len</name> <operator>=</operator> <name><name>agtv_value</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>int_value</name></name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* negative values are not supported in the opencypher spec */</comment>
    <if_stmt><if>if <condition>(<expr><name>string_len</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                        <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"right() negative values are not supported for length"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * We need the string as a text string so that we can let PG deal with
     * multibyte characters in the string.
     */</comment>
    <expr_stmt><expr><name>text_string</name> <operator>=</operator> <call><name>DatumGetTextPP</name><argument_list>(<argument><expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>text_right</name></expr></argument>,
                                                     <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>text_string</name></expr></argument>)</argument_list></call></expr></argument>,
                                                     <argument><expr><call><name>Int64GetDatum</name><argument_list>(<argument><expr><name>string_len</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* convert it back to a cstring */</comment>
    <expr_stmt><expr><name>string</name> <operator>=</operator> <call><name>text_to_cstring</name><argument_list>(<argument><expr><name>text_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>string_len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* if we have an empty string, return null */</comment>
    <if_stmt><if>if <condition>(<expr><name>string_len</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* build the result */</comment>
    <expr_stmt><expr><name><name>agtv_result</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>AGTV_STRING</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>agtv_result</name><operator>.</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>val</name></name> <operator>=</operator> <name>string</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>agtv_result</name><operator>.</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>len</name></name> <operator>=</operator> <name>string_len</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><call><name>agtype_value_to_agtype</name><argument_list>(<argument><expr><operator>&amp;</operator><name>agtv_result</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>age_left</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><name>Datum</name></type> <name>age_left</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>nargs</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name> <modifier>*</modifier></type><name>args</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type> <name>arg</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name> <modifier>*</modifier></type><name>nulls</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name> <modifier>*</modifier></type><name>types</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_value</name></type> <name>agtv_result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>text</name> <modifier>*</modifier></type><name>text_string</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>string</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>string_len</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type> <name>type</name></decl>;</decl_stmt>

    <comment type="block">/* extract argument values */</comment>
    <expr_stmt><expr><name>nargs</name> <operator>=</operator> <call><name>extract_variadic_args</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>args</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>types</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* check number of args */</comment>
    <if_stmt><if>if <condition>(<expr><name>nargs</name> <operator>!=</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                        <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"left() invalid number of arguments"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* check for a null string */</comment>
    <if_stmt><if>if <condition>(<expr><name>nargs</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>nulls</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* check for a null length */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>nulls</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                            <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"left() length parameter cannot be null"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* left() supports text, cstring, or the agtype string input */</comment>
    <expr_stmt><expr><name>arg</name> <operator>=</operator> <name><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>type</name> <operator>=</operator> <name><name>types</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>type</name> <operator>!=</operator> <name>AGTYPEOID</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>CSTRINGOID</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>text_string</name> <operator>=</operator> <call><name>cstring_to_text</name><argument_list>(<argument><expr><call><name>DatumGetCString</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><name>type</name> <operator>==</operator> <name>TEXTOID</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>text_string</name> <operator>=</operator> <call><name>DatumGetTextPP</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                            <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"left() unsupported argument type %d"</literal></expr></argument>,
                                   <argument><expr><name>type</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <decl_stmt><decl><type><name>agtype</name> <modifier>*</modifier></type><name>agt_arg</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>agtv_value</name></decl>;</decl_stmt>

        <comment type="block">/* get the agtype argument */</comment>
        <expr_stmt><expr><name>agt_arg</name> <operator>=</operator> <call><name>DATUM_GET_AGTYPE_P</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AGT_ROOT_IS_SCALAR</name><argument_list>(<argument><expr><name>agt_arg</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                            <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"left() only supports scalar arguments"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>agtv_value</name> <operator>=</operator> <call><name>get_ith_agtype_value_from_container</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>agt_arg</name><operator>-&gt;</operator><name>root</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* check for agtype null */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>agtv_value</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AGTV_NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>agtv_value</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AGTV_STRING</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>text_string</name> <operator>=</operator> <call><name>cstring_to_text_with_len</name><argument_list>(<argument><expr><name><name>agtv_value</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>val</name></name></expr></argument>,
                                                   <argument><expr><name><name>agtv_value</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                            <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"left() unsupported argument agtype %d"</literal></expr></argument>,
                                   <argument><expr><name><name>agtv_value</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* left() only supports integer and agtype integer for the second parameter. */</comment>
    <expr_stmt><expr><name>arg</name> <operator>=</operator> <name><name>args</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>type</name> <operator>=</operator> <name><name>types</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>type</name> <operator>!=</operator> <name>AGTYPEOID</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>INT2OID</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>string_len</name> <operator>=</operator> <operator>(</operator><name>int64</name><operator>)</operator> <call><name>DatumGetInt16</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><name>type</name> <operator>==</operator> <name>INT4OID</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>string_len</name> <operator>=</operator> <operator>(</operator><name>int64</name><operator>)</operator> <call><name>DatumGetInt32</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><name>type</name> <operator>==</operator> <name>INT8OID</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>string_len</name> <operator>=</operator> <operator>(</operator><name>int64</name><operator>)</operator> <call><name>DatumGetInt64</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                            <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"left() unsupported argument type %d"</literal></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <decl_stmt><decl><type><name>agtype</name> <modifier>*</modifier></type><name>agt_arg</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>agtv_value</name></decl>;</decl_stmt>

        <comment type="block">/* get the agtype argument */</comment>
        <expr_stmt><expr><name>agt_arg</name> <operator>=</operator> <call><name>DATUM_GET_AGTYPE_P</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AGT_ROOT_IS_SCALAR</name><argument_list>(<argument><expr><name>agt_arg</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                            <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"left() only supports scalar arguments"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>agtv_value</name> <operator>=</operator> <call><name>get_ith_agtype_value_from_container</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>agt_arg</name><operator>-&gt;</operator><name>root</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* no need to check for agtype null because it is an error if found */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>agtv_value</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>AGTV_INTEGER</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                            <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"left() unsupported argument agtype %d"</literal></expr></argument>,
                                   <argument><expr><name><name>agtv_value</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>string_len</name> <operator>=</operator> <name><name>agtv_value</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>int_value</name></name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* negative values are not supported in the opencypher spec */</comment>
    <if_stmt><if>if <condition>(<expr><name>string_len</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                        <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"left() negative values are not supported for length"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * We need the string as a text string so that we can let PG deal with
     * multibyte characters in the string.
     */</comment>
    <expr_stmt><expr><name>text_string</name> <operator>=</operator> <call><name>DatumGetTextPP</name><argument_list>(<argument><expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>text_left</name></expr></argument>,
                                                     <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>text_string</name></expr></argument>)</argument_list></call></expr></argument>,
                                                     <argument><expr><call><name>Int64GetDatum</name><argument_list>(<argument><expr><name>string_len</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* convert it back to a cstring */</comment>
    <expr_stmt><expr><name>string</name> <operator>=</operator> <call><name>text_to_cstring</name><argument_list>(<argument><expr><name>text_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>string_len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* if we have an empty string, return null */</comment>
    <if_stmt><if>if <condition>(<expr><name>string_len</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* build the result */</comment>
    <expr_stmt><expr><name><name>agtv_result</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>AGTV_STRING</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>agtv_result</name><operator>.</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>val</name></name> <operator>=</operator> <name>string</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>agtv_result</name><operator>.</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>len</name></name> <operator>=</operator> <name>string_len</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><call><name>agtype_value_to_agtype</name><argument_list>(<argument><expr><operator>&amp;</operator><name>agtv_result</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>age_substring</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><name>Datum</name></type> <name>age_substring</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>nargs</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name> <modifier>*</modifier></type><name>args</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type> <name>arg</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name> <modifier>*</modifier></type><name>nulls</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name> <modifier>*</modifier></type><name>types</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_value</name></type> <name>agtv_result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>text</name> <modifier>*</modifier></type><name>text_string</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>string</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>param</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>string_start</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>string_len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type> <name>type</name></decl>;</decl_stmt>

    <comment type="block">/* extract argument values */</comment>
    <expr_stmt><expr><name>nargs</name> <operator>=</operator> <call><name>extract_variadic_args</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>args</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>types</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* check number of args */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>nargs</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">2</literal> <operator>||</operator> <name>nargs</name></expr></argument> &gt;</argument_list></name> <literal type="number">3</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                        <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"substring() invalid number of arguments"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* check for null */</comment>
    <if_stmt><if>if <condition>(<expr><name>nargs</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>nulls</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* neither offset or length can be null if there is a valid string */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>nargs</name> <operator>==</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <name><name>nulls</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>)</operator> <operator>||</operator>
        <operator>(</operator><name>nargs</name> <operator>==</operator> <literal type="number">3</literal> <operator>&amp;&amp;</operator> <name><name>nulls</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                            <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"substring() offset or length cannot be null"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* substring() supports text, cstring, or the agtype string input */</comment>
    <expr_stmt><expr><name>arg</name> <operator>=</operator> <name><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>type</name> <operator>=</operator> <name><name>types</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>type</name> <operator>!=</operator> <name>AGTYPEOID</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>CSTRINGOID</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>text_string</name> <operator>=</operator> <call><name>cstring_to_text</name><argument_list>(<argument><expr><call><name>DatumGetCString</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><name>type</name> <operator>==</operator> <name>TEXTOID</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>text_string</name> <operator>=</operator> <call><name>DatumGetTextPP</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                            <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"substring() unsupported argument type %d"</literal></expr></argument>,
                                   <argument><expr><name>type</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <decl_stmt><decl><type><name>agtype</name> <modifier>*</modifier></type><name>agt_arg</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>agtv_value</name></decl>;</decl_stmt>

        <comment type="block">/* get the agtype argument */</comment>
        <expr_stmt><expr><name>agt_arg</name> <operator>=</operator> <call><name>DATUM_GET_AGTYPE_P</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AGT_ROOT_IS_SCALAR</name><argument_list>(<argument><expr><name>agt_arg</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                            <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"substring() only supports scalar arguments"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>agtv_value</name> <operator>=</operator> <call><name>get_ith_agtype_value_from_container</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>agt_arg</name><operator>-&gt;</operator><name>root</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* check for agtype null */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>agtv_value</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AGTV_NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>agtv_value</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AGTV_STRING</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>text_string</name> <operator>=</operator> <call><name>cstring_to_text_with_len</name><argument_list>(<argument><expr><name><name>agtv_value</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>val</name></name></expr></argument>,
                                                   <argument><expr><name><name>agtv_value</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                            <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"substring() unsupported argument agtype %d"</literal></expr></argument>,
                                   <argument><expr><name><name>agtv_value</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/*
     * substring() only supports integer and agtype integer for the second and
     * third parameters values.
     */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nargs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name>arg</name> <operator>=</operator> <name><name>args</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>type</name> <operator>=</operator> <name><name>types</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>type</name> <operator>!=</operator> <name>AGTYPEOID</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>INT2OID</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>param</name> <operator>=</operator> <operator>(</operator><name>int64</name><operator>)</operator> <call><name>DatumGetInt16</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <if type="elseif">else if <condition>(<expr><name>type</name> <operator>==</operator> <name>INT4OID</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>param</name> <operator>=</operator> <operator>(</operator><name>int64</name><operator>)</operator> <call><name>DatumGetInt32</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <if type="elseif">else if <condition>(<expr><name>type</name> <operator>==</operator> <name>INT8OID</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>param</name> <operator>=</operator> <operator>(</operator><name>int64</name><operator>)</operator> <call><name>DatumGetInt64</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                                <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"substring() unsupported argument type %d"</literal></expr></argument>,
                                       <argument><expr><name>type</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <decl_stmt><decl><type><name>agtype</name> <modifier>*</modifier></type><name>agt_arg</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>agtv_value</name></decl>;</decl_stmt>

            <comment type="block">/* get the agtype argument */</comment>
            <expr_stmt><expr><name>agt_arg</name> <operator>=</operator> <call><name>DATUM_GET_AGTYPE_P</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AGT_ROOT_IS_SCALAR</name><argument_list>(<argument><expr><name>agt_arg</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                                <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"substring() only supports scalar arguments"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <expr_stmt><expr><name>agtv_value</name> <operator>=</operator> <call><name>get_ith_agtype_value_from_container</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>agt_arg</name><operator>-&gt;</operator><name>root</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* no need to check for agtype null because it is an error if found */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>agtv_value</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>AGTV_INTEGER</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                                <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"substring() unsupported argument agtype %d"</literal></expr></argument>,
                                       <argument><expr><name><name>agtv_value</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <expr_stmt><expr><name>param</name> <operator>=</operator> <name><name>agtv_value</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>int_value</name></name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>string_start</name> <operator>=</operator> <name>param</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>string_len</name> <operator>=</operator> <name>param</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/* negative values are not supported in the opencypher spec */</comment>
    <if_stmt><if>if <condition>(<expr><name>string_start</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>string_len</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                        <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"substring() negative values are not supported for offset or length"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* cypher substring is 0 based while PG's is 1 based */</comment>
    <expr_stmt><expr><name>string_start</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

    <comment type="block">/*
     * We need the string as a text string so that we can let PG deal with
     * multibyte characters in the string.
     */</comment>

    <comment type="block">/* if optional length is left out */</comment>
    <if_stmt><if>if <condition>(<expr><name>nargs</name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
         <expr_stmt><expr><name>text_string</name> <operator>=</operator> <call><name>DatumGetTextPP</name><argument_list>(<argument><expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>text_substr_no_len</name></expr></argument>,
                                                          <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>text_string</name></expr></argument>)</argument_list></call></expr></argument>,
                                                          <argument><expr><call><name>Int64GetDatum</name><argument_list>(<argument><expr><name>string_start</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <comment type="block">/* if length is given */</comment>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>text_string</name> <operator>=</operator> <call><name>DatumGetTextPP</name><argument_list>(<argument><expr><call><name>DirectFunctionCall3</name><argument_list>(<argument><expr><name>text_substr</name></expr></argument>,
                                                         <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>text_string</name></expr></argument>)</argument_list></call></expr></argument>,
                                                         <argument><expr><call><name>Int64GetDatum</name><argument_list>(<argument><expr><name>string_start</name></expr></argument>)</argument_list></call></expr></argument>,
                                                         <argument><expr><call><name>Int64GetDatum</name><argument_list>(<argument><expr><name>string_len</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <comment type="block">/* convert it back to a cstring */</comment>
    <expr_stmt><expr><name>string</name> <operator>=</operator> <call><name>text_to_cstring</name><argument_list>(<argument><expr><name>text_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>string_len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* if we have an empty string, return null */</comment>
    <if_stmt><if>if <condition>(<expr><name>string_len</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* build the result */</comment>
    <expr_stmt><expr><name><name>agtv_result</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>AGTV_STRING</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>agtv_result</name><operator>.</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>val</name></name> <operator>=</operator> <name>string</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>agtv_result</name><operator>.</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>len</name></name> <operator>=</operator> <name>string_len</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><call><name>agtype_value_to_agtype</name><argument_list>(<argument><expr><operator>&amp;</operator><name>agtv_result</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>age_split</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><name>Datum</name></type> <name>age_split</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>nargs</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name> <modifier>*</modifier></type><name>args</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type> <name>arg</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name> <modifier>*</modifier></type><name>nulls</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name> <modifier>*</modifier></type><name>types</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>agtv_result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>text</name> <modifier>*</modifier></type><name>param</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>text</name> <modifier>*</modifier></type><name>text_string</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>text</name> <modifier>*</modifier></type><name>text_delimiter</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type> <name>text_array</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type> <name>type</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

    <comment type="block">/* extract argument values */</comment>
    <expr_stmt><expr><name>nargs</name> <operator>=</operator> <call><name>extract_variadic_args</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>args</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>types</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* check number of args */</comment>
    <if_stmt><if>if <condition>(<expr><name>nargs</name> <operator>!=</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                        <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"split() invalid number of arguments"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* check for a null string and delimiter */</comment>
    <if_stmt><if>if <condition>(<expr><name>nargs</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>nulls</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>||</operator> <name><name>nulls</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * split() supports text, cstring, or the agtype string input for the
     * string and delimiter values
     */</comment>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">2</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name>arg</name> <operator>=</operator> <name><name>args</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>type</name> <operator>=</operator> <name><name>types</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>type</name> <operator>!=</operator> <name>AGTYPEOID</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>CSTRINGOID</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>param</name> <operator>=</operator> <call><name>cstring_to_text</name><argument_list>(<argument><expr><call><name>DatumGetCString</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <if type="elseif">else if <condition>(<expr><name>type</name> <operator>==</operator> <name>TEXTOID</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>param</name> <operator>=</operator> <call><name>DatumGetTextPP</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                                <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"split() unsupported argument type %d"</literal></expr></argument>,
                                       <argument><expr><name>type</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <decl_stmt><decl><type><name>agtype</name> <modifier>*</modifier></type><name>agt_arg</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>agtv_value</name></decl>;</decl_stmt>

            <comment type="block">/* get the agtype argument */</comment>
            <expr_stmt><expr><name>agt_arg</name> <operator>=</operator> <call><name>DATUM_GET_AGTYPE_P</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AGT_ROOT_IS_SCALAR</name><argument_list>(<argument><expr><name>agt_arg</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                                <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"split() only supports scalar arguments"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <expr_stmt><expr><name>agtv_value</name> <operator>=</operator> <call><name>get_ith_agtype_value_from_container</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>agt_arg</name><operator>-&gt;</operator><name>root</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* check for agtype null */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>agtv_value</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AGTV_NULL</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>agtv_value</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AGTV_STRING</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>param</name> <operator>=</operator> <call><name>cstring_to_text_with_len</name><argument_list>(<argument><expr><name><name>agtv_value</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>val</name></name></expr></argument>,
                                                 <argument><expr><name><name>agtv_value</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                                <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"split() unsupported argument agtype %d"</literal></expr></argument>,
                                       <argument><expr><name><name>agtv_value</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        </block_content>}</block></else></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>text_string</name> <operator>=</operator> <name>param</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>text_delimiter</name> <operator>=</operator> <name>param</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/*
     * We need the strings as a text strings so that we can let PG deal with
     * multibyte characters in the string. The result is an ArrayType
     */</comment>
    <expr_stmt><expr><name>text_array</name> <operator>=</operator> <call><name>DirectFunctionCall2Coll</name><argument_list>(<argument><expr><name>regexp_split_to_array</name></expr></argument>,
                                         <argument><expr><name>DEFAULT_COLLATION_OID</name></expr></argument>,
                                         <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>text_string</name></expr></argument>)</argument_list></call></expr></argument>,
                                         <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>text_delimiter</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* now build an agtype array of strings */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>PointerIsValid</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>text_array</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ArrayType</name> <modifier>*</modifier></type><name>array</name> <init>= <expr><call><name>DatumGetArrayTypeP</name><argument_list>(<argument><expr><name>text_array</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>agtype_in_state</name></type> <name>result</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Datum</name> <modifier>*</modifier></type><name>elements</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>nelements</name></decl>;</decl_stmt>

        <comment type="block">/* zero the state and deconstruct the ArrayType to TEXTOID */</comment>
        <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>agtype_in_state</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>deconstruct_array</name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="char">'i'</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>elements</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                          <argument><expr><operator>&amp;</operator><name>nelements</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* open the agtype array */</comment>
        <expr_stmt><expr><name><name>result</name><operator>.</operator><name>res</name></name> <operator>=</operator> <call><name>push_agtype_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>result</name><operator>.</operator><name>parse_state</name></name></expr></argument>, <argument><expr><name>WAGT_BEGIN_ARRAY</name></expr></argument>,
                                       <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* add the values */</comment>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nelements</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>string</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>string_len</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>string_copy</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>agtype_value</name></type> <name>agtv_string</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Datum</name></type> <name>d</name></decl>;</decl_stmt>

            <comment type="block">/* get the string element from the array */</comment>
            <expr_stmt><expr><name>string</name> <operator>=</operator> <call><name>VARDATA</name><argument_list>(<argument><expr><name><name>elements</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>string_len</name> <operator>=</operator> <call><name>VARSIZE</name><argument_list>(<argument><expr><name><name>elements</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>-</operator> <name>VARHDRSZ</name></expr>;</expr_stmt>

            <comment type="block">/* make a copy */</comment>
            <expr_stmt><expr><name>string_copy</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>string_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>string_copy</name></expr></argument>, <argument><expr><name>string</name></expr></argument>, <argument><expr><name>string_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* build the agtype string */</comment>
            <expr_stmt><expr><name><name>agtv_string</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>AGTV_STRING</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>agtv_string</name><operator>.</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>val</name></name> <operator>=</operator> <name>string_copy</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>agtv_string</name><operator>.</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>len</name></name> <operator>=</operator> <name>string_len</name></expr>;</expr_stmt>

            <comment type="block">/* get the datum */</comment>
            <expr_stmt><expr><name>d</name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><call><name>agtype_value_to_agtype</name><argument_list>(<argument><expr><operator>&amp;</operator><name>agtv_string</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* add the value */</comment>
            <expr_stmt><expr><call><name>add_agtype</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>result</name></expr></argument>, <argument><expr><name>AGTYPEOID</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>

        <comment type="block">/* close the array */</comment>
        <expr_stmt><expr><name><name>result</name><operator>.</operator><name>res</name></name> <operator>=</operator> <call><name>push_agtype_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>result</name><operator>.</operator><name>parse_state</name></name></expr></argument>, <argument><expr><name>WAGT_END_ARRAY</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>agtv_result</name> <operator>=</operator> <name><name>result</name><operator>.</operator><name>res</name></name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"split() unexpected error"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><call><name>agtype_value_to_agtype</name><argument_list>(<argument><expr><name>agtv_result</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>age_replace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><name>Datum</name></type> <name>age_replace</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>nargs</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name> <modifier>*</modifier></type><name>args</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type> <name>arg</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name> <modifier>*</modifier></type><name>nulls</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name> <modifier>*</modifier></type><name>types</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_value</name></type> <name>agtv_result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>text</name> <modifier>*</modifier></type><name>param</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>text</name> <modifier>*</modifier></type><name>text_string</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>text</name> <modifier>*</modifier></type><name>text_search</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>text</name> <modifier>*</modifier></type><name>text_replace</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>text</name> <modifier>*</modifier></type><name>text_result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>string</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>string_len</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type> <name>type</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

    <comment type="block">/* extract argument values */</comment>
    <expr_stmt><expr><name>nargs</name> <operator>=</operator> <call><name>extract_variadic_args</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>args</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>types</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* check number of args */</comment>
    <if_stmt><if>if <condition>(<expr><name>nargs</name> <operator>!=</operator> <literal type="number">3</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                        <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"replace() invalid number of arguments"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* check for a null string, search, and replace */</comment>
    <if_stmt><if>if <condition>(<expr><name>nargs</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>nulls</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>||</operator> <name><name>nulls</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>||</operator> <name><name>nulls</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * replace() supports text, cstring, or the agtype string input for the
     * string and delimiter values
     */</comment>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">3</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name>arg</name> <operator>=</operator> <name><name>args</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>type</name> <operator>=</operator> <name><name>types</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>type</name> <operator>!=</operator> <name>AGTYPEOID</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>CSTRINGOID</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>param</name> <operator>=</operator> <call><name>cstring_to_text</name><argument_list>(<argument><expr><call><name>DatumGetCString</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <if type="elseif">else if <condition>(<expr><name>type</name> <operator>==</operator> <name>TEXTOID</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>param</name> <operator>=</operator> <call><name>DatumGetTextPP</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                                <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"replace() unsupported argument type %d"</literal></expr></argument>,
                                       <argument><expr><name>type</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <decl_stmt><decl><type><name>agtype</name> <modifier>*</modifier></type><name>agt_arg</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>agtv_value</name></decl>;</decl_stmt>

            <comment type="block">/* get the agtype argument */</comment>
            <expr_stmt><expr><name>agt_arg</name> <operator>=</operator> <call><name>DATUM_GET_AGTYPE_P</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AGT_ROOT_IS_SCALAR</name><argument_list>(<argument><expr><name>agt_arg</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                                <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"replace() only supports scalar arguments"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <expr_stmt><expr><name>agtv_value</name> <operator>=</operator> <call><name>get_ith_agtype_value_from_container</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>agt_arg</name><operator>-&gt;</operator><name>root</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* check for agtype null */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>agtv_value</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AGTV_NULL</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>agtv_value</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AGTV_STRING</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>param</name> <operator>=</operator> <call><name>cstring_to_text_with_len</name><argument_list>(<argument><expr><name><name>agtv_value</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>val</name></name></expr></argument>,
                                                 <argument><expr><name><name>agtv_value</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                                <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"replace() unsupported argument agtype %d"</literal></expr></argument>,
                                       <argument><expr><name><name>agtv_value</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        </block_content>}</block></else></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>text_string</name> <operator>=</operator> <name>param</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>text_search</name> <operator>=</operator> <name>param</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>text_replace</name> <operator>=</operator> <name>param</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/*
     * We need the strings as a text strings so that we can let PG deal with
     * multibyte characters in the string.
     */</comment>
    <expr_stmt><expr><name>text_result</name> <operator>=</operator> <call><name>DatumGetTextPP</name><argument_list>(<argument><expr><call><name>DirectFunctionCall3</name><argument_list>(<argument><expr><name>replace_text</name></expr></argument>,
                                                     <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>text_string</name></expr></argument>)</argument_list></call></expr></argument>,
                                                     <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>text_search</name></expr></argument>)</argument_list></call></expr></argument>,
                                                     <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>text_replace</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* convert it back to a cstring */</comment>
    <expr_stmt><expr><name>string</name> <operator>=</operator> <call><name>text_to_cstring</name><argument_list>(<argument><expr><name>text_result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>string_len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* if we have an empty string, return null */</comment>
    <if_stmt><if>if <condition>(<expr><name>string_len</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* build the result */</comment>
    <expr_stmt><expr><name><name>agtv_result</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>AGTV_STRING</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>agtv_result</name><operator>.</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>val</name></name> <operator>=</operator> <name>string</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>agtv_result</name><operator>.</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>len</name></name> <operator>=</operator> <name>string_len</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><call><name>agtype_value_to_agtype</name><argument_list>(<argument><expr><operator>&amp;</operator><name>agtv_result</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Helper function to extract one float8 compatible value from a variadic any.
 * It supports integer2/4/8, float4/8, and numeric or the agtype integer, float,
 * and numeric for the argument. It does not support a character based float,
 * otherwise we would just use tofloat. It returns a float on success or fails
 * with a message stating the funcname that called it and a specific message
 * stating the error.
 */</comment>
<function><type><specifier>static</specifier> <name>float8</name></type> <name>get_float_compatible_arg</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>arg</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>funcname</name></decl></parameter>,
                                       <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>is_null</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>float8</name></type> <name>result</name></decl>;</decl_stmt>

    <comment type="block">/* Assume the value is null. Although, this is only necessary for agtypes */</comment>
    <expr_stmt><expr><operator>*</operator><name>is_null</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>type</name> <operator>!=</operator> <name>AGTYPEOID</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>INT2OID</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>float8</name><operator>)</operator> <call><name>DatumGetInt16</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><name>type</name> <operator>==</operator> <name>INT4OID</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>float8</name><operator>)</operator> <call><name>DatumGetInt32</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><name>type</name> <operator>==</operator> <name>INT8OID</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * Get the string representation of the integer because it could be
             * too large to fit in a float. Let the float routine determine
             * what to do with it.
             */</comment>
            <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>string</name> <init>= <expr><call><name>DatumGetCString</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>int8out</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>bool</name></type> <name>is_valid</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
            <comment type="block">/* turn it into a float */</comment>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>float8in_internal_null</name><argument_list>(<argument><expr><name>string</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"double precision"</literal></expr></argument>,
                                            <argument><expr><name>string</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>is_valid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* return 0 if it was an invalid float */</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_valid</name></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>type</name> <operator>==</operator> <name>FLOAT4OID</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>float8</name><operator>)</operator> <call><name>DatumGetFloat4</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><name>type</name> <operator>==</operator> <name>FLOAT8OID</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>DatumGetFloat8</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><name>type</name> <operator>==</operator> <name>NUMERICOID</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>DatumGetFloat8</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(
                <argument><expr><name>numeric_float8_no_overflow</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                            <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s() unsupported argument type %d"</literal></expr></argument>, <argument><expr><name>funcname</name></expr></argument>,
                                   <argument><expr><name>type</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <decl_stmt><decl><type><name>agtype</name> <modifier>*</modifier></type><name>agt_arg</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>agtv_value</name></decl>;</decl_stmt>

        <comment type="block">/* get the agtype argument */</comment>
        <expr_stmt><expr><name>agt_arg</name> <operator>=</operator> <call><name>DATUM_GET_AGTYPE_P</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AGT_ROOT_IS_SCALAR</name><argument_list>(<argument><expr><name>agt_arg</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                            <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s() only supports scalar arguments"</literal></expr></argument>,
                                   <argument><expr><name>funcname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>agtv_value</name> <operator>=</operator> <call><name>get_ith_agtype_value_from_container</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>agt_arg</name><operator>-&gt;</operator><name>root</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* check for agtype null */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>agtv_value</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AGTV_NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>agtv_value</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AGTV_INTEGER</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * Get the string representation of the integer because it could be
             * too large to fit in a float. Let the float routine determine
             * what to do with it.
             */</comment>
            <decl_stmt><decl><type><name>bool</name></type> <name>is_valid</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>string</name> <init>= <expr><call><name>DatumGetCString</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>int8out</name></expr></argument>,
                                                               <argument><expr><call><name>Int64GetDatum</name><argument_list>(<argument><expr><name><name>agtv_value</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>int_value</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <comment type="block">/* turn it into a float */</comment>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>float8in_internal_null</name><argument_list>(<argument><expr><name>string</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"double precision"</literal></expr></argument>,
                                            <argument><expr><name>string</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>is_valid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* return null if it was not a valid float */</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_valid</name></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name><name>agtv_value</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AGTV_FLOAT</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>agtv_value</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>float_value</name></name></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><name><name>agtv_value</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AGTV_NUMERIC</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>DatumGetFloat8</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(
                <argument><expr><name>numeric_float8_no_overflow</name></expr></argument>,
                <argument><expr><call><name>NumericGetDatum</name><argument_list>(<argument><expr><name><name>agtv_value</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>numeric</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                            <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s() unsupported argument agtype %d"</literal></expr></argument>,
                                   <argument><expr><name>funcname</name></expr></argument>, <argument><expr><name><name>agtv_value</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* there is a valid non null value */</comment>
    <expr_stmt><expr><operator>*</operator><name>is_null</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Helper function to extract one numeric compatible value from a variadic any.
 * It supports integer2/4/8, float4/8, and numeric or the agtype integer, float,
 * and numeric for the argument. It does not support a character based numeric,
 * otherwise we would just cast it to numeric. It returns a numeric on success
 * or fails with a message stating the funcname that called it and a specific
 * message stating the error.
 */</comment>
<function><type><specifier>static</specifier> <name>Numeric</name></type> <name>get_numeric_compatible_arg</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>arg</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>funcname</name></decl></parameter>,
                                          <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>is_null</name></decl></parameter>,
                                          <parameter><decl><type><name><name>enum</name> <name>agtype_value_type</name></name> <modifier>*</modifier></type><name>ag_type</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Numeric</name></type> <name>result</name></decl>;</decl_stmt>

    <comment type="block">/* Assume the value is null. Although, this is only necessary for agtypes */</comment>
    <expr_stmt><expr><operator>*</operator><name>is_null</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>ag_type</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>*</operator><name>ag_type</name> <operator>=</operator> <name>AGTV_NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>type</name> <operator>!=</operator> <name>AGTYPEOID</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>INT2OID</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>DatumGetNumeric</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>int2_numeric</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><name>type</name> <operator>==</operator> <name>INT4OID</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>DatumGetNumeric</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>int4_numeric</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><name>type</name> <operator>==</operator> <name>INT8OID</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>DatumGetNumeric</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>int8_numeric</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><name>type</name> <operator>==</operator> <name>FLOAT4OID</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>DatumGetNumeric</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>float4_numeric</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><name>type</name> <operator>==</operator> <name>FLOAT8OID</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>DatumGetNumeric</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>float8_numeric</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><name>type</name> <operator>==</operator> <name>NUMERICOID</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>DatumGetNumeric</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                            <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s() unsupported argument type %d"</literal></expr></argument>, <argument><expr><name>funcname</name></expr></argument>,
                                   <argument><expr><name>type</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <decl_stmt><decl><type><name>agtype</name> <modifier>*</modifier></type><name>agt_arg</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>agtv_value</name></decl>;</decl_stmt>

        <comment type="block">/* get the agtype argument */</comment>
        <expr_stmt><expr><name>agt_arg</name> <operator>=</operator> <call><name>DATUM_GET_AGTYPE_P</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AGT_ROOT_IS_SCALAR</name><argument_list>(<argument><expr><name>agt_arg</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                            <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s() only supports scalar arguments"</literal></expr></argument>,
                                   <argument><expr><name>funcname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>agtv_value</name> <operator>=</operator> <call><name>get_ith_agtype_value_from_container</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>agt_arg</name><operator>-&gt;</operator><name>root</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* check for agtype null */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>agtv_value</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AGTV_NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>agtv_value</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AGTV_INTEGER</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>DatumGetNumeric</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(
                <argument><expr><name>int8_numeric</name></expr></argument>, <argument><expr><call><name>Int64GetDatum</name><argument_list>(<argument><expr><name><name>agtv_value</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>int_value</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>ag_type</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><operator>*</operator><name>ag_type</name> <operator>=</operator> <name>AGTV_INTEGER</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name><name>agtv_value</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AGTV_FLOAT</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>DatumGetNumeric</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(
                <argument><expr><name>float8_numeric</name></expr></argument>, <argument><expr><call><name>Float8GetDatum</name><argument_list>(<argument><expr><name><name>agtv_value</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>float_value</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>ag_type</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><operator>*</operator><name>ag_type</name> <operator>=</operator> <name>AGTV_FLOAT</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name><name>agtv_value</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AGTV_NUMERIC</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>agtv_value</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>numeric</name></name></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>ag_type</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><operator>*</operator><name>ag_type</name> <operator>=</operator> <name>AGTV_NUMERIC</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                            <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s() unsupported argument agtype %d"</literal></expr></argument>,
                                   <argument><expr><name>funcname</name></expr></argument>, <argument><expr><name><name>agtv_value</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* there is a valid non null value */</comment>
    <expr_stmt><expr><operator>*</operator><name>is_null</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>age_sin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><name>Datum</name></type> <name>age_sin</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>nargs</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name> <modifier>*</modifier></type><name>args</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name> <modifier>*</modifier></type><name>nulls</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name> <modifier>*</modifier></type><name>types</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_value</name></type> <name>agtv_result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>float8</name></type> <name>angle</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>float8</name></type> <name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>is_null</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* extract argument values */</comment>
    <expr_stmt><expr><name>nargs</name> <operator>=</operator> <call><name>extract_variadic_args</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>args</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>types</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* check number of args */</comment>
    <if_stmt><if>if <condition>(<expr><name>nargs</name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                        <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"sin() invalid number of arguments"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* check for a null input */</comment>
    <if_stmt><if>if <condition>(<expr><name>nargs</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>nulls</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * sin() supports integer, float, and numeric or the agtype integer, float,
     * and numeric for the angle
     */</comment>

    <expr_stmt><expr><name>angle</name> <operator>=</operator> <call><name>get_float_compatible_arg</name><argument_list>(<argument><expr><name><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>types</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"sin"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>is_null</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* check for a agtype null input */</comment>
    <if_stmt><if>if <condition>(<expr><name>is_null</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* We need the numeric input as a float8 so that we can pass it off to PG */</comment>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>DatumGetFloat8</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>dsin</name></expr></argument>,
                                                <argument><expr><call><name>Float8GetDatum</name><argument_list>(<argument><expr><name>angle</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* build the result */</comment>
    <expr_stmt><expr><name><name>agtv_result</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>AGTV_FLOAT</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>agtv_result</name><operator>.</operator><name>val</name><operator>.</operator><name>float_value</name></name> <operator>=</operator> <name>result</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><call><name>agtype_value_to_agtype</name><argument_list>(<argument><expr><operator>&amp;</operator><name>agtv_result</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>age_cos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><name>Datum</name></type> <name>age_cos</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>nargs</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name> <modifier>*</modifier></type><name>args</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name> <modifier>*</modifier></type><name>nulls</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name> <modifier>*</modifier></type><name>types</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_value</name></type> <name>agtv_result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>float8</name></type> <name>angle</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>float8</name></type> <name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>is_null</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* extract argument values */</comment>
    <expr_stmt><expr><name>nargs</name> <operator>=</operator> <call><name>extract_variadic_args</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>args</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>types</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* check number of args */</comment>
    <if_stmt><if>if <condition>(<expr><name>nargs</name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                        <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cos() invalid number of arguments"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* check for a null input */</comment>
    <if_stmt><if>if <condition>(<expr><name>nargs</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>nulls</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * cos() supports integer, float, and numeric or the agtype integer, float,
     * and numeric for the angle
     */</comment>

    <expr_stmt><expr><name>angle</name> <operator>=</operator> <call><name>get_float_compatible_arg</name><argument_list>(<argument><expr><name><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>types</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"cos"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>is_null</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* check for a agtype null input */</comment>
    <if_stmt><if>if <condition>(<expr><name>is_null</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* We need the numeric input as a float8 so that we can pass it off to PG */</comment>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>DatumGetFloat8</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>dcos</name></expr></argument>,
                                                <argument><expr><call><name>Float8GetDatum</name><argument_list>(<argument><expr><name>angle</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* build the result */</comment>
    <expr_stmt><expr><name><name>agtv_result</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>AGTV_FLOAT</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>agtv_result</name><operator>.</operator><name>val</name><operator>.</operator><name>float_value</name></name> <operator>=</operator> <name>result</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><call><name>agtype_value_to_agtype</name><argument_list>(<argument><expr><operator>&amp;</operator><name>agtv_result</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>age_tan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><name>Datum</name></type> <name>age_tan</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>nargs</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name> <modifier>*</modifier></type><name>args</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name> <modifier>*</modifier></type><name>nulls</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name> <modifier>*</modifier></type><name>types</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_value</name></type> <name>agtv_result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>float8</name></type> <name>angle</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>float8</name></type> <name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>is_null</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* extract argument values */</comment>
    <expr_stmt><expr><name>nargs</name> <operator>=</operator> <call><name>extract_variadic_args</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>args</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>types</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* check number of args */</comment>
    <if_stmt><if>if <condition>(<expr><name>nargs</name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                        <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"tan() invalid number of arguments"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* check for a null input */</comment>
    <if_stmt><if>if <condition>(<expr><name>nargs</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>nulls</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * tan() supports integer, float, and numeric or the agtype integer, float,
     * and numeric for the angle
     */</comment>

    <expr_stmt><expr><name>angle</name> <operator>=</operator> <call><name>get_float_compatible_arg</name><argument_list>(<argument><expr><name><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>types</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"tan"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>is_null</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* check for a agtype null input */</comment>
    <if_stmt><if>if <condition>(<expr><name>is_null</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* We need the numeric input as a float8 so that we can pass it off to PG */</comment>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>DatumGetFloat8</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>dtan</name></expr></argument>,
                                                <argument><expr><call><name>Float8GetDatum</name><argument_list>(<argument><expr><name>angle</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* build the result */</comment>
    <expr_stmt><expr><name><name>agtv_result</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>AGTV_FLOAT</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>agtv_result</name><operator>.</operator><name>val</name><operator>.</operator><name>float_value</name></name> <operator>=</operator> <name>result</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><call><name>agtype_value_to_agtype</name><argument_list>(<argument><expr><operator>&amp;</operator><name>agtv_result</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>age_cot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><name>Datum</name></type> <name>age_cot</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>nargs</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name> <modifier>*</modifier></type><name>args</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name> <modifier>*</modifier></type><name>nulls</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name> <modifier>*</modifier></type><name>types</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_value</name></type> <name>agtv_result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>float8</name></type> <name>angle</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>float8</name></type> <name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>is_null</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* extract argument values */</comment>
    <expr_stmt><expr><name>nargs</name> <operator>=</operator> <call><name>extract_variadic_args</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>args</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>types</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* check number of args */</comment>
    <if_stmt><if>if <condition>(<expr><name>nargs</name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                        <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cot() invalid number of arguments"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* check for a null input */</comment>
    <if_stmt><if>if <condition>(<expr><name>nargs</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>nulls</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * cot() supports integer, float, and numeric or the agtype integer, float,
     * and numeric for the angle
     */</comment>

    <expr_stmt><expr><name>angle</name> <operator>=</operator> <call><name>get_float_compatible_arg</name><argument_list>(<argument><expr><name><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>types</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"cot"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>is_null</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* check for a agtype null input */</comment>
    <if_stmt><if>if <condition>(<expr><name>is_null</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* We need the numeric input as a float8 so that we can pass it off to PG */</comment>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>DatumGetFloat8</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>dcot</name></expr></argument>,
                                                <argument><expr><call><name>Float8GetDatum</name><argument_list>(<argument><expr><name>angle</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* build the result */</comment>
    <expr_stmt><expr><name><name>agtv_result</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>AGTV_FLOAT</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>agtv_result</name><operator>.</operator><name>val</name><operator>.</operator><name>float_value</name></name> <operator>=</operator> <name>result</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><call><name>agtype_value_to_agtype</name><argument_list>(<argument><expr><operator>&amp;</operator><name>agtv_result</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>age_asin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><name>Datum</name></type> <name>age_asin</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>nargs</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name> <modifier>*</modifier></type><name>args</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name> <modifier>*</modifier></type><name>nulls</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name> <modifier>*</modifier></type><name>types</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_value</name></type> <name>agtv_result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>float8</name></type> <name>x</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>float8</name></type> <name>angle</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>is_null</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* extract argument values */</comment>
    <expr_stmt><expr><name>nargs</name> <operator>=</operator> <call><name>extract_variadic_args</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>args</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>types</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* check number of args */</comment>
    <if_stmt><if>if <condition>(<expr><name>nargs</name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                        <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"asin() invalid number of arguments"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* check for a null input */</comment>
    <if_stmt><if>if <condition>(<expr><name>nargs</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>nulls</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * asin() supports integer, float, and numeric or the agtype integer, float,
     * and numeric for the input expression.
     */</comment>

    <expr_stmt><expr><name>x</name> <operator>=</operator> <call><name>get_float_compatible_arg</name><argument_list>(<argument><expr><name><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>types</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"asin"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>is_null</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* verify that x is within range */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>x</name> <argument_list type="generic">&lt; <argument><expr><operator>-</operator><literal type="number">1</literal> <operator>||</operator> <name>x</name></expr></argument> &gt;</argument_list></name> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* check for a agtype null input */</comment>
    <if_stmt><if>if <condition>(<expr><name>is_null</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* We need the numeric input as a float8 so that we can pass it off to PG */</comment>
    <expr_stmt><expr><name>angle</name> <operator>=</operator> <call><name>DatumGetFloat8</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>dasin</name></expr></argument>,
                                               <argument><expr><call><name>Float8GetDatum</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* build the result */</comment>
    <expr_stmt><expr><name><name>agtv_result</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>AGTV_FLOAT</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>agtv_result</name><operator>.</operator><name>val</name><operator>.</operator><name>float_value</name></name> <operator>=</operator> <name>angle</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><call><name>agtype_value_to_agtype</name><argument_list>(<argument><expr><operator>&amp;</operator><name>agtv_result</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>age_acos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><name>Datum</name></type> <name>age_acos</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>nargs</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name> <modifier>*</modifier></type><name>args</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name> <modifier>*</modifier></type><name>nulls</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name> <modifier>*</modifier></type><name>types</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_value</name></type> <name>agtv_result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>float8</name></type> <name>x</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>float8</name></type> <name>angle</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>is_null</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* extract argument values */</comment>
    <expr_stmt><expr><name>nargs</name> <operator>=</operator> <call><name>extract_variadic_args</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>args</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>types</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* check number of args */</comment>
    <if_stmt><if>if <condition>(<expr><name>nargs</name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                        <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"acos() invalid number of arguments"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* check for a null input */</comment>
    <if_stmt><if>if <condition>(<expr><name>nargs</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>nulls</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * acos() supports integer, float, and numeric or the agtype integer, float,
     * and numeric for the input expression.
     */</comment>

    <expr_stmt><expr><name>x</name> <operator>=</operator> <call><name>get_float_compatible_arg</name><argument_list>(<argument><expr><name><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>types</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"acos"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>is_null</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* verify that x is within range */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>x</name> <argument_list type="generic">&lt; <argument><expr><operator>-</operator><literal type="number">1</literal> <operator>||</operator> <name>x</name></expr></argument> &gt;</argument_list></name> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* check for a agtype null input */</comment>
    <if_stmt><if>if <condition>(<expr><name>is_null</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* We need the numeric input as a float8 so that we can pass it off to PG */</comment>
    <expr_stmt><expr><name>angle</name> <operator>=</operator> <call><name>DatumGetFloat8</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>dacos</name></expr></argument>,
                                               <argument><expr><call><name>Float8GetDatum</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* build the result */</comment>
    <expr_stmt><expr><name><name>agtv_result</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>AGTV_FLOAT</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>agtv_result</name><operator>.</operator><name>val</name><operator>.</operator><name>float_value</name></name> <operator>=</operator> <name>angle</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><call><name>agtype_value_to_agtype</name><argument_list>(<argument><expr><operator>&amp;</operator><name>agtv_result</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>age_atan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><name>Datum</name></type> <name>age_atan</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>nargs</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name> <modifier>*</modifier></type><name>args</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name> <modifier>*</modifier></type><name>nulls</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name> <modifier>*</modifier></type><name>types</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_value</name></type> <name>agtv_result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>float8</name></type> <name>x</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>float8</name></type> <name>angle</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>is_null</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* extract argument values */</comment>
    <expr_stmt><expr><name>nargs</name> <operator>=</operator> <call><name>extract_variadic_args</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>args</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>types</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* check number of args */</comment>
    <if_stmt><if>if <condition>(<expr><name>nargs</name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                        <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"atan() invalid number of arguments"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* check for a null input */</comment>
    <if_stmt><if>if <condition>(<expr><name>nargs</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>nulls</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * atan() supports integer, float, and numeric or the agtype integer, float,
     * and numeric for the input expression.
     */</comment>

    <expr_stmt><expr><name>x</name> <operator>=</operator> <call><name>get_float_compatible_arg</name><argument_list>(<argument><expr><name><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>types</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"atan"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>is_null</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* check for a agtype null input */</comment>
    <if_stmt><if>if <condition>(<expr><name>is_null</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* We need the numeric input as a float8 so that we can pass it off to PG */</comment>
    <expr_stmt><expr><name>angle</name> <operator>=</operator> <call><name>DatumGetFloat8</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>datan</name></expr></argument>,
                                               <argument><expr><call><name>Float8GetDatum</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* build the result */</comment>
    <expr_stmt><expr><name><name>agtv_result</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>AGTV_FLOAT</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>agtv_result</name><operator>.</operator><name>val</name><operator>.</operator><name>float_value</name></name> <operator>=</operator> <name>angle</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><call><name>agtype_value_to_agtype</name><argument_list>(<argument><expr><operator>&amp;</operator><name>agtv_result</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>age_atan2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><name>Datum</name></type> <name>age_atan2</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>nargs</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name> <modifier>*</modifier></type><name>args</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name> <modifier>*</modifier></type><name>nulls</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name> <modifier>*</modifier></type><name>types</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_value</name></type> <name>agtv_result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>float8</name></type> <name>x</name></decl>, <decl><type ref="prev"/><name>y</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>float8</name></type> <name>angle</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>is_null</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* extract argument values */</comment>
    <expr_stmt><expr><name>nargs</name> <operator>=</operator> <call><name>extract_variadic_args</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>args</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>types</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* check number of args */</comment>
    <if_stmt><if>if <condition>(<expr><name>nargs</name> <operator>!=</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                        <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"atan2() invalid number of arguments"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* check for a null input */</comment>
    <if_stmt><if>if <condition>(<expr><name>nargs</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>nulls</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>||</operator> <name><name>nulls</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * atan2() supports integer, float, and numeric or the agtype integer,
     * float, and numeric for the input expressions.
     */</comment>

    <expr_stmt><expr><name>y</name> <operator>=</operator> <call><name>get_float_compatible_arg</name><argument_list>(<argument><expr><name><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>types</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"atan2"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>is_null</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* check for a agtype null input */</comment>
    <if_stmt><if>if <condition>(<expr><name>is_null</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>x</name> <operator>=</operator> <call><name>get_float_compatible_arg</name><argument_list>(<argument><expr><name><name>args</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>types</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"atan2"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>is_null</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* check for a agtype null input */</comment>
    <if_stmt><if>if <condition>(<expr><name>is_null</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* We need the numeric input as a float8 so that we can pass it off to PG */</comment>
    <expr_stmt><expr><name>angle</name> <operator>=</operator> <call><name>DatumGetFloat8</name><argument_list>(<argument><expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>datan2</name></expr></argument>,
                                               <argument><expr><call><name>Float8GetDatum</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr></argument>,
                                               <argument><expr><call><name>Float8GetDatum</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* build the result */</comment>
    <expr_stmt><expr><name><name>agtv_result</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>AGTV_FLOAT</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>agtv_result</name><operator>.</operator><name>val</name><operator>.</operator><name>float_value</name></name> <operator>=</operator> <name>angle</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><call><name>agtype_value_to_agtype</name><argument_list>(<argument><expr><operator>&amp;</operator><name>agtv_result</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>age_degrees</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><name>Datum</name></type> <name>age_degrees</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>nargs</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name> <modifier>*</modifier></type><name>args</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name> <modifier>*</modifier></type><name>nulls</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name> <modifier>*</modifier></type><name>types</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_value</name></type> <name>agtv_result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>float8</name></type> <name>angle_degrees</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>float8</name></type> <name>angle_radians</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>is_null</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* extract argument values */</comment>
    <expr_stmt><expr><name>nargs</name> <operator>=</operator> <call><name>extract_variadic_args</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>args</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>types</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* check number of args */</comment>
    <if_stmt><if>if <condition>(<expr><name>nargs</name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                        <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"degrees() invalid number of arguments"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* check for a null input */</comment>
    <if_stmt><if>if <condition>(<expr><name>nargs</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>nulls</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * degrees_from_radians() supports integer, float, and numeric or the agtype
     * integer, float, and numeric for the input expression.
     */</comment>

    <expr_stmt><expr><name>angle_radians</name> <operator>=</operator> <call><name>get_float_compatible_arg</name><argument_list>(<argument><expr><name><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>types</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"degrees"</literal></expr></argument>,
                                             <argument><expr><operator>&amp;</operator><name>is_null</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* check for a agtype null input */</comment>
    <if_stmt><if>if <condition>(<expr><name>is_null</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* We need the numeric input as a float8 so that we can pass it off to PG */</comment>
    <expr_stmt><expr><name>angle_degrees</name> <operator>=</operator> <call><name>DatumGetFloat8</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>degrees</name></expr></argument>,
                                                       <argument><expr><call><name>Float8GetDatum</name><argument_list>(<argument><expr><name>angle_radians</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* build the result */</comment>
    <expr_stmt><expr><name><name>agtv_result</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>AGTV_FLOAT</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>agtv_result</name><operator>.</operator><name>val</name><operator>.</operator><name>float_value</name></name> <operator>=</operator> <name>angle_degrees</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><call><name>agtype_value_to_agtype</name><argument_list>(<argument><expr><operator>&amp;</operator><name>agtv_result</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>age_radians</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><name>Datum</name></type> <name>age_radians</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>nargs</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name> <modifier>*</modifier></type><name>args</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name> <modifier>*</modifier></type><name>nulls</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name> <modifier>*</modifier></type><name>types</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_value</name></type> <name>agtv_result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>float8</name></type> <name>angle_degrees</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>float8</name></type> <name>angle_radians</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>is_null</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* extract argument values */</comment>
    <expr_stmt><expr><name>nargs</name> <operator>=</operator> <call><name>extract_variadic_args</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>args</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>types</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* check number of args */</comment>
    <if_stmt><if>if <condition>(<expr><name>nargs</name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                        <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"radians() invalid number of arguments"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* check for a null input */</comment>
    <if_stmt><if>if <condition>(<expr><name>nargs</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>nulls</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * radians_from_degrees() supports integer, float, and numeric or the agtype
     * integer, float, and numeric for the input expression.
     */</comment>

    <expr_stmt><expr><name>angle_degrees</name> <operator>=</operator> <call><name>get_float_compatible_arg</name><argument_list>(<argument><expr><name><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>types</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"radians"</literal></expr></argument>,
                                             <argument><expr><operator>&amp;</operator><name>is_null</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* check for a agtype null input */</comment>
    <if_stmt><if>if <condition>(<expr><name>is_null</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* We need the numeric input as a float8 so that we can pass it off to PG */</comment>
    <expr_stmt><expr><name>angle_radians</name> <operator>=</operator> <call><name>DatumGetFloat8</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>radians</name></expr></argument>,
                                                       <argument><expr><call><name>Float8GetDatum</name><argument_list>(<argument><expr><name>angle_degrees</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* build the result */</comment>
    <expr_stmt><expr><name><name>agtv_result</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>AGTV_FLOAT</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>agtv_result</name><operator>.</operator><name>val</name><operator>.</operator><name>float_value</name></name> <operator>=</operator> <name>angle_radians</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><call><name>agtype_value_to_agtype</name><argument_list>(<argument><expr><operator>&amp;</operator><name>agtv_result</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>age_round</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><name>Datum</name></type> <name>age_round</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Datum</name> <modifier>*</modifier></type><name>args</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name> <modifier>*</modifier></type><name>nulls</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name> <modifier>*</modifier></type><name>types</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nargs</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_value</name></type> <name>agtv_result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Numeric</name></type> <name>arg</name></decl>, <decl><type ref="prev"/><name>arg_precision</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Numeric</name></type> <name>numeric_result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>float8</name></type> <name>float_result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>is_null</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>precision</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <comment type="block">/* extract argument values */</comment>
    <expr_stmt><expr><name>nargs</name> <operator>=</operator> <call><name>extract_variadic_args</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>args</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>types</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* check number of args */</comment>
    <if_stmt><if>if <condition>(<expr><name>nargs</name> <operator>!=</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>nargs</name> <operator>!=</operator> <literal type="number">2</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"round() invalid number of arguments"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* check for a null input */</comment>
    <if_stmt><if>if <condition>(<expr><name>nargs</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>nulls</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * round() supports integer, float, and numeric or the agtype integer,
     * float, and numeric for the input expression.
     */</comment>
    <expr_stmt><expr><name>arg</name> <operator>=</operator> <call><name>get_numeric_compatible_arg</name><argument_list>(<argument><expr><name><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>types</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"round"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>is_null</name></expr></argument>,
                                     <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* check for a agtype null input */</comment>
    <if_stmt><if>if <condition>(<expr><name>is_null</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* We need the input as a numeric so that we can pass it off to PG */</comment>
    <if_stmt><if>if <condition>(<expr><name>nargs</name> <operator>==</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>nulls</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>arg_precision</name> <operator>=</operator> <call><name>get_numeric_compatible_arg</name><argument_list>(<argument><expr><name><name>args</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>types</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"round"</literal></expr></argument>,
                                                   <argument><expr><operator>&amp;</operator><name>is_null</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_null</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>precision</name> <operator>=</operator> <call><name>DatumGetInt64</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>numeric_int8</name></expr></argument>,
                                      <argument><expr><call><name>NumericGetDatum</name><argument_list>(<argument><expr><name>arg_precision</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>numeric_result</name> <operator>=</operator> <call><name>DatumGetNumeric</name><argument_list>(<argument><expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>numeric_round</name></expr></argument>,
                                             <argument><expr><call><name>NumericGetDatum</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></argument>,
                                             <argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>precision</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"round() invalid NULL precision value"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name>numeric_result</name> <operator>=</operator> <call><name>DatumGetNumeric</name><argument_list>(<argument><expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>numeric_round</name></expr></argument>,
                                         <argument><expr><call><name>NumericGetDatum</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></argument>,
                                         <argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><name>float_result</name> <operator>=</operator> <call><name>DatumGetFloat8</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>numeric_float8_no_overflow</name></expr></argument>,
                                               <argument><expr><call><name>NumericGetDatum</name><argument_list>(<argument><expr><name>numeric_result</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* build the result */</comment>
    <expr_stmt><expr><name><name>agtv_result</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>AGTV_FLOAT</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>agtv_result</name><operator>.</operator><name>val</name><operator>.</operator><name>float_value</name></name> <operator>=</operator> <name>float_result</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><call><name>agtype_value_to_agtype</name><argument_list>(<argument><expr><operator>&amp;</operator><name>agtv_result</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>age_ceil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><name>Datum</name></type> <name>age_ceil</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>nargs</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name> <modifier>*</modifier></type><name>args</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name> <modifier>*</modifier></type><name>nulls</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name> <modifier>*</modifier></type><name>types</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_value</name></type> <name>agtv_result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Numeric</name></type> <name>arg</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Numeric</name></type> <name>numeric_result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>float8</name></type> <name>float_result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>is_null</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* extract argument values */</comment>
    <expr_stmt><expr><name>nargs</name> <operator>=</operator> <call><name>extract_variadic_args</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>args</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>types</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* check number of args */</comment>
    <if_stmt><if>if <condition>(<expr><name>nargs</name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                        <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"ceil() invalid number of arguments"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* check for a null input */</comment>
    <if_stmt><if>if <condition>(<expr><name>nargs</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>nulls</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * ceil() supports integer, float, and numeric or the agtype integer,
     * float, and numeric for the input expression.
     */</comment>
    <expr_stmt><expr><name>arg</name> <operator>=</operator> <call><name>get_numeric_compatible_arg</name><argument_list>(<argument><expr><name><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>types</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"ceil"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>is_null</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* check for a agtype null input */</comment>
    <if_stmt><if>if <condition>(<expr><name>is_null</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* We need the input as a numeric so that we can pass it off to PG */</comment>
    <expr_stmt><expr><name>numeric_result</name> <operator>=</operator> <call><name>DatumGetNumeric</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>numeric_ceil</name></expr></argument>,
                                                         <argument><expr><call><name>NumericGetDatum</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>float_result</name> <operator>=</operator> <call><name>DatumGetFloat8</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>numeric_float8_no_overflow</name></expr></argument>,
                                                      <argument><expr><call><name>NumericGetDatum</name><argument_list>(<argument><expr><name>numeric_result</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* build the result */</comment>
    <expr_stmt><expr><name><name>agtv_result</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>AGTV_FLOAT</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>agtv_result</name><operator>.</operator><name>val</name><operator>.</operator><name>float_value</name></name> <operator>=</operator> <name>float_result</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><call><name>agtype_value_to_agtype</name><argument_list>(<argument><expr><operator>&amp;</operator><name>agtv_result</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>age_floor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><name>Datum</name></type> <name>age_floor</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>nargs</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name> <modifier>*</modifier></type><name>args</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name> <modifier>*</modifier></type><name>nulls</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name> <modifier>*</modifier></type><name>types</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_value</name></type> <name>agtv_result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Numeric</name></type> <name>arg</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Numeric</name></type> <name>numeric_result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>float8</name></type> <name>float_result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>is_null</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* extract argument values */</comment>
    <expr_stmt><expr><name>nargs</name> <operator>=</operator> <call><name>extract_variadic_args</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>args</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>types</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* check number of args */</comment>
    <if_stmt><if>if <condition>(<expr><name>nargs</name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                        <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"floor() invalid number of arguments"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* check for a null input */</comment>
    <if_stmt><if>if <condition>(<expr><name>nargs</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>nulls</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * floor() supports integer, float, and numeric or the agtype integer,
     * float, and numeric for the input expression.
     */</comment>
    <expr_stmt><expr><name>arg</name> <operator>=</operator> <call><name>get_numeric_compatible_arg</name><argument_list>(<argument><expr><name><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>types</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"floor"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>is_null</name></expr></argument>,
                                     <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* check for a agtype null input */</comment>
    <if_stmt><if>if <condition>(<expr><name>is_null</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* We need the input as a numeric so that we can pass it off to PG */</comment>
    <expr_stmt><expr><name>numeric_result</name> <operator>=</operator> <call><name>DatumGetNumeric</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>numeric_floor</name></expr></argument>,
                                                         <argument><expr><call><name>NumericGetDatum</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>float_result</name> <operator>=</operator> <call><name>DatumGetFloat8</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>numeric_float8_no_overflow</name></expr></argument>,
                                                      <argument><expr><call><name>NumericGetDatum</name><argument_list>(<argument><expr><name>numeric_result</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* build the result */</comment>
    <expr_stmt><expr><name><name>agtv_result</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>AGTV_FLOAT</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>agtv_result</name><operator>.</operator><name>val</name><operator>.</operator><name>float_value</name></name> <operator>=</operator> <name>float_result</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><call><name>agtype_value_to_agtype</name><argument_list>(<argument><expr><operator>&amp;</operator><name>agtv_result</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>age_abs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><name>Datum</name></type> <name>age_abs</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>nargs</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name> <modifier>*</modifier></type><name>args</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name> <modifier>*</modifier></type><name>nulls</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name> <modifier>*</modifier></type><name>types</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_value</name></type> <name>agtv_result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Numeric</name></type> <name>arg</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Numeric</name></type> <name>numeric_result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>is_null</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>enum</name> <name>agtype_value_type</name></name></type> <name>type</name> <init>= <expr><name>AGTV_NULL</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* extract argument values */</comment>
    <expr_stmt><expr><name>nargs</name> <operator>=</operator> <call><name>extract_variadic_args</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>args</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>types</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* check number of args */</comment>
    <if_stmt><if>if <condition>(<expr><name>nargs</name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                        <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"abs() invalid number of arguments"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* check for a null input */</comment>
    <if_stmt><if>if <condition>(<expr><name>nargs</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>nulls</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * abs() supports integer, float, and numeric or the agtype integer,
     * float, and numeric for the input expression.
     */</comment>
    <expr_stmt><expr><name>arg</name> <operator>=</operator> <call><name>get_numeric_compatible_arg</name><argument_list>(<argument><expr><name><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>types</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"abs"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>is_null</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* check for a agtype null input */</comment>
    <if_stmt><if>if <condition>(<expr><name>is_null</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* We need the input as a numeric so that we can pass it off to PG */</comment>
    <expr_stmt><expr><name>numeric_result</name> <operator>=</operator> <call><name>DatumGetNumeric</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>numeric_abs</name></expr></argument>,
                                                         <argument><expr><call><name>NumericGetDatum</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* build the result, based on the type */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>types</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>INT2OID</name> <operator>||</operator> <name><name>types</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>INT4OID</name> <operator>||</operator> <name><name>types</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>INT8OID</name> <operator>||</operator>
        <operator>(</operator><name><name>types</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>AGTYPEOID</name> <operator>&amp;&amp;</operator> <name>type</name> <operator>==</operator> <name>AGTV_INTEGER</name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int64</name></type> <name>int_result</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>int_result</name> <operator>=</operator> <call><name>DatumGetInt64</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>numeric_int8</name></expr></argument>,
                                                       <argument><expr><call><name>NumericGetDatum</name><argument_list>(<argument><expr><name>numeric_result</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>agtv_result</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>AGTV_INTEGER</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>agtv_result</name><operator>.</operator><name>val</name><operator>.</operator><name>int_value</name></name> <operator>=</operator> <name>int_result</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>types</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>FLOAT4OID</name> <operator>||</operator> <name><name>types</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>FLOAT8OID</name> <operator>||</operator>
        <operator>(</operator><name><name>types</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>AGTYPEOID</name> <operator>&amp;&amp;</operator> <name>type</name> <operator>==</operator> <name>AGTV_FLOAT</name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>float8</name></type> <name>float_result</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>float_result</name> <operator>=</operator> <call><name>DatumGetFloat8</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>numeric_float8_no_overflow</name></expr></argument>,
                           <argument><expr><call><name>NumericGetDatum</name><argument_list>(<argument><expr><name>numeric_result</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>agtv_result</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>AGTV_FLOAT</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>agtv_result</name><operator>.</operator><name>val</name><operator>.</operator><name>float_value</name></name> <operator>=</operator> <name>float_result</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>types</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>NUMERICOID</name> <operator>||</operator>
        <operator>(</operator><name><name>types</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>AGTYPEOID</name> <operator>&amp;&amp;</operator> <name>type</name> <operator>==</operator> <name>AGTV_NUMERIC</name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>agtv_result</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>AGTV_NUMERIC</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>agtv_result</name><operator>.</operator><name>val</name><operator>.</operator><name>numeric</name></name> <operator>=</operator> <name>numeric_result</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><call><name>agtype_value_to_agtype</name><argument_list>(<argument><expr><operator>&amp;</operator><name>agtv_result</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>age_sign</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><name>Datum</name></type> <name>age_sign</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>nargs</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name> <modifier>*</modifier></type><name>args</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name> <modifier>*</modifier></type><name>nulls</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name> <modifier>*</modifier></type><name>types</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_value</name></type> <name>agtv_result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Numeric</name></type> <name>arg</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Numeric</name></type> <name>numeric_result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>int_result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>is_null</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* extract argument values */</comment>
    <expr_stmt><expr><name>nargs</name> <operator>=</operator> <call><name>extract_variadic_args</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>args</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>types</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* check number of args */</comment>
    <if_stmt><if>if <condition>(<expr><name>nargs</name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                        <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"sign() invalid number of arguments"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* check for a null input */</comment>
    <if_stmt><if>if <condition>(<expr><name>nargs</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>nulls</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * sign() supports integer, float, and numeric or the agtype integer,
     * float, and numeric for the input expression.
     */</comment>
    <expr_stmt><expr><name>arg</name> <operator>=</operator> <call><name>get_numeric_compatible_arg</name><argument_list>(<argument><expr><name><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>types</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"sign"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>is_null</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* check for a agtype null input */</comment>
    <if_stmt><if>if <condition>(<expr><name>is_null</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* We need the input as a numeric so that we can pass it off to PG */</comment>
    <expr_stmt><expr><name>numeric_result</name> <operator>=</operator> <call><name>DatumGetNumeric</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>numeric_sign</name></expr></argument>,
                                                         <argument><expr><call><name>NumericGetDatum</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>int_result</name> <operator>=</operator> <call><name>DatumGetInt64</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>numeric_int8</name></expr></argument>,
                                                   <argument><expr><call><name>NumericGetDatum</name><argument_list>(<argument><expr><name>numeric_result</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* build the result */</comment>
    <expr_stmt><expr><name><name>agtv_result</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>AGTV_INTEGER</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>agtv_result</name><operator>.</operator><name>val</name><operator>.</operator><name>int_value</name></name> <operator>=</operator> <name>int_result</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><call><name>agtype_value_to_agtype</name><argument_list>(<argument><expr><operator>&amp;</operator><name>agtv_result</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>age_log</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><name>Datum</name></type> <name>age_log</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>nargs</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name> <modifier>*</modifier></type><name>args</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name> <modifier>*</modifier></type><name>nulls</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name> <modifier>*</modifier></type><name>types</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_value</name></type> <name>agtv_result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Numeric</name></type> <name>arg</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Numeric</name></type> <name>zero</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Numeric</name></type> <name>numeric_result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>float8</name></type> <name>float_result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>is_null</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>test</name></decl>;</decl_stmt>

    <comment type="block">/* extract argument values */</comment>
    <expr_stmt><expr><name>nargs</name> <operator>=</operator> <call><name>extract_variadic_args</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>args</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>types</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* check number of args */</comment>
    <if_stmt><if>if <condition>(<expr><name>nargs</name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                        <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"log() invalid number of arguments"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* check for a null input */</comment>
    <if_stmt><if>if <condition>(<expr><name>nargs</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>nulls</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * log() supports integer, float, and numeric or the agtype integer,
     * float, and numeric for the input expression.
     */</comment>
    <expr_stmt><expr><name>arg</name> <operator>=</operator> <call><name>get_numeric_compatible_arg</name><argument_list>(<argument><expr><name><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>types</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"log"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>is_null</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* check for a agtype null input */</comment>
    <if_stmt><if>if <condition>(<expr><name>is_null</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* get a numeric 0 as a datum to test &lt;= 0 log args */</comment>
    <expr_stmt><expr><name>zero</name> <operator>=</operator> <call><name>DatumGetNumeric</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>int8_numeric</name></expr></argument>, <argument><expr><call><name>Int64GetDatum</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>test</name> <operator>=</operator> <call><name>DatumGetInt32</name><argument_list>(<argument><expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>numeric_cmp</name></expr></argument>, <argument><expr><call><name>NumericGetDatum</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></argument>,
                                             <argument><expr><call><name>NumericGetDatum</name><argument_list>(<argument><expr><name>zero</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* return null if the argument is &lt;= 0; these are invalid args for logs */</comment>
    <if_stmt><if>if <condition>(<expr><name>test</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* We need the input as a numeric so that we can pass it off to PG */</comment>
    <expr_stmt><expr><name>numeric_result</name> <operator>=</operator> <call><name>DatumGetNumeric</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>numeric_ln</name></expr></argument>,
                                                         <argument><expr><call><name>NumericGetDatum</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>float_result</name> <operator>=</operator> <call><name>DatumGetFloat8</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>numeric_float8_no_overflow</name></expr></argument>,
                                                      <argument><expr><call><name>NumericGetDatum</name><argument_list>(<argument><expr><name>numeric_result</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* build the result */</comment>
    <expr_stmt><expr><name><name>agtv_result</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>AGTV_FLOAT</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>agtv_result</name><operator>.</operator><name>val</name><operator>.</operator><name>float_value</name></name> <operator>=</operator> <name>float_result</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><call><name>agtype_value_to_agtype</name><argument_list>(<argument><expr><operator>&amp;</operator><name>agtv_result</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>age_log10</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><name>Datum</name></type> <name>age_log10</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>nargs</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name> <modifier>*</modifier></type><name>args</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name> <modifier>*</modifier></type><name>nulls</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name> <modifier>*</modifier></type><name>types</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_value</name></type> <name>agtv_result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Numeric</name></type> <name>arg</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Numeric</name></type> <name>zero</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Numeric</name></type> <name>numeric_result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>float8</name></type> <name>float_result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type> <name>base</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>is_null</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>test</name></decl>;</decl_stmt>

    <comment type="block">/* extract argument values */</comment>
    <expr_stmt><expr><name>nargs</name> <operator>=</operator> <call><name>extract_variadic_args</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>args</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>types</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* check number of args */</comment>
    <if_stmt><if>if <condition>(<expr><name>nargs</name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                        <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"log() invalid number of arguments"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* check for a null input */</comment>
    <if_stmt><if>if <condition>(<expr><name>nargs</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>nulls</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * log10() supports integer, float, and numeric or the agtype integer,
     * float, and numeric for the input expression.
     */</comment>
    <expr_stmt><expr><name>arg</name> <operator>=</operator> <call><name>get_numeric_compatible_arg</name><argument_list>(<argument><expr><name><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>types</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"log10"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>is_null</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* check for a agtype null input */</comment>
    <if_stmt><if>if <condition>(<expr><name>is_null</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* get a numeric 0 as a datum to test &lt;= 0 log args */</comment>
    <expr_stmt><expr><name>zero</name> <operator>=</operator> <call><name>DatumGetNumeric</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>int8_numeric</name></expr></argument>, <argument><expr><call><name>Int64GetDatum</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>test</name> <operator>=</operator> <call><name>DatumGetInt32</name><argument_list>(<argument><expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>numeric_cmp</name></expr></argument>, <argument><expr><call><name>NumericGetDatum</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></argument>,
                                             <argument><expr><call><name>NumericGetDatum</name><argument_list>(<argument><expr><name>zero</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* return null if the argument is &lt;= 0; these are invalid args for logs */</comment>
    <if_stmt><if>if <condition>(<expr><name>test</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* get a numeric 10 as a datum for the base */</comment>
    <expr_stmt><expr><name>base</name> <operator>=</operator> <call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>float8_numeric</name></expr></argument>, <argument><expr><call><name>Float8GetDatum</name><argument_list>(<argument><expr><literal type="number">10.0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* We need the input as a numeric so that we can pass it off to PG */</comment>
    <expr_stmt><expr><name>numeric_result</name> <operator>=</operator> <call><name>DatumGetNumeric</name><argument_list>(<argument><expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>numeric_log</name></expr></argument>, <argument><expr><name>base</name></expr></argument>,
                                                         <argument><expr><call><name>NumericGetDatum</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>float_result</name> <operator>=</operator> <call><name>DatumGetFloat8</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>numeric_float8_no_overflow</name></expr></argument>,
                                                      <argument><expr><call><name>NumericGetDatum</name><argument_list>(<argument><expr><name>numeric_result</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* build the result */</comment>
    <expr_stmt><expr><name><name>agtv_result</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>AGTV_FLOAT</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>agtv_result</name><operator>.</operator><name>val</name><operator>.</operator><name>float_value</name></name> <operator>=</operator> <name>float_result</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><call><name>agtype_value_to_agtype</name><argument_list>(<argument><expr><operator>&amp;</operator><name>agtv_result</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>age_e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><name>Datum</name></type> <name>age_e</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>agtype_value</name></type> <name>agtv_result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>float8</name></type> <name>float_result</name></decl>;</decl_stmt>

    <comment type="block">/* get e by raising e to 1 - no, they don't have a constant e :/ */</comment>
    <expr_stmt><expr><name>float_result</name> <operator>=</operator> <call><name>DatumGetFloat8</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>dexp</name></expr></argument>, <argument><expr><call><name>Float8GetDatum</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* build the result */</comment>
    <expr_stmt><expr><name><name>agtv_result</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>AGTV_FLOAT</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>agtv_result</name><operator>.</operator><name>val</name><operator>.</operator><name>float_value</name></name> <operator>=</operator> <name>float_result</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><call><name>agtype_value_to_agtype</name><argument_list>(<argument><expr><operator>&amp;</operator><name>agtv_result</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>age_exp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><name>Datum</name></type> <name>age_exp</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>nargs</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name> <modifier>*</modifier></type><name>args</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name> <modifier>*</modifier></type><name>nulls</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name> <modifier>*</modifier></type><name>types</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_value</name></type> <name>agtv_result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Numeric</name></type> <name>arg</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Numeric</name></type> <name>numeric_result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>float8</name></type> <name>float_result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>is_null</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* extract argument values */</comment>
    <expr_stmt><expr><name>nargs</name> <operator>=</operator> <call><name>extract_variadic_args</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>args</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>types</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* check number of args */</comment>
    <if_stmt><if>if <condition>(<expr><name>nargs</name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                        <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"exp() invalid number of arguments"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* check for a null input */</comment>
    <if_stmt><if>if <condition>(<expr><name>nargs</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>nulls</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * exp() supports integer, float, and numeric or the agtype integer,
     * float, and numeric for the input expression.
     */</comment>
    <expr_stmt><expr><name>arg</name> <operator>=</operator> <call><name>get_numeric_compatible_arg</name><argument_list>(<argument><expr><name><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>types</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"exp"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>is_null</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* check for a agtype null input */</comment>
    <if_stmt><if>if <condition>(<expr><name>is_null</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* We need the input as a numeric so that we can pass it off to PG */</comment>
    <expr_stmt><expr><name>numeric_result</name> <operator>=</operator> <call><name>DatumGetNumeric</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>numeric_exp</name></expr></argument>,
                                                         <argument><expr><call><name>NumericGetDatum</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>float_result</name> <operator>=</operator> <call><name>DatumGetFloat8</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>numeric_float8_no_overflow</name></expr></argument>,
                                                      <argument><expr><call><name>NumericGetDatum</name><argument_list>(<argument><expr><name>numeric_result</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* build the result */</comment>
    <expr_stmt><expr><name><name>agtv_result</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>AGTV_FLOAT</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>agtv_result</name><operator>.</operator><name>val</name><operator>.</operator><name>float_value</name></name> <operator>=</operator> <name>float_result</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><call><name>agtype_value_to_agtype</name><argument_list>(<argument><expr><operator>&amp;</operator><name>agtv_result</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>age_sqrt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><name>Datum</name></type> <name>age_sqrt</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>nargs</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name> <modifier>*</modifier></type><name>args</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name> <modifier>*</modifier></type><name>nulls</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name> <modifier>*</modifier></type><name>types</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_value</name></type> <name>agtv_result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Numeric</name></type> <name>arg</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Numeric</name></type> <name>zero</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Numeric</name></type> <name>numeric_result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>float8</name></type> <name>float_result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>is_null</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>test</name></decl>;</decl_stmt>

    <comment type="block">/* extract argument values */</comment>
    <expr_stmt><expr><name>nargs</name> <operator>=</operator> <call><name>extract_variadic_args</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>args</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>types</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* check number of args */</comment>
    <if_stmt><if>if <condition>(<expr><name>nargs</name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                        <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"sqrt() invalid number of arguments"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* check for a null input */</comment>
    <if_stmt><if>if <condition>(<expr><name>nargs</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>nulls</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * sqrt() supports integer, float, and numeric or the agtype integer,
     * float, and numeric for the input expression.
     */</comment>
    <expr_stmt><expr><name>arg</name> <operator>=</operator> <call><name>get_numeric_compatible_arg</name><argument_list>(<argument><expr><name><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>types</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"sqrt"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>is_null</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* check for a agtype null input */</comment>
    <if_stmt><if>if <condition>(<expr><name>is_null</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* get a numeric 0 as a datum to test &lt; 0 sqrt args */</comment>
    <expr_stmt><expr><name>zero</name> <operator>=</operator> <call><name>DatumGetNumeric</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>int8_numeric</name></expr></argument>, <argument><expr><call><name>Int64GetDatum</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>test</name> <operator>=</operator> <call><name>DatumGetInt32</name><argument_list>(<argument><expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>numeric_cmp</name></expr></argument>, <argument><expr><call><name>NumericGetDatum</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></argument>,
                                             <argument><expr><call><name>NumericGetDatum</name><argument_list>(<argument><expr><name>zero</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* return null if the argument is &lt; 0; these are invalid args for sqrt */</comment>
    <if_stmt><if>if <condition>(<expr><name>test</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* We need the input as a numeric so that we can pass it off to PG */</comment>
    <expr_stmt><expr><name>numeric_result</name> <operator>=</operator> <call><name>DatumGetNumeric</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>numeric_sqrt</name></expr></argument>,
                                                         <argument><expr><call><name>NumericGetDatum</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>float_result</name> <operator>=</operator> <call><name>DatumGetFloat8</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>numeric_float8_no_overflow</name></expr></argument>,
                                                      <argument><expr><call><name>NumericGetDatum</name><argument_list>(<argument><expr><name>numeric_result</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* build the result */</comment>
    <expr_stmt><expr><name><name>agtv_result</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>AGTV_FLOAT</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>agtv_result</name><operator>.</operator><name>val</name><operator>.</operator><name>float_value</name></name> <operator>=</operator> <name>float_result</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><call><name>agtype_value_to_agtype</name><argument_list>(<argument><expr><operator>&amp;</operator><name>agtv_result</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>age_timestamp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><name>Datum</name></type> <name>age_timestamp</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>agtype_value</name></type> <name>agtv_result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>timespec</name></name></type> <name>ts</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>long</name></type> <name>ms</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <comment type="block">/* get the system time and convert it to milliseconds */</comment>
    <expr_stmt><expr><call><name>clock_gettime</name><argument_list>(<argument><expr><name>CLOCK_REALTIME</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>ms</name> <operator>+=</operator> <operator>(</operator><name><name>ts</name><operator>.</operator><name>tv_sec</name></name> <operator>*</operator> <literal type="number">1000</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><name><name>ts</name><operator>.</operator><name>tv_nsec</name></name> <operator>/</operator> <literal type="number">1000000</literal><operator>)</operator></expr>;</expr_stmt>

    <comment type="block">/* build the result */</comment>
    <expr_stmt><expr><name><name>agtv_result</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>AGTV_INTEGER</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>agtv_result</name><operator>.</operator><name>val</name><operator>.</operator><name>int_value</name></name> <operator>=</operator> <name>ms</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><call><name>agtype_value_to_agtype</name><argument_list>(<argument><expr><operator>&amp;</operator><name>agtv_result</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Converts an agtype object or array to a binary agtype_value.
 */</comment>
<function><type><name>agtype_value</name> <modifier>*</modifier></type><name>agtype_composite_to_agtype_value_binary</name><parameter_list>(<parameter><decl><type><name>agtype</name> <modifier>*</modifier></type><name>a</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>AGTYPE_CONTAINER_IS_SCALAR</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>root</name></name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                        <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot convert agtype scalar objects to binary agtype_value objects"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>agtype_value</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// convert the agtype to a binary agtype_value</comment>
    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>AGTV_BINARY</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>binary</name><operator>.</operator><name>len</name></name> <operator>=</operator> <call><name>AGTYPE_CONTAINER_SIZE</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>root</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>binary</name><operator>.</operator><name>data</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>root</name></name></expr>;</expr_stmt>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * For the given properties, update the property with the key equal
 * to var_name with the value defined in new_v. If the remove_property
 * flag is set, simply remove the property with the given property
 * name instead.
 */</comment>
<function><type><name>agtype_value</name> <modifier>*</modifier></type><name>alter_property_value</name><parameter_list>(<parameter><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>properties</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>var_name</name></decl></parameter>,
                                   <parameter><decl><type><name>agtype</name> <modifier>*</modifier></type><name>new_v</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>remove_property</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>agtype_iterator</name> <modifier>*</modifier></type><name>it</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_iterator_token</name></type> <name>tok</name> <init>= <expr><name>WAGT_DONE</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_parse_state</name> <modifier>*</modifier></type><name>parse_state</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>r</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype</name> <modifier>*</modifier></type><name>prop_agtype</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>parsed_agtype_value</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>found</name></decl>;</decl_stmt>

    <comment type="line">// if no properties, return NULL</comment>
    <if_stmt><if>if <condition>(<expr><name>properties</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <return>return <expr><name>NULL</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="line">// if properties is not an object, throw an error</comment>
    <if_stmt><if>if <condition>(<expr><name><name>properties</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>AGTV_OBJECT</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                        <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"can only update objects"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>agtype_value</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>prop_agtype</name> <operator>=</operator> <call><name>agtype_value_to_agtype</name><argument_list>(<argument><expr><name>properties</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>it</name> <operator>=</operator> <call><name>agtype_iterator_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>prop_agtype</name><operator>-&gt;</operator><name>root</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>tok</name> <operator>=</operator> <call><name>agtype_iterator_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name>it</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>parsed_agtype_value</name> <operator>=</operator> <call><name>push_agtype_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name>parse_state</name></expr></argument>, <argument><expr><name>tok</name></expr></argument>, <argument><expr><ternary><condition><expr><name>tok</name> <operator>&lt;</operator> <name>WAGT_BEGIN_ARRAY</name></expr> ?</condition><then> <expr><name>r</name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * If the new value is NULL, this is equivalent to the remove_property
     * flag set to true.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>new_v</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>remove_property</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>found</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <while>while <condition>(<expr><name>true</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>tok</name> <operator>=</operator> <call><name>agtype_iterator_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name>it</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>tok</name> <operator>==</operator> <name>WAGT_DONE</name> <operator>||</operator> <name>tok</name> <operator>==</operator> <name>WAGT_END_OBJECT</name></expr>)</condition>
        <block>{<block_content>
            <break>break;</break>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>pnstrdup</name><argument_list>(<argument><expr><name><name>r</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>val</name></name></expr></argument>, <argument><expr><name><name>r</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Check the key value, if it is equal to the passed in
         * var_name, replace the value for this key with the passed
         * in agtype. Otherwise pass the existing value to the
         * new properties agtype_value.
         */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>var_name</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <comment type="line">// push the key</comment>
            <expr_stmt><expr><name>parsed_agtype_value</name> <operator>=</operator> <call><name>push_agtype_value</name><argument_list>(
                <argument><expr><operator>&amp;</operator><name>parse_state</name></expr></argument>, <argument><expr><name>tok</name></expr></argument>, <argument><expr><ternary><condition><expr><name>tok</name> <operator>&lt;</operator> <name>WAGT_BEGIN_ARRAY</name></expr> ?</condition><then> <expr><name>r</name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="line">// get the value and push the value</comment>
            <expr_stmt><expr><name>tok</name> <operator>=</operator> <call><name>agtype_iterator_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name>it</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>parsed_agtype_value</name> <operator>=</operator> <call><name>push_agtype_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name>parse_state</name></expr></argument>, <argument><expr><name>tok</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <decl_stmt><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>new_agtype_value_v</name></decl>;</decl_stmt>

            <comment type="line">// if the remove flag is set, don't push the key or any value</comment>
            <if_stmt><if>if<condition>(<expr><name>remove_property</name></expr>)</condition>
            <block>{<block_content>
                <comment type="line">// skip the value</comment>
                <expr_stmt><expr><name>tok</name> <operator>=</operator> <call><name>agtype_iterator_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name>it</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <continue>continue;</continue>
            </block_content>}</block></if></if_stmt>

            <comment type="line">// push the key</comment>
            <expr_stmt><expr><name>parsed_agtype_value</name> <operator>=</operator> <call><name>push_agtype_value</name><argument_list>(
                <argument><expr><operator>&amp;</operator><name>parse_state</name></expr></argument>, <argument><expr><name>tok</name></expr></argument>, <argument><expr><ternary><condition><expr><name>tok</name> <operator>&lt;</operator> <name>WAGT_BEGIN_ARRAY</name></expr> ?</condition><then> <expr><name>r</name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="line">// skip the existing value for the key</comment>
            <expr_stmt><expr><name>tok</name> <operator>=</operator> <call><name>agtype_iterator_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name>it</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/*
             * If the the new agtype is scalar, push the agtype_value to the
             * parse state. If the agtype is an object or array convert the
             * agtype to a binary agtype_value to pass to the parse_state.
             * This will save uncessary deserialization and serialization
             * logic from running.
             */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>AGTYPE_CONTAINER_IS_SCALAR</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>new_v</name><operator>-&gt;</operator><name>root</name></name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <comment type="line">//get the scalar value and push as the value</comment>
                <expr_stmt><expr><name>new_agtype_value_v</name> <operator>=</operator> <call><name>get_ith_agtype_value_from_container</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>new_v</name><operator>-&gt;</operator><name>root</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><name>parsed_agtype_value</name> <operator>=</operator> <call><name>push_agtype_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name>parse_state</name></expr></argument>, <argument><expr><name>WAGT_VALUE</name></expr></argument>, <argument><expr><name>new_agtype_value_v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <decl_stmt><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><call><name>agtype_composite_to_agtype_value_binary</name><argument_list>(<argument><expr><name>new_v</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <expr_stmt><expr><name>parsed_agtype_value</name> <operator>=</operator> <call><name>push_agtype_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name>parse_state</name></expr></argument>, <argument><expr><name>WAGT_VALUE</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>

            <expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></while>

    <comment type="block">/*
     * If we have not found the property and we aren't trying to remove it,
     * add the key/value pair now.
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>remove_property</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>new_agtype_value_v</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>key</name> <init>= <expr><call><name>string_to_agtype_value</name><argument_list>(<argument><expr><name>var_name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// push the new key</comment>
        <expr_stmt><expr><name>parsed_agtype_value</name> <operator>=</operator> <call><name>push_agtype_value</name><argument_list>(
            <argument><expr><operator>&amp;</operator><name>parse_state</name></expr></argument>, <argument><expr><name>WAGT_KEY</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * If the the new agtype is scalar, push the agtype_value to the
         * parse state. If the agtype is an object or array convert the
         * agtype to a binary agtype_value to pass to the parse_state.
         * This will save uncessary deserialization and serialization
         * logic from running.
         */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>AGTYPE_CONTAINER_IS_SCALAR</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>new_v</name><operator>-&gt;</operator><name>root</name></name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>new_agtype_value_v</name> <operator>=</operator> <call><name>get_ith_agtype_value_from_container</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>new_v</name><operator>-&gt;</operator><name>root</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="line">// convert the agtype array or object to a binary agtype_value</comment>
            <expr_stmt><expr><name>parsed_agtype_value</name> <operator>=</operator> <call><name>push_agtype_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name>parse_state</name></expr></argument>, <argument><expr><name>WAGT_VALUE</name></expr></argument>, <argument><expr><name>new_agtype_value_v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <decl_stmt><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><call><name>agtype_composite_to_agtype_value_binary</name><argument_list>(<argument><expr><name>new_v</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><name>parsed_agtype_value</name> <operator>=</operator> <call><name>push_agtype_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name>parse_state</name></expr></argument>, <argument><expr><name>WAGT_VALUE</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="line">// push the end object token to parse state</comment>
    <expr_stmt><expr><name>parsed_agtype_value</name> <operator>=</operator> <call><name>push_agtype_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name>parse_state</name></expr></argument>, <argument><expr><name>WAGT_END_OBJECT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>parsed_agtype_value</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Helper function to extract 1 datum from a variadic "any" and convert, if
 * possible, to an agtype, if it isn't already.
 *
 * If the value is a NULL or agtype NULL, the function returns NULL.
 * If the datum cannot be converted, the function will error out in
 * extract_variadic_args.
 */</comment>
<function><type><name>agtype</name> <modifier>*</modifier></type><name>get_one_agtype_from_variadic_args</name><parameter_list>(<parameter><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name></decl></parameter>,
                                                 <parameter><decl><type><name>int</name></type> <name>variadic_offset</name></decl></parameter>,
                                                 <parameter><decl><type><name>int</name></type> <name>expected_nargs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>nargs</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name> <modifier>*</modifier></type><name>args</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name> <modifier>*</modifier></type><name>nulls</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name> <modifier>*</modifier></type><name>types</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype</name> <modifier>*</modifier></type><name>agtype_result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>nargs</name> <operator>=</operator> <call><name>extract_variadic_args</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>variadic_offset</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>args</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>types</name></expr></argument>,
                                  <argument><expr><operator>&amp;</operator><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* throw an error if the number of args is not the expected number */</comment>
    <if_stmt><if>if <condition>(<expr><name>nargs</name> <operator>!=</operator> <name>expected_nargs</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                        <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"number of args %d does not match expected %d"</literal></expr></argument>,
                               <argument><expr><name>nargs</name></expr></argument>, <argument><expr><name>expected_nargs</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <comment type="block">/* if null, return null */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>nulls</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition>
    <block>{<block_content>
        <return>return <expr><name>NULL</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* if type is AGTYPEOID, we don't need to convert it */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>types</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>AGTYPEOID</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>agtype_container</name> <modifier>*</modifier></type><name>agtc</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>agtype_result</name> <operator>=</operator> <call><name>DATUM_GET_AGTYPE_P</name><argument_list>(<argument><expr><name><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>agtc</name> <operator>=</operator> <operator>&amp;</operator><name><name>agtype_result</name><operator>-&gt;</operator><name>root</name></name></expr>;</expr_stmt>

        <comment type="block">/*
         * Is this a scalar (scalars are stored as one element arrays)? If so,
         * test for agtype NULL.
         */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>AGTYPE_CONTAINER_IS_SCALAR</name><argument_list>(<argument><expr><name>agtc</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
            <call><name>AGTE_IS_NULL</name><argument_list>(<argument><expr><name><name>agtc</name><operator>-&gt;</operator><name>children</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <return>return <expr><name>NULL</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if>
    <comment type="block">/* otherwise, try to convert it to an agtype */</comment>
    <else>else
    <block>{<block_content>
        <decl_stmt><decl><type><name>agtype_in_state</name></type> <name>state</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>agt_type_category</name></type> <name>tcategory</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Oid</name></type> <name>outfuncoid</name></decl>;</decl_stmt>

        <comment type="block">/* we need an empty state */</comment>
        <expr_stmt><expr><name><name>state</name><operator>.</operator><name>parse_state</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>state</name><operator>.</operator><name>res</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <comment type="block">/* get the category for the datum */</comment>
        <expr_stmt><expr><call><name>agtype_categorize_type</name><argument_list>(<argument><expr><name><name>types</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tcategory</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>outfuncoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* convert it to an agtype_value */</comment>
        <expr_stmt><expr><call><name>datum_to_agtype</name><argument_list>(<argument><expr><name><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><name>tcategory</name></expr></argument>, <argument><expr><name>outfuncoid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* convert it to an agtype */</comment>
        <expr_stmt><expr><name>agtype_result</name> <operator>=</operator> <call><name>agtype_value_to_agtype</name><argument_list>(<argument><expr><name><name>state</name><operator>.</operator><name>res</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <return>return <expr><name>agtype_result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Transfer function for age_sum(agtype, agtype).
 *
 * Note: that the running sum will change type depending on the
 * precision of the input. The most precise value determines the
 * result type.
 *
 * Note: The sql definition is STRICT so no input NULLs need to
 * be dealt with except for agtype.
 */</comment>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>age_agtype_sum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><name>Datum</name></type> <name>age_agtype_sum</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>agtype</name> <modifier>*</modifier></type><name>agt_arg0</name> <init>= <expr><call><name>AG_GET_ARG_AGTYPE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype</name> <modifier>*</modifier></type><name>agt_arg1</name> <init>= <expr><call><name>AG_GET_ARG_AGTYPE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>agtv_lhs</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>agtv_rhs</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_value</name></type> <name>agtv_result</name></decl>;</decl_stmt>

    <comment type="block">/* get our args */</comment>
    <expr_stmt><expr><name>agt_arg0</name> <operator>=</operator> <call><name>AG_GET_ARG_AGTYPE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>agt_arg1</name> <operator>=</operator> <call><name>AG_GET_ARG_AGTYPE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* only scalars are allowed */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AGT_ROOT_IS_SCALAR</name><argument_list>(<argument><expr><name>agt_arg0</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>AGT_ROOT_IS_SCALAR</name><argument_list>(<argument><expr><name>agt_arg1</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"arguments must resolve to a scalar"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* get the values */</comment>
    <expr_stmt><expr><name>agtv_lhs</name> <operator>=</operator> <call><name>get_ith_agtype_value_from_container</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>agt_arg0</name><operator>-&gt;</operator><name>root</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>agtv_rhs</name> <operator>=</operator> <call><name>get_ith_agtype_value_from_container</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>agt_arg1</name><operator>-&gt;</operator><name>root</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* only numbers are allowed */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>agtv_lhs</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>AGTV_INTEGER</name> <operator>&amp;&amp;</operator> <name><name>agtv_lhs</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>AGTV_FLOAT</name> <operator>&amp;&amp;</operator>
         <name><name>agtv_lhs</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>AGTV_NUMERIC</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name><name>agtv_rhs</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>AGTV_INTEGER</name> <operator>&amp;&amp;</operator>
        <name><name>agtv_rhs</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>AGTV_FLOAT</name> <operator>&amp;&amp;</operator> <name><name>agtv_rhs</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>AGTV_NUMERIC</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"arguments must resolve to a number"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* check for agtype null */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>agtv_lhs</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AGTV_NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><name>agt_arg1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>agtv_rhs</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AGTV_NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><name>agt_arg0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* we want to maintain the precision of the most precise input */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>agtv_lhs</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AGTV_NUMERIC</name> <operator>||</operator> <name><name>agtv_rhs</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AGTV_NUMERIC</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>agtv_result</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>AGTV_NUMERIC</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name><name>agtv_lhs</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AGTV_FLOAT</name> <operator>||</operator> <name><name>agtv_rhs</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AGTV_FLOAT</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>agtv_result</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>AGTV_FLOAT</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name><name>agtv_result</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>AGTV_INTEGER</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* switch on the type to perform the correct addition */</comment>
    <switch>switch<condition>(<expr><name><name>agtv_result</name><operator>.</operator><name>type</name></name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* if the type is integer, they are obviously both ints */</comment>
        <case>case <expr><name>AGTV_INTEGER</name></expr>:</case>
            <expr_stmt><expr><name><name>agtv_result</name><operator>.</operator><name>val</name><operator>.</operator><name>int_value</name></name> <operator>=</operator> <call><name>DatumGetInt64</name><argument_list>(
                <argument><expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>int8pl</name></expr></argument>,
                                    <argument><expr><call><name>Int64GetDatum</name><argument_list>(<argument><expr><name><name>agtv_lhs</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>int_value</name></name></expr></argument>)</argument_list></call></expr></argument>,
                                    <argument><expr><call><name>Int64GetDatum</name><argument_list>(<argument><expr><name><name>agtv_rhs</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>int_value</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <comment type="block">/* for float it can be either, float + float or float + int */</comment>
        <case>case <expr><name>AGTV_FLOAT</name></expr>:</case>
        <block>{<block_content>
            <decl_stmt><decl><type><name>Datum</name></type> <name>dfl</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Datum</name></type> <name>dfr</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Datum</name></type> <name>dresult</name></decl>;</decl_stmt>
            <comment type="block">/* extract and convert the values as necessary */</comment>
            <comment type="block">/* float + float */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>agtv_lhs</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AGTV_FLOAT</name> <operator>&amp;&amp;</operator> <name><name>agtv_rhs</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AGTV_FLOAT</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>dfl</name> <operator>=</operator> <call><name>Float8GetDatum</name><argument_list>(<argument><expr><name><name>agtv_lhs</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>float_value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>dfr</name> <operator>=</operator> <call><name>Float8GetDatum</name><argument_list>(<argument><expr><name><name>agtv_rhs</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>float_value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <comment type="block">/* float + int */</comment>
            <else>else
            <block>{<block_content>
                <decl_stmt><decl><type><name>int64</name></type> <name>ival</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>float8</name></type> <name>fval</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>bool</name></type> <name>is_null</name></decl>;</decl_stmt>

                <expr_stmt><expr><name>ival</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>agtv_lhs</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AGTV_INTEGER</name><operator>)</operator></expr> ?</condition><then>
                    <expr><name><name>agtv_lhs</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>int_value</name></name></expr> </then><else>: <expr><name><name>agtv_rhs</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>int_value</name></name></expr></else></ternary></expr>;</expr_stmt>
                <expr_stmt><expr><name>fval</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>agtv_lhs</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AGTV_FLOAT</name><operator>)</operator></expr> ?</condition><then>
                    <expr><name><name>agtv_lhs</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>float_value</name></name></expr> </then><else>: <expr><name><name>agtv_rhs</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>float_value</name></name></expr></else></ternary></expr>;</expr_stmt>

                <expr_stmt><expr><name>dfl</name> <operator>=</operator> <call><name>Float8GetDatum</name><argument_list>(<argument><expr><call><name>get_float_compatible_arg</name><argument_list>(<argument><expr><call><name>Int64GetDatum</name><argument_list>(<argument><expr><name>ival</name></expr></argument>)</argument_list></call></expr></argument>,
                                                              <argument><expr><name>INT8OID</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>,
                                                              <argument><expr><operator>&amp;</operator><name>is_null</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>dfr</name> <operator>=</operator> <call><name>Float8GetDatum</name><argument_list>(<argument><expr><name>fval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
            <comment type="block">/* add the floats and set the result */</comment>
            <expr_stmt><expr><name>dresult</name> <operator>=</operator> <call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>float8pl</name></expr></argument>, <argument><expr><name>dfl</name></expr></argument>, <argument><expr><name>dfr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>agtv_result</name><operator>.</operator><name>val</name><operator>.</operator><name>float_value</name></name> <operator>=</operator> <call><name>DatumGetFloat8</name><argument_list>(<argument><expr><name>dresult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
            <break>break;</break>
        <comment type="block">/*
         * For numeric it can be either, numeric + numeric or numeric + float or
         * numeric + int
         */</comment>
        <case>case <expr><name>AGTV_NUMERIC</name></expr>:</case>
        <block>{<block_content>
            <decl_stmt><decl><type><name>Datum</name></type> <name>dnl</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Datum</name></type> <name>dnr</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Datum</name></type> <name>dresult</name></decl>;</decl_stmt>
            <comment type="block">/* extract and convert the values as necessary */</comment>
            <comment type="block">/* numeric + numeric */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>agtv_lhs</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AGTV_NUMERIC</name> <operator>&amp;&amp;</operator> <name><name>agtv_rhs</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AGTV_NUMERIC</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>dnl</name> <operator>=</operator> <call><name>NumericGetDatum</name><argument_list>(<argument><expr><name><name>agtv_lhs</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>numeric</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>dnr</name> <operator>=</operator> <call><name>NumericGetDatum</name><argument_list>(<argument><expr><name><name>agtv_rhs</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>numeric</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <comment type="block">/* numeric + float */</comment>
            <if type="elseif">else if <condition>(<expr><name><name>agtv_lhs</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AGTV_FLOAT</name> <operator>||</operator> <name><name>agtv_rhs</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AGTV_FLOAT</name></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>float8</name></type> <name>fval</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>Numeric</name></type> <name>nval</name></decl>;</decl_stmt>

                <expr_stmt><expr><name>fval</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>agtv_lhs</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AGTV_FLOAT</name><operator>)</operator></expr> ?</condition><then>
                    <expr><name><name>agtv_lhs</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>float_value</name></name></expr> </then><else>: <expr><name><name>agtv_rhs</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>float_value</name></name></expr></else></ternary></expr>;</expr_stmt>
                <expr_stmt><expr><name>nval</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>agtv_lhs</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AGTV_NUMERIC</name><operator>)</operator></expr> ?</condition><then>
                    <expr><name><name>agtv_lhs</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>numeric</name></name></expr> </then><else>: <expr><name><name>agtv_rhs</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>numeric</name></name></expr></else></ternary></expr>;</expr_stmt>

                <expr_stmt><expr><name>dnl</name> <operator>=</operator> <call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>float8_numeric</name></expr></argument>, <argument><expr><call><name>Float8GetDatum</name><argument_list>(<argument><expr><name>fval</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>dnr</name> <operator>=</operator> <call><name>NumericGetDatum</name><argument_list>(<argument><expr><name>nval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <comment type="block">/* numeric + int */</comment>
            <else>else
            <block>{<block_content>
                <decl_stmt><decl><type><name>int64</name></type> <name>ival</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>Numeric</name></type> <name>nval</name></decl>;</decl_stmt>

                <expr_stmt><expr><name>ival</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>agtv_lhs</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AGTV_INTEGER</name><operator>)</operator></expr> ?</condition><then>
                    <expr><name><name>agtv_lhs</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>int_value</name></name></expr> </then><else>: <expr><name><name>agtv_rhs</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>int_value</name></name></expr></else></ternary></expr>;</expr_stmt>
                <expr_stmt><expr><name>nval</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>agtv_lhs</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AGTV_NUMERIC</name><operator>)</operator></expr> ?</condition><then>
                    <expr><name><name>agtv_lhs</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>numeric</name></name></expr> </then><else>: <expr><name><name>agtv_rhs</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>numeric</name></name></expr></else></ternary></expr>;</expr_stmt>

                <expr_stmt><expr><name>dnl</name> <operator>=</operator> <call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>int8_numeric</name></expr></argument>, <argument><expr><call><name>Int64GetDatum</name><argument_list>(<argument><expr><name>ival</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>dnr</name> <operator>=</operator> <call><name>NumericGetDatum</name><argument_list>(<argument><expr><name>nval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
            <comment type="block">/* add the numerics and set the result */</comment>
            <expr_stmt><expr><name>dresult</name> <operator>=</operator> <call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>numeric_add</name></expr></argument>, <argument><expr><name>dnl</name></expr></argument>, <argument><expr><name>dnr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>agtv_result</name><operator>.</operator><name>val</name><operator>.</operator><name>numeric</name></name> <operator>=</operator> <call><name>DatumGetNumeric</name><argument_list>(<argument><expr><name>dresult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
            <break>break;</break>

        <default>default:</default>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected agtype"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
    </block_content>}</block></switch>
    <comment type="block">/* return the result */</comment>
    <expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><call><name>agtype_value_to_agtype</name><argument_list>(<argument><expr><operator>&amp;</operator><name>agtv_result</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Wrapper function for float8_accum to take an agtype input.
 * This function is defined as STRICT so it does not need to check
 * for NULL input parameters
 */</comment>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>age_agtype_float8_accum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><name>Datum</name></type> <name>age_agtype_float8_accum</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Datum</name></type> <name>dfloat</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type> <name>result</name></decl>;</decl_stmt>

    <comment type="block">/* convert to a float8 datum, if possible */</comment>
    <expr_stmt><expr><name>dfloat</name> <operator>=</operator> <call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>agtype_to_float8</name></expr></argument>, <argument><expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* pass the arguments off to float8_accum */</comment>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>float8_accum</name></expr></argument>, <argument><expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>dfloat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_DATUM</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Wrapper for stdDev function. */</comment>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>age_float8_stddev_samp_aggfinalfn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><name>Datum</name></type> <name>age_float8_stddev_samp_aggfinalfn</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Datum</name></type> <name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PGFunction</name></type> <name>func</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_value</name></type> <name>agtv_float</name></decl>;</decl_stmt>

    <comment type="block">/* we can't use DirectFunctionCall1 as it errors for NULL values */</comment>
    <expr_stmt><expr><name>func</name> <operator>=</operator> <name>float8_stddev_samp</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <call>(<modifier>*</modifier><name>func</name>) <argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>agtv_float</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>AGTV_FLOAT</name></expr>;</expr_stmt>

    <comment type="block">/*
     * Check to see if float8_stddev_samp returned null. If so, we need to
     * return a agtype float 0.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>fcinfo</name><operator>-&gt;</operator><name>isnull</name></name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* we need to clear the flag */</comment>
        <expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>isnull</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>agtv_float</name><operator>.</operator><name>val</name><operator>.</operator><name>float_value</name></name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name><name>agtv_float</name><operator>.</operator><name>val</name><operator>.</operator><name>float_value</name></name> <operator>=</operator> <call><name>DatumGetFloat8</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><call><name>agtype_value_to_agtype</name><argument_list>(<argument><expr><operator>&amp;</operator><name>agtv_float</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>age_float8_stddev_pop_aggfinalfn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><name>Datum</name></type> <name>age_float8_stddev_pop_aggfinalfn</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Datum</name></type> <name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PGFunction</name></type> <name>func</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_value</name></type> <name>agtv_float</name></decl>;</decl_stmt>

    <comment type="block">/* we can't use DirectFunctionCall1 as it errors for NULL values */</comment>
    <expr_stmt><expr><name>func</name> <operator>=</operator> <name>float8_stddev_pop</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <call>(<modifier>*</modifier><name>func</name>) <argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>agtv_float</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>AGTV_FLOAT</name></expr>;</expr_stmt>

    <comment type="block">/*
     * Check to see if float8_stddev_pop returned null. If so, we need to
     * return a agtype float 0.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>fcinfo</name><operator>-&gt;</operator><name>isnull</name></name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* we need to clear the flag */</comment>
        <expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>isnull</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>agtv_float</name><operator>.</operator><name>val</name><operator>.</operator><name>float_value</name></name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name><name>agtv_float</name><operator>.</operator><name>val</name><operator>.</operator><name>float_value</name></name> <operator>=</operator> <call><name>DatumGetFloat8</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><call><name>agtype_value_to_agtype</name><argument_list>(<argument><expr><operator>&amp;</operator><name>agtv_float</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>age_agtype_larger_aggtransfn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><name>Datum</name></type> <name>age_agtype_larger_aggtransfn</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>agtype</name> <modifier>*</modifier></type><name>agtype_arg1</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype</name> <modifier>*</modifier></type><name>agtype_arg2</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype</name> <modifier>*</modifier></type><name>agtype_larger</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>test</name></decl>;</decl_stmt>

    <comment type="block">/* for max we need to ignore NULL values */</comment>
    <comment type="block">/* extract the args as agtype */</comment>
    <expr_stmt><expr><name>agtype_arg1</name> <operator>=</operator> <call><name>get_one_agtype_from_variadic_args</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>agtype_arg2</name> <operator>=</operator> <call><name>get_one_agtype_from_variadic_args</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* return NULL if both are NULL */</comment>
    <if_stmt><if>if <condition>(<expr><name>agtype_arg1</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>agtype_arg2</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <comment type="block">/* if one is NULL, return the other */</comment>
    <if_stmt><if>if <condition>(<expr><name>agtype_arg1</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>agtype_arg2</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><name>agtype_arg1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>agtype_arg1</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>agtype_arg2</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><name>agtype_arg2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* test for max value */</comment>
    <expr_stmt><expr><name>test</name> <operator>=</operator> <call><name>compare_agtype_containers_orderability</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>agtype_arg1</name><operator>-&gt;</operator><name>root</name></name></expr></argument>,
                                                  <argument><expr><operator>&amp;</operator><name><name>agtype_arg2</name><operator>-&gt;</operator><name>root</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>agtype_larger</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>test</name> <operator>&gt;=</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><name>agtype_arg1</name></expr> </then><else>: <expr><name>agtype_arg2</name></expr></else></ternary></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><name>agtype_larger</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>age_agtype_smaller_aggtransfn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><name>Datum</name></type> <name>age_agtype_smaller_aggtransfn</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>agtype</name> <modifier>*</modifier></type><name>agtype_arg1</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype</name> <modifier>*</modifier></type><name>agtype_arg2</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype</name> <modifier>*</modifier></type><name>agtype_smaller</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>test</name></decl>;</decl_stmt>

    <comment type="block">/* for min we need to ignore NULL values */</comment>
    <comment type="block">/* extract the args as agtype */</comment>
    <expr_stmt><expr><name>agtype_arg1</name> <operator>=</operator> <call><name>get_one_agtype_from_variadic_args</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>agtype_arg2</name> <operator>=</operator> <call><name>get_one_agtype_from_variadic_args</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* return NULL if both are NULL */</comment>
    <if_stmt><if>if <condition>(<expr><name>agtype_arg1</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>agtype_arg2</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <comment type="block">/* if one is NULL, return the other */</comment>
    <if_stmt><if>if <condition>(<expr><name>agtype_arg1</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>agtype_arg2</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><name>agtype_arg1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>agtype_arg1</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>agtype_arg2</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><name>agtype_arg2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* test for min value */</comment>
    <expr_stmt><expr><name>test</name> <operator>=</operator> <call><name>compare_agtype_containers_orderability</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>agtype_arg1</name><operator>-&gt;</operator><name>root</name></name></expr></argument>,
                                                  <argument><expr><operator>&amp;</operator><name><name>agtype_arg2</name><operator>-&gt;</operator><name>root</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>agtype_smaller</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>test</name> <operator>&lt;=</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><name>agtype_arg1</name></expr> </then><else>: <expr><name>agtype_arg2</name></expr></else></ternary></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><name>agtype_smaller</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* borrowed from PGs float8 routines for percentile_cont */</comment>
<function><type><specifier>static</specifier> <name>Datum</name></type> <name>float8_lerp</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>lo</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>hi</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>pct</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>double</name></type> <name>loval</name> <init>= <expr><call><name>DatumGetFloat8</name><argument_list>(<argument><expr><name>lo</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type> <name>hival</name> <init>= <expr><call><name>DatumGetFloat8</name><argument_list>(<argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <return>return <expr><call><name>Float8GetDatum</name><argument_list>(<argument><expr><name>loval</name> <operator>+</operator> <operator>(</operator><name>pct</name> <operator>*</operator> <operator>(</operator><name>hival</name> <operator>-</operator> <name>loval</name><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Code borrowed and adjusted from PG's ordered_set_transition function */</comment>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>age_percentile_aggtransfn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><name>Datum</name></type> <name>age_percentile_aggtransfn</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>PercentileGroupAggState</name> <modifier>*</modifier></type><name>pgastate</name></decl>;</decl_stmt>

    <comment type="block">/* verify we are in an aggregate context */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>AggCheckCallContext</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>AGG_CONTEXT_AGGREGATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* if this is the first invocation, create the state */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>MemoryContext</name></type> <name>old_mcxt</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>float8</name></type> <name>percentile</name></decl>;</decl_stmt>

        <comment type="block">/* validate the percentile */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
                <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"percentile value NULL is not a valid numeric value"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>percentile</name> <operator>=</operator> <call><name>DatumGetFloat8</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>agtype_to_float8</name></expr></argument>,
                         <argument><expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>percentile</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">0</literal> <operator>||</operator> <name>percentile</name></expr></argument> &gt;</argument_list></name> <literal type="number">1</literal> <operator>||</operator> <call><name>isnan</name><argument_list>(<argument><expr><name>percentile</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
                        <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"percentile value %g is not between 0 and 1"</literal></expr></argument>,
                               <argument><expr><name>percentile</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/* switch to the correct aggregate context */</comment>
        <expr_stmt><expr><name>old_mcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_mcxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* create and initialize the state */</comment>
        <expr_stmt><expr><name>pgastate</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PercentileGroupAggState</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pgastate</name><operator>-&gt;</operator><name>percentile</name></name> <operator>=</operator> <name>percentile</name></expr>;</expr_stmt>
        <comment type="block">/*
         * Percentiles need to be calculated from a sorted set. We are only
         * using float8 values, using the less than operator, and flagging
         * randomAccess to true - as we can potentially be reusing this
         * sort multiple times in the same query.
         */</comment>
        <expr_stmt><expr><name><name>pgastate</name><operator>-&gt;</operator><name>sortstate</name></name> <operator>=</operator> <call><name>tuplesort_begin_datum</name><argument_list>(<argument><expr><name>FLOAT8OID</name></expr></argument>,
                                                    <argument><expr><name>Float8LessOperator</name></expr></argument>,
                                                    <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>work_mem</name></expr></argument>,
                                                    <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pgastate</name><operator>-&gt;</operator><name>number_of_rows</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pgastate</name><operator>-&gt;</operator><name>sort_done</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

        <comment type="block">/* restore the old context */</comment>
        <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>old_mcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <comment type="block">/* otherwise, retrieve the state */</comment>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>pgastate</name> <operator>=</operator> <operator>(</operator><name>PercentileGroupAggState</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <comment type="block">/* Load the datum into the tuplesort object, but only if it's not null */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Datum</name></type> <name>dfloat</name> <init>= <expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>agtype_to_float8</name></expr></argument>, <argument><expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>tuplesort_putdatum</name><argument_list>(<argument><expr><name><name>pgastate</name><operator>-&gt;</operator><name>sortstate</name></name></expr></argument>, <argument><expr><name>dfloat</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pgastate</name><operator>-&gt;</operator><name>number_of_rows</name></name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <comment type="block">/* return the state */</comment>
    <expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><name>pgastate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Code borrowed and adjusted from PG's percentile_cont_final function */</comment>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>age_percentile_cont_aggfinalfn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><name>Datum</name></type> <name>age_percentile_cont_aggfinalfn</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>PercentileGroupAggState</name> <modifier>*</modifier></type><name>pgastate</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>float8</name></type> <name>percentile</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int64</name></type> <name>first_row</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int64</name></type> <name>second_row</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type> <name>val</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type> <name>first_val</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type> <name>second_val</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type> <name>proportion</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>isnull</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_value</name></type> <name>agtv_float</name></decl>;</decl_stmt>

    <comment type="block">/* verify we are in an aggregate context */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>AggCheckCallContext</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>AGG_CONTEXT_AGGREGATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* If there were no regular rows, the result is NULL */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* retrieve the state and percentile */</comment>
    <expr_stmt><expr><name>pgastate</name> <operator>=</operator> <operator>(</operator><name>PercentileGroupAggState</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>percentile</name> <operator>=</operator> <name><name>pgastate</name><operator>-&gt;</operator><name>percentile</name></name></expr>;</expr_stmt>

    <comment type="block">/* number_of_rows could be zero if we only saw NULL input values */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>pgastate</name><operator>-&gt;</operator><name>number_of_rows</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Finish the sort, or rescan if we already did */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>pgastate</name><operator>-&gt;</operator><name>sort_done</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>tuplesort_performsort</name><argument_list>(<argument><expr><name><name>pgastate</name><operator>-&gt;</operator><name>sortstate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pgastate</name><operator>-&gt;</operator><name>sort_done</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>tuplesort_rescan</name><argument_list>(<argument><expr><name><name>pgastate</name><operator>-&gt;</operator><name>sortstate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <comment type="block">/* calculate the percentile cont*/</comment>
    <expr_stmt><expr><name>first_row</name> <operator>=</operator> <call><name>floor</name><argument_list>(<argument><expr><name>percentile</name> <operator>*</operator> <operator>(</operator><name><name>pgastate</name><operator>-&gt;</operator><name>number_of_rows</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>second_row</name> <operator>=</operator> <call><name>ceil</name><argument_list>(<argument><expr><name>percentile</name> <operator>*</operator> <operator>(</operator><name><name>pgastate</name><operator>-&gt;</operator><name>number_of_rows</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>first_row</name> <operator>&lt;</operator> <name><name>pgastate</name><operator>-&gt;</operator><name>number_of_rows</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>tuplesort_skiptuples</name><argument_list>(<argument><expr><name><name>pgastate</name><operator>-&gt;</operator><name>sortstate</name></name></expr></argument>, <argument><expr><name>first_row</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"missing row in percentile_cont"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>tuplesort_getdatum</name><argument_list>(<argument><expr><name><name>pgastate</name><operator>-&gt;</operator><name>sortstate</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>first_val</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"missing row in percentile_cont"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>first_row</name> <operator>==</operator> <name>second_row</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>val</name> <operator>=</operator> <name>first_val</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>tuplesort_getdatum</name><argument_list>(<argument><expr><name><name>pgastate</name><operator>-&gt;</operator><name>sortstate</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>second_val</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"missing row in percentile_cont"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>proportion</name> <operator>=</operator> <operator>(</operator><name>percentile</name> <operator>*</operator> <operator>(</operator><name><name>pgastate</name><operator>-&gt;</operator><name>number_of_rows</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator> <operator>-</operator> <name>first_row</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>float8_lerp</name><argument_list>(<argument><expr><name>first_val</name></expr></argument>, <argument><expr><name>second_val</name></expr></argument>, <argument><expr><name>proportion</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* convert to an agtype float and return the result */</comment>
    <expr_stmt><expr><name><name>agtv_float</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>AGTV_FLOAT</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>agtv_float</name><operator>.</operator><name>val</name><operator>.</operator><name>float_value</name></name> <operator>=</operator> <call><name>DatumGetFloat8</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><call><name>agtype_value_to_agtype</name><argument_list>(<argument><expr><operator>&amp;</operator><name>agtv_float</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Code borrowed and adjusted from PG's percentile_disc_final function */</comment>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>age_percentile_disc_aggfinalfn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><name>Datum</name></type> <name>age_percentile_disc_aggfinalfn</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>PercentileGroupAggState</name> <modifier>*</modifier></type><name>pgastate</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type> <name>percentile</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type> <name>val</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>isnull</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int64</name></type> <name>rownum</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_value</name></type> <name>agtv_float</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>AggCheckCallContext</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>AGG_CONTEXT_AGGREGATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* If there were no regular rows, the result is NULL */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>pgastate</name> <operator>=</operator> <operator>(</operator><name>PercentileGroupAggState</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>percentile</name> <operator>=</operator> <name><name>pgastate</name><operator>-&gt;</operator><name>percentile</name></name></expr>;</expr_stmt>

    <comment type="block">/* number_of_rows could be zero if we only saw NULL input values */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>pgastate</name><operator>-&gt;</operator><name>number_of_rows</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Finish the sort, or rescan if we already did */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>pgastate</name><operator>-&gt;</operator><name>sort_done</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>tuplesort_performsort</name><argument_list>(<argument><expr><name><name>pgastate</name><operator>-&gt;</operator><name>sortstate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pgastate</name><operator>-&gt;</operator><name>sort_done</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>tuplesort_rescan</name><argument_list>(<argument><expr><name><name>pgastate</name><operator>-&gt;</operator><name>sortstate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <comment type="block">/*----------
     * We need the smallest K such that (K/N) &gt;= percentile.
     * N&gt;0, therefore K &gt;= N*percentile, therefore K = ceil(N*percentile).
     * So we skip K-1 rows (if K&gt;0) and return the next row fetched.
     *----------
     */</comment>
    <expr_stmt><expr><name>rownum</name> <operator>=</operator> <operator>(</operator><name>int64</name><operator>)</operator> <call><name>ceil</name><argument_list>(<argument><expr><name>percentile</name> <operator>*</operator> <name><name>pgastate</name><operator>-&gt;</operator><name>number_of_rows</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>rownum</name> <operator>&lt;=</operator> <name><name>pgastate</name><operator>-&gt;</operator><name>number_of_rows</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>rownum</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>tuplesort_skiptuples</name><argument_list>(<argument><expr><name><name>pgastate</name><operator>-&gt;</operator><name>sortstate</name></name></expr></argument>, <argument><expr><name>rownum</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"missing row in percentile_disc"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>tuplesort_getdatum</name><argument_list>(<argument><expr><name><name>pgastate</name><operator>-&gt;</operator><name>sortstate</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>val</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"missing row in percentile_disc"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* We shouldn't have stored any nulls, but do the right thing anyway */</comment>
    <if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* convert to an agtype float and return the result */</comment>
    <expr_stmt><expr><name><name>agtv_float</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>AGTV_FLOAT</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>agtv_float</name><operator>.</operator><name>val</name><operator>.</operator><name>float_value</name></name> <operator>=</operator> <call><name>DatumGetFloat8</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><call><name>agtype_value_to_agtype</name><argument_list>(<argument><expr><operator>&amp;</operator><name>agtv_float</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* functions to support the aggregate function COLLECT() */</comment>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>age_collect_aggtransfn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><name>Datum</name></type> <name>age_collect_aggtransfn</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>agtype_in_state</name> <modifier>*</modifier></type><name>castate</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nargs</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name> <modifier>*</modifier></type><name>args</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name> <modifier>*</modifier></type><name>nulls</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name> <modifier>*</modifier></type><name>types</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>old_mcxt</name></decl>;</decl_stmt>

    <comment type="block">/* verify we are in an aggregate context */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>AggCheckCallContext</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>AGG_CONTEXT_AGGREGATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Switch to the correct aggregate context. Otherwise, the data added to the
     * array will be lost.
     */</comment>
    <expr_stmt><expr><name>old_mcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_mcxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* if this is the first invocation, create the state */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* create and initialize the state */</comment>
        <expr_stmt><expr><name>castate</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>agtype_in_state</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>castate</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>agtype_in_state</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* start the array */</comment>
        <expr_stmt><expr><name><name>castate</name><operator>-&gt;</operator><name>res</name></name> <operator>=</operator> <call><name>push_agtype_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>castate</name><operator>-&gt;</operator><name>parse_state</name></name></expr></argument>,
                                         <argument><expr><name>WAGT_BEGIN_ARRAY</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <comment type="block">/* otherwise, retrieve the state */</comment>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name>castate</name> <operator>=</operator> <operator>(</operator><name>agtype_in_state</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/*
     * Extract the variadic args, of which there should only be one.
     * Insert the arg into the array, unless it is null. Nulls are
     * skipped over.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>nargs</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name>nargs</name> <operator>=</operator> <call><name>extract_variadic_args</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>args</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>types</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>nargs</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* only add non null values */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>nulls</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>false</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* we need to check for agtype null and skip it, if found */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>types</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>AGTYPEOID</name></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>agtype</name> <modifier>*</modifier></type><name>agt_arg</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>agtv_value</name></decl>;</decl_stmt>

                <comment type="block">/* get the agtype argument */</comment>
                <expr_stmt><expr><name>agt_arg</name> <operator>=</operator> <call><name>DATUM_GET_AGTYPE_P</name><argument_list>(<argument><expr><name><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>agtv_value</name> <operator>=</operator> <call><name>get_ith_agtype_value_from_container</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>agt_arg</name><operator>-&gt;</operator><name>root</name></name></expr></argument>,
                                                                 <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <comment type="block">/* add the arg if not agtype null */</comment>
                <if_stmt><if>if <condition>(<expr><name><name>agtv_value</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>AGTV_NULL</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>add_agtype</name><argument_list>(<argument><expr><name><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>nulls</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>castate</name></expr></argument>, <argument><expr><name><name>types</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><call><name>add_agtype</name><argument_list>(<argument><expr><name><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>nulls</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>castate</name></expr></argument>, <argument><expr><name><name>types</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>nargs</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                        <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"collect() invalid number of arguments"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* restore the old context */</comment>
    <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>old_mcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* return the state */</comment>
    <expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><name>castate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>age_collect_aggfinalfn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><name>Datum</name></type> <name>age_collect_aggfinalfn</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>agtype_in_state</name> <modifier>*</modifier></type><name>castate</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>old_mcxt</name></decl>;</decl_stmt>

    <comment type="block">/* verify we are in an aggregate context */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>AggCheckCallContext</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>AGG_CONTEXT_AGGREGATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/*
     * Get the state. There are cases where the age_collect_aggtransfn never
     * gets called. So, check to see if this is one.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* create and initialize the state */</comment>
        <expr_stmt><expr><name>castate</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>agtype_in_state</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>castate</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>agtype_in_state</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* start the array */</comment>
        <expr_stmt><expr><name><name>castate</name><operator>-&gt;</operator><name>res</name></name> <operator>=</operator> <call><name>push_agtype_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>castate</name><operator>-&gt;</operator><name>parse_state</name></name></expr></argument>,
                                         <argument><expr><name>WAGT_BEGIN_ARRAY</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name>castate</name> <operator>=</operator> <operator>(</operator><name>agtype_in_state</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <comment type="block">/* switch to the correct aggregate context */</comment>
    <expr_stmt><expr><name>old_mcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_mcxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* Finish/close the array */</comment>
    <expr_stmt><expr><name><name>castate</name><operator>-&gt;</operator><name>res</name></name> <operator>=</operator> <call><name>push_agtype_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>castate</name><operator>-&gt;</operator><name>parse_state</name></name></expr></argument>, <argument><expr><name>WAGT_END_ARRAY</name></expr></argument>,
                                     <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* restore the old context */</comment>
    <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>old_mcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* return the agtype array */</comment>
    <expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><call><name>agtype_value_to_agtype</name><argument_list>(<argument><expr><name><name>castate</name><operator>-&gt;</operator><name>res</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* helper function to quickly build an agtype_value vertex */</comment>
<function><type><name>agtype_value</name> <modifier>*</modifier></type><name>agtype_value_build_vertex</name><parameter_list>(<parameter><decl><type><name>graphid</name></type> <name>id</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>label</name></decl></parameter>,
                                        <parameter><decl><type><name>Datum</name></type> <name>properties</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>agtype_in_state</name></type> <name>result</name></decl>;</decl_stmt>

    <comment type="block">/* the label can't be NULL */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>label</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>agtype_in_state</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* push in the object beginning */</comment>
    <expr_stmt><expr><name><name>result</name><operator>.</operator><name>res</name></name> <operator>=</operator> <call><name>push_agtype_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>result</name><operator>.</operator><name>parse_state</name></name></expr></argument>, <argument><expr><name>WAGT_BEGIN_OBJECT</name></expr></argument>,
                                   <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* push the graph id key/value pair */</comment>
    <expr_stmt><expr><name><name>result</name><operator>.</operator><name>res</name></name> <operator>=</operator> <call><name>push_agtype_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>result</name><operator>.</operator><name>parse_state</name></name></expr></argument>, <argument><expr><name>WAGT_KEY</name></expr></argument>,
                                   <argument><expr><call><name>string_to_agtype_value</name><argument_list>(<argument><expr><literal type="string">"id"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><operator>.</operator><name>res</name></name> <operator>=</operator> <call><name>push_agtype_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>result</name><operator>.</operator><name>parse_state</name></name></expr></argument>, <argument><expr><name>WAGT_VALUE</name></expr></argument>,
                                   <argument><expr><call><name>integer_to_agtype_value</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* push the label key/value pair */</comment>
    <expr_stmt><expr><name><name>result</name><operator>.</operator><name>res</name></name> <operator>=</operator> <call><name>push_agtype_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>result</name><operator>.</operator><name>parse_state</name></name></expr></argument>, <argument><expr><name>WAGT_KEY</name></expr></argument>,
                                   <argument><expr><call><name>string_to_agtype_value</name><argument_list>(<argument><expr><literal type="string">"label"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><operator>.</operator><name>res</name></name> <operator>=</operator> <call><name>push_agtype_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>result</name><operator>.</operator><name>parse_state</name></name></expr></argument>, <argument><expr><name>WAGT_VALUE</name></expr></argument>,
                                   <argument><expr><call><name>string_to_agtype_value</name><argument_list>(<argument><expr><name>label</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* push the properties key/value pair */</comment>
    <expr_stmt><expr><name><name>result</name><operator>.</operator><name>res</name></name> <operator>=</operator> <call><name>push_agtype_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>result</name><operator>.</operator><name>parse_state</name></name></expr></argument>, <argument><expr><name>WAGT_KEY</name></expr></argument>,
                                   <argument><expr><call><name>string_to_agtype_value</name><argument_list>(<argument><expr><literal type="string">"properties"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>add_agtype</name><argument_list>(<argument><expr><operator>(</operator><name>Datum</name><operator>)</operator><name>properties</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>result</name></expr></argument>, <argument><expr><name>AGTYPEOID</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* push in the object end */</comment>
    <expr_stmt><expr><name><name>result</name><operator>.</operator><name>res</name></name> <operator>=</operator> <call><name>push_agtype_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>result</name><operator>.</operator><name>parse_state</name></name></expr></argument>, <argument><expr><name>WAGT_END_OBJECT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* set it as an edge */</comment>
    <expr_stmt><expr><name><name>result</name><operator>.</operator><name>res</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>AGTV_VERTEX</name></expr>;</expr_stmt>

    <comment type="block">/* return the result that was build (allocated) inside the result */</comment>
    <return>return <expr><name><name>result</name><operator>.</operator><name>res</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* helper function to quickly build an agtype_value edge */</comment>
<function><type><name>agtype_value</name> <modifier>*</modifier></type><name>agtype_value_build_edge</name><parameter_list>(<parameter><decl><type><name>graphid</name></type> <name>id</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>label</name></decl></parameter>, <parameter><decl><type><name>graphid</name></type> <name>end_id</name></decl></parameter>,
                                      <parameter><decl><type><name>graphid</name></type> <name>start_id</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>properties</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>agtype_in_state</name></type> <name>result</name></decl>;</decl_stmt>

    <comment type="block">/* the label can't be NULL */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>label</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>agtype_in_state</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* push in the object beginning */</comment>
    <expr_stmt><expr><name><name>result</name><operator>.</operator><name>res</name></name> <operator>=</operator> <call><name>push_agtype_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>result</name><operator>.</operator><name>parse_state</name></name></expr></argument>, <argument><expr><name>WAGT_BEGIN_OBJECT</name></expr></argument>,
                                   <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* push the graph id key/value pair */</comment>
    <expr_stmt><expr><name><name>result</name><operator>.</operator><name>res</name></name> <operator>=</operator> <call><name>push_agtype_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>result</name><operator>.</operator><name>parse_state</name></name></expr></argument>, <argument><expr><name>WAGT_KEY</name></expr></argument>,
                                   <argument><expr><call><name>string_to_agtype_value</name><argument_list>(<argument><expr><literal type="string">"id"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><operator>.</operator><name>res</name></name> <operator>=</operator> <call><name>push_agtype_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>result</name><operator>.</operator><name>parse_state</name></name></expr></argument>, <argument><expr><name>WAGT_VALUE</name></expr></argument>,
                                   <argument><expr><call><name>integer_to_agtype_value</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* push the label key/value pair */</comment>
    <expr_stmt><expr><name><name>result</name><operator>.</operator><name>res</name></name> <operator>=</operator> <call><name>push_agtype_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>result</name><operator>.</operator><name>parse_state</name></name></expr></argument>, <argument><expr><name>WAGT_KEY</name></expr></argument>,
                                   <argument><expr><call><name>string_to_agtype_value</name><argument_list>(<argument><expr><literal type="string">"label"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><operator>.</operator><name>res</name></name> <operator>=</operator> <call><name>push_agtype_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>result</name><operator>.</operator><name>parse_state</name></name></expr></argument>, <argument><expr><name>WAGT_VALUE</name></expr></argument>,
                                   <argument><expr><call><name>string_to_agtype_value</name><argument_list>(<argument><expr><name>label</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* push the end_id key/value pair */</comment>
    <expr_stmt><expr><name><name>result</name><operator>.</operator><name>res</name></name> <operator>=</operator> <call><name>push_agtype_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>result</name><operator>.</operator><name>parse_state</name></name></expr></argument>, <argument><expr><name>WAGT_KEY</name></expr></argument>,
                                   <argument><expr><call><name>string_to_agtype_value</name><argument_list>(<argument><expr><literal type="string">"end_id"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><operator>.</operator><name>res</name></name> <operator>=</operator> <call><name>push_agtype_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>result</name><operator>.</operator><name>parse_state</name></name></expr></argument>, <argument><expr><name>WAGT_VALUE</name></expr></argument>,
                                   <argument><expr><call><name>integer_to_agtype_value</name><argument_list>(<argument><expr><name>end_id</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* push the start_id key/value pair */</comment>
    <expr_stmt><expr><name><name>result</name><operator>.</operator><name>res</name></name> <operator>=</operator> <call><name>push_agtype_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>result</name><operator>.</operator><name>parse_state</name></name></expr></argument>, <argument><expr><name>WAGT_KEY</name></expr></argument>,
                                   <argument><expr><call><name>string_to_agtype_value</name><argument_list>(<argument><expr><literal type="string">"start_id"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><operator>.</operator><name>res</name></name> <operator>=</operator> <call><name>push_agtype_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>result</name><operator>.</operator><name>parse_state</name></name></expr></argument>, <argument><expr><name>WAGT_VALUE</name></expr></argument>,
                                   <argument><expr><call><name>integer_to_agtype_value</name><argument_list>(<argument><expr><name>start_id</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* push the properties key/value pair */</comment>
    <expr_stmt><expr><name><name>result</name><operator>.</operator><name>res</name></name> <operator>=</operator> <call><name>push_agtype_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>result</name><operator>.</operator><name>parse_state</name></name></expr></argument>, <argument><expr><name>WAGT_KEY</name></expr></argument>,
                                   <argument><expr><call><name>string_to_agtype_value</name><argument_list>(<argument><expr><literal type="string">"properties"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>add_agtype</name><argument_list>(<argument><expr><operator>(</operator><name>Datum</name><operator>)</operator><name>properties</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>result</name></expr></argument>, <argument><expr><name>AGTYPEOID</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* push in the object end */</comment>
    <expr_stmt><expr><name><name>result</name><operator>.</operator><name>res</name></name> <operator>=</operator> <call><name>push_agtype_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>result</name><operator>.</operator><name>parse_state</name></name></expr></argument>, <argument><expr><name>WAGT_END_OBJECT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* set it as an edge */</comment>
    <expr_stmt><expr><name><name>result</name><operator>.</operator><name>res</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>AGTV_EDGE</name></expr>;</expr_stmt>

    <comment type="block">/* return the result that was build (allocated) inside the result */</comment>
    <return>return <expr><name><name>result</name><operator>.</operator><name>res</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Extract an agtype_value from an agtype and optionally verify that it is of
 * the correct type. It will always complain if the passed argument is not a
 * scalar.
 *
 * Optionally, the function will throw an error, stating the calling function
 * name, for invalid values - including AGTV_NULL
 *
 * Note: This only works for scalars wrapped in an array container, not
 * in objects.
 */</comment>
<function><type><name>agtype_value</name> <modifier>*</modifier></type><name>get_agtype_value</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>funcname</name></decl></parameter>, <parameter><decl><type><name>agtype</name> <modifier>*</modifier></type><name>agt_arg</name></decl></parameter>,
                               <parameter><decl><type><name><name>enum</name> <name>agtype_value_type</name></name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>error</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>agtv_value</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* we need these */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>funcname</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>agt_arg</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* error if the argument is not a scalar */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AGTYPE_CONTAINER_IS_SCALAR</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>agt_arg</name><operator>-&gt;</operator><name>root</name></name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s: agtype argument must be a scalar"</literal></expr></argument>,
                        <argument><expr><name>funcname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* is it AGTV_NULL? */</comment>
    <if_stmt><if>if <condition>(<expr><name>error</name> <operator>&amp;&amp;</operator> <call><name>is_agtype_null</name><argument_list>(<argument><expr><name>agt_arg</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s: agtype argument must not be AGTV_NULL"</literal></expr></argument>,
                        <argument><expr><name>funcname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* get the agtype value */</comment>
    <expr_stmt><expr><name>agtv_value</name> <operator>=</operator> <call><name>get_ith_agtype_value_from_container</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>agt_arg</name><operator>-&gt;</operator><name>root</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* is it the correct type? */</comment>
    <if_stmt><if>if <condition>(<expr><name>error</name> <operator>&amp;&amp;</operator> <name><name>agtv_value</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>type</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s: agtype argument of wrong type"</literal></expr></argument>,
                        <argument><expr><name>funcname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>agtv_value</name></expr>;</return>
</block_content>}</block></function>

<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>age_eq_tilde</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<comment type="block">/*
 * Execution function for =~ aka regular expression comparisons
 *
 * Note: Everything must resolve to 2 agtype strings. All others types are
 * errors.
 */</comment>
<function><type><name>Datum</name></type> <name>age_eq_tilde</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>agtype</name> <modifier>*</modifier></type><name>agt_string</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype</name> <modifier>*</modifier></type><name>agt_pattern</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* if either are NULL return NULL */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* extract the input */</comment>
    <expr_stmt><expr><name>agt_string</name> <operator>=</operator> <call><name>AG_GET_ARG_AGTYPE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>agt_pattern</name> <operator>=</operator> <call><name>AG_GET_ARG_AGTYPE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* they both need to scalars */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>AGT_ROOT_IS_SCALAR</name><argument_list>(<argument><expr><name>agt_string</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>AGT_ROOT_IS_SCALAR</name><argument_list>(<argument><expr><name>agt_pattern</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>agtv_string</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>agtv_pattern</name></decl>;</decl_stmt>

        <comment type="block">/* get the contents of each container */</comment>
        <expr_stmt><expr><name>agtv_string</name> <operator>=</operator> <call><name>get_ith_agtype_value_from_container</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>agt_string</name><operator>-&gt;</operator><name>root</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>agtv_pattern</name> <operator>=</operator> <call><name>get_ith_agtype_value_from_container</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>agt_pattern</name><operator>-&gt;</operator><name>root</name></name></expr></argument>,
                                                           <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* if either are agtype null, return NULL */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>agtv_string</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AGTV_NULL</name> <operator>||</operator>
            <name><name>agtv_pattern</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AGTV_NULL</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* only strings can be compared, all others are errors */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>agtv_string</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AGTV_STRING</name> <operator>&amp;&amp;</operator>
            <name><name>agtv_pattern</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AGTV_STRING</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>text</name> <modifier>*</modifier></type><name>string</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>text</name> <modifier>*</modifier></type><name>pattern</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Datum</name></type> <name>result</name></decl>;</decl_stmt>

            <expr_stmt><expr><name>string</name> <operator>=</operator> <call><name>cstring_to_text_with_len</name><argument_list>(<argument><expr><name><name>agtv_string</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>val</name></name></expr></argument>,
                                              <argument><expr><name><name>agtv_string</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>pattern</name> <operator>=</operator> <call><name>cstring_to_text_with_len</name><argument_list>(<argument><expr><name><name>agtv_pattern</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>val</name></name></expr></argument>,
                                               <argument><expr><name><name>agtv_pattern</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><call><name>DirectFunctionCall2Coll</name><argument_list>(<argument><expr><name>textregexeq</name></expr></argument>, <argument><expr><name>C_COLLATION_OID</name></expr></argument>,
                                              <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>string</name></expr></argument>)</argument_list></call></expr></argument>,
                                              <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>pattern</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
            <return>return <expr><call><name>boolean_to_agtype</name><argument_list>(<argument><expr><call><name>DatumGetBool</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <comment type="block">/* if we got here we have values that are invalid */</comment>
    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                    <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"agtype string values expected"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Helper function to step through and retrieve keys from an object.
 * borrowed and modified from get_next_object_pair() in agtype_vle.c
 */</comment>
<function><type><specifier>static</specifier> <name>agtype_iterator</name> <modifier>*</modifier></type><name>get_next_object_key</name><parameter_list>(<parameter><decl><type><name>agtype_iterator</name> <modifier>*</modifier></type><name>it</name></decl></parameter>,
                                             <parameter><decl><type><name>agtype_container</name> <modifier>*</modifier></type><name>agtc</name></decl></parameter>,
                                             <parameter><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>key</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>agtype_iterator_token</name></type> <name>itok</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_value</name></type> <name>tmp</name></decl>;</decl_stmt>

    <comment type="block">/* verify input params */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>agtc</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>key</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* check to see if the container is empty */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>AGTYPE_CONTAINER_SIZE</name><argument_list>(<argument><expr><name>agtc</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <return>return <expr><name>NULL</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* if the passed iterator is NULL, this is the first time, create it */</comment>
    <if_stmt><if>if <condition>(<expr><name>it</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* initial the iterator */</comment>
        <expr_stmt><expr><name>it</name> <operator>=</operator> <call><name>agtype_iterator_init</name><argument_list>(<argument><expr><name>agtc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* get the first token */</comment>
        <expr_stmt><expr><name>itok</name> <operator>=</operator> <call><name>agtype_iterator_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name>it</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmp</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* it should be WAGT_BEGIN_OBJECT */</comment>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>itok</name> <operator>==</operator> <name>WAGT_BEGIN_OBJECT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* the next token should be a key or the end of the object */</comment>
    <expr_stmt><expr><name>itok</name> <operator>=</operator> <call><name>agtype_iterator_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name>it</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmp</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>itok</name> <operator>==</operator> <name>WAGT_KEY</name> <operator>||</operator> <name>WAGT_END_OBJECT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* if this is the end of the object return NULL */</comment>
    <if_stmt><if>if <condition>(<expr><name>itok</name> <operator>==</operator> <name>WAGT_END_OBJECT</name></expr>)</condition>
    <block>{<block_content>
        <return>return <expr><name>NULL</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* this should be the key, copy it */</comment>
    <if_stmt><if>if <condition>(<expr><name>itok</name> <operator>==</operator> <name>WAGT_KEY</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmp</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>agtype_value</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * The next token should be a value but, it could be a begin tokens for
     * arrays or objects. For those we just return NULL to ignore them.
     */</comment>
    <expr_stmt><expr><name>itok</name> <operator>=</operator> <call><name>agtype_iterator_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name>it</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmp</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>itok</name> <operator>==</operator> <name>WAGT_VALUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* return the iterator */</comment>
    <return>return <expr><name>it</name></expr>;</return>
</block_content>}</block></function>

<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>age_keys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<comment type="block">/*
 * Execution function to implement openCypher keys() function
 */</comment>
<function><type><name>Datum</name></type> <name>age_keys</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>agtype</name> <modifier>*</modifier></type><name>agt_arg</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>agtv_result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_value</name></type> <name>obj_key</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_iterator</name> <modifier>*</modifier></type><name>it</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_parse_state</name> <modifier>*</modifier></type><name>parse_state</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* check for null */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="line">//needs to be a map, node, or relationship</comment>
    <expr_stmt><expr><name>agt_arg</name> <operator>=</operator> <call><name>AG_GET_ARG_AGTYPE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * check for a scalar object. edges and vertexes are scalar, objects are not
     * scalar and will be handled separately
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>AGT_ROOT_IS_SCALAR</name><argument_list>(<argument><expr><name>agt_arg</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>agtv_result</name> <operator>=</operator> <call><name>get_ith_agtype_value_from_container</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>agt_arg</name><operator>-&gt;</operator><name>root</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* is it an agtype null, return null if it is */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>agtv_result</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AGTV_NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/* check for proper agtype and extract the properties field */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>agtv_result</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AGTV_EDGE</name> <operator>||</operator>
            <name><name>agtv_result</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AGTV_VERTEX</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>agtv_result</name> <operator>=</operator> <call><name>GET_AGTYPE_VALUE_OBJECT_VALUE</name><argument_list>(<argument><expr><name>agtv_result</name></expr></argument>,
                                                        <argument><expr><literal type="string">"properties"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>agtv_result</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>agtv_result</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>AGTV_OBJECT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                    <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"keys() argument must be a vertex, edge, object or null"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <expr_stmt><expr><name>agt_arg</name> <operator>=</operator> <call><name>agtype_value_to_agtype</name><argument_list>(<argument><expr><name>agtv_result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>agtv_result</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>AGT_ROOT_IS_OBJECT</name><argument_list>(<argument><expr><name>agt_arg</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"keys() argument must be a vertex, edge, object or null"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* push the beginning of the array */</comment>
    <expr_stmt><expr><name>agtv_result</name> <operator>=</operator> <call><name>push_agtype_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name>parse_state</name></expr></argument>, <argument><expr><name>WAGT_BEGIN_ARRAY</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* populate the array with keys */</comment>
    <while>while <condition>(<expr><operator>(</operator><name>it</name> <operator>=</operator> <call><name>get_next_object_key</name><argument_list>(<argument><expr><name>it</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>agt_arg</name><operator>-&gt;</operator><name>root</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>obj_key</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>agtv_result</name> <operator>=</operator> <call><name>push_agtype_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name>parse_state</name></expr></argument>, <argument><expr><name>WAGT_ELEM</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>obj_key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>

    <comment type="block">/* push the end of the array*/</comment>
    <expr_stmt><expr><name>agtv_result</name> <operator>=</operator> <call><name>push_agtype_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name>parse_state</name></expr></argument>, <argument><expr><name>WAGT_END_ARRAY</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>agtv_result</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>agtv_result</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>AGTV_ARRAY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><call><name>agtype_value_to_agtype</name><argument_list>(<argument><expr><name>agtv_result</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>age_nodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<comment type="block">/*
 * Execution function to implement openCypher nodes() function
 */</comment>
<function><type><name>Datum</name></type> <name>age_nodes</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>agtype</name> <modifier>*</modifier></type><name>agt_arg</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>agtv_path</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_in_state</name></type> <name>agis_result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <comment type="block">/* check for null */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>agt_arg</name> <operator>=</operator> <call><name>AG_GET_ARG_AGTYPE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* check for a scalar object */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AGT_ROOT_IS_SCALAR</name><argument_list>(<argument><expr><name>agt_arg</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"nodes() argument must resolve to a scalar value"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* get the potential path out of the array */</comment>
    <expr_stmt><expr><name>agtv_path</name> <operator>=</operator> <call><name>get_ith_agtype_value_from_container</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>agt_arg</name><operator>-&gt;</operator><name>root</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* is it an agtype null? */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>agtv_path</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AGTV_NULL</name></expr>)</condition>
    <block>{<block_content>
            <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* verify that it is an agtype path */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>agtv_path</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>AGTV_PATH</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                        <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"nodes() argument must be a path"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* clear the result structure */</comment>
    <expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>agis_result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>agtype_in_state</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* push the beginning of the array */</comment>
    <expr_stmt><expr><name><name>agis_result</name><operator>.</operator><name>res</name></name> <operator>=</operator> <call><name>push_agtype_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>agis_result</name><operator>.</operator><name>parse_state</name></name></expr></argument>,
                                        <argument><expr><name>WAGT_BEGIN_ARRAY</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* push in each vertex (every other entry) from the path */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>agtv_path</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>array</name><operator>.</operator><name>num_elems</name></name></expr>;</condition> <incr><expr><name>i</name> <operator>+=</operator> <literal type="number">2</literal></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name><name>agis_result</name><operator>.</operator><name>res</name></name> <operator>=</operator> <call><name>push_agtype_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>agis_result</name><operator>.</operator><name>parse_state</name></name></expr></argument>, <argument><expr><name>WAGT_ELEM</name></expr></argument>,
                                            <argument><expr><operator>&amp;</operator><name><name>agtv_path</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>array</name><operator>.</operator><name>elems</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <comment type="block">/* push the end of the array */</comment>
    <expr_stmt><expr><name><name>agis_result</name><operator>.</operator><name>res</name></name> <operator>=</operator> <call><name>push_agtype_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>agis_result</name><operator>.</operator><name>parse_state</name></name></expr></argument>,
                                        <argument><expr><name>WAGT_END_ARRAY</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* convert the agtype_value to a datum to return to the caller */</comment>
    <expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><call><name>agtype_value_to_agtype</name><argument_list>(<argument><expr><name><name>agis_result</name><operator>.</operator><name>res</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>age_labels</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<comment type="block">/*
 * Execution function to implement openCypher labels() function
 *
 * NOTE:
 *
 * This function is defined to return NULL on NULL input. So, no need to check
 * for SQL NULL input.
 */</comment>
<function><type><name>Datum</name></type> <name>age_labels</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>agtype</name> <modifier>*</modifier></type><name>agt_arg</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>agtv_temp</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>agtv_label</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_in_state</name></type> <name>agis_result</name></decl>;</decl_stmt>

    <comment type="block">/* get the vertex argument */</comment>
    <expr_stmt><expr><name>agt_arg</name> <operator>=</operator> <call><name>AG_GET_ARG_AGTYPE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* verify it is a scalar */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AGT_ROOT_IS_SCALAR</name><argument_list>(<argument><expr><name>agt_arg</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"labels() argument must resolve to a scalar value"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* is it an agtype null? */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>AGTYPE_CONTAINER_IS_SCALAR</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>agt_arg</name><operator>-&gt;</operator><name>root</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
        <call><name>AGTE_IS_NULL</name><argument_list>(<argument><expr><name><operator>(</operator><operator>&amp;</operator><name><name>agt_arg</name><operator>-&gt;</operator><name>root</name></name><operator>)</operator><operator>-&gt;</operator><name>children</name></name><index>[<expr><literal type="number">0</literal></expr>]</index></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* get the potential vertex */</comment>
    <expr_stmt><expr><name>agtv_temp</name> <operator>=</operator> <call><name>get_ith_agtype_value_from_container</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>agt_arg</name><operator>-&gt;</operator><name>root</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* verify that it is an agtype vertex */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>agtv_temp</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>AGTV_VERTEX</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"labels() argument must be a vertex"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* get the label from the vertex */</comment>
    <expr_stmt><expr><name>agtv_label</name> <operator>=</operator> <call><name>GET_AGTYPE_VALUE_OBJECT_VALUE</name><argument_list>(<argument><expr><name>agtv_temp</name></expr></argument>, <argument><expr><literal type="string">"label"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* it cannot be NULL */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>agtv_label</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* clear the result structure */</comment>
    <expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>agis_result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>agtype_in_state</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* push the beginning of the array */</comment>
    <expr_stmt><expr><name><name>agis_result</name><operator>.</operator><name>res</name></name> <operator>=</operator> <call><name>push_agtype_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>agis_result</name><operator>.</operator><name>parse_state</name></name></expr></argument>,
                                        <argument><expr><name>WAGT_BEGIN_ARRAY</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* push in the label */</comment>
    <expr_stmt><expr><name><name>agis_result</name><operator>.</operator><name>res</name></name> <operator>=</operator> <call><name>push_agtype_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>agis_result</name><operator>.</operator><name>parse_state</name></name></expr></argument>, <argument><expr><name>WAGT_ELEM</name></expr></argument>,
                                        <argument><expr><name>agtv_label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* push the end of the array */</comment>
    <expr_stmt><expr><name><name>agis_result</name><operator>.</operator><name>res</name></name> <operator>=</operator> <call><name>push_agtype_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>agis_result</name><operator>.</operator><name>parse_state</name></name></expr></argument>,
                                        <argument><expr><name>WAGT_END_ARRAY</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* convert the agtype_value to a datum to return to the caller */</comment>
    <expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><call><name>agtype_value_to_agtype</name><argument_list>(<argument><expr><name><name>agis_result</name><operator>.</operator><name>res</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>age_relationships</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<comment type="block">/*
 * Execution function to implement openCypher relationships() function
 */</comment>
<function><type><name>Datum</name></type> <name>age_relationships</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>agtype</name> <modifier>*</modifier></type><name>agt_arg</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>agtv_path</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_in_state</name></type> <name>agis_result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <comment type="block">/* check for null */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>agt_arg</name> <operator>=</operator> <call><name>AG_GET_ARG_AGTYPE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* check for a scalar object */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AGT_ROOT_IS_SCALAR</name><argument_list>(<argument><expr><name>agt_arg</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"relationships() argument must resolve to a scalar value"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* get the potential path out of the array */</comment>
    <expr_stmt><expr><name>agtv_path</name> <operator>=</operator> <call><name>get_ith_agtype_value_from_container</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>agt_arg</name><operator>-&gt;</operator><name>root</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* is it an agtype null? */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>agtv_path</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AGTV_NULL</name></expr>)</condition>
    <block>{<block_content>
            <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* verify that it is an agtype path */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>agtv_path</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>AGTV_PATH</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                        <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"relationships() argument must be a path"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* clear the result structure */</comment>
    <expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>agis_result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>agtype_in_state</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* push the beginning of the array */</comment>
    <expr_stmt><expr><name><name>agis_result</name><operator>.</operator><name>res</name></name> <operator>=</operator> <call><name>push_agtype_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>agis_result</name><operator>.</operator><name>parse_state</name></name></expr></argument>,
                                        <argument><expr><name>WAGT_BEGIN_ARRAY</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* push in each edge (every other entry) from the path */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>agtv_path</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>array</name><operator>.</operator><name>num_elems</name></name></expr>;</condition> <incr><expr><name>i</name> <operator>+=</operator> <literal type="number">2</literal></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name><name>agis_result</name><operator>.</operator><name>res</name></name> <operator>=</operator> <call><name>push_agtype_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>agis_result</name><operator>.</operator><name>parse_state</name></name></expr></argument>, <argument><expr><name>WAGT_ELEM</name></expr></argument>,
                                            <argument><expr><operator>&amp;</operator><name><name>agtv_path</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>array</name><operator>.</operator><name>elems</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <comment type="block">/* push the end of the array */</comment>
    <expr_stmt><expr><name><name>agis_result</name><operator>.</operator><name>res</name></name> <operator>=</operator> <call><name>push_agtype_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>agis_result</name><operator>.</operator><name>parse_state</name></name></expr></argument>,
                                        <argument><expr><name>WAGT_END_ARRAY</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* convert the agtype_value to a datum to return to the caller */</comment>
    <expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><call><name>agtype_value_to_agtype</name><argument_list>(<argument><expr><name><name>agis_result</name><operator>.</operator><name>res</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Helper function to convert an integer type (PostgreSQL or agtype) datum into
 * an int64. The function will flag if an agtype null was found. The function
 * will error out on invalid information, printing out the funcname passed.
 */</comment>
<function><type><specifier>static</specifier> <name>int64</name></type> <name>get_int64_from_int_datums</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>d</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>funcname</name></decl></parameter>,
                                       <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>is_agnull</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int64</name></type> <name>result</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <comment type="block">/* test for PG integer types */</comment>
    <if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>INT2OID</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>int64</name><operator>)</operator> <call><name>DatumGetInt16</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>type</name> <operator>==</operator> <name>INT4OID</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>int64</name><operator>)</operator> <call><name>DatumGetInt32</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>type</name> <operator>==</operator> <name>INT8OID</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>int64</name><operator>)</operator> <call><name>DatumGetInt64</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <comment type="block">/* test for agtype integer */</comment>
    <if type="elseif">else if <condition>(<expr><name>type</name> <operator>==</operator> <name>AGTYPEOID</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>agtype</name> <modifier>*</modifier></type><name>agt_arg</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>agtv_value</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>agtype_container</name> <modifier>*</modifier></type><name>agtc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

        <comment type="block">/* get the agtype argument */</comment>
        <expr_stmt><expr><name>agt_arg</name> <operator>=</operator> <call><name>DATUM_GET_AGTYPE_P</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AGT_ROOT_IS_SCALAR</name><argument_list>(<argument><expr><name>agt_arg</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s() only supports scalar arguments"</literal></expr></argument>, <argument><expr><name>funcname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <comment type="block">/* check for agtype null*/</comment>
        <expr_stmt><expr><name>agtc</name> <operator>=</operator> <operator>&amp;</operator><name><name>agt_arg</name><operator>-&gt;</operator><name>root</name></name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>AGTE_IS_NULL</name><argument_list>(<argument><expr><name><name>agtc</name><operator>-&gt;</operator><name>children</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><operator>*</operator><name>is_agnull</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <return>return <expr><literal type="number">0</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* extract it from the scalar array */</comment>
        <expr_stmt><expr><name>agtv_value</name> <operator>=</operator> <call><name>get_ith_agtype_value_from_container</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>agt_arg</name><operator>-&gt;</operator><name>root</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* check for agtype integer */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>agtv_value</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AGTV_INTEGER</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>agtv_value</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>int_value</name></name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s() unsupported argument type"</literal></expr></argument>, <argument><expr><name>funcname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s() unsupported argument type"</literal></expr></argument>, <argument><expr><name>funcname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* return the result */</comment>
    <expr_stmt><expr><operator>*</operator><name>is_agnull</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>age_range</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<comment type="block">/*
 * Execution function to implement openCypher range() function
 */</comment>
<function><type><name>Datum</name></type> <name>age_range</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Datum</name> <modifier>*</modifier></type><name>args</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name> <modifier>*</modifier></type><name>nulls</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name> <modifier>*</modifier></type><name>types</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nargs</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int64</name></type> <name>start_idx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int64</name></type> <name>end_idx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <comment type="block">/* step defaults to 1 */</comment>
    <decl_stmt><decl><type><name>int64</name></type> <name>step</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>is_agnull</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_in_state</name></type> <name>agis_result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int64</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <comment type="block">/* get the arguments */</comment>
    <expr_stmt><expr><name>nargs</name> <operator>=</operator> <call><name>extract_variadic_args</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>args</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>types</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* throw an error if the number of args is not the expected number */</comment>
    <if_stmt><if>if <condition>(<expr><name>nargs</name> <operator>!=</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <name>nargs</name> <operator>!=</operator> <literal type="number">3</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"range(): invalid number of input parameters"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* check for NULL start and end input */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>nulls</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>||</operator> <name><name>nulls</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"range(): neither start or end can be NULL"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* get the start index */</comment>
    <expr_stmt><expr><name>start_idx</name> <operator>=</operator> <call><name>get_int64_from_int_datums</name><argument_list>(<argument><expr><name><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>types</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"range"</literal></expr></argument>,
                                          <argument><expr><operator>&amp;</operator><name>is_agnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>is_agnull</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"range(): start cannot be NULL"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* get the end index */</comment>
    <expr_stmt><expr><name>end_idx</name> <operator>=</operator> <call><name>get_int64_from_int_datums</name><argument_list>(<argument><expr><name><name>args</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>types</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"range"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>is_agnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>is_agnull</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"range(): end cannot be NULL"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* get the step */</comment>
    <if_stmt><if>if <condition>(<expr><name>nargs</name> <operator>==</operator> <literal type="number">3</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>nulls</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>step</name> <operator>=</operator> <call><name>get_int64_from_int_datums</name><argument_list>(<argument><expr><name><name>args</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>types</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"range"</literal></expr></argument>,
                                         <argument><expr><operator>&amp;</operator><name>is_agnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>is_agnull</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>step</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* the step cannot be zero */</comment>
    <if_stmt><if>if <condition>(<expr><name>step</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"range(): step cannot be zero"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* clear the result structure */</comment>
    <expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>agis_result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>agtype_in_state</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* push the beginning of the array */</comment>
    <expr_stmt><expr><name><name>agis_result</name><operator>.</operator><name>res</name></name> <operator>=</operator> <call><name>push_agtype_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>agis_result</name><operator>.</operator><name>parse_state</name></name></expr></argument>,
                                        <argument><expr><name>WAGT_BEGIN_ARRAY</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* push in each agtype integer in the range */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>start_idx</name></expr>;</init>
         <condition><expr><operator>(</operator><name>step</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>i</name> <operator>&lt;=</operator> <name>end_idx</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>step</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>i</name> <operator>&gt;=</operator> <name>end_idx</name><operator>)</operator></expr>;</condition>
         <incr><expr><name>i</name> <operator>+=</operator> <name>step</name></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>agtype_value</name></type> <name>agtv</name></decl>;</decl_stmt>

        <comment type="block">/* build the integer */</comment>
        <expr_stmt><expr><name><name>agtv</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>AGTV_INTEGER</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>agtv</name><operator>.</operator><name>val</name><operator>.</operator><name>int_value</name></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
        <comment type="block">/* add the value to the array */</comment>
        <expr_stmt><expr><name><name>agis_result</name><operator>.</operator><name>res</name></name> <operator>=</operator> <call><name>push_agtype_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>agis_result</name><operator>.</operator><name>parse_state</name></name></expr></argument>, <argument><expr><name>WAGT_ELEM</name></expr></argument>,
                                            <argument><expr><operator>&amp;</operator><name>agtv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <comment type="block">/* push the end of the array */</comment>
    <expr_stmt><expr><name><name>agis_result</name><operator>.</operator><name>res</name></name> <operator>=</operator> <call><name>push_agtype_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>agis_result</name><operator>.</operator><name>parse_state</name></name></expr></argument>,
                                        <argument><expr><name>WAGT_END_ARRAY</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* convert the agtype_value to a datum to return to the caller */</comment>
    <expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><call><name>agtype_value_to_agtype</name><argument_list>(<argument><expr><name><name>agis_result</name><operator>.</operator><name>res</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>age_unnest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<comment type="block">/*
 * Function to convert the Array type of Agtype into each row. It is used for
 * Cypher `UNWIND` clause, but considering the situation in which the user can
 * directly use this function in vanilla PGSQL, put a second parameter related
 * to this.
 */</comment>
<function><type><name>Datum</name></type> <name>age_unnest</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>agtype</name> <modifier>*</modifier></type><name>agtype_arg</name> <init>= <expr><call><name>AG_GET_ARG_AGTYPE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>block_types</name> <init>= <expr><call><name>PG_GETARG_BOOL</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ReturnSetInfo</name> <modifier>*</modifier></type><name>rsi</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Tuplestorestate</name> <modifier>*</modifier></type><name>tuple_store</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TupleDesc</name></type> <name>tupdesc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TupleDesc</name></type> <name>ret_tdesc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>old_cxt</name></decl>, <decl><type ref="prev"/><name>tmp_cxt</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>skipNested</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_iterator</name> <modifier>*</modifier></type><name>it</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_value</name></type> <name>v</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_iterator_token</name></type> <name>r</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AGT_ROOT_IS_ARRAY</name><argument_list>(<argument><expr><name>agtype_arg</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                        <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot extract elements from an object"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>rsi</name> <operator>=</operator> <operator>(</operator><name>ReturnSetInfo</name> <operator>*</operator><operator>)</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>resultinfo</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>rsi</name><operator>-&gt;</operator><name>returnMode</name></name> <operator>=</operator> <name>SFRM_Materialize</name></expr>;</expr_stmt>

    <comment type="block">/* it's a simple type, so don't use get_call_result_type() */</comment>
    <expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <name><name>rsi</name><operator>-&gt;</operator><name>expectedDesc</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><name>old_cxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>rsi</name><operator>-&gt;</operator><name>econtext</name><operator>-&gt;</operator><name>ecxt_per_query_memory</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>ret_tdesc</name> <operator>=</operator> <call><name>CreateTupleDescCopy</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BlessTupleDesc</name><argument_list>(<argument><expr><name>ret_tdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>tuple_store</name> <operator>=</operator>
            <call><name>tuplestore_begin_heap</name><argument_list>(<argument><expr><name><name>rsi</name><operator>-&gt;</operator><name>allowedModes</name></name> <operator>&amp;</operator> <name>SFRM_Materialize_Random</name></expr></argument>,
                                  <argument><expr><name>false</name></expr></argument>, <argument><expr><name>work_mem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>old_cxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>tmp_cxt</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>,
                                    <argument><expr><literal type="string">"age_unnest temporary cxt"</literal></expr></argument>,
                                    <argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>it</name> <operator>=</operator> <call><name>agtype_iterator_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>agtype_arg</name><operator>-&gt;</operator><name>root</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <while>while <condition>(<expr><operator>(</operator><name>r</name> <operator>=</operator> <call><name>agtype_iterator_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name>it</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>v</name></expr></argument>, <argument><expr><name>skipNested</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>WAGT_DONE</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>skipNested</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>r</name> <operator>==</operator> <name>WAGT_ELEM</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Datum</name></type> <name><name>values</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>bool</name></type> <name><name>nulls</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <init>= <expr><block>{<expr><name>false</name></expr>}</block></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>agtype</name> <modifier>*</modifier></type><name>val</name> <init>= <expr><call><name>agtype_value_to_agtype</name><argument_list>(<argument><expr><operator>&amp;</operator><name>v</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name>block_types</name> <operator>&amp;&amp;</operator> <operator>(</operator>
                    <name><name>v</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>AGTV_VERTEX</name> <operator>||</operator> <name><name>v</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>AGTV_EDGE</name> <operator>||</operator> <name><name>v</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>AGTV_PATH</name><operator>)</operator></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                                <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"UNWIND clause does not support agtype %s"</literal></expr></argument>,
                                       <argument><expr><call><name>agtype_value_type_to_string</name><argument_list>(<argument><expr><name><name>v</name><operator>.</operator><name>type</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <comment type="block">/* use the tmp context so we can clean up after each tuple is done */</comment>
            <expr_stmt><expr><name>old_cxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>tmp_cxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>heap_form_tuple</name><argument_list>(<argument><expr><name>ret_tdesc</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>tuplestore_puttuple</name><argument_list>(<argument><expr><name>tuple_store</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* clean up and switch back */</comment>
            <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>old_cxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>MemoryContextReset</name><argument_list>(<argument><expr><name>tmp_cxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></while>

    <expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name>tmp_cxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>rsi</name><operator>-&gt;</operator><name>setResult</name></name> <operator>=</operator> <name>tuple_store</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rsi</name><operator>-&gt;</operator><name>setDesc</name></name> <operator>=</operator> <name>ret_tdesc</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
