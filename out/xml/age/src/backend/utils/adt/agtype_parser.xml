<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/workspace/age/src/backend/utils/adt/agtype_parser.c"><comment type="block">/*
 * For PostgreSQL Database Management System:
 * (formerly known as Postgres, then as Postgres95)
 *
 * Portions Copyright (c) 1996-2010, The PostgreSQL Global Development Group
 *
 * Portions Copyright (c) 1994, The Regents of the University of California
 *
 * Permission to use, copy, modify, and distribute this software and its documentation for any purpose,
 * without fee, and without a written agreement is hereby granted, provided that the above copyright notice
 * and this paragraph and the following two paragraphs appear in all copies.
 *
 * IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR DIRECT,
 * INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS,
 * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF THE UNIVERSITY
 * OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
 * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 *
 * THE SOFTWARE PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND THE UNIVERSITY OF CALIFORNIA
 * HAS NO OBLIGATIONS TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
 */</comment>

<comment type="block">/*
 * agtype parser.
 *
 * Portions Copyright (c) 1996-2018, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq/pqformat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/date.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/datetime.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/agtype_parser.h"</cpp:file></cpp:include>

<comment type="block">/*
 * The context of the parser is maintained by the recursive descent
 * mechanism, but is passed explicitly to the error reporting routine
 * for better diagnostics.
 */</comment>
<typedef>typedef <type><enum>enum <comment type="block">/* contexts of agtype parser */</comment>
<block>{
    <decl><name>AGTYPE_PARSE_VALUE</name></decl>, <comment type="block">/* expecting a value */</comment>
    <decl><name>AGTYPE_PARSE_STRING</name></decl>, <comment type="block">/* expecting a string (for a field name) */</comment>
    <decl><name>AGTYPE_PARSE_ARRAY_START</name></decl>, <comment type="block">/* saw '[', expecting value or ']' */</comment>
    <decl><name>AGTYPE_PARSE_ARRAY_NEXT</name></decl>, <comment type="block">/* saw array element, expecting ',' or ']' */</comment>
    <decl><name>AGTYPE_PARSE_OBJECT_START</name></decl>, <comment type="block">/* saw '{', expecting label or '}' */</comment>
    <decl><name>AGTYPE_PARSE_OBJECT_LABEL</name></decl>, <comment type="block">/* saw object label, expecting ':' */</comment>
    <decl><name>AGTYPE_PARSE_OBJECT_NEXT</name></decl>, <comment type="block">/* saw object value, expecting ',' or '}' */</comment>
    <decl><name>AGTYPE_PARSE_OBJECT_COMMA</name></decl>, <comment type="block">/* saw object ',', expecting next label */</comment>
    <decl><name>AGTYPE_PARSE_END</name></decl> <comment type="block">/* saw the end of a document, expect nothing */</comment>
}</block></enum></type> <name>agtype_parse_context</name>;</typedef>

<function_decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>agtype_lex</name><parameter_list>(<parameter><decl><type><name>agtype_lex_context</name> <modifier>*</modifier></type><name>lex</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>agtype_lex_string</name><parameter_list>(<parameter><decl><type><name>agtype_lex_context</name> <modifier>*</modifier></type><name>lex</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>agtype_lex_number</name><parameter_list>(<parameter><decl><type><name>agtype_lex_context</name> <modifier>*</modifier></type><name>lex</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>,
                                     <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>num_err</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>total_len</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>parse_scalar_annotation</name><parameter_list>(<parameter><decl><type><name>agtype_lex_context</name> <modifier>*</modifier></type><name>lex</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>func</name></decl></parameter>,
                                    <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>annotation</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>parse_annotation</name><parameter_list>(<parameter><decl><type><name>agtype_lex_context</name> <modifier>*</modifier></type><name>lex</name></decl></parameter>, <parameter><decl><type><name>agtype_sem_action</name> <modifier>*</modifier></type><name>sem</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>parse_scalar</name><parameter_list>(<parameter><decl><type><name>agtype_lex_context</name> <modifier>*</modifier></type><name>lex</name></decl></parameter>,
                                <parameter><decl><type><name>agtype_sem_action</name> <modifier>*</modifier></type><name>sem</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>parse_object_field</name><parameter_list>(<parameter><decl><type><name>agtype_lex_context</name> <modifier>*</modifier></type><name>lex</name></decl></parameter>,
                               <parameter><decl><type><name>agtype_sem_action</name> <modifier>*</modifier></type><name>sem</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>parse_object</name><parameter_list>(<parameter><decl><type><name>agtype_lex_context</name> <modifier>*</modifier></type><name>lex</name></decl></parameter>, <parameter><decl><type><name>agtype_sem_action</name> <modifier>*</modifier></type><name>sem</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>parse_array_element</name><parameter_list>(<parameter><decl><type><name>agtype_lex_context</name> <modifier>*</modifier></type><name>lex</name></decl></parameter>,
                                <parameter><decl><type><name>agtype_sem_action</name> <modifier>*</modifier></type><name>sem</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>parse_array</name><parameter_list>(<parameter><decl><type><name>agtype_lex_context</name> <modifier>*</modifier></type><name>lex</name></decl></parameter>, <parameter><decl><type><name>agtype_sem_action</name> <modifier>*</modifier></type><name>sem</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>report_parse_error</name><parameter_list>(<parameter><decl><type><name>agtype_parse_context</name></type> <name>ctx</name></decl></parameter>,
                               <parameter><decl><type><name>agtype_lex_context</name> <modifier>*</modifier></type><name>lex</name></decl></parameter>)</parameter_list>
    pg_attribute_noreturn<parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>report_invalid_token</name><parameter_list>(<parameter><decl><type><name>agtype_lex_context</name> <modifier>*</modifier></type><name>lex</name></decl></parameter>)</parameter_list>
    pg_attribute_noreturn<parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>report_agtype_context</name><parameter_list>(<parameter><decl><type><name>agtype_lex_context</name> <modifier>*</modifier></type><name>lex</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>extract_mb_char</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Recursive Descent parser support routines */</comment>

<comment type="block">/*
 * lex_peek
 *
 * what is the current look_ahead token?
*/</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>agtype_token_type</name></type> <name>lex_peek</name><parameter_list>(<parameter><decl><type><name>agtype_lex_context</name> <modifier>*</modifier></type><name>lex</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><name><name>lex</name><operator>-&gt;</operator><name>token_type</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * lex_accept
 *
 * accept the look_ahead token and move the lexer to the next token if the
 * look_ahead token matches the token parameter. In that case, and if required,
 * also hand back the de-escaped lexeme.
 *
 * returns true if the token matched, false otherwise.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>bool</name></type> <name>lex_accept</name><parameter_list>(<parameter><decl><type><name>agtype_lex_context</name> <modifier>*</modifier></type><name>lex</name></decl></parameter>, <parameter><decl><type><name>agtype_token_type</name></type> <name>token</name></decl></parameter>,
                              <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>lexeme</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>lex</name><operator>-&gt;</operator><name>token_type</name></name> <operator>==</operator> <name>token</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>lexeme</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>lex</name><operator>-&gt;</operator><name>token_type</name></name> <operator>==</operator> <name>AGTYPE_TOKEN_STRING</name></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name><name>lex</name><operator>-&gt;</operator><name>strval</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><operator>*</operator><name>lexeme</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name><name>lex</name><operator>-&gt;</operator><name>strval</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><operator>(</operator><name><name>lex</name><operator>-&gt;</operator><name>token_terminator</name></name> <operator>-</operator> <name><name>lex</name><operator>-&gt;</operator><name>token_start</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>tokstr</name> <init>= <expr><call><name>palloc</name><argument_list>(<argument><expr><name>len</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>tokstr</name></expr></argument>, <argument><expr><name><name>lex</name><operator>-&gt;</operator><name>token_start</name></name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>tokstr</name><index>[<expr><name>len</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
                <expr_stmt><expr><operator>*</operator><name>lexeme</name> <operator>=</operator> <name>tokstr</name></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>agtype_lex</name><argument_list>(<argument><expr><name>lex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>true</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * lex_accept
 *
 * move the lexer to the next token if the current look_ahead token matches
 * the parameter token. Otherwise, report an error.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>lex_expect</name><parameter_list>(<parameter><decl><type><name>agtype_parse_context</name></type> <name>ctx</name></decl></parameter>,
                              <parameter><decl><type><name>agtype_lex_context</name> <modifier>*</modifier></type><name>lex</name></decl></parameter>, <parameter><decl><type><name>agtype_token_type</name></type> <name>token</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>lex_accept</name><argument_list>(<argument><expr><name>lex</name></expr></argument>, <argument><expr><name>token</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>report_parse_error</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>lex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* chars to consider as part of an alphanumeric token */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AGTYPE_ALPHANUMERIC_CHAR</name><parameter_list>(<parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro> \
    <cpp:value>(((c) &gt;= 'a' &amp;&amp; (c) &lt;= 'z') || ((c) &gt;= 'A' &amp;&amp; (c) &lt;= 'Z') || \
     ((c) &gt;= '0' &amp;&amp; (c) &lt;= '9') || (c) == '_' || IS_HIGHBIT_SET(c))</cpp:value></cpp:define>

<comment type="block">/*
 * Utility function to check if a string is a valid agtype number.
 *
 * str is of length len, and need not be null-terminated.
 */</comment>
<function><type><name>bool</name></type> <name>is_valid_agtype_number</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>bool</name></type> <name>numeric_error</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>total_len</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_lex_context</name></type> <name>dummy_lex</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * agtype_lex_number expects a leading  '-' to have been eaten already.
     *
     * having to cast away the constness of str is ugly, but there's not much
     * easy alternative.
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>str</name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>dummy_lex</name><operator>.</operator><name>input</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>str</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>dummy_lex</name><operator>.</operator><name>input_length</name></name> <operator>=</operator> <name>len</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name><name>dummy_lex</name><operator>.</operator><name>input</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>str</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>dummy_lex</name><operator>.</operator><name>input_length</name></name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><call><name>agtype_lex_number</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dummy_lex</name></expr></argument>, <argument><expr><name><name>dummy_lex</name><operator>.</operator><name>input</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>numeric_error</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>total_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><operator>(</operator><operator>!</operator><name>numeric_error</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>total_len</name> <operator>==</operator> <name><name>dummy_lex</name><operator>.</operator><name>input_length</name></name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * make_agtype_lex_context
 *
 * lex constructor, with or without StringInfo object
 * for de-escaped lexemes.
 *
 * Without is better as it makes the processing faster, so only make one
 * if really required.
 *
 * If you already have the agtype as a text* value, use the first of these
 * functions, otherwise use agtype_lex_context_cstring_len().
 */</comment>
<function><type><name>agtype_lex_context</name> <modifier>*</modifier></type><name>make_agtype_lex_context</name><parameter_list>(<parameter><decl><type><name>text</name> <modifier>*</modifier></type><name>t</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>need_escapes</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>make_agtype_lex_context_cstring_len</name><argument_list>(
        <argument><expr><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>need_escapes</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>agtype_lex_context</name> <modifier>*</modifier></type><name>make_agtype_lex_context_cstring_len</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>,
                                                        <parameter><decl><type><name>bool</name></type> <name>need_escapes</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>agtype_lex_context</name> <modifier>*</modifier></type><name>lex</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>agtype_lex_context</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>lex</name><operator>-&gt;</operator><name>input</name></name> <operator>=</operator> <name><name>lex</name><operator>-&gt;</operator><name>token_terminator</name></name> <operator>=</operator> <name><name>lex</name><operator>-&gt;</operator><name>line_start</name></name> <operator>=</operator> <name>str</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>lex</name><operator>-&gt;</operator><name>line_number</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>lex</name><operator>-&gt;</operator><name>input_length</name></name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>need_escapes</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>lex</name><operator>-&gt;</operator><name>strval</name></name> <operator>=</operator> <call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return <expr><name>lex</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * parse_agtype
 *
 * Publicly visible entry point for the agtype parser.
 *
 * lex is a lexing context, set up for the agtype to be processed by calling
 * make_agtype_lex_context(). sem is a structure of function pointers to
 * semantic action routines to be called at appropriate spots during parsing,
 * and a pointer to a state object to be passed to those routines.
 */</comment>
<function><type><name>void</name></type> <name>parse_agtype</name><parameter_list>(<parameter><decl><type><name>agtype_lex_context</name> <modifier>*</modifier></type><name>lex</name></decl></parameter>, <parameter><decl><type><name>agtype_sem_action</name> <modifier>*</modifier></type><name>sem</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>agtype_token_type</name></type> <name>tok</name></decl>;</decl_stmt>

    <comment type="block">/* get the initial token */</comment>
    <expr_stmt><expr><call><name>agtype_lex</name><argument_list>(<argument><expr><name>lex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>tok</name> <operator>=</operator> <call><name>lex_peek</name><argument_list>(<argument><expr><name>lex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* parse by recursive descent */</comment>
    <switch>switch <condition>(<expr><name>tok</name></expr>)</condition>
    <block>{<block_content>
    <case>case <expr><name>AGTYPE_TOKEN_OBJECT_START</name></expr>:</case>
        <expr_stmt><expr><call><name>parse_object</name><argument_list>(<argument><expr><name>lex</name></expr></argument>, <argument><expr><name>sem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
    <case>case <expr><name>AGTYPE_TOKEN_ARRAY_START</name></expr>:</case>
        <expr_stmt><expr><call><name>parse_array</name><argument_list>(<argument><expr><name>lex</name></expr></argument>, <argument><expr><name>sem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
    <default>default:</default>
        <expr_stmt><expr><call><name>parse_scalar</name><argument_list>(<argument><expr><name>lex</name></expr></argument>, <argument><expr><name>sem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* agtype can be a bare scalar */</comment>
    </block_content>}</block></switch>

    <expr_stmt><expr><call><name>lex_expect</name><argument_list>(<argument><expr><name>AGTYPE_PARSE_END</name></expr></argument>, <argument><expr><name>lex</name></expr></argument>, <argument><expr><name>AGTYPE_TOKEN_END</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>parse_scalar_annotation</name><parameter_list>(<parameter><decl><type><name>agtype_lex_context</name> <modifier>*</modifier></type><name>lex</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>func</name></decl></parameter>,
                                    <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>annotation</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/* check next token for annotations (typecasts, etc.) */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>lex_peek</name><argument_list>(<argument><expr><name>lex</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>AGTYPE_TOKEN_ANNOTATION</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* eat the annotation token */</comment>
        <expr_stmt><expr><call><name>lex_accept</name><argument_list>(<argument><expr><name>lex</name></expr></argument>, <argument><expr><name>AGTYPE_TOKEN_ANNOTATION</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>lex_peek</name><argument_list>(<argument><expr><name>lex</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>AGTYPE_TOKEN_IDENTIFIER</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* eat the identifier token and get the annotation value */</comment>
            <if_stmt><if>if <condition>(<expr><name>func</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>lex_accept</name><argument_list>(<argument><expr><name>lex</name></expr></argument>, <argument><expr><name>AGTYPE_TOKEN_IDENTIFIER</name></expr></argument>, <argument><expr><name>annotation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>lex_accept</name><argument_list>(<argument><expr><name>lex</name></expr></argument>, <argument><expr><name>AGTYPE_TOKEN_IDENTIFIER</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid value for annotation"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>parse_annotation</name><parameter_list>(<parameter><decl><type><name>agtype_lex_context</name> <modifier>*</modifier></type><name>lex</name></decl></parameter>, <parameter><decl><type><name>agtype_sem_action</name> <modifier>*</modifier></type><name>sem</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>annotation</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_annotation_action</name></type> <name>afunc</name> <init>= <expr><name><name>sem</name><operator>-&gt;</operator><name>agtype_annotation</name></name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* check next token for annotations (typecasts, etc.) */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>lex_peek</name><argument_list>(<argument><expr><name>lex</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>AGTYPE_TOKEN_ANNOTATION</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* eat the annotation token */</comment>
        <expr_stmt><expr><call><name>lex_accept</name><argument_list>(<argument><expr><name>lex</name></expr></argument>, <argument><expr><name>AGTYPE_TOKEN_ANNOTATION</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>lex_peek</name><argument_list>(<argument><expr><name>lex</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>AGTYPE_TOKEN_IDENTIFIER</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* eat the identifier token and get the annotation value */</comment>
            <expr_stmt><expr><call><name>lex_accept</name><argument_list>(<argument><expr><name>lex</name></expr></argument>, <argument><expr><name>AGTYPE_TOKEN_IDENTIFIER</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>annotation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid value for annotation"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

        <comment type="block">/* pass to annotation callback */</comment>
        <if_stmt><if>if <condition>(<expr><name>afunc</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call>(<modifier>*</modifier><name>afunc</name>)<argument_list>(<argument><expr><name><name>sem</name><operator>-&gt;</operator><name>semstate</name></name></expr></argument>, <argument><expr><name>annotation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *  Recursive Descent parse routines. There is one for each structural
 *  element in an agtype document:
 *    - scalar (string, number, true, false, null)
 *    - array  ( [ ] )
 *    - array element
 *    - object ( { } )
 *    - object field
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>parse_scalar</name><parameter_list>(<parameter><decl><type><name>agtype_lex_context</name> <modifier>*</modifier></type><name>lex</name></decl></parameter>,
                                <parameter><decl><type><name>agtype_sem_action</name> <modifier>*</modifier></type><name>sem</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>val</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>annotation</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_scalar_action</name></type> <name>sfunc</name> <init>= <expr><name><name>sem</name><operator>-&gt;</operator><name>scalar</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>valaddr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_token_type</name></type> <name>tok</name> <init>= <expr><call><name>lex_peek</name><argument_list>(<argument><expr><name>lex</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>valaddr</name> <operator>=</operator> <ternary><condition><expr><name>sfunc</name> <operator>==</operator> <name>NULL</name></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>: <expr><operator>&amp;</operator><name>val</name></expr></else></ternary></expr>;</expr_stmt>

    <comment type="block">/* a scalar must be a string, a number, true, false, or null */</comment>
    <switch>switch <condition>(<expr><name>tok</name></expr>)</condition>
    <block>{<block_content>
    <case>case <expr><name>AGTYPE_TOKEN_TRUE</name></expr>:</case>
        <expr_stmt><expr><call><name>lex_accept</name><argument_list>(<argument><expr><name>lex</name></expr></argument>, <argument><expr><name>AGTYPE_TOKEN_TRUE</name></expr></argument>, <argument><expr><name>valaddr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
    <case>case <expr><name>AGTYPE_TOKEN_FALSE</name></expr>:</case>
        <expr_stmt><expr><call><name>lex_accept</name><argument_list>(<argument><expr><name>lex</name></expr></argument>, <argument><expr><name>AGTYPE_TOKEN_FALSE</name></expr></argument>, <argument><expr><name>valaddr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
    <case>case <expr><name>AGTYPE_TOKEN_NULL</name></expr>:</case>
        <expr_stmt><expr><call><name>lex_accept</name><argument_list>(<argument><expr><name>lex</name></expr></argument>, <argument><expr><name>AGTYPE_TOKEN_NULL</name></expr></argument>, <argument><expr><name>valaddr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
    <case>case <expr><name>AGTYPE_TOKEN_INTEGER</name></expr>:</case>
        <expr_stmt><expr><call><name>lex_accept</name><argument_list>(<argument><expr><name>lex</name></expr></argument>, <argument><expr><name>AGTYPE_TOKEN_INTEGER</name></expr></argument>, <argument><expr><name>valaddr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
    <case>case <expr><name>AGTYPE_TOKEN_FLOAT</name></expr>:</case>
        <expr_stmt><expr><call><name>lex_accept</name><argument_list>(<argument><expr><name>lex</name></expr></argument>, <argument><expr><name>AGTYPE_TOKEN_FLOAT</name></expr></argument>, <argument><expr><name>valaddr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
    <case>case <expr><name>AGTYPE_TOKEN_STRING</name></expr>:</case>
        <expr_stmt><expr><call><name>lex_accept</name><argument_list>(<argument><expr><name>lex</name></expr></argument>, <argument><expr><name>AGTYPE_TOKEN_STRING</name></expr></argument>, <argument><expr><name>valaddr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
    <default>default:</default>
        <expr_stmt><expr><call><name>report_parse_error</name><argument_list>(<argument><expr><name>AGTYPE_PARSE_VALUE</name></expr></argument>, <argument><expr><name>lex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></switch>

    <comment type="block">/* parse annotations (typecasts) */</comment>
    <expr_stmt><expr><call><name>parse_scalar_annotation</name><argument_list>(<argument><expr><name>lex</name></expr></argument>, <argument><expr><name>sfunc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>annotation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>sfunc</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call>(<modifier>*</modifier><name>sfunc</name>)<argument_list>(<argument><expr><name><name>sem</name><operator>-&gt;</operator><name>semstate</name></name></expr></argument>, <argument><expr><name>val</name></expr></argument>, <argument><expr><name>tok</name></expr></argument>, <argument><expr><name>annotation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>parse_object_field</name><parameter_list>(<parameter><decl><type><name>agtype_lex_context</name> <modifier>*</modifier></type><name>lex</name></decl></parameter>, <parameter><decl><type><name>agtype_sem_action</name> <modifier>*</modifier></type><name>sem</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/*
     * An object field is "fieldname" : value where value can be a scalar,
     * object or array.  Note: in user-facing docs and error messages, we
     * generally call a field name a "key".
     */</comment>

    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>fname</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt> <comment type="block">/* keep compiler quiet */</comment>
    <decl_stmt><decl><type><name>agtype_ofield_action</name></type> <name>ostart</name> <init>= <expr><name><name>sem</name><operator>-&gt;</operator><name>object_field_start</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_ofield_action</name></type> <name>oend</name> <init>= <expr><name><name>sem</name><operator>-&gt;</operator><name>object_field_end</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>isnull</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>fnameaddr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_token_type</name></type> <name>tok</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>ostart</name> <operator>!=</operator> <name>NULL</name> <operator>||</operator> <name>oend</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>fnameaddr</name> <operator>=</operator> <operator>&amp;</operator><name>fname</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>lex_accept</name><argument_list>(<argument><expr><name>lex</name></expr></argument>, <argument><expr><name>AGTYPE_TOKEN_STRING</name></expr></argument>, <argument><expr><name>fnameaddr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>report_parse_error</name><argument_list>(<argument><expr><name>AGTYPE_PARSE_STRING</name></expr></argument>, <argument><expr><name>lex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>lex_expect</name><argument_list>(<argument><expr><name>AGTYPE_PARSE_OBJECT_LABEL</name></expr></argument>, <argument><expr><name>lex</name></expr></argument>, <argument><expr><name>AGTYPE_TOKEN_COLON</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>tok</name> <operator>=</operator> <call><name>lex_peek</name><argument_list>(<argument><expr><name>lex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>isnull</name> <operator>=</operator> <name>tok</name> <operator>==</operator> <name>AGTYPE_TOKEN_NULL</name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>ostart</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call>(<modifier>*</modifier><name>ostart</name>)<argument_list>(<argument><expr><name><name>sem</name><operator>-&gt;</operator><name>semstate</name></name></expr></argument>, <argument><expr><name>fname</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <switch>switch <condition>(<expr><name>tok</name></expr>)</condition>
    <block>{<block_content>
    <case>case <expr><name>AGTYPE_TOKEN_OBJECT_START</name></expr>:</case>
        <expr_stmt><expr><call><name>parse_object</name><argument_list>(<argument><expr><name>lex</name></expr></argument>, <argument><expr><name>sem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
    <case>case <expr><name>AGTYPE_TOKEN_ARRAY_START</name></expr>:</case>
        <expr_stmt><expr><call><name>parse_array</name><argument_list>(<argument><expr><name>lex</name></expr></argument>, <argument><expr><name>sem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
    <default>default:</default>
        <expr_stmt><expr><call><name>parse_scalar</name><argument_list>(<argument><expr><name>lex</name></expr></argument>, <argument><expr><name>sem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></switch>

    <if_stmt><if>if <condition>(<expr><name>oend</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call>(<modifier>*</modifier><name>oend</name>)<argument_list>(<argument><expr><name><name>sem</name><operator>-&gt;</operator><name>semstate</name></name></expr></argument>, <argument><expr><name>fname</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>parse_object</name><parameter_list>(<parameter><decl><type><name>agtype_lex_context</name> <modifier>*</modifier></type><name>lex</name></decl></parameter>, <parameter><decl><type><name>agtype_sem_action</name> <modifier>*</modifier></type><name>sem</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/*
     * an object is a possibly empty sequence of object fields, separated by
     * commas and surrounded by curly braces.
     */</comment>
    <decl_stmt><decl><type><name>agtype_struct_action</name></type> <name>ostart</name> <init>= <expr><name><name>sem</name><operator>-&gt;</operator><name>object_start</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_struct_action</name></type> <name>oend</name> <init>= <expr><name><name>sem</name><operator>-&gt;</operator><name>object_end</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_token_type</name></type> <name>tok</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>check_stack_depth</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>ostart</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call>(<modifier>*</modifier><name>ostart</name>)<argument_list>(<argument><expr><name><name>sem</name><operator>-&gt;</operator><name>semstate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Data inside an object is at a higher nesting level than the object
     * itself. Note that we increment this after we call the semantic routine
     * for the object start and restore it before we call the routine for the
     * object end.
     */</comment>
    <expr_stmt><expr><name><name>lex</name><operator>-&gt;</operator><name>lex_level</name></name><operator>++</operator></expr>;</expr_stmt>

    <comment type="block">/* we know this will succeed, just clearing the token */</comment>
    <expr_stmt><expr><call><name>lex_expect</name><argument_list>(<argument><expr><name>AGTYPE_PARSE_OBJECT_START</name></expr></argument>, <argument><expr><name>lex</name></expr></argument>, <argument><expr><name>AGTYPE_TOKEN_OBJECT_START</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>tok</name> <operator>=</operator> <call><name>lex_peek</name><argument_list>(<argument><expr><name>lex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <switch>switch <condition>(<expr><name>tok</name></expr>)</condition>
    <block>{<block_content>
    <case>case <expr><name>AGTYPE_TOKEN_STRING</name></expr>:</case>
        <expr_stmt><expr><call><name>parse_object_field</name><argument_list>(<argument><expr><name>lex</name></expr></argument>, <argument><expr><name>sem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <while>while <condition>(<expr><call><name>lex_accept</name><argument_list>(<argument><expr><name>lex</name></expr></argument>, <argument><expr><name>AGTYPE_TOKEN_COMMA</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>parse_object_field</name><argument_list>(<argument><expr><name>lex</name></expr></argument>, <argument><expr><name>sem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
        <break>break;</break>
    <case>case <expr><name>AGTYPE_TOKEN_OBJECT_END</name></expr>:</case>
        <break>break;</break>
    <default>default:</default>
        <comment type="block">/* case of an invalid initial token inside the object */</comment>
        <expr_stmt><expr><call><name>report_parse_error</name><argument_list>(<argument><expr><name>AGTYPE_PARSE_OBJECT_START</name></expr></argument>, <argument><expr><name>lex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></switch>

    <expr_stmt><expr><call><name>lex_expect</name><argument_list>(<argument><expr><name>AGTYPE_PARSE_OBJECT_NEXT</name></expr></argument>, <argument><expr><name>lex</name></expr></argument>, <argument><expr><name>AGTYPE_TOKEN_OBJECT_END</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>lex</name><operator>-&gt;</operator><name>lex_level</name></name><operator>--</operator></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>oend</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call>(<modifier>*</modifier><name>oend</name>)<argument_list>(<argument><expr><name><name>sem</name><operator>-&gt;</operator><name>semstate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* parse annotations (typecasts) */</comment>
    <expr_stmt><expr><call><name>parse_annotation</name><argument_list>(<argument><expr><name>lex</name></expr></argument>, <argument><expr><name>sem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>parse_array_element</name><parameter_list>(<parameter><decl><type><name>agtype_lex_context</name> <modifier>*</modifier></type><name>lex</name></decl></parameter>,
                                <parameter><decl><type><name>agtype_sem_action</name> <modifier>*</modifier></type><name>sem</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>agtype_aelem_action</name></type> <name>astart</name> <init>= <expr><name><name>sem</name><operator>-&gt;</operator><name>array_element_start</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_aelem_action</name></type> <name>aend</name> <init>= <expr><name><name>sem</name><operator>-&gt;</operator><name>array_element_end</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_token_type</name></type> <name>tok</name> <init>= <expr><call><name>lex_peek</name><argument_list>(<argument><expr><name>lex</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>bool</name></type> <name>isnull</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>isnull</name> <operator>=</operator> <name>tok</name> <operator>==</operator> <name>AGTYPE_TOKEN_NULL</name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>astart</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call>(<modifier>*</modifier><name>astart</name>)<argument_list>(<argument><expr><name><name>sem</name><operator>-&gt;</operator><name>semstate</name></name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* an array element is any object, array or scalar */</comment>
    <switch>switch <condition>(<expr><name>tok</name></expr>)</condition>
    <block>{<block_content>
    <case>case <expr><name>AGTYPE_TOKEN_OBJECT_START</name></expr>:</case>
        <expr_stmt><expr><call><name>parse_object</name><argument_list>(<argument><expr><name>lex</name></expr></argument>, <argument><expr><name>sem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
    <case>case <expr><name>AGTYPE_TOKEN_ARRAY_START</name></expr>:</case>
        <expr_stmt><expr><call><name>parse_array</name><argument_list>(<argument><expr><name>lex</name></expr></argument>, <argument><expr><name>sem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
    <default>default:</default>
        <expr_stmt><expr><call><name>parse_scalar</name><argument_list>(<argument><expr><name>lex</name></expr></argument>, <argument><expr><name>sem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></switch>

    <if_stmt><if>if <condition>(<expr><name>aend</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call>(<modifier>*</modifier><name>aend</name>)<argument_list>(<argument><expr><name><name>sem</name><operator>-&gt;</operator><name>semstate</name></name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>parse_array</name><parameter_list>(<parameter><decl><type><name>agtype_lex_context</name> <modifier>*</modifier></type><name>lex</name></decl></parameter>, <parameter><decl><type><name>agtype_sem_action</name> <modifier>*</modifier></type><name>sem</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/*
     * an array is a possibly empty sequence of array elements, separated by
     * commas and surrounded by square brackets.
     */</comment>
    <decl_stmt><decl><type><name>agtype_struct_action</name></type> <name>astart</name> <init>= <expr><name><name>sem</name><operator>-&gt;</operator><name>array_start</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_struct_action</name></type> <name>aend</name> <init>= <expr><name><name>sem</name><operator>-&gt;</operator><name>array_end</name></name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>check_stack_depth</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>astart</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call>(<modifier>*</modifier><name>astart</name>)<argument_list>(<argument><expr><name><name>sem</name><operator>-&gt;</operator><name>semstate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Data inside an array is at a higher nesting level than the array
     * itself. Note that we increment this after we call the semantic routine
     * for the array start and restore it before we call the routine for the
     * array end.
     */</comment>
    <expr_stmt><expr><name><name>lex</name><operator>-&gt;</operator><name>lex_level</name></name><operator>++</operator></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>lex_expect</name><argument_list>(<argument><expr><name>AGTYPE_PARSE_ARRAY_START</name></expr></argument>, <argument><expr><name>lex</name></expr></argument>, <argument><expr><name>AGTYPE_TOKEN_ARRAY_START</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>lex_peek</name><argument_list>(<argument><expr><name>lex</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>AGTYPE_TOKEN_ARRAY_END</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>parse_array_element</name><argument_list>(<argument><expr><name>lex</name></expr></argument>, <argument><expr><name>sem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <while>while <condition>(<expr><call><name>lex_accept</name><argument_list>(<argument><expr><name>lex</name></expr></argument>, <argument><expr><name>AGTYPE_TOKEN_COMMA</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>parse_array_element</name><argument_list>(<argument><expr><name>lex</name></expr></argument>, <argument><expr><name>sem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>lex_expect</name><argument_list>(<argument><expr><name>AGTYPE_PARSE_ARRAY_NEXT</name></expr></argument>, <argument><expr><name>lex</name></expr></argument>, <argument><expr><name>AGTYPE_TOKEN_ARRAY_END</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>lex</name><operator>-&gt;</operator><name>lex_level</name></name><operator>--</operator></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>aend</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call>(<modifier>*</modifier><name>aend</name>)<argument_list>(<argument><expr><name><name>sem</name><operator>-&gt;</operator><name>semstate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* parse annotations (typecasts) */</comment>
    <expr_stmt><expr><call><name>parse_annotation</name><argument_list>(<argument><expr><name>lex</name></expr></argument>, <argument><expr><name>sem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Lex one token from the input stream.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>agtype_lex</name><parameter_list>(<parameter><decl><type><name>agtype_lex_context</name> <modifier>*</modifier></type><name>lex</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>

    <comment type="block">/* Skip leading whitespace. */</comment>
    <expr_stmt><expr><name>s</name> <operator>=</operator> <name><name>lex</name><operator>-&gt;</operator><name>token_terminator</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>len</name> <operator>=</operator> <name>s</name> <operator>-</operator> <name><name>lex</name><operator>-&gt;</operator><name>input</name></name></expr>;</expr_stmt>
    <while>while <condition>(<expr><name>len</name> <operator>&lt;</operator> <name><name>lex</name><operator>-&gt;</operator><name>input_length</name></name> <operator>&amp;&amp;</operator>
           <operator>(</operator><operator>*</operator><name>s</name> <operator>==</operator> <literal type="char">' '</literal> <operator>||</operator> <operator>*</operator><name>s</name> <operator>==</operator> <literal type="char">'\t'</literal> <operator>||</operator> <operator>*</operator><name>s</name> <operator>==</operator> <literal type="char">'\n'</literal> <operator>||</operator> <operator>*</operator><name>s</name> <operator>==</operator> <literal type="char">'\r'</literal><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>*</operator><name>s</name> <operator>==</operator> <literal type="char">'\n'</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><operator>++</operator><name><name>lex</name><operator>-&gt;</operator><name>line_number</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><operator>++</operator><name>s</name></expr>;</expr_stmt>
        <expr_stmt><expr><operator>++</operator><name>len</name></expr>;</expr_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><name><name>lex</name><operator>-&gt;</operator><name>token_start</name></name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>

    <comment type="block">/* Determine token type. */</comment>
    <if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;=</operator> <name><name>lex</name><operator>-&gt;</operator><name>input_length</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>lex</name><operator>-&gt;</operator><name>token_start</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>lex</name><operator>-&gt;</operator><name>prev_token_terminator</name></name> <operator>=</operator> <name><name>lex</name><operator>-&gt;</operator><name>token_terminator</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>lex</name><operator>-&gt;</operator><name>token_terminator</name></name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>lex</name><operator>-&gt;</operator><name>token_type</name></name> <operator>=</operator> <name>AGTYPE_TOKEN_END</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <switch>switch <condition>(<expr><operator>*</operator><name>s</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* Single-character token, some kind of punctuation mark. */</comment>
        <case>case <expr><literal type="char">'{'</literal></expr>:</case>
            <expr_stmt><expr><name><name>lex</name><operator>-&gt;</operator><name>prev_token_terminator</name></name> <operator>=</operator> <name><name>lex</name><operator>-&gt;</operator><name>token_terminator</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>lex</name><operator>-&gt;</operator><name>token_terminator</name></name> <operator>=</operator> <name>s</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>lex</name><operator>-&gt;</operator><name>token_type</name></name> <operator>=</operator> <name>AGTYPE_TOKEN_OBJECT_START</name></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><literal type="char">'}'</literal></expr>:</case>
            <expr_stmt><expr><name><name>lex</name><operator>-&gt;</operator><name>prev_token_terminator</name></name> <operator>=</operator> <name><name>lex</name><operator>-&gt;</operator><name>token_terminator</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>lex</name><operator>-&gt;</operator><name>token_terminator</name></name> <operator>=</operator> <name>s</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>lex</name><operator>-&gt;</operator><name>token_type</name></name> <operator>=</operator> <name>AGTYPE_TOKEN_OBJECT_END</name></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><literal type="char">'['</literal></expr>:</case>
            <expr_stmt><expr><name><name>lex</name><operator>-&gt;</operator><name>prev_token_terminator</name></name> <operator>=</operator> <name><name>lex</name><operator>-&gt;</operator><name>token_terminator</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>lex</name><operator>-&gt;</operator><name>token_terminator</name></name> <operator>=</operator> <name>s</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>lex</name><operator>-&gt;</operator><name>token_type</name></name> <operator>=</operator> <name>AGTYPE_TOKEN_ARRAY_START</name></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><literal type="char">']'</literal></expr>:</case>
            <expr_stmt><expr><name><name>lex</name><operator>-&gt;</operator><name>prev_token_terminator</name></name> <operator>=</operator> <name><name>lex</name><operator>-&gt;</operator><name>token_terminator</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>lex</name><operator>-&gt;</operator><name>token_terminator</name></name> <operator>=</operator> <name>s</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>lex</name><operator>-&gt;</operator><name>token_type</name></name> <operator>=</operator> <name>AGTYPE_TOKEN_ARRAY_END</name></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><literal type="char">','</literal></expr>:</case>
            <expr_stmt><expr><name><name>lex</name><operator>-&gt;</operator><name>prev_token_terminator</name></name> <operator>=</operator> <name><name>lex</name><operator>-&gt;</operator><name>token_terminator</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>lex</name><operator>-&gt;</operator><name>token_terminator</name></name> <operator>=</operator> <name>s</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>lex</name><operator>-&gt;</operator><name>token_type</name></name> <operator>=</operator> <name>AGTYPE_TOKEN_COMMA</name></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><literal type="char">':'</literal></expr>:</case>
            <comment type="block">/* if this is an annotation '::' */</comment>
            <if_stmt><if>if <condition>(<expr><operator>(</operator><name>len</name> <operator>&lt;</operator> <name><name>lex</name><operator>-&gt;</operator><name>input_length</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>*</operator><operator>(</operator><name>s</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>==</operator> <literal type="char">':'</literal></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>s</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>lex</name><operator>-&gt;</operator><name>prev_token_terminator</name></name> <operator>=</operator> <name><name>lex</name><operator>-&gt;</operator><name>token_terminator</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>lex</name><operator>-&gt;</operator><name>token_terminator</name></name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>lex</name><operator>-&gt;</operator><name>token_type</name></name> <operator>=</operator> <name>AGTYPE_TOKEN_ANNOTATION</name></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><name><name>lex</name><operator>-&gt;</operator><name>prev_token_terminator</name></name> <operator>=</operator> <name><name>lex</name><operator>-&gt;</operator><name>token_terminator</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>lex</name><operator>-&gt;</operator><name>token_terminator</name></name> <operator>=</operator> <name>s</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>lex</name><operator>-&gt;</operator><name>token_type</name></name> <operator>=</operator> <name>AGTYPE_TOKEN_COLON</name></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
            <break>break;</break>
        <case>case <expr><literal type="char">'"'</literal></expr>:</case>
            <comment type="block">/* string */</comment>
            <expr_stmt><expr><call><name>agtype_lex_string</name><argument_list>(<argument><expr><name>lex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>lex</name><operator>-&gt;</operator><name>token_type</name></name> <operator>=</operator> <name>AGTYPE_TOKEN_STRING</name></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><literal type="char">'-'</literal></expr>:</case>
            <comment type="block">/* Negative numbers and special float values. */</comment>
            <if_stmt><if>if <condition>(<expr><operator>*</operator><operator>(</operator><name>s</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>==</operator> <literal type="char">'i'</literal> <operator>||</operator> <operator>*</operator><operator>(</operator><name>s</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>==</operator> <literal type="char">'I'</literal></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>s1</name> <init>= <expr><name>s</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name>s1</name></expr></init></decl>;</decl_stmt>

                <comment type="block">/* advance p to the end of the token */</comment>
                <while>while <condition>(<expr><name>p</name> <operator>-</operator> <name>s</name> <operator>&lt;</operator> <name><name>lex</name><operator>-&gt;</operator><name>input_length</name></name> <operator>-</operator> <name>len</name> <operator>&amp;&amp;</operator>
                       <operator>(</operator><operator>(</operator><operator>*</operator><name>p</name> <operator>&gt;=</operator> <literal type="char">'a'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>p</name> <operator>&lt;=</operator> <literal type="char">'z'</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><operator>*</operator><name>p</name> <operator>&gt;=</operator> <literal type="char">'A'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>p</name> <operator>&lt;=</operator> <literal type="char">'Z'</literal><operator>)</operator><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>

                <comment type="block">/* update the terminators */</comment>
                <expr_stmt><expr><name><name>lex</name><operator>-&gt;</operator><name>prev_token_terminator</name></name> <operator>=</operator> <name><name>lex</name><operator>-&gt;</operator><name>token_terminator</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>lex</name><operator>-&gt;</operator><name>token_terminator</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>

                <expr_stmt><expr><name><name>lex</name><operator>-&gt;</operator><name>token_type</name></name> <operator>=</operator> <name>AGTYPE_TOKEN_INVALID</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>len</name> <operator>=</operator> <name>p</name> <operator>-</operator> <name>s1</name></expr>;</expr_stmt>
                <switch>switch <condition>(<expr><name>len</name></expr>)</condition>
                <block>{<block_content>
                <case>case <expr><literal type="number">3</literal></expr>:</case>
                    <if_stmt><if>if <condition>(<expr><call><name>pg_strncasecmp</name><argument_list>(<argument><expr><name>s1</name></expr></argument>, <argument><expr><literal type="string">"inf"</literal></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><name><name>lex</name><operator>-&gt;</operator><name>token_type</name></name> <operator>=</operator> <name>AGTYPE_TOKEN_FLOAT</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
                    <break>break;</break>
                <case>case <expr><literal type="number">8</literal></expr>:</case>
                    <if_stmt><if>if <condition>(<expr><call><name>pg_strncasecmp</name><argument_list>(<argument><expr><name>s1</name></expr></argument>, <argument><expr><literal type="string">"Infinity"</literal></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><name><name>lex</name><operator>-&gt;</operator><name>token_type</name></name> <operator>=</operator> <name>AGTYPE_TOKEN_FLOAT</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
                    <break>break;</break>
                </block_content>}</block></switch>
                <if_stmt><if>if <condition>(<expr><name><name>lex</name><operator>-&gt;</operator><name>token_type</name></name> <operator>==</operator> <name>AGTYPE_TOKEN_INVALID</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>report_invalid_token</name><argument_list>(<argument><expr><name>lex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><call><name>agtype_lex_number</name><argument_list>(<argument><expr><name>lex</name></expr></argument>, <argument><expr><name>s</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
            <comment type="block">/* token is assigned in agtype_lex_number */</comment>
            <break>break;</break>
        <case>case <expr><literal type="char">'0'</literal></expr>:</case>
        <case>case <expr><literal type="char">'1'</literal></expr>:</case>
        <case>case <expr><literal type="char">'2'</literal></expr>:</case>
        <case>case <expr><literal type="char">'3'</literal></expr>:</case>
        <case>case <expr><literal type="char">'4'</literal></expr>:</case>
        <case>case <expr><literal type="char">'5'</literal></expr>:</case>
        <case>case <expr><literal type="char">'6'</literal></expr>:</case>
        <case>case <expr><literal type="char">'7'</literal></expr>:</case>
        <case>case <expr><literal type="char">'8'</literal></expr>:</case>
        <case>case <expr><literal type="char">'9'</literal></expr>:</case>
            <comment type="block">/* Positive number. */</comment>
            <expr_stmt><expr><call><name>agtype_lex_number</name><argument_list>(<argument><expr><name>lex</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* token is assigned in agtype_lex_number */</comment>
            <break>break;</break>
        <default>default:</default>
        <block>{<block_content>
            <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

            <comment type="block">/*
             * We're not dealing with a string, number, legal
             * punctuation mark, or end of string.  The only legal
             * tokens we might find here are true, false, and null,
             * but for error reporting purposes we scan until we see a
             * non-alphanumeric character.  That way, we can report
             * the whole word as an unexpected token, rather than just
             * some unintuitive prefix thereof.
             */</comment>
            <for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name>s</name></expr>;</init> <condition><expr><name>p</name> <operator>-</operator> <name>s</name> <operator>&lt;</operator> <name><name>lex</name><operator>-&gt;</operator><name>input_length</name></name> <operator>-</operator> <name>len</name> <operator>&amp;&amp;</operator>
                        <call><name>AGTYPE_ALPHANUMERIC_CHAR</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</condition>
                 <incr><expr><name>p</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
                <comment type="block">/* skip */</comment><empty_stmt>;</empty_stmt></block_content></block></for>

            <comment type="block">/*
             * We got some sort of unexpected punctuation or an
             * otherwise unexpected character, so just complain about
             * that one character.
             */</comment>
            <if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>s</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name><name>lex</name><operator>-&gt;</operator><name>prev_token_terminator</name></name> <operator>=</operator> <name><name>lex</name><operator>-&gt;</operator><name>token_terminator</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>lex</name><operator>-&gt;</operator><name>token_terminator</name></name> <operator>=</operator> <name>s</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>report_invalid_token</name><argument_list>(<argument><expr><name>lex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <comment type="block">/*
             * We've got a real alphanumeric token here.  If it
             * happens to be true, false, or null, all is well.  If
             * not, error out.
             */</comment>
            <expr_stmt><expr><name><name>lex</name><operator>-&gt;</operator><name>prev_token_terminator</name></name> <operator>=</operator> <name><name>lex</name><operator>-&gt;</operator><name>token_terminator</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>lex</name><operator>-&gt;</operator><name>token_terminator</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>

            <comment type="block">/* it is an identifier, unless proven otherwise */</comment>
            <expr_stmt><expr><name><name>lex</name><operator>-&gt;</operator><name>token_type</name></name> <operator>=</operator> <name>AGTYPE_TOKEN_IDENTIFIER</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>len</name> <operator>=</operator> <name>p</name> <operator>-</operator> <name>s</name></expr>;</expr_stmt>
            <switch>switch <condition>(<expr><name>len</name></expr>)</condition>
            <block>{<block_content>
            <comment type="block">/* A note about the mixture of case and case insensitivity -
             * The original code adheres to the JSON spec where true,
             * false, and null are strictly lower case. The Postgres float
             * logic, on the other hand, is case insensitive, allowing for
             * possibly many different input sources for float values. Hence,
             * the mixture of the two.
             */</comment>
            <case>case <expr><literal type="number">3</literal></expr>:</case>
                <if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>pg_strncasecmp</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="string">"NaN"</literal></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator>
                    <operator>(</operator><call><name>pg_strncasecmp</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="string">"inf"</literal></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name><name>lex</name><operator>-&gt;</operator><name>token_type</name></name> <operator>=</operator> <name>AGTYPE_TOKEN_FLOAT</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <break>break;</break>
            <case>case <expr><literal type="number">4</literal></expr>:</case>
                <if_stmt><if>if <condition>(<expr><call><name>memcmp</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="string">"true"</literal></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name><name>lex</name><operator>-&gt;</operator><name>token_type</name></name> <operator>=</operator> <name>AGTYPE_TOKEN_TRUE</name></expr>;</expr_stmt></block_content></block></if>
                <if type="elseif">else if <condition>(<expr><call><name>memcmp</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="string">"null"</literal></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name><name>lex</name><operator>-&gt;</operator><name>token_type</name></name> <operator>=</operator> <name>AGTYPE_TOKEN_NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <break>break;</break>
            <case>case <expr><literal type="number">5</literal></expr>:</case>
                <if_stmt><if>if <condition>(<expr><call><name>memcmp</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="string">"false"</literal></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name><name>lex</name><operator>-&gt;</operator><name>token_type</name></name> <operator>=</operator> <name>AGTYPE_TOKEN_FALSE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <break>break;</break>
            <case>case <expr><literal type="number">8</literal></expr>:</case>
                <if_stmt><if>if <condition>(<expr><call><name>pg_strncasecmp</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="string">"Infinity"</literal></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name><name>lex</name><operator>-&gt;</operator><name>token_type</name></name> <operator>=</operator> <name>AGTYPE_TOKEN_FLOAT</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <break>break;</break>
            </block_content>}</block></switch>
        </block_content>}</block> <comment type="block">/* end of default case */</comment>
        </block_content>}</block></switch> <comment type="block">/* end of switch */</comment>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * The next token in the input stream is known to be a string; lex it.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>agtype_lex_string</name><parameter_list>(<parameter><decl><type><name>agtype_lex_context</name> <modifier>*</modifier></type><name>lex</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>hi_surrogate</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>lex</name><operator>-&gt;</operator><name>strval</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>resetStringInfo</name><argument_list>(<argument><expr><name><name>lex</name><operator>-&gt;</operator><name>strval</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>lex</name><operator>-&gt;</operator><name>input_length</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>s</name> <operator>=</operator> <name><name>lex</name><operator>-&gt;</operator><name>token_start</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>len</name> <operator>=</operator> <name><name>lex</name><operator>-&gt;</operator><name>token_start</name></name> <operator>-</operator> <name><name>lex</name><operator>-&gt;</operator><name>input</name></name></expr>;</expr_stmt>
    <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name>s</name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>len</name><operator>++</operator></expr>;</expr_stmt>
        <comment type="block">/* Premature end of the string. */</comment>
        <if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;=</operator> <name><name>lex</name><operator>-&gt;</operator><name>input_length</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>lex</name><operator>-&gt;</operator><name>token_terminator</name></name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>report_invalid_token</name><argument_list>(<argument><expr><name>lex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><operator>*</operator><name>s</name> <operator>==</operator> <literal type="char">'"'</literal></expr>)</condition>
        <block>{<block_content>
            <break>break;</break>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><operator>*</operator><name>s</name> <operator>&lt;</operator> <literal type="number">32</literal></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* Per RFC4627, these characters MUST be escaped. */</comment>
            <comment type="block">/* Since *s isn't printable, exclude it from the context string */</comment>
            <expr_stmt><expr><name><name>lex</name><operator>-&gt;</operator><name>token_terminator</name></name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid input syntax for type %s"</literal></expr></argument>, <argument><expr><literal type="string">"agtype"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Character with value 0x%02x must be escaped."</literal></expr></argument>,
                               <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><operator>*</operator><name>s</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>report_agtype_context</name><argument_list>(<argument><expr><name>lex</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><operator>*</operator><name>s</name> <operator>==</operator> <literal type="char">'\\'</literal></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* OK, we have an escape character. */</comment>
            <expr_stmt><expr><name>s</name><operator>++</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name>len</name><operator>++</operator></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;=</operator> <name><name>lex</name><operator>-&gt;</operator><name>input_length</name></name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name><name>lex</name><operator>-&gt;</operator><name>token_terminator</name></name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>report_invalid_token</name><argument_list>(<argument><expr><name>lex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <if type="elseif">else if <condition>(<expr><operator>*</operator><name>s</name> <operator>==</operator> <literal type="char">'u'</literal></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int</name></type> <name>ch</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

                <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <literal type="number">4</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
                <block>{<block_content>
                    <expr_stmt><expr><name>s</name><operator>++</operator></expr>;</expr_stmt>
                    <expr_stmt><expr><name>len</name><operator>++</operator></expr>;</expr_stmt>
                    <if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;=</operator> <name><name>lex</name><operator>-&gt;</operator><name>input_length</name></name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><name><name>lex</name><operator>-&gt;</operator><name>token_terminator</name></name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>report_invalid_token</name><argument_list>(<argument><expr><name>lex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if>
                    <if type="elseif">else if <condition>(<expr><operator>*</operator><name>s</name> <operator>&gt;=</operator> <literal type="char">'0'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>s</name> <operator>&lt;=</operator> <literal type="char">'9'</literal></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><name>ch</name> <operator>=</operator> <operator>(</operator><name>ch</name> <operator>*</operator> <literal type="number">16</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><operator>*</operator><name>s</name> <operator>-</operator> <literal type="char">'0'</literal><operator>)</operator></expr>;</expr_stmt>
                    </block_content>}</block></if>
                    <if type="elseif">else if <condition>(<expr><operator>*</operator><name>s</name> <operator>&gt;=</operator> <literal type="char">'a'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>s</name> <operator>&lt;=</operator> <literal type="char">'f'</literal></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><name>ch</name> <operator>=</operator> <operator>(</operator><name>ch</name> <operator>*</operator> <literal type="number">16</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><operator>*</operator><name>s</name> <operator>-</operator> <literal type="char">'a'</literal><operator>)</operator> <operator>+</operator> <literal type="number">10</literal></expr>;</expr_stmt>
                    </block_content>}</block></if>
                    <if type="elseif">else if <condition>(<expr><operator>*</operator><name>s</name> <operator>&gt;=</operator> <literal type="char">'A'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>s</name> <operator>&lt;=</operator> <literal type="char">'F'</literal></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><name>ch</name> <operator>=</operator> <operator>(</operator><name>ch</name> <operator>*</operator> <literal type="number">16</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><operator>*</operator><name>s</name> <operator>-</operator> <literal type="char">'A'</literal><operator>)</operator> <operator>+</operator> <literal type="number">10</literal></expr>;</expr_stmt>
                    </block_content>}</block></if>
                    <else>else
                    <block>{<block_content>
                        <expr_stmt><expr><name><name>lex</name><operator>-&gt;</operator><name>token_terminator</name></name> <operator>=</operator> <name>s</name> <operator>+</operator> <call><name>pg_mblen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>ereport</name><argument_list>(
                            <argument><expr><name>ERROR</name></expr></argument>,
                            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid input syntax for type %s"</literal></expr></argument>,
                                    <argument><expr><literal type="string">"agtype"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errdetail</name><argument_list>(
                                 <argument><expr><literal type="string">"\"\\u\" must be followed by four hexadecimal digits."</literal></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>report_agtype_context</name><argument_list>(<argument><expr><name>lex</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></else></if_stmt>
                </block_content>}</block></for>
                <if_stmt><if>if <condition>(<expr><name><name>lex</name><operator>-&gt;</operator><name>strval</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>char</name></type> <name><name>utf8str</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>int</name></type> <name>utf8len</name></decl>;</decl_stmt>

                    <if_stmt><if>if <condition>(<expr><name>ch</name> <operator>&gt;=</operator> <literal type="number">0xd800</literal> <operator>&amp;&amp;</operator> <name>ch</name> <operator>&lt;=</operator> <literal type="number">0xdbff</literal></expr>)</condition>
                    <block>{<block_content>
                        <if_stmt><if>if <condition>(<expr><name>hi_surrogate</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><call><name>ereport</name><argument_list>(
                                <argument><expr><name>ERROR</name></expr></argument>,
                                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
                                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid input syntax for type %s"</literal></expr></argument>,
                                        <argument><expr><literal type="string">"agtype"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                                 <call><name>errdetail</name><argument_list>(
                                     <argument><expr><literal type="string">"Unicode high surrogate must not follow a high surrogate."</literal></expr></argument>)</argument_list></call><operator>,</operator>
                                 <call><name>report_agtype_context</name><argument_list>(<argument><expr><name>lex</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></if></if_stmt>
                        <expr_stmt><expr><name>hi_surrogate</name> <operator>=</operator> <operator>(</operator><name>ch</name> <operator>&amp;</operator> <literal type="number">0x3ff</literal><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">10</literal></expr>;</expr_stmt>
                        <continue>continue;</continue>
                    </block_content>}</block></if>
                    <if type="elseif">else if <condition>(<expr><name>ch</name> <operator>&gt;=</operator> <literal type="number">0xdc00</literal> <operator>&amp;&amp;</operator> <name>ch</name> <operator>&lt;=</operator> <literal type="number">0xdfff</literal></expr>)</condition>
                    <block>{<block_content>
                        <if_stmt><if>if <condition>(<expr><name>hi_surrogate</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
                        <block>{<block_content>
                            <expr_stmt><expr><call><name>ereport</name><argument_list>(
                                <argument><expr><name>ERROR</name></expr></argument>,
                                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
                                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid input syntax for type %s"</literal></expr></argument>,
                                        <argument><expr><literal type="string">"agtype"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                                 <call><name>errdetail</name><argument_list>(
                                     <argument><expr><literal type="string">"Unicode low surrogate must follow a high surrogate."</literal></expr></argument>)</argument_list></call><operator>,</operator>
                                 <call><name>report_agtype_context</name><argument_list>(<argument><expr><name>lex</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        </block_content>}</block></if></if_stmt>
                        <expr_stmt><expr><name>ch</name> <operator>=</operator> <literal type="number">0x10000</literal> <operator>+</operator> <name>hi_surrogate</name> <operator>+</operator> <operator>(</operator><name>ch</name> <operator>&amp;</operator> <literal type="number">0x3ff</literal><operator>)</operator></expr>;</expr_stmt>
                        <expr_stmt><expr><name>hi_surrogate</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>

                    <if_stmt><if>if <condition>(<expr><name>hi_surrogate</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>ereport</name><argument_list>(
                            <argument><expr><name>ERROR</name></expr></argument>,
                            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid input syntax for type %s"</literal></expr></argument>,
                                    <argument><expr><literal type="string">"agtype"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errdetail</name><argument_list>(
                                 <argument><expr><literal type="string">"Unicode low surrogate must follow a high surrogate."</literal></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>report_agtype_context</name><argument_list>(<argument><expr><name>lex</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>

                    <comment type="block">/*
                     * For UTF8, replace the escape sequence by the actual
                     * utf8 character in lex-&gt;strval. Do this also for other
                     * encodings if the escape designates an ASCII character,
                     * otherwise raise an error.
                     */</comment>

                    <if_stmt><if>if <condition>(<expr><name>ch</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
                    <block>{<block_content>
                        <comment type="block">/* We can't allow this, since our TEXT type doesn't */</comment>
                        <expr_stmt><expr><call><name>ereport</name><argument_list>(
                            <argument><expr><name>ERROR</name></expr></argument>,
                            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNTRANSLATABLE_CHARACTER</name></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unsupported Unicode escape sequence"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"\\u0000 cannot be converted to text."</literal></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>report_agtype_context</name><argument_list>(<argument><expr><name>lex</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if>
                    <if type="elseif">else if <condition>(<expr><call><name>GetDatabaseEncoding</name><argument_list>()</argument_list></call> <operator>==</operator> <name>PG_UTF8</name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>unicode_to_utf8</name><argument_list>(<argument><expr><name>ch</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>utf8str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name>utf8len</name> <operator>=</operator> <call><name>pg_utf_mblen</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>utf8str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><name><name>lex</name><operator>-&gt;</operator><name>strval</name></name></expr></argument>, <argument><expr><name>utf8str</name></expr></argument>, <argument><expr><name>utf8len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if>
                    <if type="elseif">else if <condition>(<expr><name>ch</name> <operator>&lt;=</operator> <literal type="number">0x007f</literal></expr>)</condition>
                    <block>{<block_content>
                        <comment type="block">/*
                         * This is the only way to designate things like a
                         * form feed character in agtype, so it's useful in all
                         * encodings.
                         */</comment>
                        <expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name><name>lex</name><operator>-&gt;</operator><name>strval</name></name></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>)</operator><name>ch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if>
                    <else>else
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>ereport</name><argument_list>(
                            <argument><expr><name>ERROR</name></expr></argument>,
                            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNTRANSLATABLE_CHARACTER</name></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unsupported Unicode escape sequence"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errdetail</name><argument_list>(
                                 <argument><expr><literal type="string">"Unicode escape values cannot be used for code point values above 007F when the server encoding is not UTF8."</literal></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>report_agtype_context</name><argument_list>(<argument><expr><name>lex</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></else></if_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if>
            <if type="elseif">else if <condition>(<expr><name><name>lex</name><operator>-&gt;</operator><name>strval</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name>hi_surrogate</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>ereport</name><argument_list>(
                        <argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid input syntax for type %s"</literal></expr></argument>, <argument><expr><literal type="string">"agtype"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errdetail</name><argument_list>(
                             <argument><expr><literal type="string">"Unicode low surrogate must follow a high surrogate."</literal></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>report_agtype_context</name><argument_list>(<argument><expr><name>lex</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>

                <switch>switch <condition>(<expr><operator>*</operator><name>s</name></expr>)</condition>
                <block>{<block_content>
                <case>case <expr><literal type="char">'"'</literal></expr>:</case>
                <case>case <expr><literal type="char">'\\'</literal></expr>:</case>
                <case>case <expr><literal type="char">'/'</literal></expr>:</case>
                    <expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name><name>lex</name><operator>-&gt;</operator><name>strval</name></name></expr></argument>, <argument><expr><operator>*</operator><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>
                <case>case <expr><literal type="char">'b'</literal></expr>:</case>
                    <expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name><name>lex</name><operator>-&gt;</operator><name>strval</name></name></expr></argument>, <argument><expr><literal type="char">'\b'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>
                <case>case <expr><literal type="char">'f'</literal></expr>:</case>
                    <expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name><name>lex</name><operator>-&gt;</operator><name>strval</name></name></expr></argument>, <argument><expr><literal type="char">'\f'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>
                <case>case <expr><literal type="char">'n'</literal></expr>:</case>
                    <expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name><name>lex</name><operator>-&gt;</operator><name>strval</name></name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>
                <case>case <expr><literal type="char">'r'</literal></expr>:</case>
                    <expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name><name>lex</name><operator>-&gt;</operator><name>strval</name></name></expr></argument>, <argument><expr><literal type="char">'\r'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>
                <case>case <expr><literal type="char">'t'</literal></expr>:</case>
                    <expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name><name>lex</name><operator>-&gt;</operator><name>strval</name></name></expr></argument>, <argument><expr><literal type="char">'\t'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>
                <default>default:</default>
                    <comment type="block">/* Not a valid string escape, so error out. */</comment>
                    <expr_stmt><expr><name><name>lex</name><operator>-&gt;</operator><name>token_terminator</name></name> <operator>=</operator> <name>s</name> <operator>+</operator> <call><name>pg_mblen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>ereport</name><argument_list>(
                        <argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid input syntax for type %s"</literal></expr></argument>, <argument><expr><literal type="string">"agtype"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Escape sequence \"\\%s\" is invalid."</literal></expr></argument>,
                                   <argument><expr><call><name>extract_mb_char</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>report_agtype_context</name><argument_list>(<argument><expr><name>lex</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></switch>
            </block_content>}</block></if>
            <if type="elseif">else if <condition>(<expr><call><name>strchr</name><argument_list>(<argument><expr><literal type="string">"\"\\/bfnrt"</literal></expr></argument>, <argument><expr><operator>*</operator><name>s</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/*
                 * Simpler processing if we're not bothered about de-escaping
                 *
                 * It's very tempting to remove the strchr() call here and
                 * replace it with a switch statement, but testing so far has
                 * shown it's not a performance win.
                 */</comment>
                <expr_stmt><expr><name><name>lex</name><operator>-&gt;</operator><name>token_terminator</name></name> <operator>=</operator> <name>s</name> <operator>+</operator> <call><name>pg_mblen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid input syntax for type %s"</literal></expr></argument>, <argument><expr><literal type="string">"agtype"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Escape sequence \"\\%s\" is invalid."</literal></expr></argument>,
                                   <argument><expr><call><name>extract_mb_char</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>report_agtype_context</name><argument_list>(<argument><expr><name>lex</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name><name>lex</name><operator>-&gt;</operator><name>strval</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>hi_surrogate</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(
                    <argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid input syntax for type %s"</literal></expr></argument>, <argument><expr><literal type="string">"agtype"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errdetail</name><argument_list>(
                         <argument><expr><literal type="string">"Unicode low surrogate must follow a high surrogate."</literal></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>report_agtype_context</name><argument_list>(<argument><expr><name>lex</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name><name>lex</name><operator>-&gt;</operator><name>strval</name></name></expr></argument>, <argument><expr><operator>*</operator><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <if_stmt><if>if <condition>(<expr><name>hi_surrogate</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(
            <argument><expr><name>ERROR</name></expr></argument>,
            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid input syntax for type %s"</literal></expr></argument>, <argument><expr><literal type="string">"agtype"</literal></expr></argument>)</argument_list></call><operator>,</operator>
             <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Unicode low surrogate must follow a high surrogate."</literal></expr></argument>)</argument_list></call><operator>,</operator>
             <call><name>report_agtype_context</name><argument_list>(<argument><expr><name>lex</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Hooray, we found the end of the string! */</comment>
    <expr_stmt><expr><name><name>lex</name><operator>-&gt;</operator><name>prev_token_terminator</name></name> <operator>=</operator> <name><name>lex</name><operator>-&gt;</operator><name>token_terminator</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>lex</name><operator>-&gt;</operator><name>token_terminator</name></name> <operator>=</operator> <name>s</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * The next token in the input stream is known to be a number; lex it.
 *
 * In agtype, a number consists of four parts:
 *
 * (1) An optional minus sign ('-').
 *
 * (2) Either a single '0', or a string of one or more digits that does not
 *     begin with a '0'.
 *
 * (3) An optional decimal part, consisting of a period ('.') followed by
 *     one or more digits.  (Note: While this part can be omitted
 *     completely, it's not OK to have only the decimal point without
 *     any digits afterwards.)
 *
 * (4) An optional exponent part, consisting of 'e' or 'E', optionally
 *     followed by '+' or '-', followed by one or more digits.  (Note:
 *     As with the decimal part, if 'e' or 'E' is present, it must be
 *     followed by at least one digit.)
 *
 * The 's' argument to this function points to the ostensible beginning
 * of part 2 - i.e. the character after any optional minus sign, or the
 * first character of the string if there is none.
 *
 * If num_err is not NULL, we return an error flag to *num_err rather than
 * raising an error for a badly-formed number.  Also, if total_len is not NULL
 * the distance from lex-&gt;input to the token end+1 is returned to *total_len.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>agtype_lex_number</name><parameter_list>(<parameter><decl><type><name>agtype_lex_context</name> <modifier>*</modifier></type><name>lex</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>,
                                     <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>num_err</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>total_len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>bool</name></type> <name>error</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><name>s</name> <operator>-</operator> <name><name>lex</name><operator>-&gt;</operator><name>input</name></name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* assume we have an integer until proven otherwise */</comment>
    <expr_stmt><expr><name><name>lex</name><operator>-&gt;</operator><name>token_type</name></name> <operator>=</operator> <name>AGTYPE_TOKEN_INTEGER</name></expr>;</expr_stmt>

    <comment type="block">/* Part (1): leading sign indicator. */</comment>
    <comment type="block">/* Caller already did this for us; so do nothing. */</comment>

    <comment type="block">/* Part (2): parse main digit string. */</comment>
    <if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <name><name>lex</name><operator>-&gt;</operator><name>input_length</name></name> <operator>&amp;&amp;</operator> <operator>*</operator><name>s</name> <operator>==</operator> <literal type="char">'0'</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>s</name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>len</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>len</name> <operator>&lt;</operator> <name><name>lex</name><operator>-&gt;</operator><name>input_length</name></name> <operator>&amp;&amp;</operator> <operator>*</operator><name>s</name> <operator>&gt;=</operator> <literal type="char">'1'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>s</name> <operator>&lt;=</operator> <literal type="char">'9'</literal></expr>)</condition>
    <block>{<block_content>
        <do>do
        <block>{<block_content>
            <expr_stmt><expr><name>s</name><operator>++</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name>len</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block> while <condition>(<expr><name>len</name> <operator>&lt;</operator> <name><name>lex</name><operator>-&gt;</operator><name>input_length</name></name> <operator>&amp;&amp;</operator> <operator>*</operator><name>s</name> <operator>&gt;=</operator> <literal type="char">'0'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>s</name> <operator>&lt;=</operator> <literal type="char">'9'</literal></expr>)</condition>;</do>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name>error</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* Part (3): parse optional decimal portion. */</comment>
    <if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <name><name>lex</name><operator>-&gt;</operator><name>input_length</name></name> <operator>&amp;&amp;</operator> <operator>*</operator><name>s</name> <operator>==</operator> <literal type="char">'.'</literal></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* since we have a decimal point, we have a float */</comment>
        <expr_stmt><expr><name><name>lex</name><operator>-&gt;</operator><name>token_type</name></name> <operator>=</operator> <name>AGTYPE_TOKEN_FLOAT</name></expr>;</expr_stmt>

        <expr_stmt><expr><name>s</name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>len</name><operator>++</operator></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <name><name>lex</name><operator>-&gt;</operator><name>input_length</name></name> <operator>||</operator> <operator>*</operator><name><name>s</name> <argument_list type="generic">&lt; <argument><expr><literal type="char">'0'</literal> <operator>||</operator> <operator>*</operator><name>s</name></expr></argument> &gt;</argument_list></name> <literal type="char">'9'</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>error</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <do>do
            <block>{<block_content>
                <expr_stmt><expr><name>s</name><operator>++</operator></expr>;</expr_stmt>
                <expr_stmt><expr><name>len</name><operator>++</operator></expr>;</expr_stmt>
            </block_content>}</block> while <condition>(<expr><name>len</name> <operator>&lt;</operator> <name><name>lex</name><operator>-&gt;</operator><name>input_length</name></name> <operator>&amp;&amp;</operator> <operator>*</operator><name>s</name> <operator>&gt;=</operator> <literal type="char">'0'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>s</name> <operator>&lt;=</operator> <literal type="char">'9'</literal></expr>)</condition>;</do>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Part (4): parse optional exponent. */</comment>
    <if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <name><name>lex</name><operator>-&gt;</operator><name>input_length</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><operator>*</operator><name>s</name> <operator>==</operator> <literal type="char">'e'</literal> <operator>||</operator> <operator>*</operator><name>s</name> <operator>==</operator> <literal type="char">'E'</literal><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* since we have an exponent, we have a float */</comment>
        <expr_stmt><expr><name><name>lex</name><operator>-&gt;</operator><name>token_type</name></name> <operator>=</operator> <name>AGTYPE_TOKEN_FLOAT</name></expr>;</expr_stmt>

        <expr_stmt><expr><name>s</name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>len</name><operator>++</operator></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <name><name>lex</name><operator>-&gt;</operator><name>input_length</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><operator>*</operator><name>s</name> <operator>==</operator> <literal type="char">'+'</literal> <operator>||</operator> <operator>*</operator><name>s</name> <operator>==</operator> <literal type="char">'-'</literal><operator>)</operator></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>s</name><operator>++</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name>len</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <name><name>lex</name><operator>-&gt;</operator><name>input_length</name></name> <operator>||</operator> <operator>*</operator><name><name>s</name> <argument_list type="generic">&lt; <argument><expr><literal type="char">'0'</literal> <operator>||</operator> <operator>*</operator><name>s</name></expr></argument> &gt;</argument_list></name> <literal type="char">'9'</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>error</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <do>do
            <block>{<block_content>
                <expr_stmt><expr><name>s</name><operator>++</operator></expr>;</expr_stmt>
                <expr_stmt><expr><name>len</name><operator>++</operator></expr>;</expr_stmt>
            </block_content>}</block> while <condition>(<expr><name>len</name> <operator>&lt;</operator> <name><name>lex</name><operator>-&gt;</operator><name>input_length</name></name> <operator>&amp;&amp;</operator> <operator>*</operator><name>s</name> <operator>&gt;=</operator> <literal type="char">'0'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>s</name> <operator>&lt;=</operator> <literal type="char">'9'</literal></expr>)</condition>;</do>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Check for trailing garbage.  As in agtype_lex(), any alphanumeric stuff
     * here should be considered part of the token for error-reporting
     * purposes.
     */</comment>
    <for>for <control>(<init>;</init> <condition><expr><name>len</name> <operator>&lt;</operator> <name><name>lex</name><operator>-&gt;</operator><name>input_length</name></name> <operator>&amp;&amp;</operator> <call><name>AGTYPE_ALPHANUMERIC_CHAR</name><argument_list>(<argument><expr><operator>*</operator><name>s</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>s</name><operator>++</operator></expr><operator>,</operator> <expr><name>len</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><name>error</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></for>

    <if_stmt><if>if <condition>(<expr><name>total_len</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>*</operator><name>total_len</name> <operator>=</operator> <name>len</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>num_err</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* let the caller handle any error */</comment>
        <expr_stmt><expr><operator>*</operator><name>num_err</name> <operator>=</operator> <name>error</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/* return token endpoint */</comment>
        <expr_stmt><expr><name><name>lex</name><operator>-&gt;</operator><name>prev_token_terminator</name></name> <operator>=</operator> <name><name>lex</name><operator>-&gt;</operator><name>token_terminator</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>lex</name><operator>-&gt;</operator><name>token_terminator</name></name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>
        <comment type="block">/* handle error if any */</comment>
        <if_stmt><if>if <condition>(<expr><name>error</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>report_invalid_token</name><argument_list>(<argument><expr><name>lex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Report a parse error.
 *
 * lex-&gt;token_start and lex-&gt;token_terminator must identify the current token.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>report_parse_error</name><parameter_list>(<parameter><decl><type><name>agtype_parse_context</name></type> <name>ctx</name></decl></parameter>,
                               <parameter><decl><type><name>agtype_lex_context</name> <modifier>*</modifier></type><name>lex</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>token</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>toklen</name></decl>;</decl_stmt>

    <comment type="block">/* Handle case where the input ended prematurely. */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>lex</name><operator>-&gt;</operator><name>token_start</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>lex</name><operator>-&gt;</operator><name>token_type</name></name> <operator>==</operator> <name>AGTYPE_TOKEN_END</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
                        <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid input syntax for type %s"</literal></expr></argument>, <argument><expr><literal type="string">"agtype"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                        <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"The input string ended unexpectedly."</literal></expr></argument>)</argument_list></call><operator>,</operator>
                        <call><name>report_agtype_context</name><argument_list>(<argument><expr><name>lex</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Separate out the current token. */</comment>
    <expr_stmt><expr><name>toklen</name> <operator>=</operator> <name><name>lex</name><operator>-&gt;</operator><name>token_terminator</name></name> <operator>-</operator> <name><name>lex</name><operator>-&gt;</operator><name>token_start</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>toklen</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><name><name>lex</name><operator>-&gt;</operator><name>token_start</name></name></expr></argument>, <argument><expr><name>toklen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>token</name><index>[<expr><name>toklen</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

    <comment type="block">/* Complain, with the appropriate detail message. */</comment>
    <if_stmt><if>if <condition>(<expr><name>ctx</name> <operator>==</operator> <name>AGTYPE_PARSE_END</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid input syntax for type %s"</literal></expr></argument>, <argument><expr><literal type="string">"agtype"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Expected end of input, but found \"%s\"."</literal></expr></argument>, <argument><expr><name>token</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>report_agtype_context</name><argument_list>(<argument><expr><name>lex</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <switch>switch <condition>(<expr><name>ctx</name></expr>)</condition>
        <block>{<block_content>
        <case>case <expr><name>AGTYPE_PARSE_VALUE</name></expr>:</case>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(
                <argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid input syntax for type %s"</literal></expr></argument>, <argument><expr><literal type="string">"agtype"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Expected agtype value, but found \"%s\"."</literal></expr></argument>, <argument><expr><name>token</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>report_agtype_context</name><argument_list>(<argument><expr><name>lex</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>AGTYPE_PARSE_STRING</name></expr>:</case>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid input syntax for type %s"</literal></expr></argument>, <argument><expr><literal type="string">"agtype"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Expected string, but found \"%s\"."</literal></expr></argument>, <argument><expr><name>token</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>report_agtype_context</name><argument_list>(<argument><expr><name>lex</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>AGTYPE_PARSE_ARRAY_START</name></expr>:</case>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid input syntax for type %s"</literal></expr></argument>, <argument><expr><literal type="string">"agtype"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errdetail</name><argument_list>(
                         <argument><expr><literal type="string">"Expected array element or \"]\", but found \"%s\"."</literal></expr></argument>,
                         <argument><expr><name>token</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>report_agtype_context</name><argument_list>(<argument><expr><name>lex</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>AGTYPE_PARSE_ARRAY_NEXT</name></expr>:</case>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid input syntax for type %s"</literal></expr></argument>, <argument><expr><literal type="string">"agtype"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Expected \",\" or \"]\", but found \"%s\"."</literal></expr></argument>,
                               <argument><expr><name>token</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>report_agtype_context</name><argument_list>(<argument><expr><name>lex</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>AGTYPE_PARSE_OBJECT_START</name></expr>:</case>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid input syntax for type %s"</literal></expr></argument>, <argument><expr><literal type="string">"agtype"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Expected string or \"}\", but found \"%s\"."</literal></expr></argument>,
                               <argument><expr><name>token</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>report_agtype_context</name><argument_list>(<argument><expr><name>lex</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>AGTYPE_PARSE_OBJECT_LABEL</name></expr>:</case>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid input syntax for type %s"</literal></expr></argument>, <argument><expr><literal type="string">"agtype"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Expected \":\", but found \"%s\"."</literal></expr></argument>, <argument><expr><name>token</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>report_agtype_context</name><argument_list>(<argument><expr><name>lex</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>AGTYPE_PARSE_OBJECT_NEXT</name></expr>:</case>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid input syntax for type %s"</literal></expr></argument>, <argument><expr><literal type="string">"agtype"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Expected \",\" or \"}\", but found \"%s\"."</literal></expr></argument>,
                               <argument><expr><name>token</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>report_agtype_context</name><argument_list>(<argument><expr><name>lex</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>AGTYPE_PARSE_OBJECT_COMMA</name></expr>:</case>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid input syntax for type %s"</literal></expr></argument>, <argument><expr><literal type="string">"agtype"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Expected string, but found \"%s\"."</literal></expr></argument>, <argument><expr><name>token</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>report_agtype_context</name><argument_list>(<argument><expr><name>lex</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <default>default:</default>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected agtype parse state: %d"</literal></expr></argument>, <argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></switch>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Report an invalid input token.
 *
 * lex-&gt;token_start and lex-&gt;token_terminator must identify the token.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>report_invalid_token</name><parameter_list>(<parameter><decl><type><name>agtype_lex_context</name> <modifier>*</modifier></type><name>lex</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>token</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>toklen</name></decl>;</decl_stmt>

    <comment type="block">/* Separate out the offending token. */</comment>
    <expr_stmt><expr><name>toklen</name> <operator>=</operator> <name><name>lex</name><operator>-&gt;</operator><name>token_terminator</name></name> <operator>-</operator> <name><name>lex</name><operator>-&gt;</operator><name>token_start</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>toklen</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><name><name>lex</name><operator>-&gt;</operator><name>token_start</name></name></expr></argument>, <argument><expr><name>toklen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>token</name><index>[<expr><name>toklen</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
                    <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid input syntax for type %s"</literal></expr></argument>, <argument><expr><literal type="string">"agtype"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                    <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Token \"%s\" is invalid."</literal></expr></argument>, <argument><expr><name>token</name></expr></argument>)</argument_list></call><operator>,</operator>
                    <call><name>report_agtype_context</name><argument_list>(<argument><expr><name>lex</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Report a CONTEXT line for bogus agtype input.
 *
 * lex-&gt;token_terminator must be set to identify the spot where we detected
 * the error.  Note that lex-&gt;token_start might be NULL, in case we recognized
 * error at EOF.
 *
 * The return value isn't meaningful, but we make it non-void so that this
 * can be invoked inside ereport().
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>report_agtype_context</name><parameter_list>(<parameter><decl><type><name>agtype_lex_context</name> <modifier>*</modifier></type><name>lex</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>context_start</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>context_end</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>line_start</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>line_number</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ctxt</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>ctxtlen</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>prefix</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>suffix</name></decl>;</decl_stmt>

    <comment type="block">/* Choose boundaries for the part of the input we will display */</comment>
    <expr_stmt><expr><name>context_start</name> <operator>=</operator> <name><name>lex</name><operator>-&gt;</operator><name>input</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>context_end</name> <operator>=</operator> <name><name>lex</name><operator>-&gt;</operator><name>token_terminator</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>line_start</name> <operator>=</operator> <name>context_start</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>line_number</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
    <block>{<block_content>
        <comment type="block">/* Always advance over newlines */</comment>
        <if_stmt><if>if <condition>(<expr><name>context_start</name> <operator>&lt;</operator> <name>context_end</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>context_start</name> <operator>==</operator> <literal type="char">'\n'</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>context_start</name><operator>++</operator></expr>;</expr_stmt>
            <expr_stmt><expr><name>line_start</name> <operator>=</operator> <name>context_start</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>line_number</name><operator>++</operator></expr>;</expr_stmt>
            <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>
        <comment type="block">/* Otherwise, done as soon as we are close enough to context_end */</comment>
        <if_stmt><if>if <condition>(<expr><name>context_end</name> <operator>-</operator> <name>context_start</name> <operator>&lt;</operator> <literal type="number">50</literal></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>
        <comment type="block">/* Advance to next multibyte character */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>IS_HIGHBIT_SET</name><argument_list>(<argument><expr><operator>*</operator><name>context_start</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>context_start</name> <operator>+=</operator> <call><name>pg_mblen</name><argument_list>(<argument><expr><name>context_start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name>context_start</name><operator>++</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/*
     * We add "..." to indicate that the excerpt doesn't start at the
     * beginning of the line ... but if we're within 3 characters of the
     * beginning of the line, we might as well just show the whole line.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>context_start</name> <operator>-</operator> <name>line_start</name> <operator>&lt;=</operator> <literal type="number">3</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>context_start</name> <operator>=</operator> <name>line_start</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Get a null-terminated copy of the data to present */</comment>
    <expr_stmt><expr><name>ctxtlen</name> <operator>=</operator> <name>context_end</name> <operator>-</operator> <name>context_start</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>ctxt</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>ctxtlen</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>ctxt</name></expr></argument>, <argument><expr><name>context_start</name></expr></argument>, <argument><expr><name>ctxtlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ctxt</name><index>[<expr><name>ctxtlen</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

    <comment type="block">/*
     * Show the context, prefixing "..." if not starting at start of line, and
     * suffixing "..." if not ending at end of line.
     */</comment>
    <expr_stmt><expr><name>prefix</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>context_start</name> <operator>&gt;</operator> <name>line_start</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">"..."</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>lex</name><operator>-&gt;</operator><name>token_type</name></name> <operator>!=</operator> <name>AGTYPE_TOKEN_END</name> <operator>&amp;&amp;</operator>
        <name>context_end</name> <operator>-</operator> <name><name>lex</name><operator>-&gt;</operator><name>input</name></name> <operator>&lt;</operator> <name><name>lex</name><operator>-&gt;</operator><name>input_length</name></name> <operator>&amp;&amp;</operator> <operator>*</operator><name>context_end</name> <operator>!=</operator> <literal type="char">'\n'</literal> <operator>&amp;&amp;</operator>
        <operator>*</operator><name>context_end</name> <operator>!=</operator> <literal type="char">'\r'</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>suffix</name> <operator>=</operator> <literal type="string">"..."</literal></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>suffix</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <return>return <expr><call><name>errcontext</name><argument_list>(<argument><expr><literal type="string">"agtype data, line %d: %s%s%s"</literal></expr></argument>, <argument><expr><name>line_number</name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>,
                      <argument><expr><name>ctxt</name></expr></argument>, <argument><expr><name>suffix</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Extract a single, possibly multi-byte char from the input string.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>extract_mb_char</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>pg_mblen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>len</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>res</name><index>[<expr><name>len</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

    <return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Encode 'value' of datetime type 'typid' into agtype string in ISO format
 * using optionally preallocated buffer 'buf'.
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type><name>agtype_encode_date_time</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>typid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>buf</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>MAXDATELEN</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <switch>switch <condition>(<expr><name>typid</name></expr>)</condition>
    <block>{<block_content>
    <case>case <expr><name>DATEOID</name></expr>:</case>
    <block>{<block_content>
        <decl_stmt><decl><type><name>DateADT</name></type> <name>date</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>struct</name> <name>pg_tm</name></name></type> <name>tm</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>date</name> <operator>=</operator> <call><name>DatumGetDateADT</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Same as date_out(), but forcing DateStyle */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>DATE_NOT_FINITE</name><argument_list>(<argument><expr><name>date</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>EncodeSpecialDate</name><argument_list>(<argument><expr><name>date</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><call><name>j2date</name><argument_list>(<argument><expr><name>date</name> <operator>+</operator> <name>POSTGRES_EPOCH_JDATE</name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>tm</name><operator>.</operator><name>tm_year</name></name><operator>)</operator></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>tm</name><operator>.</operator><name>tm_mon</name></name><operator>)</operator></expr></argument>,
                   <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>tm</name><operator>.</operator><name>tm_mday</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>EncodeDateOnly</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tm</name></expr></argument>, <argument><expr><name>USE_XSD_DATES</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block>
    <break>break;</break>
    <case>case <expr><name>TIMEOID</name></expr>:</case>
    <block>{<block_content>
        <decl_stmt><decl><type><name>TimeADT</name></type> <name>time</name> <init>= <expr><call><name>DatumGetTimeADT</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>struct</name> <name>pg_tm</name></name></type> <name>tt</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>tm</name> <init>= <expr><operator>&amp;</operator><name>tt</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>fsec_t</name></type> <name>fsec</name></decl>;</decl_stmt>

        <comment type="block">/* Same as time_out(), but forcing DateStyle */</comment>
        <expr_stmt><expr><call><name>time2tm</name><argument_list>(<argument><expr><name>time</name></expr></argument>, <argument><expr><name>tm</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fsec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>EncodeTimeOnly</name><argument_list>(<argument><expr><name>tm</name></expr></argument>, <argument><expr><name>fsec</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>USE_XSD_DATES</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
    <break>break;</break>
    <case>case <expr><name>TIMETZOID</name></expr>:</case>
    <block>{<block_content>
        <decl_stmt><decl><type><name>TimeTzADT</name> <modifier>*</modifier></type><name>time</name> <init>= <expr><call><name>DatumGetTimeTzADTP</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>struct</name> <name>pg_tm</name></name></type> <name>tt</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>tm</name> <init>= <expr><operator>&amp;</operator><name>tt</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>fsec_t</name></type> <name>fsec</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>tz</name></decl>;</decl_stmt>

        <comment type="block">/* Same as timetz_out(), but forcing DateStyle */</comment>
        <expr_stmt><expr><call><name>timetz2tm</name><argument_list>(<argument><expr><name>time</name></expr></argument>, <argument><expr><name>tm</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fsec</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>EncodeTimeOnly</name><argument_list>(<argument><expr><name>tm</name></expr></argument>, <argument><expr><name>fsec</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>tz</name></expr></argument>, <argument><expr><name>USE_XSD_DATES</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
    <break>break;</break>
    <case>case <expr><name>TIMESTAMPOID</name></expr>:</case>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Timestamp</name></type> <name>timestamp</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>struct</name> <name>pg_tm</name></name></type> <name>tm</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>fsec_t</name></type> <name>fsec</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>timestamp</name> <operator>=</operator> <call><name>DatumGetTimestamp</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* Same as timestamp_out(), but forcing DateStyle */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>TIMESTAMP_NOT_FINITE</name><argument_list>(<argument><expr><name>timestamp</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>EncodeSpecialTimestamp</name><argument_list>(<argument><expr><name>timestamp</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><call><name>timestamp2tm</name><argument_list>(<argument><expr><name>timestamp</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tm</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fsec</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>EncodeDateTime</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tm</name></expr></argument>, <argument><expr><name>fsec</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>USE_XSD_DATES</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATETIME_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
                            <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"timestamp out of range"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block>
    <break>break;</break>
    <case>case <expr><name>TIMESTAMPTZOID</name></expr>:</case>
    <block>{<block_content>
        <decl_stmt><decl><type><name>TimestampTz</name></type> <name>timestamp</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>struct</name> <name>pg_tm</name></name></type> <name>tm</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>tz</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>fsec_t</name></type> <name>fsec</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tzn</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name>timestamp</name> <operator>=</operator> <call><name>DatumGetTimestampTz</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* Same as timestamptz_out(), but forcing DateStyle */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>TIMESTAMP_NOT_FINITE</name><argument_list>(<argument><expr><name>timestamp</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>EncodeSpecialTimestamp</name><argument_list>(<argument><expr><name>timestamp</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><call><name>timestamp2tm</name><argument_list>(<argument><expr><name>timestamp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tz</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tm</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fsec</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tzn</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>EncodeDateTime</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tm</name></expr></argument>, <argument><expr><name>fsec</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>tz</name></expr></argument>, <argument><expr><name>tzn</name></expr></argument>, <argument><expr><name>USE_XSD_DATES</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATETIME_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
                            <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"timestamp out of range"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block>
    <break>break;</break>
    <default>default:</default>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unknown agtype value datetime type oid %d"</literal></expr></argument>, <argument><expr><name>typid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    </block_content>}</block></switch>

    <return>return <expr><name>buf</name></expr>;</return>
</block_content>}</block></function>
</unit>
