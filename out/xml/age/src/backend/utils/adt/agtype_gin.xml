<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/age/src/backend/utils/adt/agtype_gin.c"><comment type="block">/*
 * For PostgreSQL Database Management System:
 * (formerly known as Postgres, then as Postgres95)
 *
 * Portions Copyright (c) 1996-2010, The PostgreSQL Global Development Group
 *
 * Portions Copyright (c) 1994, The Regents of the University of California
 *
 * Permission to use, copy, modify, and distribute this software and its
 * documentation for any purpose, without fee, and without a written agreement
 * is hereby granted, provided that the above copyright notice and this
 * paragraph and the following two paragraphs appear in all copies.
 *
 * IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR
 * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
 * LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION,
 * EVEN IF THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 * FITNESS FOR A PARTICULAR PURPOSE.
 *
 * THE SOFTWARE PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND THE UNIVERSITY OF
 * CALIFORNIA HAS NO OBLIGATIONS TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,
 * ENHANCEMENTS, OR MODIFICATIONS.
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/gin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/hash.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/stratnum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_collation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/varlena.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/agtype.h"</cpp:file></cpp:include>

<typedef>typedef <type><struct>struct <name>PathHashStack</name>
<block>{
    <decl_stmt><decl><type><name>uint32</name></type> <name>hash</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name><name>struct</name> <name>PathHashStack</name></name> <modifier>*</modifier></type><name>parent</name></decl>;</decl_stmt>
}</block></struct></type> <name>PathHashStack</name>;</typedef>

<function_decl><type><specifier>static</specifier> <name>Datum</name></type> <name>make_text_key</name><parameter_list>(<parameter><decl><type><name>char</name></type> <name>flag</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Datum</name></type> <name>make_scalar_key</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>agtype_value</name> <modifier>*</modifier></type><name>scalar_val</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_key</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAXINT8LEN</name></cpp:macro>        <cpp:value>25</cpp:value></cpp:define>

<comment type="block">/*
 *
 * agtype_ops GIN opclass support functions
 *
 */</comment>
<comment type="block">/*
 * Compares two keys (not indexed items!) and returns an integer less than zero,
 * zero, or greater than zero, indicating whether the first key is less than,
 * equal to, or greater than the second. NULL keys are never passed to this
 * function.
 */</comment>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>gin_compare_agtype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><name>Datum</name></type> <name>gin_compare_agtype</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>text</name> <modifier>*</modifier></type><name>arg1</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>arg2</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type> <name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>a1p</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>a2p</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>len1</name></decl>, <decl><type ref="prev"/><name>len2</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>arg1</name> <operator>=</operator> <call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>arg2</name> <operator>=</operator> <call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>a1p</name> <operator>=</operator> <call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>a2p</name> <operator>=</operator> <call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>arg2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>len1</name> <operator>=</operator> <call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>len2</name> <operator>=</operator> <call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>arg2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Compare text as bttextcmp does, but always using C collation */</comment>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>varstr_cmp</name><argument_list>(<argument><expr><name>a1p</name></expr></argument>, <argument><expr><name>len1</name></expr></argument>, <argument><expr><name>a2p</name></expr></argument>, <argument><expr><name>len2</name></expr></argument>, <argument><expr><name>C_COLLATION_OID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>arg2</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_INT32</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Returns a palloc'd array of keys given an item to be indexed. The number of
 * returned keys must be stored into *nkeys. The return value can be NULL if the
 * item contains no keys.
 */</comment>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>gin_extract_agtype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><name>Datum</name></type> <name>gin_extract_agtype</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>agtype</name> <modifier>*</modifier></type><name>agt</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name> <modifier>*</modifier></type><name>nentries</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>total</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_iterator</name> <modifier>*</modifier></type><name>it</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_value</name></type> <name>v</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_iterator_token</name></type> <name>r</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name> <modifier>*</modifier></type><name>entries</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>agt</name> <operator>=</operator> <operator>(</operator><name>agtype</name> <operator>*</operator><operator>)</operator> <call><name>AG_GET_ARG_AGTYPE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>nentries</name> <operator>=</operator> <operator>(</operator><name>int32</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>total</name> <operator>=</operator> <literal type="number">2</literal> <operator>*</operator> <call><name>AGT_ROOT_COUNT</name><argument_list>(<argument><expr><name>agt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* If the root level is empty, we certainly have no keys */</comment>
    <if_stmt><if>if <condition>(<expr><name>total</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>nentries</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Otherwise, use 2 * root count as initial estimate of result size */</comment>
    <expr_stmt><expr><name>entries</name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>total</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>it</name> <operator>=</operator> <call><name>agtype_iterator_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>agt</name><operator>-&gt;</operator><name>root</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <while>while <condition>(<expr><operator>(</operator><name>r</name> <operator>=</operator> <call><name>agtype_iterator_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name>it</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>v</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>WAGT_DONE</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Since we recurse into the object, we might need more space */</comment>
        <if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;=</operator> <name>total</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>total</name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>entries</name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator> <call><name>repalloc</name><argument_list>(<argument><expr><name>entries</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>total</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <switch>switch <condition>(<expr><name>r</name></expr>)</condition>
        <block>{<block_content>
            <case>case <expr><name>WAGT_KEY</name></expr>:</case>
                <expr_stmt><expr><name><name>entries</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>make_scalar_key</name><argument_list>(<argument><expr><operator>&amp;</operator><name>v</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><name>WAGT_ELEM</name></expr>:</case>
                <comment type="block">/* Pretend string array elements are keys */</comment>
                <expr_stmt><expr><name><name>entries</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>make_scalar_key</name><argument_list>(<argument><expr><operator>&amp;</operator><name>v</name></expr></argument>, <argument><expr><operator>(</operator><name><name>v</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>AGTV_STRING</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><name>WAGT_VALUE</name></expr>:</case>
                <expr_stmt><expr><name><name>entries</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>make_scalar_key</name><argument_list>(<argument><expr><operator>&amp;</operator><name>v</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            <default>default:</default>
                <comment type="block">/* we can ignore structural items */</comment>
                <break>break;</break>
        </block_content>}</block></switch>
    </block_content>}</block></while>

    <expr_stmt><expr><operator>*</operator><name>nentries</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><name>entries</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Returns a palloc'd array of keys given a value to be queried; that is, query
 * is the value on the right-hand side of an indexable operator whose left-hand
 * side is the indexed column. The number of returned keys must be stored into
 * *nkeys. If any of the keys can be null, also palloc an array of *nkeys bool
 * fields, store its address at *nullFlags, and set these null flags as needed.
 * *nullFlags can be left NULL (its initial value) if all keys are non-null.
 * The return value can be NULL if the query contains no keys.
 *
 * searchMode is an output argument that allows extractQuery to specify details
 * about how the search will be done. If *searchMode is set to
 * GIN_SEARCH_MODE_DEFAULT (which is the value it is initialized to before
 * call), only items that match at least one of the returned keys are considered
 * candidate matches. If *searchMode is set to GIN_SEARCH_MODE_ALL, then all
 * non-null items in the index are considered candidate matches, whether they
 * match any of the returned keys or not. This is only done when the contains
 * or exists all strategy are used and the passed map is empty.
 */</comment>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>gin_extract_agtype_query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><name>Datum</name></type> <name>gin_extract_agtype_query</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int32</name> <modifier>*</modifier></type><name>nentries</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>StrategyNumber</name></type> <name>strategy</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name> <modifier>*</modifier></type><name>searchMode</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name> <modifier>*</modifier></type><name>entries</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>||</operator>
        <call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>nentries</name> <operator>=</operator> <operator>(</operator><name>int32</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>strategy</name> <operator>=</operator> <call><name>PG_GETARG_UINT16</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>searchMode</name> <operator>=</operator> <operator>(</operator><name>int32</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>strategy</name> <operator>==</operator> <name>AGTYPE_CONTAINS_STRATEGY_NUMBER</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Query is a agtype, so just apply gin_extract_agtype... */</comment>
        <expr_stmt><expr><name>entries</name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator>
            <call><name>DatumGetPointer</name><argument_list>(<argument><expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>gin_extract_agtype</name></expr></argument>,
                                                <argument><expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>,
                                                <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>nentries</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* ...although "contains {}" requires a full index scan */</comment>
        <if_stmt><if>if <condition>(<expr><operator>*</operator><name>nentries</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><operator>*</operator><name>searchMode</name> <operator>=</operator> <name>GIN_SEARCH_MODE_ALL</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>strategy</name> <operator>==</operator> <name>AGTYPE_EXISTS_STRATEGY_NUMBER</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Query is a text string, which we treat as a key */</comment>
        <decl_stmt><decl><type><name>text</name> <modifier>*</modifier></type><name>query</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><operator>*</operator><name>nentries</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>entries</name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator><call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>entries</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>make_text_key</name><argument_list>(<argument><expr><name>AGT_GIN_FLAG_KEY</name></expr></argument>, <argument><expr><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr></argument>,
                                   <argument><expr><call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>strategy</name> <operator>==</operator> <name>AGTYPE_EXISTS_ANY_STRATEGY_NUMBER</name> <operator>||</operator>
             <name>strategy</name> <operator>==</operator> <name>AGTYPE_EXISTS_ALL_STRATEGY_NUMBER</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Query is a text array; each element is treated as a key */</comment>
        <decl_stmt><decl><type><name>ArrayType</name> <modifier>*</modifier></type><name>query</name> <init>= <expr><call><name>PG_GETARG_ARRAYTYPE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Datum</name> <modifier>*</modifier></type><name>key_datums</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name> <modifier>*</modifier></type><name>key_nulls</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>key_count</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>deconstruct_array</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="char">'i'</literal></expr></argument>,
                          <argument><expr><operator>&amp;</operator><name>key_datums</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>key_nulls</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>key_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>entries</name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>key_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator> <expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>key_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <comment type="block">/* Nulls in the array are ignored */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>key_nulls</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
            <block>{<block_content>
                <continue>continue;</continue>
            </block_content>}</block></if></if_stmt>

            <expr_stmt><expr><name><name>entries</name><index>[<expr><name>j</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>make_text_key</name><argument_list>(<argument><expr><name>AGT_GIN_FLAG_KEY</name></expr></argument>,
                                         <argument><expr><call><name>VARDATA</name><argument_list>(<argument><expr><name><name>key_datums</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>,
                                         <argument><expr><call><name>VARSIZE</name><argument_list>(<argument><expr><name><name>key_datums</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>-</operator> <name>VARHDRSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>

        <expr_stmt><expr><operator>*</operator><name>nentries</name> <operator>=</operator> <name>j</name></expr>;</expr_stmt>
        <comment type="block">/* ExistsAll with no keys should match everything */</comment>
        <if_stmt><if>if <condition>(<expr><name>j</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>strategy</name> <operator>==</operator> <name>AGTYPE_EXISTS_ALL_STRATEGY_NUMBER</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><operator>*</operator><name>searchMode</name> <operator>=</operator> <name>GIN_SEARCH_MODE_ALL</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized strategy number: %d"</literal></expr></argument>, <argument><expr><name>strategy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>entries</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>            <comment type="block">/* keep compiler quiet */</comment>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><name>entries</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Returns true if an indexed item satisfies the query operator for the given
 * strategy (or might satisfy it, if the recheck indication is returned). This
 * function does not have direct access to the indexed item's value, since GIN
 * does not store items explicitly. Rather, what is available is knowledge about
 * which key values extracted from the query appear in a given indexed item. The
 * check array has length nkeys, which is the same as the number of keys
 * previously returned by gin_extract_agtype_query for this query datum. Each
 * element of the check array is true if the indexed item contains the
 * corresponding query key, i.e., if (check[i] == true) the i-th key of the
 * gin_extract_agtype_query result array is present in the indexed item. The
 * original query datum is passed in case the consistent method needs to consult
 * it, and so are the queryKeys[] and nullFlags[] arrays previously returned by
 * gin_extract_agtype_query.
 *
 * When extractQuery returns a null key in queryKeys[], the corresponding
 * check[] element is true if the indexed item contains a null key; that is, the
 * semantics of check[] are like IS NOT DISTINCT FROM. The consistent function
 * can examine the corresponding nullFlags[] element if it needs to tell the
 * difference between a regular value match and a null match.
 *
 * On success, *recheck should be set to true if the heap tuple needs to be
 * rechecked against the query operator, or false if the index test is exact.
 * That is, a false return value guarantees that the heap tuple does not match
 * the query; a true return value with *recheck set to false guarantees that the
 * heap tuple does match the query; and a true return value with *recheck set to
 * true means that the heap tuple might match the query, so it needs to be
 * fetched and rechecked by evaluating the query operator directly against the
 * originally indexed item.
 */</comment>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>gin_consistent_agtype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><name>Datum</name></type> <name>gin_consistent_agtype</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>bool</name> <modifier>*</modifier></type><name>check</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>StrategyNumber</name></type> <name>strategy</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type> <name>nkeys</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name> <modifier>*</modifier></type><name>recheck</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>res</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type> <name>i</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>||</operator>
        <call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>check</name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>strategy</name> <operator>=</operator> <call><name>PG_GETARG_UINT16</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>nkeys</name> <operator>=</operator> <call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>recheck</name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>strategy</name> <operator>==</operator> <name>AGTYPE_CONTAINS_STRATEGY_NUMBER</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * We must always recheck, since we can't tell from the index whether
         * the positions of the matched items match the structure of the query
         * object.  (Even if we could, we'd also have to worry about hashed
         * keys and the index's failure to distinguish keys from string array
         * elements.)  However, the tuple certainly doesn't match unless it
         * contains all the query keys.
         */</comment>
        <expr_stmt><expr><operator>*</operator><name>recheck</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nkeys</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>check</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>res</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>strategy</name> <operator>==</operator> <name>AGTYPE_EXISTS_STRATEGY_NUMBER</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * Although the key is certainly present in the index, we must recheck
         * because (1) the key might be hashed, and (2) the index match might
         * be for a key that's not at top level of the JSON object.  For (1),
         * we could look at the query key to see if it's hashed and not
         * recheck if not, but the index lacks enough info to tell about (2).
         */</comment>
        <expr_stmt><expr><operator>*</operator><name>recheck</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>res</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>strategy</name> <operator>==</operator> <name>AGTYPE_EXISTS_ANY_STRATEGY_NUMBER</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* As for plain exists, we must recheck */</comment>
        <expr_stmt><expr><operator>*</operator><name>recheck</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>res</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>strategy</name> <operator>==</operator> <name>AGTYPE_EXISTS_ALL_STRATEGY_NUMBER</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* As for plain exists, we must recheck */</comment>
        <expr_stmt><expr><operator>*</operator><name>recheck</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        <comment type="block">/* ... but unless all the keys are present, we can say "false" */</comment>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nkeys</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>check</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>res</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized strategy number: %d"</literal></expr></argument>, <argument><expr><name>strategy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * gin_triconsistent_agtype is similar to gin_consistent_agtype, but instead of
 * booleans in the check vector, there are three possible values for each key:
 * GIN_TRUE, GIN_FALSE and GIN_MAYBE. GIN_FALSE and GIN_TRUE have the same
 * meaning as regular boolean values, while GIN_MAYBE means that the presence of
 * that key is not known. When GIN_MAYBE values are present, the function should
 * only return GIN_TRUE if the item certainly matches whether or not the index
 * item contains the corresponding query keys. Likewise, the function must
 * return GIN_FALSE only if the item certainly does not match, whether or not it
 * contains the GIN_MAYBE keys. If the result depends on the GIN_MAYBE entries,
 * i.e., the match cannot be confirmed or refuted based on the known query keys,
 * the function must return GIN_MAYBE.
 *
 * When there are no GIN_MAYBE values in the check vector, a GIN_MAYBE return
 * value is the equivalent of setting the recheck flag in the boolean consistent
 * function.
 */</comment>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>gin_triconsistent_agtype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><name>Datum</name></type> <name>gin_triconsistent_agtype</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>GinTernaryValue</name> <modifier>*</modifier></type><name>check</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>StrategyNumber</name></type> <name>strategy</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type> <name>nkeys</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>GinTernaryValue</name></type> <name>res</name> <init>= <expr><name>GIN_MAYBE</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type> <name>i</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>check</name> <operator>=</operator> <operator>(</operator><name>GinTernaryValue</name> <operator>*</operator><operator>)</operator><call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>strategy</name> <operator>=</operator> <call><name>PG_GETARG_UINT16</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>nkeys</name> <operator>=</operator> <call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Note that we never return GIN_TRUE, only GIN_MAYBE or GIN_FALSE; this
     * corresponds to always forcing recheck in the regular consistent
     * function, for the reasons listed there.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>strategy</name> <operator>==</operator> <name>AGTYPE_CONTAINS_STRATEGY_NUMBER</name> <operator>||</operator>
        <name>strategy</name> <operator>==</operator> <name>AGTYPE_EXISTS_ALL_STRATEGY_NUMBER</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* All extracted keys must be present */</comment>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nkeys</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>check</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>GIN_FALSE</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>res</name> <operator>=</operator> <name>GIN_FALSE</name></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>strategy</name> <operator>==</operator> <name>AGTYPE_EXISTS_STRATEGY_NUMBER</name> <operator>||</operator>
             <name>strategy</name> <operator>==</operator> <name>AGTYPE_EXISTS_ANY_STRATEGY_NUMBER</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* At least one extracted key must be present */</comment>
        <expr_stmt><expr><name>res</name> <operator>=</operator> <name>GIN_FALSE</name></expr>;</expr_stmt>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nkeys</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>check</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>GIN_TRUE</name> <operator>||</operator> <name><name>check</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>GIN_MAYBE</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>res</name> <operator>=</operator> <name>GIN_MAYBE</name></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized strategy number: %d"</literal></expr></argument>, <argument><expr><name>strategy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_GIN_TERNARY_VALUE</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Construct a agtype_ops GIN key from a flag byte and a textual representation
 * (which need not be null-terminated).  This function is responsible
 * for hashing overlength text representations; it will add the
 * AGT_GIN_FLAG_HASHED bit to the flag value if it does that.
 */</comment>
<function><type><specifier>static</specifier> <name>Datum</name></type> <name>make_text_key</name><parameter_list>(<parameter><decl><type><name>char</name></type> <name>flag</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>text</name> <modifier>*</modifier></type><name>item</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>hashbuf</name><index>[<expr><literal type="number">10</literal></expr>]</index></name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <name>AGT_GIN_MAX_LENGTH</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>uint32</name></type> <name>hashval</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>hashval</name> <operator>=</operator> <call><name>DatumGetUInt32</name><argument_list>(<argument><expr><call><name>hash_any</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator> <name>str</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>hashbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>hashbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%08x"</literal></expr></argument>, <argument><expr><name>hashval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>str</name> <operator>=</operator> <name>hashbuf</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>len</name> <operator>=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>flag</name> <operator>|=</operator> <name>AGT_GIN_FLAG_HASHED</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Now build the text Datum.  For simplicity we build a 4-byte-header
     * varlena text Datum here, but we expect it will get converted to short
     * header format when stored in the index.
     */</comment>
    <expr_stmt><expr><name>item</name> <operator>=</operator> <operator>(</operator><name>text</name> <operator>*</operator><operator>)</operator><call><name>palloc</name><argument_list>(<argument><expr><name>VARHDRSZ</name> <operator>+</operator> <name>len</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><name>item</name></expr></argument>, <argument><expr><name>VARHDRSZ</name> <operator>+</operator> <name>len</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><operator>*</operator><call><name>VARDATA</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>flag</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><call><name>VARDATA</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Create a textual representation of a agtype_value that will serve as a GIN
 * key in a agtype_ops index.  is_key is true if the JsonbValue is a key,
 * or if it is a string array element (since we pretend those are keys,
 * see jsonb.h).
 */</comment>
<function><type><specifier>static</specifier> <name>Datum</name></type> <name>make_scalar_key</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>agtype_value</name> <modifier>*</modifier></type><name>scalarVal</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_key</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Datum</name></type> <name>item</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>cstr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><name>MAXINT8LEN</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
    <switch>switch <condition>(<expr><name><name>scalarVal</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition>
    <block>{<block_content>
    <case>case <expr><name>AGTV_NULL</name></expr>:</case>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>is_key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>item</name> <operator>=</operator> <call><name>make_text_key</name><argument_list>(<argument><expr><name>AGT_GIN_FLAG_NULL</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
    <case>case <expr><name>AGTV_INTEGER</name></expr>:</case>
    <block>{<block_content>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>is_key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>pg_lltoa</name><argument_list>(<argument><expr><name><name>scalarVal</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>int_value</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>item</name> <operator>=</operator> <call><name>make_text_key</name><argument_list>(<argument><expr><name>AGT_GIN_FLAG_NUM</name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>AGTV_FLOAT</name></expr>:</case>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>is_key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>cstr</name> <operator>=</operator> <call><name>float8out_internal</name><argument_list>(<argument><expr><name><name>scalarVal</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>float_value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>item</name> <operator>=</operator> <call><name>make_text_key</name><argument_list>(<argument><expr><name>AGT_GIN_FLAG_NUM</name></expr></argument>, <argument><expr><name>cstr</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>cstr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
    <case>case <expr><name>AGTV_BOOL</name></expr>:</case>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>is_key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>item</name> <operator>=</operator> <call><name>make_text_key</name><argument_list>(<argument><expr><name>AGT_GIN_FLAG_BOOL</name></expr></argument>,
                             <argument><expr><ternary><condition><expr><name><name>scalarVal</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>boolean</name></name></expr> ?</condition><then> <expr><literal type="string">"t"</literal></expr> </then><else>: <expr><literal type="string">"f"</literal></expr></else></ternary></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
    <case>case <expr><name>AGTV_NUMERIC</name></expr>:</case>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>is_key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/*
         * A normalized textual representation, free of trailing zeroes,
         * is required so that numerically equal values will produce equal
         * strings.
         *
         * It isn't ideal that numerics are stored in a relatively bulky
         * textual format.  However, it's a notationally convenient way of
         * storing a "union" type in the GIN B-Tree, and indexing Jsonb
         * strings takes precedence.
         */</comment>
        <expr_stmt><expr><name>cstr</name> <operator>=</operator> <call><name>numeric_normalize</name><argument_list>(<argument><expr><name><name>scalarVal</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>numeric</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>item</name> <operator>=</operator> <call><name>make_text_key</name><argument_list>(<argument><expr><name>AGT_GIN_FLAG_NUM</name></expr></argument>, <argument><expr><name>cstr</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>cstr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>cstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
    <case>case <expr><name>AGTV_STRING</name></expr>:</case>
        <expr_stmt><expr><name>item</name> <operator>=</operator> <call><name>make_text_key</name><argument_list>(<argument><expr><ternary><condition><expr><name>is_key</name></expr> ?</condition><then> <expr><name>AGT_GIN_FLAG_KEY</name></expr> </then><else>: <expr><name>AGT_GIN_FLAG_STR</name></expr></else></ternary></expr></argument>,
                             <argument><expr><name><name>scalarVal</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>val</name></name></expr></argument>,
                             <argument><expr><name><name>scalarVal</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
    <case>case <expr><name>AGTV_VERTEX</name></expr>:</case>
    <case>case <expr><name>AGTV_EDGE</name></expr>:</case>
    <case>case <expr><name>AGTV_PATH</name></expr>:</case>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"agtype type: %d is not a scalar"</literal></expr></argument>, <argument><expr><name><name>scalarVal</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
    <default>default:</default>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized agtype type: %d"</literal></expr></argument>, <argument><expr><name><name>scalarVal</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
    </block_content>}</block></switch>

    <return>return <expr><name>item</name></expr>;</return>
</block_content>}</block></function>
</unit>
