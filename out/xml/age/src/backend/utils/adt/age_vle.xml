<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/age/src/backend/utils/adt/age_vle.c"><comment type="block">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"funcapi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/age_vle.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/ag_graph.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/graphid.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/age_graphid_ds.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/cypher_nodes.h"</cpp:file></cpp:include>

<comment type="block">/* defines */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GET_GRAPHID_ARRAY_FROM_CONTAINER</name><parameter_list>(<parameter><type><name>vpc</name></type></parameter>)</parameter_list></cpp:macro> \
            <cpp:value>(graphid *) (&amp;vpc-&gt;graphid_array_data)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EDGE_STATE_HTAB_NAME</name></cpp:macro> <cpp:value>"Edge state "</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EDGE_STATE_HTAB_INITIAL_SIZE</name></cpp:macro> <cpp:value>100000</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EXISTS_HTAB_NAME</name></cpp:macro> <cpp:value>"known edges"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EXISTS_HTAB_NAME_INITIAL_SIZE</name></cpp:macro> <cpp:value>1000</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAXIMUM_NUMBER_OF_CACHED_LOCAL_CONTEXTS</name></cpp:macro> <cpp:value>5</cpp:value></cpp:define>

<comment type="block">/* edge state entry for the edge_state_hashtable */</comment>
<typedef>typedef <type><struct>struct <name>edge_state_entry</name>
<block>{
    <decl_stmt><decl><type><name>graphid</name></type> <name>edge_id</name></decl>;</decl_stmt>               <comment type="block">/* edge id, it is also the hash key */</comment>
    <decl_stmt><decl><type><name>bool</name></type> <name>used_in_path</name></decl>;</decl_stmt>             <comment type="block">/* like visited but more descriptive */</comment>
    <decl_stmt><decl><type><name>bool</name></type> <name>has_been_matched</name></decl>;</decl_stmt>         <comment type="block">/* have we checked for a  match */</comment>
    <decl_stmt><decl><type><name>bool</name></type> <name>matched</name></decl>;</decl_stmt>                  <comment type="block">/* is it a match */</comment>
}</block></struct></type> <name>edge_state_entry</name>;</typedef>

<comment type="block">/*
 * VLE_path_function is an enum for the path function to use. This currently can
 * be one of two possibilities - where the target vertex is provided and where
 * it isn't.
 */</comment>
<typedef>typedef <type><enum>enum
<block>{                                  <comment type="block">/* Given a path (u)-[e]-(v)                */</comment>
    <decl><name>VLE_FUNCTION_PATHS_FROM</name></decl>,       <comment type="block">/* Paths from a (u) without a provided (v) */</comment>
    <decl><name>VLE_FUNCTION_PATHS_TO</name></decl>,         <comment type="block">/* Paths to a (v) without a provided (u)   */</comment>
    <decl><name>VLE_FUNCTION_PATHS_BETWEEN</name></decl>,    <comment type="block">/* Paths between a (u) and a provided (v)  */</comment>
    <decl><name>VLE_FUNCTION_PATHS_ALL</name></decl>,        <comment type="block">/* All paths without a provided (u) or (v) */</comment>
    <decl><name>VLE_FUNCTION_NONE</name></decl>
}</block></enum></type> <name>VLE_path_function</name>;</typedef>

<comment type="block">/* VLE local context per each unique age_vle function activation */</comment>
<typedef>typedef <type><struct>struct <name>VLE_local_context</name>
<block>{
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>graph_name</name></decl>;</decl_stmt>              <comment type="block">/* name of the graph */</comment>
    <decl_stmt><decl><type><name>Oid</name></type> <name>graph_oid</name></decl>;</decl_stmt>                 <comment type="block">/* graph oid for searching */</comment>
    <decl_stmt><decl><type><name>GRAPH_global_context</name> <modifier>*</modifier></type><name>ggctx</name></decl>;</decl_stmt>   <comment type="block">/* global graph context pointer */</comment>
    <decl_stmt><decl><type><name>graphid</name></type> <name>vsid</name></decl>;</decl_stmt>                  <comment type="block">/* starting vertex id */</comment>
    <decl_stmt><decl><type><name>graphid</name></type> <name>veid</name></decl>;</decl_stmt>                  <comment type="block">/* ending vertex id */</comment>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>edge_label_name</name></decl>;</decl_stmt>         <comment type="block">/* edge label name for match */</comment>
    <decl_stmt><decl><type><name>agtype</name> <modifier>*</modifier></type><name>edge_property_constraint</name></decl>;</decl_stmt> <comment type="block">/* edge property constraint as agtype */</comment>
    <decl_stmt><decl><type><name>int64</name></type> <name>lidx</name></decl>;</decl_stmt>                    <comment type="block">/* lower (start) bound index */</comment>
    <decl_stmt><decl><type><name>int64</name></type> <name>uidx</name></decl>;</decl_stmt>                    <comment type="block">/* upper (end) bound index */</comment>
    <decl_stmt><decl><type><name>bool</name></type> <name>uidx_infinite</name></decl>;</decl_stmt>            <comment type="block">/* flag if the upper bound is omitted */</comment>
    <decl_stmt><decl><type><name>cypher_rel_dir</name></type> <name>edge_direction</name></decl>;</decl_stmt> <comment type="block">/* the direction of the edge */</comment>
    <decl_stmt><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>edge_state_hashtable</name></decl>;</decl_stmt>    <comment type="block">/* local state hashtable for our edges */</comment>
    <decl_stmt><decl><type><name>ListGraphId</name> <modifier>*</modifier></type><name>dfs_vertex_stack</name></decl>;</decl_stmt> <comment type="block">/* dfs stack for vertices */</comment>
    <decl_stmt><decl><type><name>ListGraphId</name> <modifier>*</modifier></type><name>dfs_edge_stack</name></decl>;</decl_stmt>   <comment type="block">/* dfs stack for edges */</comment>
    <decl_stmt><decl><type><name>ListGraphId</name> <modifier>*</modifier></type><name>dfs_path_stack</name></decl>;</decl_stmt>   <comment type="block">/* dfs stack containing the path */</comment>
    <decl_stmt><decl><type><name>VLE_path_function</name></type> <name>path_function</name></decl>;</decl_stmt> <comment type="block">/* which path function to use */</comment>
    <decl_stmt><decl><type><name>GraphIdNode</name> <modifier>*</modifier></type><name>next_vertex</name></decl>;</decl_stmt>      <comment type="block">/* for VLE_FUNCTION_PATHS_TO */</comment>
    <decl_stmt><decl><type><name>int64</name></type> <name>vle_grammar_node_id</name></decl>;</decl_stmt>     <comment type="block">/* the unique VLE grammar assigned node id */</comment>
    <decl_stmt><decl><type><name>bool</name></type> <name>use_cache</name></decl>;</decl_stmt>                <comment type="block">/* are we using VLE_local_context cache */</comment>
    <decl_stmt><decl><type><name><name>struct</name> <name>VLE_local_context</name></name> <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>  <comment type="block">/* the next chained VLE_local_context */</comment>
    <decl_stmt><decl><type><name>bool</name></type> <name>is_dirty</name></decl>;</decl_stmt>                 <comment type="block">/* is this VLE context reusable */</comment>
}</block></struct></type> <name>VLE_local_context</name>;</typedef>

<comment type="block">/*
 * Container to hold the graphid array that contains one valid path. This
 * structure will allow it to be easily passed as an AGTYPE pointer. The
 * structure is set up to contains a BINARY container that can be accessed by
 * functions that need to process the path.
 */</comment>
<typedef>typedef <type><struct>struct <name>VLE_path_container</name>
<block>{
    <decl_stmt><decl><type><name>char</name></type> <name><name>vl_len_</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt> <comment type="block">/* Do not touch this field! */</comment>
    <decl_stmt><decl><type><name>uint32</name></type> <name>header</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type> <name>graph_oid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int64</name></type> <name>graphid_array_size</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int64</name></type> <name>container_size_bytes</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>graphid</name></type> <name>graphid_array_data</name></decl>;</decl_stmt>
}</block></struct></type> <name>VLE_path_container</name>;</typedef>

<comment type="block">/* declarations */</comment>

<comment type="block">/* global variable to hold the per process global cached VLE_local contexts */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>VLE_local_context</name> <modifier>*</modifier></type><name>global_vle_local_contexts</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* agtype functions */</comment>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>is_an_edge_match</name><parameter_list>(<parameter><decl><type><name>VLE_local_context</name> <modifier>*</modifier></type><name>vlelctx</name></decl></parameter>, <parameter><decl><type><name>edge_entry</name> <modifier>*</modifier></type><name>ee</name></decl></parameter>)</parameter_list>;</function_decl>
<comment type="block">/* VLE local context functions */</comment>
<function_decl><type><specifier>static</specifier> <name>VLE_local_context</name> <modifier>*</modifier></type><name>build_local_vle_context</name><parameter_list>(<parameter><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name></decl></parameter>,
                                                  <parameter><decl><type><name>FuncCallContext</name> <modifier>*</modifier></type><name>funcctx</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>create_VLE_local_state_hashtable</name><parameter_list>(<parameter><decl><type><name>VLE_local_context</name> <modifier>*</modifier></type><name>vlelctx</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>free_VLE_local_context</name><parameter_list>(<parameter><decl><type><name>VLE_local_context</name> <modifier>*</modifier></type><name>vlelctx</name></decl></parameter>)</parameter_list>;</function_decl>
<comment type="block">/* VLE graph traversal functions */</comment>
<function_decl><type><specifier>static</specifier> <name>edge_state_entry</name> <modifier>*</modifier></type><name>get_edge_state</name><parameter_list>(<parameter><decl><type><name>VLE_local_context</name> <modifier>*</modifier></type><name>vlelctx</name></decl></parameter>,
                                        <parameter><decl><type><name>graphid</name></type> <name>edge_id</name></decl></parameter>)</parameter_list>;</function_decl>
<comment type="block">/* graphid data structures */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>load_initial_dfs_stacks</name><parameter_list>(<parameter><decl><type><name>VLE_local_context</name> <modifier>*</modifier></type><name>vlelctx</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>dfs_find_a_path_between</name><parameter_list>(<parameter><decl><type><name>VLE_local_context</name> <modifier>*</modifier></type><name>vlelctx</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>dfs_find_a_path_from</name><parameter_list>(<parameter><decl><type><name>VLE_local_context</name> <modifier>*</modifier></type><name>vlelctx</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>do_vsid_and_veid_exist</name><parameter_list>(<parameter><decl><type><name>VLE_local_context</name> <modifier>*</modifier></type><name>vlelctx</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>add_valid_vertex_edges</name><parameter_list>(<parameter><decl><type><name>VLE_local_context</name> <modifier>*</modifier></type><name>vlelctx</name></decl></parameter>,
                                   <parameter><decl><type><name>graphid</name></type> <name>vertex_id</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>graphid</name></type> <name>get_next_vertex</name><parameter_list>(<parameter><decl><type><name>VLE_local_context</name> <modifier>*</modifier></type><name>vlelctx</name></decl></parameter>, <parameter><decl><type><name>edge_entry</name> <modifier>*</modifier></type><name>ee</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>is_edge_in_path</name><parameter_list>(<parameter><decl><type><name>VLE_local_context</name> <modifier>*</modifier></type><name>vlelctx</name></decl></parameter>, <parameter><decl><type><name>graphid</name></type> <name>edge_id</name></decl></parameter>)</parameter_list>;</function_decl>
<comment type="block">/* VLE path and edge building functions */</comment>
<function_decl><type><specifier>static</specifier> <name>VLE_path_container</name> <modifier>*</modifier></type><name>create_VLE_path_container</name><parameter_list>(<parameter><decl><type><name>int64</name></type> <name>path_size</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>VLE_path_container</name> <modifier>*</modifier></type><name>build_VLE_path_container</name><parameter_list>(<parameter><decl><type><name>VLE_local_context</name> <modifier>*</modifier></type><name>vlelctx</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>VLE_path_container</name> <modifier>*</modifier></type><name>build_VLE_zero_container</name><parameter_list>(<parameter><decl><type><name>VLE_local_context</name> <modifier>*</modifier></type><name>vlelctx</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>agtype_value</name> <modifier>*</modifier></type><name>build_path</name><parameter_list>(<parameter><decl><type><name>VLE_path_container</name> <modifier>*</modifier></type><name>vpc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>agtype_value</name> <modifier>*</modifier></type><name>build_edge_list</name><parameter_list>(<parameter><decl><type><name>VLE_path_container</name> <modifier>*</modifier></type><name>vpc</name></decl></parameter>)</parameter_list>;</function_decl>
<comment type="block">/* VLE_local_context cache management */</comment>
<function_decl><type><specifier>static</specifier> <name>VLE_local_context</name> <modifier>*</modifier></type><name>get_cached_VLE_local_context</name><parameter_list>(<parameter><decl><type><name>int64</name></type> <name>vle_node_id</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>cache_VLE_local_context</name><parameter_list>(<parameter><decl><type><name>VLE_local_context</name> <modifier>*</modifier></type><name>vlelctx</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* definitions */</comment>

<comment type="block">/*
 * Helper function to retrieve a cached VLE local context. It will also purge
 * off any contexts beyond the maximum defined number of cached contexts. It
 * will promote (a very basic LRU) the recently fetched context to the head of
 * the list. If a context doesn't exist or is dirty, it will purge it off and
 * return NULL.
 */</comment>
<function><type><specifier>static</specifier> <name>VLE_local_context</name> <modifier>*</modifier></type><name>get_cached_VLE_local_context</name><parameter_list>(<parameter><decl><type><name>int64</name></type> <name>vle_grammar_node_id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>VLE_local_context</name> <modifier>*</modifier></type><name>vlelctx</name> <init>= <expr><name>global_vle_local_contexts</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>VLE_local_context</name> <modifier>*</modifier></type><name>prev</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>VLE_local_context</name> <modifier>*</modifier></type><name>next</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>cache_size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <comment type="block">/* while we have contexts to check */</comment>
    <while>while <condition>(<expr><name>vlelctx</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* purge any contexts past the maximum cache size */</comment>
        <if_stmt><if>if <condition>(<expr><name>cache_size</name> <operator>&gt;=</operator> <name>MAXIMUM_NUMBER_OF_CACHED_LOCAL_CONTEXTS</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* set the next pointer to the context that follows */</comment>
            <expr_stmt><expr><name>next</name> <operator>=</operator> <name><name>vlelctx</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>

            <comment type="block">/*
             * Clear (unlink) the previous context's next pointer, if needed.
             * Also clear prev as we are at the end of avaiable cached contexts
             * and just purging them off. Remember, this forms a loop that will
             * exit the while after purging.
             */</comment>
            <if_stmt><if>if <condition>(<expr><name>prev</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name><name>prev</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>prev</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <comment type="block">/* free the context */</comment>
            <expr_stmt><expr><call><name>free_VLE_local_context</name><argument_list>(<argument><expr><name>vlelctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* set to the next one */</comment>
            <expr_stmt><expr><name>vlelctx</name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>

            <comment type="block">/* if there is another context beyond the max, we will re-enter */</comment>
            <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* if this context belongs to this grammar node */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>vlelctx</name><operator>-&gt;</operator><name>vle_grammar_node_id</name></name> <operator>==</operator> <name>vle_grammar_node_id</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* and isn't dirty */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>vlelctx</name><operator>-&gt;</operator><name>is_dirty</name></name> <operator>==</operator> <name>false</name></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>GRAPH_global_context</name> <modifier>*</modifier></type><name>ggctx</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

                <comment type="block">/*
                 * Get the GRAPH global context associated with this local VLE
                 * context. We need to verify it still exists and that the
                 * pointer is valid.
                 */</comment>
                <expr_stmt><expr><name>ggctx</name> <operator>=</operator> <call><name>find_GRAPH_global_context</name><argument_list>(<argument><expr><name><name>vlelctx</name><operator>-&gt;</operator><name>graph_oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/*
                 * If ggctx == NULL, vlelctx is bad and vlelctx needs to be
                 * removed.
                 * If ggctx == vlelctx-&gt;ggctx, then vlelctx is good.
                 * If ggctx != vlelctx-&gt;ggctx, then vlelctx needs to be updated.
                 * In the end, vlelctx-&gt;ggctx will be set to ggctx.
                 */</comment>

                <comment type="block">/*
                 * If the returned ggctx isn't valid (there was some update to
                 * the underlying graph), then set it to NULL. This will force a
                 * rebuild of it.
                 */</comment>
                <if_stmt><if>if <condition>(<expr><name>ggctx</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>is_ggctx_invalid</name><argument_list>(<argument><expr><name>ggctx</name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>ggctx</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>

                <expr_stmt><expr><name><name>vlelctx</name><operator>-&gt;</operator><name>ggctx</name></name> <operator>=</operator> <name>ggctx</name></expr>;</expr_stmt>

                <comment type="block">/*
                 * If the context is good and isn't at the head of the cache,
                 * promote it to the head.
                 */</comment>
                <if_stmt><if>if <condition>(<expr><name>ggctx</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>vlelctx</name> <operator>!=</operator> <name>global_vle_local_contexts</name></expr>)</condition>
                <block>{<block_content>
                    <comment type="block">/* adjust the links to cut out the node */</comment>
                    <expr_stmt><expr><name><name>prev</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>vlelctx</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
                    <comment type="block">/* point the context to the old head of the list */</comment>
                    <expr_stmt><expr><name><name>vlelctx</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>global_vle_local_contexts</name></expr>;</expr_stmt>
                    <comment type="block">/* point the head to this context */</comment>
                    <expr_stmt><expr><name>global_vle_local_contexts</name> <operator>=</operator> <name>vlelctx</name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>

                <comment type="block">/* if we have a good one, return it. */</comment>
                <if_stmt><if>if <condition>(<expr><name>ggctx</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
                <block>{<block_content>
                    <return>return <expr><name>vlelctx</name></expr>;</return>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>

            <comment type="block">/* otherwise, clean and remove it, and return NULL */</comment>

            <comment type="block">/* set the top if necessary and unlink it */</comment>
            <if_stmt><if>if <condition>(<expr><name>prev</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>global_vle_local_contexts</name> <operator>=</operator> <name><name>vlelctx</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><name><name>prev</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>vlelctx</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>

            <comment type="block">/* now free it and return NULL */</comment>
            <expr_stmt><expr><call><name>free_VLE_local_context</name><argument_list>(<argument><expr><name>vlelctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>NULL</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <comment type="block">/* save the previous context */</comment>
        <expr_stmt><expr><name>prev</name> <operator>=</operator> <name>vlelctx</name></expr>;</expr_stmt>
        <comment type="block">/* get the next context */</comment>
        <expr_stmt><expr><name>vlelctx</name> <operator>=</operator> <name><name>vlelctx</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
        <comment type="block">/* keep track of cache size */</comment>
        <expr_stmt><expr><name>cache_size</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></while>
    <return>return <expr><name>vlelctx</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>cache_VLE_local_context</name><parameter_list>(<parameter><decl><type><name>VLE_local_context</name> <modifier>*</modifier></type><name>vlelctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/* if the context passed is null, just return */</comment>
    <if_stmt><if>if <condition>(<expr><name>vlelctx</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* if the global link is null, just assign it the local context */</comment>
    <if_stmt><if>if <condition>(<expr><name>global_vle_local_contexts</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>global_vle_local_contexts</name> <operator>=</operator> <name>vlelctx</name></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* if there is a global link, add the local context to the top */</comment>
    <expr_stmt><expr><name><name>vlelctx</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>global_vle_local_contexts</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>global_vle_local_contexts</name> <operator>=</operator> <name>vlelctx</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* helper function to create the local VLE edge state hashtable. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>create_VLE_local_state_hashtable</name><parameter_list>(<parameter><decl><type><name>VLE_local_context</name> <modifier>*</modifier></type><name>vlelctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HASHCTL</name></type> <name>edge_state_ctl</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>graph_name</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>eshn</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>glen</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>elen</name></decl>;</decl_stmt>

    <comment type="block">/* get the graph name and length */</comment>
    <expr_stmt><expr><name>graph_name</name> <operator>=</operator> <name><name>vlelctx</name><operator>-&gt;</operator><name>graph_name</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>glen</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>graph_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* get the edge state htab name length */</comment>
    <expr_stmt><expr><name>elen</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>EDGE_STATE_HTAB_NAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* allocate the space and build the name */</comment>
    <expr_stmt><expr><name>eshn</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>elen</name> <operator>+</operator> <name>glen</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* copy in the name */</comment>
    <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>eshn</name></expr></argument>, <argument><expr><name>EDGE_STATE_HTAB_NAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* add in the graph name */</comment>
    <expr_stmt><expr><name>eshn</name> <operator>=</operator> <call><name>strncat</name><argument_list>(<argument><expr><name>eshn</name></expr></argument>, <argument><expr><name>graph_name</name></expr></argument>, <argument><expr><name>glen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* initialize the edge state hashtable */</comment>
    <expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>edge_state_ctl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>edge_state_ctl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>edge_state_ctl</name><operator>.</operator><name>keysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int64</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>edge_state_ctl</name><operator>.</operator><name>entrysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>edge_state_entry</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>edge_state_ctl</name><operator>.</operator><name>hash</name></name> <operator>=</operator> <name>tag_hash</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>vlelctx</name><operator>-&gt;</operator><name>edge_state_hashtable</name></name> <operator>=</operator> <call><name>hash_create</name><argument_list>(<argument><expr><name>eshn</name></expr></argument>,
                                                <argument><expr><name>EDGE_STATE_HTAB_INITIAL_SIZE</name></expr></argument>,
                                                <argument><expr><operator>&amp;</operator><name>edge_state_ctl</name></expr></argument>,
                                                <argument><expr><name>HASH_ELEM</name> <operator>|</operator> <name>HASH_FUNCTION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>eshn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Helper function to compare the edge constraint (properties we are looking
 * for in a matching edge) against an edge entry's property.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type> <name>is_an_edge_match</name><parameter_list>(<parameter><decl><type><name>VLE_local_context</name> <modifier>*</modifier></type><name>vlelctx</name></decl></parameter>, <parameter><decl><type><name>edge_entry</name> <modifier>*</modifier></type><name>ee</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>agtype</name> <modifier>*</modifier></type><name>edge_property</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_container</name> <modifier>*</modifier></type><name>agtc_edge_property</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_container</name> <modifier>*</modifier></type><name>agtc_edge_property_constraint</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_iterator</name> <modifier>*</modifier></type><name>constraint_it</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_iterator</name> <modifier>*</modifier></type><name>property_it</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>edge_label_name</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>num_edge_property_constraints</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>num_edge_properties</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <comment type="block">/* get the number of conditions from the prototype edge */</comment>
    <expr_stmt><expr><name>num_edge_property_constraints</name> <operator>=</operator> <call><name>AGT_ROOT_COUNT</name><argument_list>(<argument><expr><name><name>vlelctx</name><operator>-&gt;</operator><name>edge_property_constraint</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * We only care about verifying that we have all of the property conditions.
     * We don't care about extra unmatched properties. If there aren't any edge
     * constraints, then the edge passes by default.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>vlelctx</name><operator>-&gt;</operator><name>edge_label_name</name></name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>num_edge_property_constraints</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <return>return <expr><name>true</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* get the edge label name from the oid */</comment>
    <expr_stmt><expr><name>edge_label_name</name> <operator>=</operator> <call><name>get_rel_name</name><argument_list>(<argument><expr><call><name>get_edge_entry_label_table_oid</name><argument_list>(<argument><expr><name>ee</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* get our edge's properties */</comment>
    <expr_stmt><expr><name>edge_property</name> <operator>=</operator> <call><name>DATUM_GET_AGTYPE_P</name><argument_list>(<argument><expr><call><name>get_edge_entry_properties</name><argument_list>(<argument><expr><name>ee</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* get the containers */</comment>
    <expr_stmt><expr><name>agtc_edge_property_constraint</name> <operator>=</operator> <operator>&amp;</operator><name><name>vlelctx</name><operator>-&gt;</operator><name>edge_property_constraint</name><operator>-&gt;</operator><name>root</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>agtc_edge_property</name> <operator>=</operator> <operator>&amp;</operator><name><name>edge_property</name><operator>-&gt;</operator><name>root</name></name></expr>;</expr_stmt>
    <comment type="block">/* get the number of properties in the edge to be matched */</comment>
    <expr_stmt><expr><name>num_edge_properties</name> <operator>=</operator> <call><name>AGTYPE_CONTAINER_SIZE</name><argument_list>(<argument><expr><name>agtc_edge_property</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Check to see if the edge_properties object has AT LEAST as many pairs
     * to compare as the edge_property_constraint object has pairs. If not, it
     * can't possibly match.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>num_edge_property_constraints</name> <operator>&gt;</operator> <name>num_edge_properties</name></expr>)</condition>
    <block>{<block_content>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Check for a label constraint. If the label name is NULL, there isn't one.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>vlelctx</name><operator>-&gt;</operator><name>edge_label_name</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
        <call><name>strcmp</name><argument_list>(<argument><expr><name><name>vlelctx</name><operator>-&gt;</operator><name>edge_label_name</name></name></expr></argument>, <argument><expr><name>edge_label_name</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* get the iterators */</comment>
    <expr_stmt><expr><name>constraint_it</name> <operator>=</operator> <call><name>agtype_iterator_init</name><argument_list>(<argument><expr><name>agtc_edge_property_constraint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>property_it</name> <operator>=</operator> <call><name>agtype_iterator_init</name><argument_list>(<argument><expr><name>agtc_edge_property</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* return the value of deep contains */</comment>
    <return>return <expr><call><name>agtype_deep_contains</name><argument_list>(<argument><expr><operator>&amp;</operator><name>property_it</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>constraint_it</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Helper function to free up the memory used by the VLE_local_context.
 *
 * Currently, the only structures that needs to be freed are the edge state
 * hashtable and the dfs stacks (vertex, edge, and path). The hashtable is easy
 * because hash_create packages everything into its own memory context. So, you
 * only need to do a destroy.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>free_VLE_local_context</name><parameter_list>(<parameter><decl><type><name>VLE_local_context</name> <modifier>*</modifier></type><name>vlelctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/* if the VLE context is NULL, do nothing */</comment>
    <if_stmt><if>if <condition>(<expr><name>vlelctx</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* free the stored graph name */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>vlelctx</name><operator>-&gt;</operator><name>graph_name</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>vlelctx</name><operator>-&gt;</operator><name>graph_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>vlelctx</name><operator>-&gt;</operator><name>graph_name</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* free the stored edge label name */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>vlelctx</name><operator>-&gt;</operator><name>edge_label_name</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>vlelctx</name><operator>-&gt;</operator><name>edge_label_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>vlelctx</name><operator>-&gt;</operator><name>edge_label_name</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* we need to free our state hashtable */</comment>
    <expr_stmt><expr><call><name>hash_destroy</name><argument_list>(<argument><expr><name><name>vlelctx</name><operator>-&gt;</operator><name>edge_state_hashtable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>vlelctx</name><operator>-&gt;</operator><name>edge_state_hashtable</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

    <comment type="block">/*
     * We need to free the contents of our stacks if the context is not dirty.
     * These stacks are created in a more volatile memory context. If the
     * process was interupted, they will be garbage collected by PG. The only
     * time we will ever clean them here is if the cache isn't being used.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>vlelctx</name><operator>-&gt;</operator><name>is_dirty</name></name> <operator>==</operator> <name>false</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>free_graphid_stack</name><argument_list>(<argument><expr><name><name>vlelctx</name><operator>-&gt;</operator><name>dfs_vertex_stack</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>free_graphid_stack</name><argument_list>(<argument><expr><name><name>vlelctx</name><operator>-&gt;</operator><name>dfs_edge_stack</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>free_graphid_stack</name><argument_list>(<argument><expr><name><name>vlelctx</name><operator>-&gt;</operator><name>dfs_path_stack</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* free the containers */</comment>
    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>vlelctx</name><operator>-&gt;</operator><name>dfs_vertex_stack</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>vlelctx</name><operator>-&gt;</operator><name>dfs_edge_stack</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>vlelctx</name><operator>-&gt;</operator><name>dfs_path_stack</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>vlelctx</name><operator>-&gt;</operator><name>dfs_vertex_stack</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>vlelctx</name><operator>-&gt;</operator><name>dfs_edge_stack</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>vlelctx</name><operator>-&gt;</operator><name>dfs_path_stack</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

    <comment type="block">/* and finally the context itself */</comment>
    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>vlelctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>vlelctx</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* helper function to check if our start and end vertices exist */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type> <name>do_vsid_and_veid_exist</name><parameter_list>(<parameter><decl><type><name>VLE_local_context</name> <modifier>*</modifier></type><name>vlelctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/* if we are only using the starting vertex */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>vlelctx</name><operator>-&gt;</operator><name>path_function</name></name> <operator>==</operator> <name>VLE_FUNCTION_PATHS_FROM</name> <operator>||</operator>
        <name><name>vlelctx</name><operator>-&gt;</operator><name>path_function</name></name> <operator>==</operator> <name>VLE_FUNCTION_PATHS_ALL</name></expr>)</condition>
    <block>{<block_content>
        <return>return <expr><operator>(</operator><call><name>get_vertex_entry</name><argument_list>(<argument><expr><name><name>vlelctx</name><operator>-&gt;</operator><name>ggctx</name></name></expr></argument>, <argument><expr><name><name>vlelctx</name><operator>-&gt;</operator><name>vsid</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* if we are only using the ending vertex */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>vlelctx</name><operator>-&gt;</operator><name>path_function</name></name> <operator>==</operator> <name>VLE_FUNCTION_PATHS_TO</name></expr>)</condition>
    <block>{<block_content>
        <return>return <expr><operator>(</operator><call><name>get_vertex_entry</name><argument_list>(<argument><expr><name><name>vlelctx</name><operator>-&gt;</operator><name>ggctx</name></name></expr></argument>, <argument><expr><name><name>vlelctx</name><operator>-&gt;</operator><name>veid</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* if we are using both start and end */</comment>
    <return>return <expr><operator>(</operator><operator>(</operator><call><name>get_vertex_entry</name><argument_list>(<argument><expr><name><name>vlelctx</name><operator>-&gt;</operator><name>ggctx</name></name></expr></argument>, <argument><expr><name><name>vlelctx</name><operator>-&gt;</operator><name>vsid</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name><operator>)</operator> <operator>&amp;&amp;</operator>
            <operator>(</operator><call><name>get_vertex_entry</name><argument_list>(<argument><expr><name><name>vlelctx</name><operator>-&gt;</operator><name>ggctx</name></name></expr></argument>, <argument><expr><name><name>vlelctx</name><operator>-&gt;</operator><name>veid</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name><operator>)</operator><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* load the initial edges into the dfs_edge_stack */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>load_initial_dfs_stacks</name><parameter_list>(<parameter><decl><type><name>VLE_local_context</name> <modifier>*</modifier></type><name>vlelctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/*
     * If either the vsid or veid don't exist - don't load anything because
     * there won't be anything to find.
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>do_vsid_and_veid_exist</name><argument_list>(<argument><expr><name>vlelctx</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* add in the edges for the start vertex */</comment>
    <expr_stmt><expr><call><name>add_valid_vertex_edges</name><argument_list>(<argument><expr><name>vlelctx</name></expr></argument>, <argument><expr><name><name>vlelctx</name><operator>-&gt;</operator><name>vsid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Helper function to build the local VLE context. This is also the point
 * where, if necessary, the global GRAPH contexts are created and freed.
 */</comment>
<function><type><specifier>static</specifier> <name>VLE_local_context</name> <modifier>*</modifier></type><name>build_local_vle_context</name><parameter_list>(<parameter><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name></decl></parameter>,
                                                  <parameter><decl><type><name>FuncCallContext</name> <modifier>*</modifier></type><name>funcctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldctx</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>GRAPH_global_context</name> <modifier>*</modifier></type><name>ggctx</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>VLE_local_context</name> <modifier>*</modifier></type><name>vlelctx</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>agtv_temp</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>agtv_object</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>graph_name</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type> <name>graph_oid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int64</name></type> <name>vle_grammar_node_id</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>use_cache</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/*
     * Get the VLE grammar node id, if it exists. Remember, we overload the
     * age_vle function, for now, for backwards compatability
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>PG_NARGS</name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">8</literal></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* get the VLE grammar node id */</comment>
        <expr_stmt><expr><name>agtv_temp</name> <operator>=</operator> <call><name>get_agtype_value</name><argument_list>(<argument><expr><literal type="string">"age_vle"</literal></expr></argument>, <argument><expr><call><name>AG_GET_ARG_AGTYPE_P</name><argument_list>(<argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call></expr></argument>,
                                     <argument><expr><name>AGTV_INTEGER</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>vle_grammar_node_id</name> <operator>=</operator> <name><name>agtv_temp</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>int_value</name></name></expr>;</expr_stmt>

        <comment type="block">/* we are using the VLE local context cache, so set it */</comment>
        <expr_stmt><expr><name>use_cache</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* fetch the VLE_local_context if it is cached */</comment>
    <expr_stmt><expr><name>vlelctx</name> <operator>=</operator> <call><name>get_cached_VLE_local_context</name><argument_list>(<argument><expr><name>vle_grammar_node_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* if we are caching VLE_local_contexts and this grammar node is cached */</comment>
    <if_stmt><if>if <condition>(<expr><name>use_cache</name> <operator>&amp;&amp;</operator> <name>vlelctx</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * No context change is needed here as the cache entry is in the proper
         * context. Additionally, all of the modifications are either pointers
         * to objects already in the proper context or primative types that will
         * be stored in that context since the memory is allocated there.
         */</comment>

        <comment type="block">/* get and update the start vertex id */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>is_agtype_null</name><argument_list>(<argument><expr><call><name>AG_GET_ARG_AGTYPE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>vlelctx</name><operator>-&gt;</operator><name>vsid</name></name> <operator>=</operator> <call><name>get_graphid</name><argument_list>(<argument><expr><name><name>vlelctx</name><operator>-&gt;</operator><name>next_vertex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* increment to the next vertex */</comment>
            <expr_stmt><expr><name><name>vlelctx</name><operator>-&gt;</operator><name>next_vertex</name></name> <operator>=</operator> <call><name>next_GraphIdNode</name><argument_list>(<argument><expr><name><name>vlelctx</name><operator>-&gt;</operator><name>next_vertex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><name>agtv_temp</name> <operator>=</operator> <call><name>get_agtype_value</name><argument_list>(<argument><expr><literal type="string">"age_vle"</literal></expr></argument>, <argument><expr><call><name>AG_GET_ARG_AGTYPE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>,
                                         <argument><expr><name>AGTV_VERTEX</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>agtv_temp</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>agtv_temp</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AGTV_VERTEX</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>agtv_temp</name> <operator>=</operator> <call><name>GET_AGTYPE_VALUE_OBJECT_VALUE</name><argument_list>(<argument><expr><name>agtv_temp</name></expr></argument>, <argument><expr><literal type="string">"id"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <if type="elseif">else if <condition>(<expr><name>agtv_temp</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>agtv_temp</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>AGTV_INTEGER</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"start vertex argument must be a vertex or the integer id"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name><name>vlelctx</name><operator>-&gt;</operator><name>vsid</name></name> <operator>=</operator> <name><name>agtv_temp</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>int_value</name></name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <comment type="block">/* get and update the end vertex id */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>is_agtype_null</name><argument_list>(<argument><expr><call><name>AG_GET_ARG_AGTYPE_P</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>vlelctx</name><operator>-&gt;</operator><name>veid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><name>agtv_temp</name> <operator>=</operator> <call><name>get_agtype_value</name><argument_list>(<argument><expr><literal type="string">"age_vle"</literal></expr></argument>, <argument><expr><call><name>AG_GET_ARG_AGTYPE_P</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>,
                                         <argument><expr><name>AGTV_VERTEX</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name>agtv_temp</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>agtv_temp</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AGTV_VERTEX</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>agtv_temp</name> <operator>=</operator> <call><name>GET_AGTYPE_VALUE_OBJECT_VALUE</name><argument_list>(<argument><expr><name>agtv_temp</name></expr></argument>, <argument><expr><literal type="string">"id"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <if type="elseif">else if <condition>(<expr><name>agtv_temp</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>agtv_temp</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>AGTV_INTEGER</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"end vertex argument must be a vertex or the integer id"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name><name>vlelctx</name><operator>-&gt;</operator><name>veid</name></name> <operator>=</operator> <name><name>agtv_temp</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>int_value</name></name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><name><name>vlelctx</name><operator>-&gt;</operator><name>is_dirty</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

        <comment type="block">/* we need the SRF context to add in the edges to the stacks */</comment>
        <expr_stmt><expr><name>oldctx</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>funcctx</name><operator>-&gt;</operator><name>multi_call_memory_ctx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* load the initial edges into the dfs stacks */</comment>
        <expr_stmt><expr><call><name>load_initial_dfs_stacks</name><argument_list>(<argument><expr><name>vlelctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* switch back to the original context */</comment>
        <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* return the context */</comment>
        <return>return <expr><name>vlelctx</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* we are not using a cached VLE_local_context, so create a new one */</comment>

    <comment type="block">/*
     * If we are going to cache this context, we need to use TopMemoryContext
     * to save the contents of the context. Otherwise, we just use a regular
     * context for SRFs
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>use_cache</name> <operator>==</operator> <name>true</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>oldctx</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name>oldctx</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>funcctx</name><operator>-&gt;</operator><name>multi_call_memory_ctx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* get the graph name - this is a required argument */</comment>
    <expr_stmt><expr><name>agtv_temp</name> <operator>=</operator> <call><name>get_agtype_value</name><argument_list>(<argument><expr><literal type="string">"age_vle"</literal></expr></argument>, <argument><expr><call><name>AG_GET_ARG_AGTYPE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>,
                                 <argument><expr><name>AGTV_STRING</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>graph_name</name> <operator>=</operator> <call><name>pnstrdup</name><argument_list>(<argument><expr><name><name>agtv_temp</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>val</name></name></expr></argument>,
                          <argument><expr><name><name>agtv_temp</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* get the graph oid */</comment>
    <expr_stmt><expr><name>graph_oid</name> <operator>=</operator> <call><name>get_graph_oid</name><argument_list>(<argument><expr><name>graph_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Create or retrieve the GRAPH global context for this graph. This function
     * will also purge off invalidated contexts.
    */</comment>
    <expr_stmt><expr><name>ggctx</name> <operator>=</operator> <call><name>manage_GRAPH_global_contexts</name><argument_list>(<argument><expr><name>graph_name</name></expr></argument>, <argument><expr><name>graph_oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* allocate and initialize local VLE context */</comment>
    <expr_stmt><expr><name>vlelctx</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>VLE_local_context</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* store the cache usage */</comment>
    <expr_stmt><expr><name><name>vlelctx</name><operator>-&gt;</operator><name>use_cache</name></name> <operator>=</operator> <name>use_cache</name></expr>;</expr_stmt>

    <comment type="block">/* set the VLE grammar node id */</comment>
    <expr_stmt><expr><name><name>vlelctx</name><operator>-&gt;</operator><name>vle_grammar_node_id</name></name> <operator>=</operator> <name>vle_grammar_node_id</name></expr>;</expr_stmt>

    <comment type="block">/* set the graph name and id */</comment>
    <expr_stmt><expr><name><name>vlelctx</name><operator>-&gt;</operator><name>graph_name</name></name> <operator>=</operator> <name>graph_name</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>vlelctx</name><operator>-&gt;</operator><name>graph_oid</name></name> <operator>=</operator> <name>graph_oid</name></expr>;</expr_stmt>

    <comment type="block">/* set the global context referenced by this local VLE context */</comment>
    <expr_stmt><expr><name><name>vlelctx</name><operator>-&gt;</operator><name>ggctx</name></name> <operator>=</operator> <name>ggctx</name></expr>;</expr_stmt>

    <comment type="block">/* initialize the path function */</comment>
    <expr_stmt><expr><name><name>vlelctx</name><operator>-&gt;</operator><name>path_function</name></name> <operator>=</operator> <name>VLE_FUNCTION_PATHS_BETWEEN</name></expr>;</expr_stmt>

    <comment type="block">/* initialize the next vertex, in this case the first */</comment>
    <expr_stmt><expr><name><name>vlelctx</name><operator>-&gt;</operator><name>next_vertex</name></name> <operator>=</operator> <call><name>peek_stack_head</name><argument_list>(<argument><expr><call><name>get_graph_vertices</name><argument_list>(<argument><expr><name>ggctx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* if there isn't one, the graph is empty */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>vlelctx</name><operator>-&gt;</operator><name>next_vertex</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"age_vle: empty graph"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <comment type="block">/*
     * Get the start vertex id - this is an optional parameter and determines
     * which path function is used. If a start vertex isn't provided, we
     * retrieve them incrementally from the vertices list.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>is_agtype_null</name><argument_list>(<argument><expr><call><name>AG_GET_ARG_AGTYPE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* set _TO */</comment>
        <expr_stmt><expr><name><name>vlelctx</name><operator>-&gt;</operator><name>path_function</name></name> <operator>=</operator> <name>VLE_FUNCTION_PATHS_TO</name></expr>;</expr_stmt>

        <comment type="block">/* get the start vertex */</comment>
        <expr_stmt><expr><name><name>vlelctx</name><operator>-&gt;</operator><name>vsid</name></name> <operator>=</operator> <call><name>get_graphid</name><argument_list>(<argument><expr><name><name>vlelctx</name><operator>-&gt;</operator><name>next_vertex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* increment to the next vertex */</comment>
        <expr_stmt><expr><name><name>vlelctx</name><operator>-&gt;</operator><name>next_vertex</name></name> <operator>=</operator> <call><name>next_GraphIdNode</name><argument_list>(<argument><expr><name><name>vlelctx</name><operator>-&gt;</operator><name>next_vertex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name>agtv_temp</name> <operator>=</operator> <call><name>get_agtype_value</name><argument_list>(<argument><expr><literal type="string">"age_vle"</literal></expr></argument>, <argument><expr><call><name>AG_GET_ARG_AGTYPE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>,
                                     <argument><expr><name>AGTV_VERTEX</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>agtv_temp</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>agtv_temp</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AGTV_VERTEX</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>agtv_temp</name> <operator>=</operator> <call><name>GET_AGTYPE_VALUE_OBJECT_VALUE</name><argument_list>(<argument><expr><name>agtv_temp</name></expr></argument>, <argument><expr><literal type="string">"id"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>agtv_temp</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>agtv_temp</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>AGTV_INTEGER</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"start vertex argument must be a vertex or the integer id"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>vlelctx</name><operator>-&gt;</operator><name>vsid</name></name> <operator>=</operator> <name><name>agtv_temp</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>int_value</name></name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/*
     * Get the end vertex id - this is an optional parameter and determines
     * which path function is used.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>is_agtype_null</name><argument_list>(<argument><expr><call><name>AG_GET_ARG_AGTYPE_P</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>vlelctx</name><operator>-&gt;</operator><name>path_function</name></name> <operator>==</operator> <name>VLE_FUNCTION_PATHS_TO</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>vlelctx</name><operator>-&gt;</operator><name>path_function</name></name> <operator>=</operator> <name>VLE_FUNCTION_PATHS_ALL</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><name><name>vlelctx</name><operator>-&gt;</operator><name>path_function</name></name> <operator>=</operator> <name>VLE_FUNCTION_PATHS_FROM</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><name><name>vlelctx</name><operator>-&gt;</operator><name>veid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name>agtv_temp</name> <operator>=</operator> <call><name>get_agtype_value</name><argument_list>(<argument><expr><literal type="string">"age_vle"</literal></expr></argument>, <argument><expr><call><name>AG_GET_ARG_AGTYPE_P</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>,
                                     <argument><expr><name>AGTV_VERTEX</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>agtv_temp</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>agtv_temp</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AGTV_VERTEX</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>agtv_temp</name> <operator>=</operator> <call><name>GET_AGTYPE_VALUE_OBJECT_VALUE</name><argument_list>(<argument><expr><name>agtv_temp</name></expr></argument>, <argument><expr><literal type="string">"id"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>agtv_temp</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>agtv_temp</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>AGTV_INTEGER</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"end vertex argument must be a vertex or the integer id"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>vlelctx</name><operator>-&gt;</operator><name>path_function</name></name> <operator>=</operator> <name>VLE_FUNCTION_PATHS_BETWEEN</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>vlelctx</name><operator>-&gt;</operator><name>veid</name></name> <operator>=</operator> <name><name>agtv_temp</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>int_value</name></name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* get the VLE edge prototype */</comment>
    <expr_stmt><expr><name>agtv_temp</name> <operator>=</operator> <call><name>get_agtype_value</name><argument_list>(<argument><expr><literal type="string">"age_vle"</literal></expr></argument>, <argument><expr><call><name>AG_GET_ARG_AGTYPE_P</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></argument>,
                                 <argument><expr><name>AGTV_EDGE</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* get the edge prototype's property conditions */</comment>
    <expr_stmt><expr><name>agtv_object</name> <operator>=</operator> <call><name>GET_AGTYPE_VALUE_OBJECT_VALUE</name><argument_list>(<argument><expr><name>agtv_temp</name></expr></argument>, <argument><expr><literal type="string">"properties"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* store the properties as an agtype */</comment>
    <expr_stmt><expr><name><name>vlelctx</name><operator>-&gt;</operator><name>edge_property_constraint</name></name> <operator>=</operator> <call><name>agtype_value_to_agtype</name><argument_list>(<argument><expr><name>agtv_object</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* get the edge prototype's label name */</comment>
    <expr_stmt><expr><name>agtv_temp</name> <operator>=</operator> <call><name>GET_AGTYPE_VALUE_OBJECT_VALUE</name><argument_list>(<argument><expr><name>agtv_temp</name></expr></argument>, <argument><expr><literal type="string">"label"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>agtv_temp</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AGTV_STRING</name> <operator>&amp;&amp;</operator>
        <name><name>agtv_temp</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>len</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>vlelctx</name><operator>-&gt;</operator><name>edge_label_name</name></name> <operator>=</operator> <call><name>pnstrdup</name><argument_list>(<argument><expr><name><name>agtv_temp</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>val</name></name></expr></argument>,
                                            <argument><expr><name><name>agtv_temp</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name><name>vlelctx</name><operator>-&gt;</operator><name>edge_label_name</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* get the left range index */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>is_agtype_null</name><argument_list>(<argument><expr><call><name>AG_GET_ARG_AGTYPE_P</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>vlelctx</name><operator>-&gt;</operator><name>lidx</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name>agtv_temp</name> <operator>=</operator> <call><name>get_agtype_value</name><argument_list>(<argument><expr><literal type="string">"age_vle"</literal></expr></argument>, <argument><expr><call><name>AG_GET_ARG_AGTYPE_P</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></argument>,
                                     <argument><expr><name>AGTV_INTEGER</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>vlelctx</name><operator>-&gt;</operator><name>lidx</name></name> <operator>=</operator> <name><name>agtv_temp</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>int_value</name></name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* get the right range index. NULL means infinite */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>is_agtype_null</name><argument_list>(<argument><expr><call><name>AG_GET_ARG_AGTYPE_P</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>vlelctx</name><operator>-&gt;</operator><name>uidx_infinite</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>vlelctx</name><operator>-&gt;</operator><name>uidx</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name>agtv_temp</name> <operator>=</operator> <call><name>get_agtype_value</name><argument_list>(<argument><expr><literal type="string">"age_vle"</literal></expr></argument>, <argument><expr><call><name>AG_GET_ARG_AGTYPE_P</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr></argument>,
                                     <argument><expr><name>AGTV_INTEGER</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>vlelctx</name><operator>-&gt;</operator><name>uidx</name></name> <operator>=</operator> <name><name>agtv_temp</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>int_value</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>vlelctx</name><operator>-&gt;</operator><name>uidx_infinite</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <comment type="block">/* get edge direction */</comment>
    <expr_stmt><expr><name>agtv_temp</name> <operator>=</operator> <call><name>get_agtype_value</name><argument_list>(<argument><expr><literal type="string">"age_vle"</literal></expr></argument>, <argument><expr><call><name>AG_GET_ARG_AGTYPE_P</name><argument_list>(<argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr></argument>,
                                 <argument><expr><name>AGTV_INTEGER</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>vlelctx</name><operator>-&gt;</operator><name>edge_direction</name></name> <operator>=</operator> <name><name>agtv_temp</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>int_value</name></name></expr>;</expr_stmt>

    <comment type="block">/* create the local state hashtable */</comment>
    <expr_stmt><expr><call><name>create_VLE_local_state_hashtable</name><argument_list>(<argument><expr><name>vlelctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* initialize the dfs stacks */</comment>
    <expr_stmt><expr><name><name>vlelctx</name><operator>-&gt;</operator><name>dfs_vertex_stack</name></name> <operator>=</operator> <call><name>new_graphid_stack</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>vlelctx</name><operator>-&gt;</operator><name>dfs_edge_stack</name></name> <operator>=</operator> <call><name>new_graphid_stack</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>vlelctx</name><operator>-&gt;</operator><name>dfs_path_stack</name></name> <operator>=</operator> <call><name>new_graphid_stack</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* load in the starting edge(s) */</comment>
    <expr_stmt><expr><call><name>load_initial_dfs_stacks</name><argument_list>(<argument><expr><name>vlelctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* this is a new one so nothing follows it */</comment>
    <expr_stmt><expr><name><name>vlelctx</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

    <comment type="block">/* mark as dirty */</comment>
    <expr_stmt><expr><name><name>vlelctx</name><operator>-&gt;</operator><name>is_dirty</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

    <comment type="block">/* if this is to be cached, cache it */</comment>
    <if_stmt><if>if <condition>(<expr><name>use_cache</name> <operator>==</operator> <name>true</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>cache_VLE_local_context</name><argument_list>(<argument><expr><name>vlelctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* switch back to the original context */</comment>
    <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* return the new context */</comment>
    <return>return <expr><name>vlelctx</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Helper function to get the specified edge's state. If it does not find it, it
 * creates and initializes it.
 */</comment>
<function><type><specifier>static</specifier> <name>edge_state_entry</name> <modifier>*</modifier></type><name>get_edge_state</name><parameter_list>(<parameter><decl><type><name>VLE_local_context</name> <modifier>*</modifier></type><name>vlelctx</name></decl></parameter>,
                                        <parameter><decl><type><name>graphid</name></type> <name>edge_id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>edge_state_entry</name> <modifier>*</modifier></type><name>ese</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* retrieve the edge_state_entry from the edge state hashtable */</comment>
    <expr_stmt><expr><name>ese</name> <operator>=</operator> <operator>(</operator><name>edge_state_entry</name> <operator>*</operator><operator>)</operator><call><name>hash_search</name><argument_list>(<argument><expr><name><name>vlelctx</name><operator>-&gt;</operator><name>edge_state_hashtable</name></name></expr></argument>,
                                          <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>edge_id</name></expr></argument>, <argument><expr><name>HASH_ENTER</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* if it isn't found, it needs to be created and initialized */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* the edge id is also the hash key for resolving collisions */</comment>
        <expr_stmt><expr><name><name>ese</name><operator>-&gt;</operator><name>edge_id</name></name> <operator>=</operator> <name>edge_id</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>ese</name><operator>-&gt;</operator><name>used_in_path</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>ese</name><operator>-&gt;</operator><name>has_been_matched</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>ese</name><operator>-&gt;</operator><name>matched</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>ese</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Helper function to get the id of the next vertex to move to. This is to
 * simplify finding the next vertex due to the VLE edge's direction.
 */</comment>
<function><type><specifier>static</specifier> <name>graphid</name></type> <name>get_next_vertex</name><parameter_list>(<parameter><decl><type><name>VLE_local_context</name> <modifier>*</modifier></type><name>vlelctx</name></decl></parameter>, <parameter><decl><type><name>edge_entry</name> <modifier>*</modifier></type><name>ee</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>graphid</name></type> <name>terminal_vertex_id</name></decl>;</decl_stmt>

    <comment type="block">/* get the result based on the specified VLE edge direction */</comment>
    <switch>switch <condition>(<expr><name><name>vlelctx</name><operator>-&gt;</operator><name>edge_direction</name></name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>CYPHER_REL_DIR_RIGHT</name></expr>:</case>
            <expr_stmt><expr><name>terminal_vertex_id</name> <operator>=</operator> <call><name>get_edge_entry_end_vertex_id</name><argument_list>(<argument><expr><name>ee</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>CYPHER_REL_DIR_LEFT</name></expr>:</case>
            <expr_stmt><expr><name>terminal_vertex_id</name> <operator>=</operator> <call><name>get_edge_entry_start_vertex_id</name><argument_list>(<argument><expr><name>ee</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>CYPHER_REL_DIR_NONE</name></expr>:</case>
        <block>{<block_content>
            <decl_stmt><decl><type><name>ListGraphId</name> <modifier>*</modifier></type><name>vertex_stack</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>graphid</name></type> <name>parent_vertex_id</name></decl>;</decl_stmt>

            <expr_stmt><expr><name>vertex_stack</name> <operator>=</operator> <name><name>vlelctx</name><operator>-&gt;</operator><name>dfs_vertex_stack</name></name></expr>;</expr_stmt>
            <comment type="block">/*
             * Get the parent vertex of this edge. When we are looking at edges
             * as un-directional, where we go to next depends on where we came
             * from. This is because we can go against an edge.
             */</comment>
            <expr_stmt><expr><name>parent_vertex_id</name> <operator>=</operator> <call><name>PEEK_GRAPHID_STACK</name><argument_list>(<argument><expr><name>vertex_stack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* find the terminal vertex */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>get_edge_entry_start_vertex_id</name><argument_list>(<argument><expr><name>ee</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>parent_vertex_id</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>terminal_vertex_id</name> <operator>=</operator> <call><name>get_edge_entry_end_vertex_id</name><argument_list>(<argument><expr><name>ee</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <if type="elseif">else if <condition>(<expr><call><name>get_edge_entry_end_vertex_id</name><argument_list>(<argument><expr><name>ee</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>parent_vertex_id</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>terminal_vertex_id</name> <operator>=</operator> <call><name>get_edge_entry_start_vertex_id</name><argument_list>(<argument><expr><name>ee</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"get_next_vertex: no parent match"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>

            <break>break;</break>
        </block_content>}</block>

        <default>default:</default>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"get_next_vertex: unknown edge direction"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></switch>

    <return>return <expr><name>terminal_vertex_id</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Helper function to find one path BETWEEN two vertices.
 *
 * Note: On the very first entry into this function, the starting vertex's edges
 * should have already been loaded into the edge stack (this should have been
 * done by the SRF initialization phase).
 *
 * This function will always return on either a valid path found (true) or none
 * found (false). If one is found, the position (vertex &amp; edge) will still be in
 * the stack. Each successive invocation within the SRF will then look for the
 * next available path until there aren't any left.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type> <name>dfs_find_a_path_between</name><parameter_list>(<parameter><decl><type><name>VLE_local_context</name> <modifier>*</modifier></type><name>vlelctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ListGraphId</name> <modifier>*</modifier></type><name>vertex_stack</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListGraphId</name> <modifier>*</modifier></type><name>edge_stack</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListGraphId</name> <modifier>*</modifier></type><name>path_stack</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>graphid</name></type> <name>end_vertex_id</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>vlelctx</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* for ease of reading */</comment>
    <expr_stmt><expr><name>vertex_stack</name> <operator>=</operator> <name><name>vlelctx</name><operator>-&gt;</operator><name>dfs_vertex_stack</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>edge_stack</name> <operator>=</operator> <name><name>vlelctx</name><operator>-&gt;</operator><name>dfs_edge_stack</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>path_stack</name> <operator>=</operator> <name><name>vlelctx</name><operator>-&gt;</operator><name>dfs_path_stack</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>end_vertex_id</name> <operator>=</operator> <name><name>vlelctx</name><operator>-&gt;</operator><name>veid</name></name></expr>;</expr_stmt>

    <comment type="block">/* while we have edges to process */</comment>
    <while>while <condition>(<expr><operator>!</operator><operator>(</operator><call><name>IS_GRAPHID_STACK_EMPTY</name><argument_list>(<argument><expr><name>edge_stack</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>graphid</name></type> <name>edge_id</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>graphid</name></type> <name>next_vertex_id</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>edge_state_entry</name> <modifier>*</modifier></type><name>ese</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>edge_entry</name> <modifier>*</modifier></type><name>ee</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type> <name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

        <comment type="block">/* get an edge, but leave it on the stack for now */</comment>
        <expr_stmt><expr><name>edge_id</name> <operator>=</operator> <call><name>PEEK_GRAPHID_STACK</name><argument_list>(<argument><expr><name>edge_stack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* get the edge's state */</comment>
        <expr_stmt><expr><name>ese</name> <operator>=</operator> <call><name>get_edge_state</name><argument_list>(<argument><expr><name>vlelctx</name></expr></argument>, <argument><expr><name>edge_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/*
         * If the edge is already in use, it means that the edge is in the path.
         * So, we need to see if it is the last path entry (we are backing up -
         * we need to remove the edge from the path stack and reset its state
         * and from the edge stack as we are done with it) or an interior edge
         * in the path (loop - we need to remove the edge from the edge stack
         * and start with the next edge).
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>ese</name><operator>-&gt;</operator><name>used_in_path</name></name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>graphid</name></type> <name>path_edge_id</name></decl>;</decl_stmt>

            <comment type="block">/* get the edge id on the top of the path stack (last edge) */</comment>
            <expr_stmt><expr><name>path_edge_id</name> <operator>=</operator> <call><name>PEEK_GRAPHID_STACK</name><argument_list>(<argument><expr><name>path_stack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/*
             * If the ids are the same, we're backing up. So, remove it from the
             * path stack and reset used_in_path.
             */</comment>
            <if_stmt><if>if <condition>(<expr><name>edge_id</name> <operator>==</operator> <name>path_edge_id</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>pop_graphid_stack</name><argument_list>(<argument><expr><name>path_stack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>ese</name><operator>-&gt;</operator><name>used_in_path</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <comment type="block">/* now remove it from the edge stack */</comment>
            <expr_stmt><expr><call><name>pop_graphid_stack</name><argument_list>(<argument><expr><name>edge_stack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/*
             * Remove its source vertex, if we are looking at edges as
             * un-directional. We only maintain the vertex stack when the
             * edge_direction is CYPHER_REL_DIR_NONE. This is to save space
             * and time.
             */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>vlelctx</name><operator>-&gt;</operator><name>edge_direction</name></name> <operator>==</operator> <name>CYPHER_REL_DIR_NONE</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>pop_graphid_stack</name><argument_list>(<argument><expr><name>vertex_stack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <comment type="block">/* move to the next edge */</comment>
            <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/*
         * Mark it and push it on the path stack. There is no need to push it on
         * the edge stack as it is already there.
         */</comment>
        <expr_stmt><expr><name><name>ese</name><operator>-&gt;</operator><name>used_in_path</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>push_graphid_stack</name><argument_list>(<argument><expr><name>path_stack</name></expr></argument>, <argument><expr><name>edge_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* now get the edge entry so we can get the next vertex to move to */</comment>
        <expr_stmt><expr><name>ee</name> <operator>=</operator> <call><name>get_edge_entry</name><argument_list>(<argument><expr><name><name>vlelctx</name><operator>-&gt;</operator><name>ggctx</name></name></expr></argument>, <argument><expr><name>edge_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>next_vertex_id</name> <operator>=</operator> <call><name>get_next_vertex</name><argument_list>(<argument><expr><name>vlelctx</name></expr></argument>, <argument><expr><name>ee</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Is this the end of a path that meets our requirements? Is its length
         * within the bounds specified?
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>next_vertex_id</name> <operator>==</operator> <name>end_vertex_id</name> <operator>&amp;&amp;</operator>
            <call><name>get_stack_size</name><argument_list>(<argument><expr><name>path_stack</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <name><name>vlelctx</name><operator>-&gt;</operator><name>lidx</name></name> <operator>&amp;&amp;</operator>
            <operator>(</operator><name><name>vlelctx</name><operator>-&gt;</operator><name>uidx_infinite</name></name> <operator>||</operator>
             <call><name>get_stack_size</name><argument_list>(<argument><expr><name>path_stack</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <name><name>vlelctx</name><operator>-&gt;</operator><name>uidx</name></name><operator>)</operator></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* we found one */</comment>
            <expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <comment type="block">/*
         * If we have found the end vertex but, we are not within our upper
         * bounds, we need to back up. We still need to continue traversing
         * the graph if we aren't within our lower bounds, though.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>next_vertex_id</name> <operator>==</operator> <name>end_vertex_id</name> <operator>&amp;&amp;</operator>
            <operator>!</operator><name><name>vlelctx</name><operator>-&gt;</operator><name>uidx_infinite</name></name> <operator>&amp;&amp;</operator>
            <call><name>get_stack_size</name><argument_list>(<argument><expr><name>path_stack</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name><name>vlelctx</name><operator>-&gt;</operator><name>uidx</name></name></expr>)</condition>
        <block>{<block_content>
            <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* add in the edges for the next vertex if we won't exceed the bounds */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>vlelctx</name><operator>-&gt;</operator><name>uidx_infinite</name></name> <operator>||</operator>
            <call><name>get_stack_size</name><argument_list>(<argument><expr><name>path_stack</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name><name>vlelctx</name><operator>-&gt;</operator><name>uidx</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>add_valid_vertex_edges</name><argument_list>(<argument><expr><name>vlelctx</name></expr></argument>, <argument><expr><name>next_vertex_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition>
        <block>{<block_content>
            <return>return <expr><name>true</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></while>

    <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Helper function to find one path FROM a start vertex.
 *
 * Note: On the very first entry into this function, the starting vertex's edges
 * should have already been loaded into the edge stack (this should have been
 * done by the SRF initialization phase).
 *
 * This function will always return on either a valid path found (true) or none
 * found (false). If one is found, the position (vertex &amp; edge) will still be in
 * the stack. Each successive invocation within the SRF will then look for the
 * next available path until there aren't any left.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type> <name>dfs_find_a_path_from</name><parameter_list>(<parameter><decl><type><name>VLE_local_context</name> <modifier>*</modifier></type><name>vlelctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ListGraphId</name> <modifier>*</modifier></type><name>vertex_stack</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListGraphId</name> <modifier>*</modifier></type><name>edge_stack</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListGraphId</name> <modifier>*</modifier></type><name>path_stack</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>vlelctx</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* for ease of reading */</comment>
    <expr_stmt><expr><name>vertex_stack</name> <operator>=</operator> <name><name>vlelctx</name><operator>-&gt;</operator><name>dfs_vertex_stack</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>edge_stack</name> <operator>=</operator> <name><name>vlelctx</name><operator>-&gt;</operator><name>dfs_edge_stack</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>path_stack</name> <operator>=</operator> <name><name>vlelctx</name><operator>-&gt;</operator><name>dfs_path_stack</name></name></expr>;</expr_stmt>

    <comment type="block">/* while we have edges to process */</comment>
    <while>while <condition>(<expr><operator>!</operator><operator>(</operator><call><name>IS_GRAPHID_STACK_EMPTY</name><argument_list>(<argument><expr><name>edge_stack</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>graphid</name></type> <name>edge_id</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>graphid</name></type> <name>next_vertex_id</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>edge_state_entry</name> <modifier>*</modifier></type><name>ese</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>edge_entry</name> <modifier>*</modifier></type><name>ee</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type> <name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

        <comment type="block">/* get an edge, but leave it on the stack for now */</comment>
        <expr_stmt><expr><name>edge_id</name> <operator>=</operator> <call><name>PEEK_GRAPHID_STACK</name><argument_list>(<argument><expr><name>edge_stack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* get the edge's state */</comment>
        <expr_stmt><expr><name>ese</name> <operator>=</operator> <call><name>get_edge_state</name><argument_list>(<argument><expr><name>vlelctx</name></expr></argument>, <argument><expr><name>edge_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/*
         * If the edge is already in use, it means that the edge is in the path.
         * So, we need to see if it is the last path entry (we are backing up -
         * we need to remove the edge from the path stack and reset its state
         * and from the edge stack as we are done with it) or an interior edge
         * in the path (loop - we need to remove the edge from the edge stack
         * and start with the next edge).
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>ese</name><operator>-&gt;</operator><name>used_in_path</name></name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>graphid</name></type> <name>path_edge_id</name></decl>;</decl_stmt>

            <comment type="block">/* get the edge id on the top of the path stack (last edge) */</comment>
            <expr_stmt><expr><name>path_edge_id</name> <operator>=</operator> <call><name>PEEK_GRAPHID_STACK</name><argument_list>(<argument><expr><name>path_stack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/*
             * If the ids are the same, we're backing up. So, remove it from the
             * path stack and reset used_in_path.
             */</comment>
            <if_stmt><if>if <condition>(<expr><name>edge_id</name> <operator>==</operator> <name>path_edge_id</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>pop_graphid_stack</name><argument_list>(<argument><expr><name>path_stack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>ese</name><operator>-&gt;</operator><name>used_in_path</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <comment type="block">/* now remove it from the edge stack */</comment>
            <expr_stmt><expr><call><name>pop_graphid_stack</name><argument_list>(<argument><expr><name>edge_stack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/*
             * Remove its source vertex, if we are looking at edges as
             * un-directional. We only maintain the vertex stack when the
             * edge_direction is CYPHER_REL_DIR_NONE. This is to save space
             * and time.
             */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>vlelctx</name><operator>-&gt;</operator><name>edge_direction</name></name> <operator>==</operator> <name>CYPHER_REL_DIR_NONE</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>pop_graphid_stack</name><argument_list>(<argument><expr><name>vertex_stack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <comment type="block">/* move to the next edge */</comment>
            <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/*
         * Mark it and push it on the path stack. There is no need to push it on
         * the edge stack as it is already there.
         */</comment>
        <expr_stmt><expr><name><name>ese</name><operator>-&gt;</operator><name>used_in_path</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>push_graphid_stack</name><argument_list>(<argument><expr><name>path_stack</name></expr></argument>, <argument><expr><name>edge_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* now get the edge entry so we can get the next vertex to move to */</comment>
        <expr_stmt><expr><name>ee</name> <operator>=</operator> <call><name>get_edge_entry</name><argument_list>(<argument><expr><name><name>vlelctx</name><operator>-&gt;</operator><name>ggctx</name></name></expr></argument>, <argument><expr><name>edge_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>next_vertex_id</name> <operator>=</operator> <call><name>get_next_vertex</name><argument_list>(<argument><expr><name>vlelctx</name></expr></argument>, <argument><expr><name>ee</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Is this a path that meets our requirements? Is its length within the
         * bounds specified?
         */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>get_stack_size</name><argument_list>(<argument><expr><name>path_stack</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <name><name>vlelctx</name><operator>-&gt;</operator><name>lidx</name></name> <operator>&amp;&amp;</operator>
            <operator>(</operator><name><name>vlelctx</name><operator>-&gt;</operator><name>uidx_infinite</name></name> <operator>||</operator>
             <call><name>get_stack_size</name><argument_list>(<argument><expr><name>path_stack</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <name><name>vlelctx</name><operator>-&gt;</operator><name>uidx</name></name><operator>)</operator></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* we found one */</comment>
            <expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* add in the edges for the next vertex if we won't exceed the bounds */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>vlelctx</name><operator>-&gt;</operator><name>uidx_infinite</name></name> <operator>||</operator>
            <call><name>get_stack_size</name><argument_list>(<argument><expr><name>path_stack</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name><name>vlelctx</name><operator>-&gt;</operator><name>uidx</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>add_valid_vertex_edges</name><argument_list>(<argument><expr><name>vlelctx</name></expr></argument>, <argument><expr><name>next_vertex_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition>
        <block>{<block_content>
            <return>return <expr><name>true</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></while>

    <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Helper routine to quickly check if an edge_id is in the path stack. It is
 * only meant as a quick check to avoid doing a much more costly hash search for
 * smaller sized lists. But, it is O(n) so it should only be used for small
 * path_stacks and where appropriate.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type> <name>is_edge_in_path</name><parameter_list>(<parameter><decl><type><name>VLE_local_context</name> <modifier>*</modifier></type><name>vlelctx</name></decl></parameter>, <parameter><decl><type><name>graphid</name></type> <name>edge_id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>GraphIdNode</name> <modifier>*</modifier></type><name>edge</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* start at the top of the stack */</comment>
    <expr_stmt><expr><name>edge</name> <operator>=</operator> <call><name>peek_stack_head</name><argument_list>(<argument><expr><name><name>vlelctx</name><operator>-&gt;</operator><name>dfs_path_stack</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* go through the path stack, return true if we find the edge */</comment>
    <while>while <condition>(<expr><name>edge</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>get_graphid</name><argument_list>(<argument><expr><name>edge</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>edge_id</name></expr>)</condition>
        <block>{<block_content>
            <return>return <expr><name>true</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <comment type="block">/* get the next stack element */</comment>
        <expr_stmt><expr><name>edge</name> <operator>=</operator> <call><name>next_GraphIdNode</name><argument_list>(<argument><expr><name>edge</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>
    <comment type="block">/* we didn't find it if we get here */</comment>
    <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Helper function to add in valid vertex edges as part of the dfs path
 * algorithm. What constitutes a valid edge is the following -
 *
 *     1) Edge matches the correct direction specified.
 *     2) Edge is not currently in the path.
 *     3) Edge matches minimum edge properties specified.
 *
 * Note: The vertex must exist.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>add_valid_vertex_edges</name><parameter_list>(<parameter><decl><type><name>VLE_local_context</name> <modifier>*</modifier></type><name>vlelctx</name></decl></parameter>,
                                   <parameter><decl><type><name>graphid</name></type> <name>vertex_id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ListGraphId</name> <modifier>*</modifier></type><name>vertex_stack</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListGraphId</name> <modifier>*</modifier></type><name>edge_stack</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListGraphId</name> <modifier>*</modifier></type><name>edges</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>vertex_entry</name> <modifier>*</modifier></type><name>ve</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>GraphIdNode</name> <modifier>*</modifier></type><name>edge_in</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>GraphIdNode</name> <modifier>*</modifier></type><name>edge_out</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>GraphIdNode</name> <modifier>*</modifier></type><name>edge_self</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* get the vertex entry */</comment>
    <expr_stmt><expr><name>ve</name> <operator>=</operator> <call><name>get_vertex_entry</name><argument_list>(<argument><expr><name><name>vlelctx</name><operator>-&gt;</operator><name>ggctx</name></name></expr></argument>, <argument><expr><name>vertex_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* there better be a valid vertex */</comment>
    <if_stmt><if>if <condition>(<expr><name>ve</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"add_valid_vertex_edges: no vertex found"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* point to stacks */</comment>
    <expr_stmt><expr><name>vertex_stack</name> <operator>=</operator> <name><name>vlelctx</name><operator>-&gt;</operator><name>dfs_vertex_stack</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>edge_stack</name> <operator>=</operator> <name><name>vlelctx</name><operator>-&gt;</operator><name>dfs_edge_stack</name></name></expr>;</expr_stmt>

    <comment type="block">/* set to the first edge for each edge list for the specified direction */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>vlelctx</name><operator>-&gt;</operator><name>edge_direction</name></name> <operator>==</operator> <name>CYPHER_REL_DIR_RIGHT</name> <operator>||</operator>
        <name><name>vlelctx</name><operator>-&gt;</operator><name>edge_direction</name></name> <operator>==</operator> <name>CYPHER_REL_DIR_NONE</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>edges</name> <operator>=</operator> <call><name>get_vertex_entry_edges_out</name><argument_list>(<argument><expr><name>ve</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>edge_out</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>edges</name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr> ?</condition><then> <expr><call><name>get_list_head</name><argument_list>(<argument><expr><name>edges</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>vlelctx</name><operator>-&gt;</operator><name>edge_direction</name></name> <operator>==</operator> <name>CYPHER_REL_DIR_LEFT</name> <operator>||</operator>
        <name><name>vlelctx</name><operator>-&gt;</operator><name>edge_direction</name></name> <operator>==</operator> <name>CYPHER_REL_DIR_NONE</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>edges</name> <operator>=</operator> <call><name>get_vertex_entry_edges_in</name><argument_list>(<argument><expr><name>ve</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>edge_in</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>edges</name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr> ?</condition><then> <expr><call><name>get_list_head</name><argument_list>(<argument><expr><name>edges</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <comment type="block">/* set to the first selfloop edge */</comment>
    <expr_stmt><expr><name>edges</name> <operator>=</operator> <call><name>get_vertex_entry_edges_self</name><argument_list>(<argument><expr><name>ve</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>edge_self</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>edges</name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr> ?</condition><then> <expr><call><name>get_list_head</name><argument_list>(<argument><expr><name>edges</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr>;</expr_stmt>

    <comment type="block">/* add in valid vertex edges */</comment>
    <while>while <condition>(<expr><name>edge_out</name> <operator>!=</operator> <name>NULL</name> <operator>||</operator> <name>edge_in</name> <operator>!=</operator> <name>NULL</name> <operator>||</operator> <name>edge_self</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>edge_entry</name> <modifier>*</modifier></type><name>ee</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>edge_state_entry</name> <modifier>*</modifier></type><name>ese</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>graphid</name></type> <name>edge_id</name></decl>;</decl_stmt>

        <comment type="block">/* get the edge_id from the next available edge*/</comment>
        <if_stmt><if>if <condition>(<expr><name>edge_out</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>edge_id</name> <operator>=</operator> <call><name>get_graphid</name><argument_list>(<argument><expr><name>edge_out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>edge_in</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>edge_id</name> <operator>=</operator> <call><name>get_graphid</name><argument_list>(<argument><expr><name>edge_in</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><name>edge_id</name> <operator>=</operator> <call><name>get_graphid</name><argument_list>(<argument><expr><name>edge_self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <comment type="block">/*
         * This is a fast existence check, relative to the hash search, for when
         * the path stack is small. If the edge is in the path, we skip it.
         */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>get_stack_size</name><argument_list>(<argument><expr><name><name>vlelctx</name><operator>-&gt;</operator><name>dfs_path_stack</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">10</literal> <operator>&amp;&amp;</operator>
            <call><name>is_edge_in_path</name><argument_list>(<argument><expr><name>vlelctx</name></expr></argument>, <argument><expr><name>edge_id</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* set to the next available edge */</comment>
            <if_stmt><if>if <condition>(<expr><name>edge_out</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>edge_out</name> <operator>=</operator> <call><name>next_GraphIdNode</name><argument_list>(<argument><expr><name>edge_out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <if type="elseif">else if <condition>(<expr><name>edge_in</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>edge_in</name> <operator>=</operator> <call><name>next_GraphIdNode</name><argument_list>(<argument><expr><name>edge_in</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><name>edge_self</name> <operator>=</operator> <call><name>next_GraphIdNode</name><argument_list>(<argument><expr><name>edge_self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
            <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* get the edge entry */</comment>
        <expr_stmt><expr><name>ee</name> <operator>=</operator> <call><name>get_edge_entry</name><argument_list>(<argument><expr><name><name>vlelctx</name><operator>-&gt;</operator><name>ggctx</name></name></expr></argument>, <argument><expr><name>edge_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* it better exist */</comment>
        <if_stmt><if>if <condition>(<expr><name>ee</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"add_valid_vertex_edges: no edge found"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <comment type="block">/* get its state */</comment>
        <expr_stmt><expr><name>ese</name> <operator>=</operator> <call><name>get_edge_state</name><argument_list>(<argument><expr><name>vlelctx</name></expr></argument>, <argument><expr><name>edge_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/*
         * Don't add any edges that we have already seen because they will
         * cause a loop to form.
         */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>ese</name><operator>-&gt;</operator><name>used_in_path</name></name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* validate the edge if it hasn't been already */</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>ese</name><operator>-&gt;</operator><name>has_been_matched</name></name> <operator>&amp;&amp;</operator> <call><name>is_an_edge_match</name><argument_list>(<argument><expr><name>vlelctx</name></expr></argument>, <argument><expr><name>ee</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name><name>ese</name><operator>-&gt;</operator><name>has_been_matched</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>ese</name><operator>-&gt;</operator><name>matched</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            </block_content>}</block></if>
            <if type="elseif">else if <condition>(<expr><operator>!</operator><name><name>ese</name><operator>-&gt;</operator><name>has_been_matched</name></name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name><name>ese</name><operator>-&gt;</operator><name>has_been_matched</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>ese</name><operator>-&gt;</operator><name>matched</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <comment type="block">/* if it is a match, add it */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>ese</name><operator>-&gt;</operator><name>has_been_matched</name></name> <operator>&amp;&amp;</operator> <name><name>ese</name><operator>-&gt;</operator><name>matched</name></name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/*
                 * We need to maintain our source vertex for each edge added
                 * if the edge_direction is CYPHER_REL_DIR_NONE. This is due
                 * to the edges having a fixed direction and the dfs
                 * algorithm working strictly through edges. With an
                 * un-directional VLE edge, you don't know the vertex that
                 * you just came from. So, we need to store it.
                 */</comment>
                 <if_stmt><if>if <condition>(<expr><name><name>vlelctx</name><operator>-&gt;</operator><name>edge_direction</name></name> <operator>==</operator> <name>CYPHER_REL_DIR_NONE</name></expr>)</condition>
                 <block>{<block_content>
                     <expr_stmt><expr><call><name>push_graphid_stack</name><argument_list>(<argument><expr><name>vertex_stack</name></expr></argument>, <argument><expr><call><name>get_vertex_entry_id</name><argument_list>(<argument><expr><name>ve</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                 </block_content>}</block></if></if_stmt>
                 <expr_stmt><expr><call><name>push_graphid_stack</name><argument_list>(<argument><expr><name>edge_stack</name></expr></argument>, <argument><expr><name>edge_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
        <comment type="block">/* get the next working edge */</comment>
        <if_stmt><if>if <condition>(<expr><name>edge_out</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>edge_out</name> <operator>=</operator> <call><name>next_GraphIdNode</name><argument_list>(<argument><expr><name>edge_out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>edge_in</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>edge_in</name> <operator>=</operator> <call><name>next_GraphIdNode</name><argument_list>(<argument><expr><name>edge_in</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><name>edge_self</name> <operator>=</operator> <call><name>next_GraphIdNode</name><argument_list>(<argument><expr><name>edge_self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/*
 * Helper function to create the VLE path container that holds the graphid array
 * containing the found path. The path_size is the total number of vertices and
 * edges in the path.
 */</comment>
<function><type><specifier>static</specifier> <name>VLE_path_container</name> <modifier>*</modifier></type><name>create_VLE_path_container</name><parameter_list>(<parameter><decl><type><name>int64</name></type> <name>path_size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>VLE_path_container</name> <modifier>*</modifier></type><name>vpc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>container_size_bytes</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <comment type="block">/*
     * For the total container size (in graphids int64s) we need to add the
     * following space (in graphids) to hold each of the following fields -
     *
     *     One for the VARHDRSZ which is a int32 and a pad of 32.
     *     One for both the header and graph oid (they are both 32 bits).
     *     One for the size of the graphid_array_size.
     *     One for the container_size_bytes.
     *
     */</comment>
    <expr_stmt><expr><name>container_size_bytes</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>graphid</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>(</operator><name>path_size</name> <operator>+</operator> <literal type="number">4</literal><operator>)</operator></expr>;</expr_stmt>

    <comment type="block">/* allocate the container */</comment>
    <expr_stmt><expr><name>vpc</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>container_size_bytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* initialze the PG headers */</comment>
    <expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><name>vpc</name></expr></argument>, <argument><expr><name>container_size_bytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* initialize the container */</comment>
    <expr_stmt><expr><name><name>vpc</name><operator>-&gt;</operator><name>header</name></name> <operator>=</operator> <name>AGT_FBINARY</name> <operator>|</operator> <name>AGT_FBINARY_TYPE_VLE_PATH</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>vpc</name><operator>-&gt;</operator><name>graphid_array_size</name></name> <operator>=</operator> <name>path_size</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>vpc</name><operator>-&gt;</operator><name>container_size_bytes</name></name> <operator>=</operator> <name>container_size_bytes</name></expr>;</expr_stmt>

    <comment type="block">/* the graphid array is already zeroed out */</comment>
    <comment type="block">/* all of the other fields are set by the caller */</comment>

    <return>return <expr><name>vpc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Helper function to build a VLE_path_container containing the graphid array
 * from the path_stack. The graphid array will be a complete path (vertices and
 * edges interleaved) -
 *
 *     start vertex, first edge,... nth edge, end vertex
 *
 * The VLE_path_container is allocated in such a way as to wrap the array and
 * include the following additional data -
 *
 *     The header is to allow the graphid array to be encoded as an agtype
 *     container of type BINARY. This way the array doesn't need to be
 *     transformed back and forth.
 *
 *     The graph oid to facilitate the retrieval of the correct vertex and edge
 *     entries.
 *
 *     The total number of elements in the array.
 *
 *     The total size of the container for copying.
 *
 * Note: Remember to pfree it when done. Even though it should be destroyed on
 *       exiting the SRF context.
 */</comment>

<function><type><specifier>static</specifier> <name>VLE_path_container</name> <modifier>*</modifier></type><name>build_VLE_path_container</name><parameter_list>(<parameter><decl><type><name>VLE_local_context</name> <modifier>*</modifier></type><name>vlelctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ListGraphId</name> <modifier>*</modifier></type><name>stack</name> <init>= <expr><name><name>vlelctx</name><operator>-&gt;</operator><name>dfs_path_stack</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>VLE_path_container</name> <modifier>*</modifier></type><name>vpc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>graphid</name> <modifier>*</modifier></type><name>graphid_array</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>GraphIdNode</name> <modifier>*</modifier></type><name>edge</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>graphid</name></type> <name>vid</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>index</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>ssize</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>stack</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <return>return <expr><name>NULL</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* allocate the graphid array */</comment>
    <expr_stmt><expr><name>ssize</name> <operator>=</operator> <call><name>get_stack_size</name><argument_list>(<argument><expr><name>stack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Create the container. Note that the path size will always be 2 times the
     * number of edges plus 1 -&gt; (u)-[e]-(v)
     */</comment>
    <expr_stmt><expr><name>vpc</name> <operator>=</operator> <call><name>create_VLE_path_container</name><argument_list>(<argument><expr><operator>(</operator><name>ssize</name> <operator>*</operator> <literal type="number">2</literal><operator>)</operator> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* set the graph_oid */</comment>
    <expr_stmt><expr><name><name>vpc</name><operator>-&gt;</operator><name>graph_oid</name></name> <operator>=</operator> <name><name>vlelctx</name><operator>-&gt;</operator><name>graph_oid</name></name></expr>;</expr_stmt>

    <comment type="block">/* get the graphid_array from the container */</comment>
    <expr_stmt><expr><name>graphid_array</name> <operator>=</operator> <call><name>GET_GRAPHID_ARRAY_FROM_CONTAINER</name><argument_list>(<argument><expr><name>vpc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* get and store the start vertex */</comment>
    <expr_stmt><expr><name>vid</name> <operator>=</operator> <name><name>vlelctx</name><operator>-&gt;</operator><name>vsid</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>graphid_array</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>vid</name></expr>;</expr_stmt>

    <comment type="block">/* get the head of the stack */</comment>
    <expr_stmt><expr><name>edge</name> <operator>=</operator> <call><name>peek_stack_head</name><argument_list>(<argument><expr><name>stack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * We need to fill in the array from the back to the front. This is due
     * to the order of the path stack - last in first out. Remember that the
     * last entry is a vertex.
     */</comment>
    <expr_stmt><expr><name>index</name> <operator>=</operator> <name><name>vpc</name><operator>-&gt;</operator><name>graphid_array_size</name></name> <operator>-</operator> <literal type="number">2</literal></expr>;</expr_stmt>

    <comment type="block">/* copy while we have an edge to copy */</comment>
    <while>while <condition>(<expr><name>edge</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* 0 is the vsid, we should never get here */</comment>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>index</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* store and set to the next edge */</comment>
        <expr_stmt><expr><name><name>graphid_array</name><index>[<expr><name>index</name></expr>]</index></name> <operator>=</operator> <call><name>get_graphid</name><argument_list>(<argument><expr><name>edge</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>edge</name> <operator>=</operator> <call><name>next_GraphIdNode</name><argument_list>(<argument><expr><name>edge</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* we need to skip over the interior vertices */</comment>
        <expr_stmt><expr><name>index</name> <operator>-=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
    </block_content>}</block></while>

    <comment type="block">/* now add in the interior vertices, starting from the first edge */</comment>
    <for>for <control>(<init><expr><name>index</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>index</name> <operator>&lt;</operator> <name><name>vpc</name><operator>-&gt;</operator><name>graphid_array_size</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</condition> <incr><expr><name>index</name> <operator>+=</operator> <literal type="number">2</literal></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>edge_entry</name> <modifier>*</modifier></type><name>ee</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name>ee</name> <operator>=</operator> <call><name>get_edge_entry</name><argument_list>(<argument><expr><name><name>vlelctx</name><operator>-&gt;</operator><name>ggctx</name></name></expr></argument>, <argument><expr><name><name>graphid_array</name><index>[<expr><name>index</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>vid</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>vid</name> <operator>==</operator> <call><name>get_edge_entry_start_vertex_id</name><argument_list>(<argument><expr><name>ee</name></expr></argument>)</argument_list></call><operator>)</operator></expr> ?</condition><then>
                   <expr><call><name>get_edge_entry_end_vertex_id</name><argument_list>(<argument><expr><name>ee</name></expr></argument>)</argument_list></call></expr> </then><else>:
                   <expr><call><name>get_edge_entry_start_vertex_id</name><argument_list>(<argument><expr><name>ee</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>graphid_array</name><index>[<expr><name>index</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>vid</name></expr>;</expr_stmt>
    </block_content>}</block></for>

    <comment type="block">/* return the container */</comment>
    <return>return <expr><name>vpc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* helper function to build a VPC for just the start vertex */</comment>
<function><type><specifier>static</specifier> <name>VLE_path_container</name> <modifier>*</modifier></type><name>build_VLE_zero_container</name><parameter_list>(<parameter><decl><type><name>VLE_local_context</name> <modifier>*</modifier></type><name>vlelctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ListGraphId</name> <modifier>*</modifier></type><name>stack</name> <init>= <expr><name><name>vlelctx</name><operator>-&gt;</operator><name>dfs_path_stack</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>VLE_path_container</name> <modifier>*</modifier></type><name>vpc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>graphid</name> <modifier>*</modifier></type><name>graphid_array</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>graphid</name></type> <name>vid</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <comment type="block">/* we should have an empty stack */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>get_stack_size</name><argument_list>(<argument><expr><name>stack</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Create the container. Note that the path size will always be 1 as this is
     * just the starting vertex.
     */</comment>
    <expr_stmt><expr><name>vpc</name> <operator>=</operator> <call><name>create_VLE_path_container</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* set the graph_oid */</comment>
    <expr_stmt><expr><name><name>vpc</name><operator>-&gt;</operator><name>graph_oid</name></name> <operator>=</operator> <name><name>vlelctx</name><operator>-&gt;</operator><name>graph_oid</name></name></expr>;</expr_stmt>

    <comment type="block">/* get the graphid_array from the container */</comment>
    <expr_stmt><expr><name>graphid_array</name> <operator>=</operator> <call><name>GET_GRAPHID_ARRAY_FROM_CONTAINER</name><argument_list>(<argument><expr><name>vpc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* get and store the start vertex */</comment>
    <expr_stmt><expr><name>vid</name> <operator>=</operator> <name><name>vlelctx</name><operator>-&gt;</operator><name>vsid</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>graphid_array</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>vid</name></expr>;</expr_stmt>

    <return>return <expr><name>vpc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Helper function to build an AGTV_ARRAY of edges from an array of graphids.
 *
 * Note: You should free the array when done. Although, it should be freed
 *       when the context is destroyed from the return of the SRF call.
 */</comment>
<function><type><specifier>static</specifier> <name>agtype_value</name> <modifier>*</modifier></type><name>build_edge_list</name><parameter_list>(<parameter><decl><type><name>VLE_path_container</name> <modifier>*</modifier></type><name>vpc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>GRAPH_global_context</name> <modifier>*</modifier></type><name>ggctx</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_in_state</name></type> <name>edges_result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type> <name>graph_oid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>graphid</name> <modifier>*</modifier></type><name>graphid_array</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int64</name></type> <name>graphid_array_size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>index</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <comment type="block">/* get the graph_oid */</comment>
    <expr_stmt><expr><name>graph_oid</name> <operator>=</operator> <name><name>vpc</name><operator>-&gt;</operator><name>graph_oid</name></name></expr>;</expr_stmt>

    <comment type="block">/* get the GRAPH global context for this graph */</comment>
    <expr_stmt><expr><name>ggctx</name> <operator>=</operator> <call><name>find_GRAPH_global_context</name><argument_list>(<argument><expr><name>graph_oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* verify we got a global context */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ggctx</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* get the graphid_array and size */</comment>
    <expr_stmt><expr><name>graphid_array</name> <operator>=</operator> <call><name>GET_GRAPHID_ARRAY_FROM_CONTAINER</name><argument_list>(<argument><expr><name>vpc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>graphid_array_size</name> <operator>=</operator> <name><name>vpc</name><operator>-&gt;</operator><name>graphid_array_size</name></name></expr>;</expr_stmt>

    <comment type="block">/* initialize our agtype array */</comment>
    <expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>edges_result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>agtype_in_state</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>edges_result</name><operator>.</operator><name>res</name></name> <operator>=</operator> <call><name>push_agtype_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>edges_result</name><operator>.</operator><name>parse_state</name></name></expr></argument>,
                                         <argument><expr><name>WAGT_BEGIN_ARRAY</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>index</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>index</name> <operator>&lt;</operator> <name>graphid_array_size</name> <operator>-</operator> <literal type="number">1</literal></expr>;</condition> <incr><expr><name>index</name> <operator>+=</operator> <literal type="number">2</literal></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>label_name</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>edge_entry</name> <modifier>*</modifier></type><name>ee</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>agtv_edge</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

        <comment type="block">/* get the edge entry from the hashtable */</comment>
        <expr_stmt><expr><name>ee</name> <operator>=</operator> <call><name>get_edge_entry</name><argument_list>(<argument><expr><name>ggctx</name></expr></argument>, <argument><expr><name><name>graphid_array</name><index>[<expr><name>index</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* get the label name from the oid */</comment>
        <expr_stmt><expr><name>label_name</name> <operator>=</operator> <call><name>get_rel_name</name><argument_list>(<argument><expr><call><name>get_edge_entry_label_table_oid</name><argument_list>(<argument><expr><name>ee</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* reconstruct the edge */</comment>
        <expr_stmt><expr><name>agtv_edge</name> <operator>=</operator> <call><name>agtype_value_build_edge</name><argument_list>(<argument><expr><call><name>get_edge_entry_id</name><argument_list>(<argument><expr><name>ee</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>label_name</name></expr></argument>,
                                            <argument><expr><call><name>get_edge_entry_end_vertex_id</name><argument_list>(<argument><expr><name>ee</name></expr></argument>)</argument_list></call></expr></argument>,
                                            <argument><expr><call><name>get_edge_entry_start_vertex_id</name><argument_list>(<argument><expr><name>ee</name></expr></argument>)</argument_list></call></expr></argument>,
                                            <argument><expr><call><name>get_edge_entry_properties</name><argument_list>(<argument><expr><name>ee</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* push the edge*/</comment>
        <expr_stmt><expr><name><name>edges_result</name><operator>.</operator><name>res</name></name> <operator>=</operator> <call><name>push_agtype_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>edges_result</name><operator>.</operator><name>parse_state</name></name></expr></argument>,
                                             <argument><expr><name>WAGT_ELEM</name></expr></argument>, <argument><expr><name>agtv_edge</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <comment type="block">/* close our agtype array */</comment>
    <expr_stmt><expr><name><name>edges_result</name><operator>.</operator><name>res</name></name> <operator>=</operator> <call><name>push_agtype_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>edges_result</name><operator>.</operator><name>parse_state</name></name></expr></argument>,
                                         <argument><expr><name>WAGT_END_ARRAY</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* make it an array */</comment>
    <expr_stmt><expr><name><name>edges_result</name><operator>.</operator><name>res</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>AGTV_ARRAY</name></expr>;</expr_stmt>

    <comment type="block">/* return it */</comment>
    <return>return <expr><name><name>edges_result</name><operator>.</operator><name>res</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Helper function to build an array of type AGTV_PATH from an array of
 * graphids.
 *
 * Note: You should free the array when done. Although, it should be freed
 *       when the context is destroyed from the return of the SRF call.
 */</comment>
<function><type><specifier>static</specifier> <name>agtype_value</name> <modifier>*</modifier></type><name>build_path</name><parameter_list>(<parameter><decl><type><name>VLE_path_container</name> <modifier>*</modifier></type><name>vpc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>GRAPH_global_context</name> <modifier>*</modifier></type><name>ggctx</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_in_state</name></type> <name>path_result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type> <name>graph_oid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>graphid</name> <modifier>*</modifier></type><name>graphid_array</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int64</name></type> <name>graphid_array_size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>index</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <comment type="block">/* get the graph_oid */</comment>
    <expr_stmt><expr><name>graph_oid</name> <operator>=</operator> <name><name>vpc</name><operator>-&gt;</operator><name>graph_oid</name></name></expr>;</expr_stmt>

    <comment type="block">/* get the GRAPH global context for this graph */</comment>
    <expr_stmt><expr><name>ggctx</name> <operator>=</operator> <call><name>find_GRAPH_global_context</name><argument_list>(<argument><expr><name>graph_oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* verify we got a global context */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ggctx</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* get the graphid_array and size */</comment>
    <expr_stmt><expr><name>graphid_array</name> <operator>=</operator> <call><name>GET_GRAPHID_ARRAY_FROM_CONTAINER</name><argument_list>(<argument><expr><name>vpc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>graphid_array_size</name> <operator>=</operator> <name><name>vpc</name><operator>-&gt;</operator><name>graphid_array_size</name></name></expr>;</expr_stmt>

    <comment type="block">/* initialize our agtype array */</comment>
    <expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>path_result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>agtype_in_state</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>path_result</name><operator>.</operator><name>res</name></name> <operator>=</operator> <call><name>push_agtype_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>path_result</name><operator>.</operator><name>parse_state</name></name></expr></argument>,
                                        <argument><expr><name>WAGT_BEGIN_ARRAY</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>index</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>index</name> <operator>&lt;</operator> <name>graphid_array_size</name></expr>;</condition> <incr><expr><name>index</name> <operator>+=</operator> <literal type="number">2</literal></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>label_name</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>vertex_entry</name> <modifier>*</modifier></type><name>ve</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>edge_entry</name> <modifier>*</modifier></type><name>ee</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>agtv_vertex</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>agtv_edge</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

        <comment type="block">/* get the vertex entry from the hashtable */</comment>
        <expr_stmt><expr><name>ve</name> <operator>=</operator> <call><name>get_vertex_entry</name><argument_list>(<argument><expr><name>ggctx</name></expr></argument>, <argument><expr><name><name>graphid_array</name><index>[<expr><name>index</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* get the label name from the oid */</comment>
        <expr_stmt><expr><name>label_name</name> <operator>=</operator> <call><name>get_rel_name</name><argument_list>(<argument><expr><call><name>get_vertex_entry_label_table_oid</name><argument_list>(<argument><expr><name>ve</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* reconstruct the vertex */</comment>
        <expr_stmt><expr><name>agtv_vertex</name> <operator>=</operator> <call><name>agtype_value_build_vertex</name><argument_list>(<argument><expr><call><name>get_vertex_entry_id</name><argument_list>(<argument><expr><name>ve</name></expr></argument>)</argument_list></call></expr></argument>,
                                                <argument><expr><name>label_name</name></expr></argument>,
                                                <argument><expr><call><name>get_vertex_entry_properties</name><argument_list>(<argument><expr><name>ve</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* push the vertex */</comment>
        <expr_stmt><expr><name><name>path_result</name><operator>.</operator><name>res</name></name> <operator>=</operator> <call><name>push_agtype_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>path_result</name><operator>.</operator><name>parse_state</name></name></expr></argument>, <argument><expr><name>WAGT_ELEM</name></expr></argument>,
                                            <argument><expr><name>agtv_vertex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Remember that we have more vertices than edges. So, we need to check
         * if the above vertex was the last vertex in the path.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>index</name> <operator>+</operator> <literal type="number">1</literal> <operator>&gt;=</operator> <name>graphid_array_size</name></expr>)</condition>
        <block>{<block_content>
            <break>break;</break>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* get the edge entry from the hashtable */</comment>
        <expr_stmt><expr><name>ee</name> <operator>=</operator> <call><name>get_edge_entry</name><argument_list>(<argument><expr><name>ggctx</name></expr></argument>, <argument><expr><name><name>graphid_array</name><index>[<expr><name>index</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* get the label name from the oid */</comment>
        <expr_stmt><expr><name>label_name</name> <operator>=</operator> <call><name>get_rel_name</name><argument_list>(<argument><expr><call><name>get_edge_entry_label_table_oid</name><argument_list>(<argument><expr><name>ee</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* reconstruct the edge */</comment>
        <expr_stmt><expr><name>agtv_edge</name> <operator>=</operator> <call><name>agtype_value_build_edge</name><argument_list>(<argument><expr><call><name>get_edge_entry_id</name><argument_list>(<argument><expr><name>ee</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>label_name</name></expr></argument>,
                                            <argument><expr><call><name>get_edge_entry_end_vertex_id</name><argument_list>(<argument><expr><name>ee</name></expr></argument>)</argument_list></call></expr></argument>,
                                            <argument><expr><call><name>get_edge_entry_start_vertex_id</name><argument_list>(<argument><expr><name>ee</name></expr></argument>)</argument_list></call></expr></argument>,
                                            <argument><expr><call><name>get_edge_entry_properties</name><argument_list>(<argument><expr><name>ee</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* push the edge*/</comment>
        <expr_stmt><expr><name><name>path_result</name><operator>.</operator><name>res</name></name> <operator>=</operator> <call><name>push_agtype_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>path_result</name><operator>.</operator><name>parse_state</name></name></expr></argument>, <argument><expr><name>WAGT_ELEM</name></expr></argument>,
                                            <argument><expr><name>agtv_edge</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <comment type="block">/* close our agtype array */</comment>
    <expr_stmt><expr><name><name>path_result</name><operator>.</operator><name>res</name></name> <operator>=</operator> <call><name>push_agtype_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>path_result</name><operator>.</operator><name>parse_state</name></name></expr></argument>,
                                        <argument><expr><name>WAGT_END_ARRAY</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* make it a path */</comment>
    <expr_stmt><expr><name><name>path_result</name><operator>.</operator><name>res</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>AGTV_PATH</name></expr>;</expr_stmt>

    <comment type="block">/* return the path */</comment>
    <return>return <expr><name><name>path_result</name><operator>.</operator><name>res</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * All front facing PG and exposed functions below
 */</comment>

<comment type="block">/*
 * PG VLE function that takes the following input and returns a row called edges
 * of type agtype BINARY VLE_path_container (this is an internal structure for
 * returning a graphid array of the path. You need to use internal routines to
 * properly use this data) -
 *
 *     0 - agtype REQUIRED (graph name as string)
 *                 Note: This is automatically added by transform_FuncCall.
 *
 *     1 - agtype OPTIONAL (start vertex as a vertex or the integer id)
 *                 Note: Leaving this NULL switches the path algorithm from
 *                       VLE_FUNCTION_PATHS_BETWEEN to VLE_FUNCTION_PATHS_TO
 *     2 - agtype OPTIONAL (end vertex as a vertex or the integer id)
 *                 Note: Leaving this NULL switches the path algorithm from
 *                       VLE_FUNCTION_PATHS_BETWEEN to VLE_FUNCTION_PATHS_FROM
 *                       or - if the starting vertex is NULL - from
 *                       VLE_FUNCTION_PATHS_TO to VLE_FUNCTION_PATHS_ALL
 *     3 - agtype REQUIRED (edge prototype to match as an edge)
 *                 Note: Only the label and properties are used. The
 *                       rest is ignored.
 *     4 - agtype OPTIONAL lidx (lower range index)
 *                 Note: 0 itself is currently not supported but here it is
 *                       equivalent to 1.
 *                       A NULL is appropriate here for a 0 lower bound.
 *     5 - agtype OPTIONAL uidx (upper range index)
 *                 Note: A NULL is appropriate here for an infinite upper bound.
 *     6 - agtype REQUIRED edge direction (enum) as an integer. REQUIRED
 *
 * This is a set returning function. This means that the first call sets
 * up the initial structures and then outputs the first row. After that each
 * subsequent call generates one row of output data. PG will continue to call
 * the function until the function tells PG that it doesn't have any more rows
 * to output. At that point, the function needs to clean up all of its data
 * structures that are not meant to last between SRFs.
 */</comment>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>age_vle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><name>Datum</name></type> <name>age_vle</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>FuncCallContext</name> <modifier>*</modifier></type><name>funcctx</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>VLE_local_context</name> <modifier>*</modifier></type><name>vlelctx</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>found_a_path</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>done</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>is_zero_bound</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldctx</name></decl>;</decl_stmt>

    <comment type="block">/* Initialization for the first call to the SRF */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>SRF_IS_FIRSTCALL</name><argument_list>()</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* all of these arguments need to be non NULL */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>||</operator> <comment type="block">/* graph name */</comment>
            <call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call> <operator>||</operator> <comment type="block">/* edge prototype */</comment>
            <call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>)</condition>   <comment type="block">/* direction */</comment>
        <block>{<block_content>
             <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"age_vle: invalid NULL argument passed"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* create a function context for cross-call persistence */</comment>
        <expr_stmt><expr><name>funcctx</name> <operator>=</operator> <call><name>SRF_FIRSTCALL_INIT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* build the local vle context */</comment>
        <expr_stmt><expr><name>vlelctx</name> <operator>=</operator> <call><name>build_local_vle_context</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>funcctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Point the function call context's user pointer to the local VLE
         * context just created
         */</comment>
        <expr_stmt><expr><name><name>funcctx</name><operator>-&gt;</operator><name>user_fctx</name></name> <operator>=</operator> <name>vlelctx</name></expr>;</expr_stmt>

        <comment type="block">/* if we are starting from zero [*0..x] flag it */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>vlelctx</name><operator>-&gt;</operator><name>lidx</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>is_zero_bound</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>done</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* stuff done on every call of the function */</comment>
    <expr_stmt><expr><name>funcctx</name> <operator>=</operator> <call><name>SRF_PERCALL_SETUP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* restore our VLE local context */</comment>
    <expr_stmt><expr><name>vlelctx</name> <operator>=</operator> <operator>(</operator><name>VLE_local_context</name> <operator>*</operator><operator>)</operator><name><name>funcctx</name><operator>-&gt;</operator><name>user_fctx</name></name></expr>;</expr_stmt>

    <comment type="block">/*
     * All work done in dfs_find_a_path needs to be done in a context that
     * survives multiple SRF calls. So switch to the appropriate context.
     */</comment>
    <expr_stmt><expr><name>oldctx</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>funcctx</name><operator>-&gt;</operator><name>multi_call_memory_ctx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <while>while <condition>(<expr><name>done</name> <operator>==</operator> <name>false</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* find one path based on specific input */</comment>
        <switch>switch <condition>(<expr><name><name>vlelctx</name><operator>-&gt;</operator><name>path_function</name></name></expr>)</condition>
        <block>{<block_content>
            <case>case <expr><name>VLE_FUNCTION_PATHS_TO</name></expr>:</case>
            <case>case <expr><name>VLE_FUNCTION_PATHS_BETWEEN</name></expr>:</case>
                <expr_stmt><expr><name>found_a_path</name> <operator>=</operator> <call><name>dfs_find_a_path_between</name><argument_list>(<argument><expr><name>vlelctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>

            <case>case <expr><name>VLE_FUNCTION_PATHS_ALL</name></expr>:</case>
            <case>case <expr><name>VLE_FUNCTION_PATHS_FROM</name></expr>:</case>
                <expr_stmt><expr><name>found_a_path</name> <operator>=</operator> <call><name>dfs_find_a_path_from</name><argument_list>(<argument><expr><name>vlelctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>

            <default>default:</default>
                <expr_stmt><expr><name>found_a_path</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                <break>break;</break>
        </block_content>}</block></switch>

        <comment type="block">/* if we found a path, or are done, flag it so we can output the data */</comment>
        <if_stmt><if>if <condition>(<expr><name>found_a_path</name> <operator>==</operator> <name>true</name> <operator>||</operator>
            <operator>(</operator><name>found_a_path</name> <operator>==</operator> <name>false</name> <operator>&amp;&amp;</operator> <name><name>vlelctx</name><operator>-&gt;</operator><name>next_vertex</name></name> <operator>==</operator> <name>NULL</name><operator>)</operator> <operator>||</operator>
            <operator>(</operator><name>found_a_path</name> <operator>==</operator> <name>false</name> <operator>&amp;&amp;</operator>
             <operator>(</operator><name><name>vlelctx</name><operator>-&gt;</operator><name>path_function</name></name> <operator>==</operator> <name>VLE_FUNCTION_PATHS_BETWEEN</name> <operator>||</operator>
              <name><name>vlelctx</name><operator>-&gt;</operator><name>path_function</name></name> <operator>==</operator> <name>VLE_FUNCTION_PATHS_FROM</name><operator>)</operator><operator>)</operator></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>done</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <comment type="block">/* if we need to fetch a new vertex and rerun the find */</comment>
        <if type="elseif">else if <condition>(<expr><operator>(</operator><name><name>vlelctx</name><operator>-&gt;</operator><name>path_function</name></name> <operator>==</operator> <name>VLE_FUNCTION_PATHS_ALL</name><operator>)</operator> <operator>||</operator>
                 <operator>(</operator><name><name>vlelctx</name><operator>-&gt;</operator><name>path_function</name></name> <operator>==</operator> <name>VLE_FUNCTION_PATHS_TO</name><operator>)</operator></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* get the next start vertex id */</comment>
            <expr_stmt><expr><name><name>vlelctx</name><operator>-&gt;</operator><name>vsid</name></name> <operator>=</operator> <call><name>get_graphid</name><argument_list>(<argument><expr><name><name>vlelctx</name><operator>-&gt;</operator><name>next_vertex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* increment to the next vertex */</comment>
            <expr_stmt><expr><name><name>vlelctx</name><operator>-&gt;</operator><name>next_vertex</name></name> <operator>=</operator> <call><name>next_GraphIdNode</name><argument_list>(<argument><expr><name><name>vlelctx</name><operator>-&gt;</operator><name>next_vertex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* load in the starting edge(s) */</comment>
            <expr_stmt><expr><call><name>load_initial_dfs_stacks</name><argument_list>(<argument><expr><name>vlelctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* if we are starting from zero [*0..x] flag it */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>vlelctx</name><operator>-&gt;</operator><name>lidx</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>is_zero_bound</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>done</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            </block_content>}</block></if>
            <comment type="block">/* otherwise we need to loop back around */</comment>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><name>done</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if>
        <comment type="block">/* we shouldn't get here */</comment>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"age_vle() invalid path function"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></while>

    <comment type="block">/* switch back to a more volatile context */</comment>
    <expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * If we find a path, we need to convert the path_stack into a list that
     * the outside world can use.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>found_a_path</name> <operator>||</operator> <name>is_zero_bound</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>VLE_path_container</name> <modifier>*</modifier></type><name>vpc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

        <comment type="block">/* if this isn't the zero boundary case generate a normal vpc */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_zero_bound</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* the path_stack should have something in it if we have a path */</comment>
            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>vlelctx</name><operator>-&gt;</operator><name>dfs_path_stack</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/*
             * Build the graphid array into a VLE_path_container from the
             * path_stack. This will also correct for the path_stack being last
             * in, first out.
             */</comment>
            <expr_stmt><expr><name>vpc</name> <operator>=</operator> <call><name>build_VLE_path_container</name><argument_list>(<argument><expr><name>vlelctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <comment type="block">/* otherwise, this is the zero boundary case [*0..x] */</comment>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><name>vpc</name> <operator>=</operator> <call><name>build_VLE_zero_container</name><argument_list>(<argument><expr><name>vlelctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <comment type="block">/* return the result and signal that the function is not yet done */</comment>
        <expr_stmt><expr><call><name>SRF_RETURN_NEXT</name><argument_list>(<argument><expr><name>funcctx</name></expr></argument>, <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>vpc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <comment type="block">/* otherwise, we are done and we need to cleanup and signal done */</comment>
    <else>else
    <block>{<block_content>
        <comment type="block">/* mark local context as clean */</comment>
        <expr_stmt><expr><name><name>vlelctx</name><operator>-&gt;</operator><name>is_dirty</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

        <comment type="block">/* free the local context, if we aren't caching it */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>vlelctx</name><operator>-&gt;</operator><name>use_cache</name></name> <operator>==</operator> <name>false</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>free_VLE_local_context</name><argument_list>(<argument><expr><name>vlelctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* signal that we are done */</comment>
        <expr_stmt><expr><call><name>SRF_RETURN_DONE</name><argument_list>(<argument><expr><name>funcctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Exposed helper function to make an agtype AGTV_PATH from a
 * VLE_path_container.
 */</comment>
<function><type><name>agtype</name> <modifier>*</modifier></type><name>agt_materialize_vle_path</name><parameter_list>(<parameter><decl><type><name>agtype</name> <modifier>*</modifier></type><name>agt_arg_vpc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/* convert the agtype_value to agtype and return it */</comment>
    <return>return <expr><call><name>agtype_value_to_agtype</name><argument_list>(<argument><expr><call><name>agtv_materialize_vle_path</name><argument_list>(<argument><expr><name>agt_arg_vpc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Exposed helper function to make an agtype_value AGTV_PATH from a
 * VLE_path_container.
 */</comment>
<function><type><name>agtype_value</name> <modifier>*</modifier></type><name>agtv_materialize_vle_path</name><parameter_list>(<parameter><decl><type><name>agtype</name> <modifier>*</modifier></type><name>agt_arg_vpc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>VLE_path_container</name> <modifier>*</modifier></type><name>vpc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>agtv_path</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* the passed argument should not be NULL */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>agt_arg_vpc</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * The path must be a binary container and the type of the object in the
     * container must be an AGT_FBINARY_TYPE_VLE_PATH.
     */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>AGT_ROOT_IS_BINARY</name><argument_list>(<argument><expr><name>agt_arg_vpc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>AGT_ROOT_BINARY_FLAGS</name><argument_list>(<argument><expr><name>agt_arg_vpc</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>AGT_FBINARY_TYPE_VLE_PATH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* get the container */</comment>
    <expr_stmt><expr><name>vpc</name> <operator>=</operator> <operator>(</operator><name>VLE_path_container</name> <operator>*</operator><operator>)</operator><name>agt_arg_vpc</name></expr>;</expr_stmt>

    <comment type="block">/* it should not be null */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>vpc</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* build the AGTV_PATH from the VLE_path_container */</comment>
    <expr_stmt><expr><name>agtv_path</name> <operator>=</operator> <call><name>build_path</name><argument_list>(<argument><expr><name>vpc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>agtv_path</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* PG function to match 2 VLE edges */</comment>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>age_match_two_vle_edges</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><name>Datum</name></type> <name>age_match_two_vle_edges</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>agtype</name> <modifier>*</modifier></type><name>agt_arg_vpc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>VLE_path_container</name> <modifier>*</modifier></type><name>left_path</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>right_path</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>graphid</name> <modifier>*</modifier></type><name>left_array</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>right_array</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>left_array_size</name></decl>;</decl_stmt>

    <comment type="block">/* get the VLE_path_container argument */</comment>
    <expr_stmt><expr><name>agt_arg_vpc</name> <operator>=</operator> <call><name>AG_GET_ARG_AGTYPE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AGT_ROOT_IS_BINARY</name><argument_list>(<argument><expr><name>agt_arg_vpc</name></expr></argument>)</argument_list></call> <operator>||</operator>
        <call><name>AGT_ROOT_BINARY_FLAGS</name><argument_list>(<argument><expr><name>agt_arg_vpc</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>AGT_FBINARY_TYPE_VLE_PATH</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
            <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"argument 1 of age_match_two_vle_edges must be a VLE_Path_Container"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* cast argument as a VLE_Path_Container and extract graphid array */</comment>
    <expr_stmt><expr><name>left_path</name> <operator>=</operator> <operator>(</operator><name>VLE_path_container</name> <operator>*</operator><operator>)</operator><name>agt_arg_vpc</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>left_array_size</name> <operator>=</operator> <name><name>left_path</name><operator>-&gt;</operator><name>graphid_array_size</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>left_array</name> <operator>=</operator> <call><name>GET_GRAPHID_ARRAY_FROM_CONTAINER</name><argument_list>(<argument><expr><name>left_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>agt_arg_vpc</name> <operator>=</operator> <call><name>AG_GET_ARG_AGTYPE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AGT_ROOT_IS_BINARY</name><argument_list>(<argument><expr><name>agt_arg_vpc</name></expr></argument>)</argument_list></call> <operator>||</operator>
        <call><name>AGT_ROOT_BINARY_FLAGS</name><argument_list>(<argument><expr><name>agt_arg_vpc</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>AGT_FBINARY_TYPE_VLE_PATH</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
            <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"argument 2 of age_match_two_vle_edges must be a VLE_Path_Container"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* cast argument as a VLE_Path_Container and extract graphid array */</comment>
    <expr_stmt><expr><name>right_path</name> <operator>=</operator> <operator>(</operator><name>VLE_path_container</name> <operator>*</operator><operator>)</operator><name>agt_arg_vpc</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>right_array</name> <operator>=</operator> <call><name>GET_GRAPHID_ARRAY_FROM_CONTAINER</name><argument_list>(<argument><expr><name>right_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>left_array</name><index>[<expr><name>left_array_size</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <name><name>right_array</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * This function is used when we need to know if the passed in id is at the end
 * of a path. The first arg is the path the second is the vertex id to check and
 * the last is a boolean that syas whether to check the start or the end of the
 * vle path.
 */</comment>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>age_match_vle_edge_to_id_qual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><name>Datum</name></type> <name>age_match_vle_edge_to_id_qual</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>nargs</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name> <modifier>*</modifier></type><name>args</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name> <modifier>*</modifier></type><name>nulls</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name> <modifier>*</modifier></type><name>types</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype</name> <modifier>*</modifier></type><name>agt_arg_vpc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype</name> <modifier>*</modifier></type><name>edge_id</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype</name> <modifier>*</modifier></type><name>pos_agt</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>id</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>position</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>VLE_path_container</name> <modifier>*</modifier></type><name>vle_path</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>graphid</name> <modifier>*</modifier></type><name>array</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>vle_is_on_left</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>graphid</name></type> <name>gid</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <comment type="block">/* extract argument values */</comment>
    <expr_stmt><expr><name>nargs</name> <operator>=</operator> <call><name>extract_variadic_args</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>args</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>types</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>nargs</name> <operator>!=</operator> <literal type="number">3</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                        <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"age_match_vle_edge_to_id_qual() invalid number of arguments"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* the arguments cannot be NULL */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>nulls</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>||</operator> <name><name>nulls</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>||</operator> <name><name>nulls</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"age_match_vle_edge_to_id_qual() arguments must be non NULL"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* get the VLE_path_container argument */</comment>
    <expr_stmt><expr><name>agt_arg_vpc</name> <operator>=</operator> <call><name>DATUM_GET_AGTYPE_P</name><argument_list>(<argument><expr><name><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AGT_ROOT_IS_BINARY</name><argument_list>(<argument><expr><name>agt_arg_vpc</name></expr></argument>)</argument_list></call> <operator>||</operator>
        <call><name>AGT_ROOT_BINARY_FLAGS</name><argument_list>(<argument><expr><name>agt_arg_vpc</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>AGT_FBINARY_TYPE_VLE_PATH</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
            <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"argument 1 of age_match_vle_edge_to_edge_qual must be a VLE_Path_Container"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* cast argument as a VLE_Path_Container and extract graphid array */</comment>
    <expr_stmt><expr><name>vle_path</name> <operator>=</operator> <operator>(</operator><name>VLE_path_container</name> <operator>*</operator><operator>)</operator><name>agt_arg_vpc</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>array</name> <operator>=</operator> <call><name>GET_GRAPHID_ARRAY_FROM_CONTAINER</name><argument_list>(<argument><expr><name>vle_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>types</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name>AGTYPEOID</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Get the edge id we are checking the end of the list too */</comment>
        <expr_stmt><expr><name>edge_id</name> <operator>=</operator> <call><name>AG_GET_ARG_AGTYPE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AGT_ROOT_IS_SCALAR</name><argument_list>(<argument><expr><name>edge_id</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"argument 2 of age_match_vle_edge_to_edge_qual must be an integer"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>id</name> <operator>=</operator> <call><name>get_ith_agtype_value_from_container</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>edge_id</name><operator>-&gt;</operator><name>root</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>id</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>AGTV_INTEGER</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"argument 2 of age_match_vle_edge_to_edge_qual must be an integer"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>gid</name> <operator>=</operator> <name><name>id</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>int_value</name></name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name><name>types</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name>GRAPHIDOID</name></expr>)</condition>
    <block>{<block_content>

        <expr_stmt><expr><name>gid</name> <operator>=</operator> <call><name>DATUM_GET_GRAPHID</name><argument_list>(<argument><expr><name><name>args</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"match_vle_terminal_edge() arguement 1 must be an agtype integer or a graphid"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><name>pos_agt</name> <operator>=</operator> <call><name>AG_GET_ARG_AGTYPE_P</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AGT_ROOT_IS_SCALAR</name><argument_list>(<argument><expr><name>pos_agt</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"argument 3 of age_match_vle_edge_to_edge_qual must be an integer"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>position</name> <operator>=</operator> <call><name>get_ith_agtype_value_from_container</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pos_agt</name><operator>-&gt;</operator><name>root</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>position</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>AGTV_BOOL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"argument 3 of age_match_vle_edge_to_edge_qual must be an integer"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>vle_is_on_left</name> <operator>=</operator> <name><name>position</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>boolean</name></name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>vle_is_on_left</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>array_size</name> <init>= <expr><name><name>vle_path</name><operator>-&gt;</operator><name>graphid_array_size</name></name></expr></init></decl>;</decl_stmt>

        <comment type="block">/*
         * Path is like ...[vle_edge]-()-[regular_edge]... Get the graphid of
         * the vertex at the endof the path and check that it matches the id
         * that was passed in the second arg. The transform logic is responsible
         * for making that the start or end id, depending on its direction.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>gid</name> <operator>!=</operator> <name><name>array</name><index>[<expr><name>array_size</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/*
         * Path is like ...[edge]-()-[vle_edge]... Get the vertex at the start
         * of the vle edge and check against id.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>gid</name> <operator>!=</operator> <name><name>array</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Exposed helper function to make an agtype_value AGTV_ARRAY of edges from a
 * VLE_path_container.
 */</comment>
<function><type><name>agtype_value</name> <modifier>*</modifier></type><name>agtv_materialize_vle_edges</name><parameter_list>(<parameter><decl><type><name>agtype</name> <modifier>*</modifier></type><name>agt_arg_vpc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>VLE_path_container</name> <modifier>*</modifier></type><name>vpc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>agtv_array</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* the passed argument should not be NULL */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>agt_arg_vpc</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * The path must be a binary container and the type of the object in the
     * container must be an AGT_FBINARY_TYPE_VLE_PATH.
     */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>AGT_ROOT_IS_BINARY</name><argument_list>(<argument><expr><name>agt_arg_vpc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>AGT_ROOT_BINARY_FLAGS</name><argument_list>(<argument><expr><name>agt_arg_vpc</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>AGT_FBINARY_TYPE_VLE_PATH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* get the container */</comment>
    <expr_stmt><expr><name>vpc</name> <operator>=</operator> <operator>(</operator><name>VLE_path_container</name> <operator>*</operator><operator>)</operator><name>agt_arg_vpc</name></expr>;</expr_stmt>

    <comment type="block">/* it should not be null */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>vpc</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* build the AGTV_ARRAY of edges from the VLE_path_container */</comment>
    <expr_stmt><expr><name>agtv_array</name> <operator>=</operator> <call><name>build_edge_list</name><argument_list>(<argument><expr><name>vpc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* convert the agtype_value to agtype and return it */</comment>
    <return>return <expr><name>agtv_array</name></expr>;</return>

</block_content>}</block></function>

<comment type="block">/* PG wrapper function for agtv_materialize_vle_edges */</comment>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>age_materialize_vle_edges</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><name>Datum</name></type> <name>age_materialize_vle_edges</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>agtype</name> <modifier>*</modifier></type><name>agt_arg_vpc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>agtv_array</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* if we have a NULL VLE_path_container, return NULL */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* get the VLE_path_container argument */</comment>
    <expr_stmt><expr><name>agt_arg_vpc</name> <operator>=</operator> <call><name>AG_GET_ARG_AGTYPE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* if NULL, return NULL */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>is_agtype_null</name><argument_list>(<argument><expr><name>agt_arg_vpc</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>agtv_array</name> <operator>=</operator> <call><name>agtv_materialize_vle_edges</name><argument_list>(<argument><expr><name>agt_arg_vpc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><call><name>agtype_value_to_agtype</name><argument_list>(<argument><expr><name>agtv_array</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* PG wrapper function for age_materialize_vle_path */</comment>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>age_materialize_vle_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><name>Datum</name></type> <name>age_materialize_vle_path</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>agtype</name> <modifier>*</modifier></type><name>agt_arg_vpc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* if we have a NULL VLE_path_container, return NULL */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* get the VLE_path_container argument */</comment>
    <expr_stmt><expr><name>agt_arg_vpc</name> <operator>=</operator> <call><name>AG_GET_ARG_AGTYPE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* if NULL, return NULL */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>is_agtype_null</name><argument_list>(<argument><expr><name>agt_arg_vpc</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><call><name>agt_materialize_vle_path</name><argument_list>(<argument><expr><name>agt_arg_vpc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * PG function to take a VLE_path_container and return whether the supplied end
 * vertex (target/veid) matches against the last edge in the VLE path. The VLE
 * path is encoded in a BINARY container.
 */</comment>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>age_match_vle_terminal_edge</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><name>Datum</name></type> <name>age_match_vle_terminal_edge</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>nargs</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name> <modifier>*</modifier></type><name>args</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name> <modifier>*</modifier></type><name>nulls</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name> <modifier>*</modifier></type><name>types</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>VLE_path_container</name> <modifier>*</modifier></type><name>vpc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype</name> <modifier>*</modifier></type><name>agt_arg_vsid</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype</name> <modifier>*</modifier></type><name>agt_arg_veid</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype</name> <modifier>*</modifier></type><name>agt_arg_path</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>agtv_temp</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>graphid</name></type> <name>vsid</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>graphid</name></type> <name>veid</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>graphid</name> <modifier>*</modifier></type><name>gida</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>gidasize</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <comment type="block">/* extract argument values */</comment>
    <expr_stmt><expr><name>nargs</name> <operator>=</operator> <call><name>extract_variadic_args</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>args</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>types</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>nargs</name> <operator>!=</operator> <literal type="number">3</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                        <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"age_match_terminal_edge() invalid number of arguments"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* the arguments cannot be NULL */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>nulls</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>||</operator> <name><name>nulls</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>||</operator> <name><name>nulls</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"match_vle_terminal_edge() arguments cannot be NULL"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* get the vpc */</comment>
    <expr_stmt><expr><name>agt_arg_path</name> <operator>=</operator> <call><name>DATUM_GET_AGTYPE_P</name><argument_list>(<argument><expr><name><name>args</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* it cannot be NULL */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>is_agtype_null</name><argument_list>(<argument><expr><name>agt_arg_path</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"match_vle_terminal_edge() argument 3 cannot be NULL"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * The vpc (path) must be a binary container and the type of the object in
     * the container must be an AGT_FBINARY_TYPE_VLE_PATH.
     */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>AGT_ROOT_IS_BINARY</name><argument_list>(<argument><expr><name>agt_arg_path</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>AGT_ROOT_BINARY_FLAGS</name><argument_list>(<argument><expr><name>agt_arg_path</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>AGT_FBINARY_TYPE_VLE_PATH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* get the container */</comment>
    <expr_stmt><expr><name>vpc</name> <operator>=</operator> <operator>(</operator><name>VLE_path_container</name> <operator>*</operator><operator>)</operator><name>agt_arg_path</name></expr>;</expr_stmt>

    <comment type="block">/* get the graphid array from the container */</comment>
    <expr_stmt><expr><name>gida</name> <operator>=</operator> <call><name>GET_GRAPHID_ARRAY_FROM_CONTAINER</name><argument_list>(<argument><expr><name>vpc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* get the gida array size */</comment>
    <expr_stmt><expr><name>gidasize</name> <operator>=</operator> <name><name>vpc</name><operator>-&gt;</operator><name>graphid_array_size</name></name></expr>;</expr_stmt>

    <comment type="block">/* verify the minimum size is 3 or 1 */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>gidasize</name> <operator>&gt;=</operator> <literal type="number">3</literal> <operator>||</operator> <name>gidasize</name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* get the vsid */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>types</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>AGTYPEOID</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>agt_arg_vsid</name> <operator>=</operator> <call><name>DATUM_GET_AGTYPE_P</name><argument_list>(<argument><expr><name><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_agtype_null</name><argument_list>(<argument><expr><name>agt_arg_vsid</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>

            <expr_stmt><expr><name>agtv_temp</name> <operator>=</operator>
               <call><name>get_ith_agtype_value_from_container</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>agt_arg_vsid</name><operator>-&gt;</operator><name>root</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>agtv_temp</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AGTV_INTEGER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>vsid</name> <operator>=</operator> <name><name>agtv_temp</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>int_value</name></name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"match_vle_terminal_edge() argument 1 must be non NULL"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name><name>types</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>GRAPHIDOID</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>vsid</name> <operator>=</operator> <call><name>DATUM_GET_GRAPHID</name><argument_list>(<argument><expr><name><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"match_vle_terminal_edge() arguement 1 must be an agtype integer or a graphid"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* get the veid */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>types</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name>AGTYPEOID</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>agt_arg_veid</name> <operator>=</operator> <call><name>DATUM_GET_AGTYPE_P</name><argument_list>(<argument><expr><name><name>args</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_agtype_null</name><argument_list>(<argument><expr><name>agt_arg_veid</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>agtv_temp</name> <operator>=</operator> <call><name>get_ith_agtype_value_from_container</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>agt_arg_veid</name><operator>-&gt;</operator><name>root</name></name></expr></argument>,
                                                            <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>agtv_temp</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AGTV_INTEGER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>veid</name> <operator>=</operator> <name><name>agtv_temp</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>int_value</name></name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"match_vle_terminal_edge() argument 2 must be non NULL"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name><name>types</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name>GRAPHIDOID</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>veid</name> <operator>=</operator> <call><name>DATUM_GET_GRAPHID</name><argument_list>(<argument><expr><name><name>args</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"match_vle_terminal_edge() arguement 2 must be an agtype integer or a graphid"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* compare the path beginning or end points */</comment>
    <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name><name>gida</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>vsid</name> <operator>&amp;&amp;</operator> <name>veid</name> <operator>==</operator> <name><name>gida</name><index>[<expr><name>gidasize</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* PG helper function to build an agtype (Datum) edge for matching */</comment>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>age_build_vle_match_edge</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><name>Datum</name></type> <name>age_build_vle_match_edge</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>agtype_in_state</name></type> <name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_value</name></type> <name>agtv_zero</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_value</name></type> <name>agtv_nstr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>agtv_temp</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* create an agtype_value integer 0 */</comment>
    <expr_stmt><expr><name><name>agtv_zero</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>AGTV_INTEGER</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>agtv_zero</name><operator>.</operator><name>val</name><operator>.</operator><name>int_value</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <comment type="block">/* create an agtype_value null string */</comment>
    <expr_stmt><expr><name><name>agtv_nstr</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>AGTV_STRING</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>agtv_nstr</name><operator>.</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>len</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>agtv_nstr</name><operator>.</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>val</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

    <comment type="block">/* zero the state */</comment>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>agtype_in_state</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* start the object */</comment>
    <expr_stmt><expr><name><name>result</name><operator>.</operator><name>res</name></name> <operator>=</operator> <call><name>push_agtype_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>result</name><operator>.</operator><name>parse_state</name></name></expr></argument>, <argument><expr><name>WAGT_BEGIN_OBJECT</name></expr></argument>,
                                   <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* create dummy graph id */</comment>
    <expr_stmt><expr><name><name>result</name><operator>.</operator><name>res</name></name> <operator>=</operator> <call><name>push_agtype_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>result</name><operator>.</operator><name>parse_state</name></name></expr></argument>, <argument><expr><name>WAGT_KEY</name></expr></argument>,
                                   <argument><expr><call><name>string_to_agtype_value</name><argument_list>(<argument><expr><literal type="string">"id"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><operator>.</operator><name>res</name></name> <operator>=</operator> <call><name>push_agtype_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>result</name><operator>.</operator><name>parse_state</name></name></expr></argument>, <argument><expr><name>WAGT_VALUE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>agtv_zero</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* process the label */</comment>
    <expr_stmt><expr><name><name>result</name><operator>.</operator><name>res</name></name> <operator>=</operator> <call><name>push_agtype_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>result</name><operator>.</operator><name>parse_state</name></name></expr></argument>, <argument><expr><name>WAGT_KEY</name></expr></argument>,
                                   <argument><expr><call><name>string_to_agtype_value</name><argument_list>(<argument><expr><literal type="string">"label"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>agtv_temp</name> <operator>=</operator> <call><name>get_agtype_value</name><argument_list>(<argument><expr><literal type="string">"build_vle_match_edge"</literal></expr></argument>,
                                     <argument><expr><call><name>AG_GET_ARG_AGTYPE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>AGTV_STRING</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>result</name><operator>.</operator><name>res</name></name> <operator>=</operator> <call><name>push_agtype_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>result</name><operator>.</operator><name>parse_state</name></name></expr></argument>, <argument><expr><name>WAGT_VALUE</name></expr></argument>,
                                       <argument><expr><name>agtv_temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name><name>result</name><operator>.</operator><name>res</name></name> <operator>=</operator> <call><name>push_agtype_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>result</name><operator>.</operator><name>parse_state</name></name></expr></argument>, <argument><expr><name>WAGT_VALUE</name></expr></argument>,
                                       <argument><expr><operator>&amp;</operator><name>agtv_nstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <comment type="block">/* create dummy end_id */</comment>
    <expr_stmt><expr><name><name>result</name><operator>.</operator><name>res</name></name> <operator>=</operator> <call><name>push_agtype_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>result</name><operator>.</operator><name>parse_state</name></name></expr></argument>, <argument><expr><name>WAGT_KEY</name></expr></argument>,
                                   <argument><expr><call><name>string_to_agtype_value</name><argument_list>(<argument><expr><literal type="string">"end_id"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><operator>.</operator><name>res</name></name> <operator>=</operator> <call><name>push_agtype_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>result</name><operator>.</operator><name>parse_state</name></name></expr></argument>, <argument><expr><name>WAGT_VALUE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>agtv_zero</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* create dummy start_id */</comment>
    <expr_stmt><expr><name><name>result</name><operator>.</operator><name>res</name></name> <operator>=</operator> <call><name>push_agtype_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>result</name><operator>.</operator><name>parse_state</name></name></expr></argument>, <argument><expr><name>WAGT_KEY</name></expr></argument>,
                                   <argument><expr><call><name>string_to_agtype_value</name><argument_list>(<argument><expr><literal type="string">"start_id"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><operator>.</operator><name>res</name></name> <operator>=</operator> <call><name>push_agtype_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>result</name><operator>.</operator><name>parse_state</name></name></expr></argument>, <argument><expr><name>WAGT_VALUE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>agtv_zero</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* process the properties */</comment>
    <expr_stmt><expr><name><name>result</name><operator>.</operator><name>res</name></name> <operator>=</operator> <call><name>push_agtype_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>result</name><operator>.</operator><name>parse_state</name></name></expr></argument>, <argument><expr><name>WAGT_KEY</name></expr></argument>,
                                   <argument><expr><call><name>string_to_agtype_value</name><argument_list>(<argument><expr><literal type="string">"properties"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>agtype</name> <modifier>*</modifier></type><name>properties</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name>properties</name> <operator>=</operator> <call><name>AG_GET_ARG_AGTYPE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AGT_ROOT_IS_OBJECT</name><argument_list>(<argument><expr><name>properties</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"build_vle_match_edge(): properties argument must be an object"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>add_agtype</name><argument_list>(<argument><expr><operator>(</operator><name>Datum</name><operator>)</operator><name>properties</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>result</name></expr></argument>, <argument><expr><name>AGTYPEOID</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name><name>result</name><operator>.</operator><name>res</name></name> <operator>=</operator> <call><name>push_agtype_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>result</name><operator>.</operator><name>parse_state</name></name></expr></argument>, <argument><expr><name>WAGT_BEGIN_OBJECT</name></expr></argument>,
                                       <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>result</name><operator>.</operator><name>res</name></name> <operator>=</operator> <call><name>push_agtype_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>result</name><operator>.</operator><name>parse_state</name></name></expr></argument>, <argument><expr><name>WAGT_END_OBJECT</name></expr></argument>,
                                       <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><name><name>result</name><operator>.</operator><name>res</name></name> <operator>=</operator> <call><name>push_agtype_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>result</name><operator>.</operator><name>parse_state</name></name></expr></argument>, <argument><expr><name>WAGT_END_OBJECT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>result</name><operator>.</operator><name>res</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>AGTV_EDGE</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><call><name>agtype_value_to_agtype</name><argument_list>(<argument><expr><name><name>result</name><operator>.</operator><name>res</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * This function checks the edges in a MATCH clause to see if they are unique or
 * not. Filters out all the paths where the edge uniques rules are not met.
 * Arguements can be a combination of agtype ints and VLE_path_containers.
 */</comment>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>_ag_enforce_edge_uniqueness</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function><type><name>Datum</name></type> <name>_ag_enforce_edge_uniqueness</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>exists_hash</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HASHCTL</name></type> <name>exists_ctl</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name> <modifier>*</modifier></type><name>args</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name> <modifier>*</modifier></type><name>nulls</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name> <modifier>*</modifier></type><name>types</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nargs</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <comment type="block">/* extract our arguments */</comment>
    <expr_stmt><expr><name>nargs</name> <operator>=</operator> <call><name>extract_variadic_args</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>args</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>types</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* verify the arguments */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nargs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>nulls</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
        <block>{<block_content>
             <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                     <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                      <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"_ag_enforce_edge_uniqueness argument %d must not be NULL"</literal></expr></argument>,
                             <argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>types</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name>AGTYPEOID</name> <operator>&amp;&amp;</operator>
            <name><name>types</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name>INT8OID</name> <operator>&amp;&amp;</operator>
            <name><name>types</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name>GRAPHIDOID</name></expr>)</condition>
        <block>{<block_content>
             <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                     <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                      <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"_ag_enforce_edge_uniqueness argument %d must be AGTYPE, INT8, or GRAPHIDOID"</literal></expr></argument>,
                             <argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/* configure the hash table */</comment>
    <expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>exists_ctl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>exists_ctl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>exists_ctl</name><operator>.</operator><name>keysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int64</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>exists_ctl</name><operator>.</operator><name>entrysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int64</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>exists_ctl</name><operator>.</operator><name>hash</name></name> <operator>=</operator> <name>tag_hash</name></expr>;</expr_stmt>

    <comment type="block">/* create exists_hash table */</comment>
    <expr_stmt><expr><name>exists_hash</name> <operator>=</operator> <call><name>hash_create</name><argument_list>(<argument><expr><name>EXISTS_HTAB_NAME</name></expr></argument>, <argument><expr><name>EXISTS_HTAB_NAME_INITIAL_SIZE</name></expr></argument>,
                              <argument><expr><operator>&amp;</operator><name>exists_ctl</name></expr></argument>, <argument><expr><name>HASH_ELEM</name> <operator>|</operator> <name>HASH_FUNCTION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* insert arguments into hash table */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nargs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <comment type="block">/* if it is an INT8OID or a GRAPHIDOID */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>types</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>INT8OID</name> <operator>||</operator> <name><name>types</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>GRAPHIDOID</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>graphid</name></type> <name>edge_id</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>bool</name></type> <name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int64</name> <modifier>*</modifier></type><name>value</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><name>edge_id</name> <operator>=</operator> <call><name>DatumGetInt64</name><argument_list>(<argument><expr><name><name>args</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* insert the edge_id */</comment>
            <expr_stmt><expr><name>value</name> <operator>=</operator> <operator>(</operator><name>int64</name> <operator>*</operator><operator>)</operator><call><name>hash_search</name><argument_list>(<argument><expr><name>exists_hash</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>edge_id</name></expr></argument>,
                                         <argument><expr><name>HASH_ENTER</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* if we found it, we're done, we have a duplicate */</comment>
            <if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>hash_destroy</name><argument_list>(<argument><expr><name>exists_hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <comment type="block">/* otherwise, add it to the returned bucket */</comment>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><operator>*</operator><name>value</name> <operator>=</operator> <name>edge_id</name></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>

            <continue>continue;</continue>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name><name>types</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>AGTYPEOID</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* get the argument */</comment>
            <decl_stmt><decl><type><name>agtype</name> <modifier>*</modifier></type><name>agt_i</name> <init>= <expr><call><name>DATUM_GET_AGTYPE_P</name><argument_list>(<argument><expr><name><name>args</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <comment type="block">/* if the argument is an AGTYPE VLE_path_container */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>AGT_ROOT_IS_BINARY</name><argument_list>(<argument><expr><name>agt_i</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
                <call><name>AGT_ROOT_BINARY_FLAGS</name><argument_list>(<argument><expr><name>agt_i</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>AGT_FBINARY_TYPE_VLE_PATH</name></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>VLE_path_container</name> <modifier>*</modifier></type><name>vpc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>graphid</name> <modifier>*</modifier></type><name>graphid_array</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int64</name></type> <name>graphid_array_size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int64</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

                <comment type="block">/* cast to VLE_path_container */</comment>
                <expr_stmt><expr><name>vpc</name> <operator>=</operator> <operator>(</operator><name>VLE_path_container</name> <operator>*</operator><operator>)</operator><name>agt_i</name></expr>;</expr_stmt>

                <comment type="block">/* get the graphid array */</comment>
                <expr_stmt><expr><name>graphid_array</name> <operator>=</operator> <call><name>GET_GRAPHID_ARRAY_FROM_CONTAINER</name><argument_list>(<argument><expr><name>vpc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/* get the graphid array size */</comment>
                <expr_stmt><expr><name>graphid_array_size</name> <operator>=</operator> <name><name>vpc</name><operator>-&gt;</operator><name>graphid_array_size</name></name></expr>;</expr_stmt>

                <comment type="block">/* insert all the edges in the vpc, into the hash table */</comment>
                <for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>graphid_array_size</name> <operator>-</operator> <literal type="number">1</literal></expr>;</condition> <incr><expr><name>j</name><operator>+=</operator><literal type="number">2</literal></expr></incr>)</control>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>int64</name> <modifier>*</modifier></type><name>value</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>bool</name></type> <name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>graphid</name></type> <name>edge_id</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

                    <comment type="block">/* get the edge id */</comment>
                    <expr_stmt><expr><name>edge_id</name> <operator>=</operator> <name><name>graphid_array</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>

                    <comment type="block">/* insert the edge id */</comment>
                    <expr_stmt><expr><name>value</name> <operator>=</operator> <operator>(</operator><name>int64</name> <operator>*</operator><operator>)</operator><call><name>hash_search</name><argument_list>(<argument><expr><name>exists_hash</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>edge_id</name></expr></argument>,
                                                 <argument><expr><name>HASH_ENTER</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <comment type="block">/* if we found it, we're done, we have a duplicate */</comment>
                    <if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>hash_destroy</name><argument_list>(<argument><expr><name>exists_hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if>
                    <comment type="block">/* otherwise, add it to the returned bucket */</comment>
                    <else>else
                    <block>{<block_content>
                        <expr_stmt><expr><operator>*</operator><name>value</name> <operator>=</operator> <name>edge_id</name></expr>;</expr_stmt>
                    </block_content>}</block></else></if_stmt>
                </block_content>}</block></for>
            </block_content>}</block></if>
            <comment type="block">/* if it is a regular AGTYPE scalar */</comment>
            <if type="elseif">else if <condition>(<expr><call><name>AGT_ROOT_IS_SCALAR</name><argument_list>(<argument><expr><name>agt_i</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>agtv_id</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int64</name> <modifier>*</modifier></type><name>value</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>bool</name></type> <name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>graphid</name></type> <name>edge_id</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

                <expr_stmt><expr><name>agtv_id</name> <operator>=</operator> <call><name>get_ith_agtype_value_from_container</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>agt_i</name><operator>-&gt;</operator><name>root</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <if_stmt><if>if <condition>(<expr><name><name>agtv_id</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>AGTV_INTEGER</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"_ag_enforce_edge_uniqueness parameter %d must resolve to an agtype integer"</literal></expr></argument>,
                                    <argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>

                <expr_stmt><expr><name>edge_id</name> <operator>=</operator> <name><name>agtv_id</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>int_value</name></name></expr>;</expr_stmt>

                <comment type="block">/* insert the edge_id */</comment>
                <expr_stmt><expr><name>value</name> <operator>=</operator> <operator>(</operator><name>int64</name> <operator>*</operator><operator>)</operator><call><name>hash_search</name><argument_list>(<argument><expr><name>exists_hash</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>edge_id</name></expr></argument>,
                                             <argument><expr><name>HASH_ENTER</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/* if we found it, we're done, we have a duplicate */</comment>
                <if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>hash_destroy</name><argument_list>(<argument><expr><name>exists_hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if>
                <comment type="block">/* otherwise, add it to the returned bucket */</comment>
                <else>else
                <block>{<block_content>
                    <expr_stmt><expr><operator>*</operator><name>value</name> <operator>=</operator> <name>edge_id</name></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"_ag_enforce_edge_uniqueness invalid parameter type %d"</literal></expr></argument>,
                                <argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if>
        <comment type="block">/* it is neither a VLE_path_container, AGTYPE, INT8, or a GRAPHIDOID */</comment>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"_ag_enforce_edge_uniqueness invalid parameter type %d"</literal></expr></argument>,
                            <argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/* if all entries were successfully inserted, we have no duplicates */</comment>
    <expr_stmt><expr><call><name>hash_destroy</name><argument_list>(<argument><expr><name>exists_hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
