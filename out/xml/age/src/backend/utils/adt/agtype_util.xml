<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/builded_projects/age/src/backend/utils/adt/agtype_util.c"><comment type="block">/*
 * For PostgreSQL Database Management System:
 * (formerly known as Postgres, then as Postgres95)
 *
 * Portions Copyright (c) 1996-2010, The PostgreSQL Global Development Group
 *
 * Portions Copyright (c) 1994, The Regents of the University of California
 *
 * Permission to use, copy, modify, and distribute this software and its documentation for any purpose,
 * without fee, and without a written agreement is hereby granted, provided that the above copyright notice
 * and this paragraph and the following two paragraphs appear in all copies.
 *
 * IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR DIRECT,
 * INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS,
 * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF THE UNIVERSITY
 * OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
 * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 *
 * THE SOFTWARE PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND THE UNIVERSITY OF CALIFORNIA
 * HAS NO OBLIGATIONS TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
 */</comment>

<comment type="block">/*
 * converting between agtype and agtype_values, and iterating.
 *
 * Portions Copyright (c) 2014-2018, PostgreSQL Global Development Group
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;math.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/hash.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_collation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/varlena.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/agtype.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/agtype_ext.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/graphid.h"</cpp:file></cpp:include>

<comment type="block">/*
 * Maximum number of elements in an array (or key/value pairs in an object).
 * This is limited by two things: the size of the agtentry array must fit
 * in MaxAllocSize, and the number of elements (or pairs) must fit in the bits
 * reserved for that in the agtype_container.header field.
 *
 * (The total size of an array's or object's elements is also limited by
 * AGTENTRY_OFFLENMASK, but we're not concerned about that here.)
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AGTYPE_MAX_ELEMS</name></cpp:macro> <cpp:value>(Min(MaxAllocSize / sizeof(agtype_value), AGT_CMASK))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AGTYPE_MAX_PAIRS</name></cpp:macro> <cpp:value>(Min(MaxAllocSize / sizeof(agtype_pair), AGT_CMASK))</cpp:value></cpp:define>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>fill_agtype_value</name><parameter_list>(<parameter><decl><type><name>agtype_container</name> <modifier>*</modifier></type><name>container</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>index</name></decl></parameter>,
                              <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>base_addr</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>offset</name></decl></parameter>,
                              <parameter><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>result</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>equals_agtype_scalar_value</name><parameter_list>(<parameter><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>agtype</name> <modifier>*</modifier></type><name>convert_to_agtype</name><parameter_list>(<parameter><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>val</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>convert_agtype_value</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><name>agtentry</name> <modifier>*</modifier></type><name>header</name></decl></parameter>,
                                 <parameter><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>val</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>level</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>convert_agtype_array</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><name>agtentry</name> <modifier>*</modifier></type><name>pheader</name></decl></parameter>,
                                 <parameter><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>val</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>level</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>convert_agtype_object</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><name>agtentry</name> <modifier>*</modifier></type><name>pheader</name></decl></parameter>,
                                  <parameter><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>val</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>level</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>convert_agtype_scalar</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><name>agtentry</name> <modifier>*</modifier></type><name>entry</name></decl></parameter>,
                                  <parameter><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>scalar_val</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>append_to_buffer</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>copy_to_buffer</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>offset</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>data</name></decl></parameter>,
                           <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>agtype_iterator</name> <modifier>*</modifier></type><name>iterator_from_container</name><parameter_list>(<parameter><decl><type><name>agtype_container</name> <modifier>*</modifier></type><name>container</name></decl></parameter>,
                                                <parameter><decl><type><name>agtype_iterator</name> <modifier>*</modifier></type><name>parent</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>agtype_iterator</name> <modifier>*</modifier></type><name>free_and_get_parent</name><parameter_list>(<parameter><decl><type><name>agtype_iterator</name> <modifier>*</modifier></type><name>it</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>agtype_parse_state</name> <modifier>*</modifier></type><name>push_state</name><parameter_list>(<parameter><decl><type><name>agtype_parse_state</name> <modifier>*</modifier><modifier>*</modifier></type><name>pstate</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>append_key</name><parameter_list>(<parameter><decl><type><name>agtype_parse_state</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>string</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>append_value</name><parameter_list>(<parameter><decl><type><name>agtype_parse_state</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>scalar_val</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>append_element</name><parameter_list>(<parameter><decl><type><name>agtype_parse_state</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>,
                           <parameter><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>scalar_val</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>length_compare_agtype_string_value</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>length_compare_agtype_pair</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>,
                                      <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>binequal</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>agtype_value</name> <modifier>*</modifier></type><name>push_agtype_value_scalar</name><parameter_list>(<parameter><decl><type><name>agtype_parse_state</name> <modifier>*</modifier><modifier>*</modifier></type><name>pstate</name></decl></parameter>,
                                              <parameter><decl><type><name>agtype_iterator_token</name></type> <name>seq</name></decl></parameter>,
                                              <parameter><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>scalar_val</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>compare_two_floats_orderability</name><parameter_list>(<parameter><decl><type><name>float8</name></type> <name>lhs</name></decl></parameter>, <parameter><decl><type><name>float8</name></type> <name>rhs</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>get_type_sort_priority</name><parameter_list>(<parameter><decl><type><name><name>enum</name> <name>agtype_value_type</name></name></type> <name>type</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * Turn an in-memory agtype_value into an agtype for on-disk storage.
 *
 * There isn't an agtype_to_agtype_value(), because generally we find it more
 * convenient to directly iterate through the agtype representation and only
 * really convert nested scalar values.  agtype_iterator_next() does this, so
 * that clients of the iteration code don't have to directly deal with the
 * binary representation (agtype_deep_contains() is a notable exception,
 * although all exceptions are internal to this module).  In general, functions
 * that accept an agtype_value argument are concerned with the manipulation of
 * scalar values, or simple containers of scalar values, where it would be
 * inconvenient to deal with a great amount of other state.
 */</comment>
<function><type><name>agtype</name> <modifier>*</modifier></type><name>agtype_value_to_agtype</name><parameter_list>(<parameter><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>val</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>agtype</name> <modifier>*</modifier></type><name>out</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>IS_A_AGTYPE_SCALAR</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Scalar value */</comment>
        <decl_stmt><decl><type><name>agtype_parse_state</name> <modifier>*</modifier></type><name>pstate</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>agtype_value</name></type> <name>scalar_array</name></decl>;</decl_stmt>

        <expr_stmt><expr><name><name>scalar_array</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>AGTV_ARRAY</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>scalar_array</name><operator>.</operator><name>val</name><operator>.</operator><name>array</name><operator>.</operator><name>raw_scalar</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>scalar_array</name><operator>.</operator><name>val</name><operator>.</operator><name>array</name><operator>.</operator><name>num_elems</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>push_agtype_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pstate</name></expr></argument>, <argument><expr><name>WAGT_BEGIN_ARRAY</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>scalar_array</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>push_agtype_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pstate</name></expr></argument>, <argument><expr><name>WAGT_ELEM</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>push_agtype_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pstate</name></expr></argument>, <argument><expr><name>WAGT_END_ARRAY</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>out</name> <operator>=</operator> <call><name>convert_to_agtype</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name><name>val</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AGTV_OBJECT</name> <operator>||</operator> <name><name>val</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AGTV_ARRAY</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>out</name> <operator>=</operator> <call><name>convert_to_agtype</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>val</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AGTV_BINARY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>out</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>VARHDRSZ</name> <operator>+</operator> <name><name>val</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>binary</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>VARHDRSZ</name> <operator>+</operator> <name><name>val</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>binary</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><call><name>VARDATA</name><argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>val</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>binary</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>val</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>binary</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <return>return <expr><name>out</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Get the offset of the variable-length portion of an agtype node within
 * the variable-length-data part of its container.  The node is identified
 * by index within the container's agtentry array.
 */</comment>
<function><type><name>uint32</name></type> <name>get_agtype_offset</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>agtype_container</name> <modifier>*</modifier></type><name>agtc</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>index</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>uint32</name></type> <name>offset</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Start offset of this entry is equal to the end offset of the previous
     * entry.  Walk backwards to the most recent entry stored as an end
     * offset, returning that offset plus any lengths in between.
     */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>index</name> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name>offset</name> <operator>+=</operator> <call><name>AGTE_OFFLENFLD</name><argument_list>(<argument><expr><name><name>agtc</name><operator>-&gt;</operator><name>children</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>AGTE_HAS_OFF</name><argument_list>(<argument><expr><name><name>agtc</name><operator>-&gt;</operator><name>children</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>
    </block_content>}</block></for>

    <return>return <expr><name>offset</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Get the length of the variable-length portion of an agtype node.
 * The node is identified by index within the container's agtentry array.
 */</comment>
<function><type><name>uint32</name></type> <name>get_agtype_length</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>agtype_container</name> <modifier>*</modifier></type><name>agtc</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>index</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>uint32</name></type> <name>off</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type> <name>len</name></decl>;</decl_stmt>

    <comment type="block">/*
     * If the length is stored directly in the agtentry, just return it.
     * Otherwise, get the begin offset of the entry, and subtract that from
     * the stored end+1 offset.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>AGTE_HAS_OFF</name><argument_list>(<argument><expr><name><name>agtc</name><operator>-&gt;</operator><name>children</name><index>[<expr><name>index</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>off</name> <operator>=</operator> <call><name>get_agtype_offset</name><argument_list>(<argument><expr><name>agtc</name></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>AGTE_OFFLENFLD</name><argument_list>(<argument><expr><name><name>agtc</name><operator>-&gt;</operator><name>children</name><index>[<expr><name>index</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>-</operator> <name>off</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>AGTE_OFFLENFLD</name><argument_list>(<argument><expr><name><name>agtc</name><operator>-&gt;</operator><name>children</name><index>[<expr><name>index</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <return>return <expr><name>len</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Helper function to generate the sort priorty of a type. Larger
 * numbers have higher priority.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>get_type_sort_priority</name><parameter_list>(<parameter><decl><type><name><name>enum</name> <name>agtype_value_type</name></name></type> <name>type</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>AGTV_OBJECT</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>AGTV_VERTEX</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>AGTV_ARRAY</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="number">2</literal></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>AGTV_STRING</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="number">3</literal></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>AGTV_BOOL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="number">4</literal></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>AGTV_NUMERIC</name> <operator>||</operator> <name>type</name> <operator>==</operator> <name>AGTV_INTEGER</name> <operator>||</operator> <name>type</name> <operator>==</operator> <name>AGTV_FLOAT</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="number">5</literal></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>AGTV_NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="number">6</literal></expr>;</return></block_content></block></if></if_stmt>
    <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * BT comparator worker function.  Returns an integer less than, equal to, or
 * greater than zero, indicating whether a is less than, equal to, or greater
 * than b.  Consistent with the requirements for a B-Tree operator class
 *
 * Strings are compared lexically, in contrast with other places where we use a
 * much simpler comparator logic for searching through Strings.  Since this is
 * called from B-Tree support function 1, we're careful about not leaking
 * memory here.
 */</comment>
<function><type><name>int</name></type> <name>compare_agtype_containers_orderability</name><parameter_list>(<parameter><decl><type><name>agtype_container</name> <modifier>*</modifier></type><name>a</name></decl></parameter>,
                                           <parameter><decl><type><name>agtype_container</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>agtype_iterator</name> <modifier>*</modifier></type><name>ita</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_iterator</name> <modifier>*</modifier></type><name>itb</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>ita</name> <operator>=</operator> <call><name>agtype_iterator_init</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>itb</name> <operator>=</operator> <call><name>agtype_iterator_init</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <do>do
    <block>{<block_content>
        <decl_stmt><decl><type><name>agtype_value</name></type> <name>va</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>agtype_value</name></type> <name>vb</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>agtype_iterator_token</name></type> <name>ra</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>agtype_iterator_token</name></type> <name>rb</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>ra</name> <operator>=</operator> <call><name>agtype_iterator_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ita</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>va</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rb</name> <operator>=</operator> <call><name>agtype_iterator_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name>itb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vb</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>ra</name> <operator>==</operator> <name>rb</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>ra</name> <operator>==</operator> <name>WAGT_DONE</name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* Decisively equal */</comment>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><name>ra</name> <operator>==</operator> <name>WAGT_END_ARRAY</name> <operator>||</operator> <name>ra</name> <operator>==</operator> <name>WAGT_END_OBJECT</name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/*
                 * There is no array or object to compare at this stage of
                 * processing.  AGTV_ARRAY/AGTV_OBJECT values are compared
                 * initially, at the WAGT_BEGIN_ARRAY and WAGT_BEGIN_OBJECT
                 * tokens.
                 */</comment>
                <continue>continue;</continue>
            </block_content>}</block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>va</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name><name>vb</name><operator>.</operator><name>type</name></name><operator>)</operator> <operator>||</operator>
                <operator>(</operator><operator>(</operator><name><name>va</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>AGTV_INTEGER</name> <operator>||</operator> <name><name>va</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>AGTV_FLOAT</name> <operator>||</operator>
                  <name><name>va</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>AGTV_NUMERIC</name><operator>)</operator> <operator>&amp;&amp;</operator>
                 <operator>(</operator><name><name>vb</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>AGTV_INTEGER</name> <operator>||</operator> <name><name>vb</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>AGTV_FLOAT</name> <operator>||</operator>
                  <name><name>vb</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>AGTV_NUMERIC</name><operator>)</operator><operator>)</operator></expr>)</condition>
            <block>{<block_content>
                <switch>switch <condition>(<expr><name><name>va</name><operator>.</operator><name>type</name></name></expr>)</condition>
                <block>{<block_content>
                <case>case <expr><name>AGTV_STRING</name></expr>:</case>
                <case>case <expr><name>AGTV_NULL</name></expr>:</case>
                <case>case <expr><name>AGTV_NUMERIC</name></expr>:</case>
                <case>case <expr><name>AGTV_BOOL</name></expr>:</case>
                <case>case <expr><name>AGTV_INTEGER</name></expr>:</case>
                <case>case <expr><name>AGTV_FLOAT</name></expr>:</case>
                <case>case <expr><name>AGTV_EDGE</name></expr>:</case>
                <case>case <expr><name>AGTV_VERTEX</name></expr>:</case>
                <case>case <expr><name>AGTV_PATH</name></expr>:</case>
                    <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>compare_agtype_scalar_values</name><argument_list>(<argument><expr><operator>&amp;</operator><name>va</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>
                <case>case <expr><name>AGTV_ARRAY</name></expr>:</case>

                    <comment type="block">/*
                     * This could be a "raw scalar" pseudo array.  That's
                     * a special case here though, since we still want the
                     * general type-based comparisons to apply, and as far
                     * as we're concerned a pseudo array is just a scalar.
                     */</comment>
                    <if_stmt><if>if <condition>(<expr><name><name>va</name><operator>.</operator><name>val</name><operator>.</operator><name>array</name><operator>.</operator><name>raw_scalar</name></name> <operator>!=</operator> <name><name>vb</name><operator>.</operator><name>val</name><operator>.</operator><name>array</name><operator>.</operator><name>raw_scalar</name></name></expr>)</condition>
                    <block>{<block_content>
                        <if_stmt><if>if <condition>(<expr><name><name>va</name><operator>.</operator><name>val</name><operator>.</operator><name>array</name><operator>.</operator><name>raw_scalar</name></name></expr>)</condition>
                        <block>{<block_content>
                            <comment type="block">/* advance iterator ita and get contained type */</comment>
                            <expr_stmt><expr><name>ra</name> <operator>=</operator> <call><name>agtype_iterator_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ita</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>va</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><name>res</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><call><name>get_type_sort_priority</name><argument_list>(<argument><expr><name><name>va</name><operator>.</operator><name>type</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator>
                                   <call><name>get_type_sort_priority</name><argument_list>(<argument><expr><name><name>vb</name><operator>.</operator><name>type</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr> ?</condition><then>
                                      <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>:
                                      <expr><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>
                        </block_content>}</block></if>
                        <else>else
                        <block>{<block_content>
                            <comment type="block">/* advance iterator itb and get contained type */</comment>
                            <expr_stmt><expr><name>rb</name> <operator>=</operator> <call><name>agtype_iterator_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name>itb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vb</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><name>res</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><call><name>get_type_sort_priority</name><argument_list>(<argument><expr><name><name>va</name><operator>.</operator><name>type</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator>
                                   <call><name>get_type_sort_priority</name><argument_list>(<argument><expr><name><name>vb</name><operator>.</operator><name>type</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr> ?</condition><then>
                                      <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>:
                                      <expr><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>
                        </block_content>}</block></else></if_stmt>
                    </block_content>}</block></if></if_stmt>
                    <break>break;</break>
                <case>case <expr><name>AGTV_OBJECT</name></expr>:</case>
                    <break>break;</break>
                <case>case <expr><name>AGTV_BINARY</name></expr>:</case>
                    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unexpected AGTV_BINARY value"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></switch>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <comment type="block">/* Type-defined order */</comment>
                <expr_stmt><expr><name>res</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><call><name>get_type_sort_priority</name><argument_list>(<argument><expr><name><name>va</name><operator>.</operator><name>type</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator>
                       <call><name>get_type_sort_priority</name><argument_list>(<argument><expr><name><name>vb</name><operator>.</operator><name>type</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr> ?</condition><then>
                          <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>:
                          <expr><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="block">/*
             * It's safe to assume that the types differed, and that the va
             * and vb values passed were set.
             *
             * If the two values were of the same container type, then there'd
             * have been a chance to observe the variation in the number of
             * elements/pairs (when processing WAGT_BEGIN_OBJECT, say). They're
             * either two heterogeneously-typed containers, or a container and
             * some scalar type.
             */</comment>

            <comment type="block">/*
             * Check for the premature array or object end.
             * If left side is shorter, less than.
             */</comment>
            <if_stmt><if>if <condition>(<expr><name>ra</name> <operator>==</operator> <name>WAGT_END_ARRAY</name> <operator>||</operator> <name>ra</name> <operator>==</operator> <name>WAGT_END_OBJECT</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>res</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>
            <comment type="block">/* If right side is shorter, greater than */</comment>
            <if_stmt><if>if <condition>(<expr><name>rb</name> <operator>==</operator> <name>WAGT_END_ARRAY</name> <operator>||</operator> <name>rb</name> <operator>==</operator> <name>WAGT_END_OBJECT</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>res</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>

            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>va</name><operator>.</operator><name>type</name></name> <operator>!=</operator> <name><name>vb</name><operator>.</operator><name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>va</name><operator>.</operator><name>type</name></name> <operator>!=</operator> <name>AGTV_BINARY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>vb</name><operator>.</operator><name>type</name></name> <operator>!=</operator> <name>AGTV_BINARY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* Type-defined order */</comment>
            <expr_stmt><expr><name>res</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><call><name>get_type_sort_priority</name><argument_list>(<argument><expr><name><name>va</name><operator>.</operator><name>type</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator>
                   <call><name>get_type_sort_priority</name><argument_list>(<argument><expr><name><name>vb</name><operator>.</operator><name>type</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr> ?</condition><then>
                      <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>:
                      <expr><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block> while <condition>(<expr><name>res</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>;</do>

    <while>while <condition>(<expr><name>ita</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>agtype_iterator</name> <modifier>*</modifier></type><name>i</name> <init>= <expr><name><name>ita</name><operator>-&gt;</operator><name>parent</name></name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>ita</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>ita</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
    </block_content>}</block></while>
    <while>while <condition>(<expr><name>itb</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>agtype_iterator</name> <modifier>*</modifier></type><name>i</name> <init>= <expr><name><name>itb</name><operator>-&gt;</operator><name>parent</name></name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>itb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>itb</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
    </block_content>}</block></while>

    <return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Find value in object (i.e. the "value" part of some key/value pair in an
 * object), or find a matching element if we're looking through an array.  Do
 * so on the basis of equality of the object keys only, or alternatively
 * element values only, with a caller-supplied value "key".  The "flags"
 * argument allows the caller to specify which container types are of interest.
 *
 * This exported utility function exists to facilitate various cases concerned
 * with "containment".  If asked to look through an object, the caller had
 * better pass an agtype String, because their keys can only be strings.
 * Otherwise, for an array, any type of agtype_value will do.
 *
 * In order to proceed with the search, it is necessary for callers to have
 * both specified an interest in exactly one particular container type with an
 * appropriate flag, as well as having the pointed-to agtype container be of
 * one of those same container types at the top level. (Actually, we just do
 * whichever makes sense to save callers the trouble of figuring it out - at
 * most one can make sense, because the container either points to an array
 * (possibly a "raw scalar" pseudo array) or an object.)
 *
 * Note that we can return an AGTV_BINARY agtype_value if this is called on an
 * object, but we never do so on an array.  If the caller asks to look through
 * a container type that is not of the type pointed to by the container,
 * immediately fall through and return NULL.  If we cannot find the value,
 * return NULL.  Otherwise, return palloc()'d copy of value.
 */</comment>
<function><type><name>agtype_value</name> <modifier>*</modifier></type><name>find_agtype_value_from_container</name><parameter_list>(<parameter><decl><type><name>agtype_container</name> <modifier>*</modifier></type><name>container</name></decl></parameter>,
                                               <parameter><decl><type><name>uint32</name></type> <name>flags</name></decl></parameter>, <parameter><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>key</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>agtentry</name> <modifier>*</modifier></type><name>children</name> <init>= <expr><name><name>container</name><operator>-&gt;</operator><name>children</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>count</name> <init>= <expr><call><name>AGTYPE_CONTAINER_SIZE</name><argument_list>(<argument><expr><name>container</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <operator>~</operator><operator>(</operator><name>AGT_FARRAY</name> <operator>|</operator> <name>AGT_FOBJECT</name><operator>)</operator><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Quick out without a palloc cycle if object/array is empty */</comment>
    <if_stmt><if>if <condition>(<expr><name>count</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <return>return <expr><name>NULL</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>agtype_value</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>AGT_FARRAY</name><operator>)</operator> <operator>&amp;&amp;</operator> <call><name>AGTYPE_CONTAINER_IS_ARRAY</name><argument_list>(<argument><expr><name>container</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>base_addr</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>children</name> <operator>+</operator> <name>count</name><operator>)</operator></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>uint32</name></type> <name>offset</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <expr_stmt><expr><call><name>fill_agtype_value</name><argument_list>(<argument><expr><name>container</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>base_addr</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>key</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name><name>result</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><call><name>equals_agtype_scalar_value</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <return>return <expr><name>result</name></expr>;</return></block_content></block></if></if_stmt>
            </block_content>}</block></if></if_stmt>

            <expr_stmt><expr><call><name>AGTE_ADVANCE_OFFSET</name><argument_list>(<argument><expr><name>offset</name></expr></argument>, <argument><expr><name><name>children</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>AGT_FOBJECT</name><operator>)</operator> <operator>&amp;&amp;</operator> <call><name>AGTYPE_CONTAINER_IS_OBJECT</name><argument_list>(<argument><expr><name>container</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Since this is an object, account for *Pairs* of AGTentrys */</comment>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>base_addr</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>children</name> <operator>+</operator> <name>count</name> <operator>*</operator> <literal type="number">2</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>uint32</name></type> <name>stop_low</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>uint32</name></type> <name>stop_high</name> <init>= <expr><name>count</name></expr></init></decl>;</decl_stmt>

        <comment type="block">/* Object key passed by caller must be a string */</comment>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AGTV_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Binary search on object/pair keys *only* */</comment>
        <while>while <condition>(<expr><name>stop_low</name> <operator>&lt;</operator> <name>stop_high</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>uint32</name></type> <name>stop_middle</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>difference</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>agtype_value</name></type> <name>candidate</name></decl>;</decl_stmt>

            <expr_stmt><expr><name>stop_middle</name> <operator>=</operator> <name>stop_low</name> <operator>+</operator> <operator>(</operator><name>stop_high</name> <operator>-</operator> <name>stop_low</name><operator>)</operator> <operator>/</operator> <literal type="number">2</literal></expr>;</expr_stmt>

            <expr_stmt><expr><name><name>candidate</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>AGTV_STRING</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>candidate</name><operator>.</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>val</name></name> <operator>=</operator>
                <name>base_addr</name> <operator>+</operator> <call><name>get_agtype_offset</name><argument_list>(<argument><expr><name>container</name></expr></argument>, <argument><expr><name>stop_middle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>candidate</name><operator>.</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>len</name></name> <operator>=</operator> <call><name>get_agtype_length</name><argument_list>(<argument><expr><name>container</name></expr></argument>,
                                                         <argument><expr><name>stop_middle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name>difference</name> <operator>=</operator> <call><name>length_compare_agtype_string_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name>candidate</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name>difference</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* Found our key, return corresponding value */</comment>
                <decl_stmt><decl><type><name>int</name></type> <name>index</name> <init>= <expr><name>stop_middle</name> <operator>+</operator> <name>count</name></expr></init></decl>;</decl_stmt>

                <expr_stmt><expr><call><name>fill_agtype_value</name><argument_list>(<argument><expr><name>container</name></expr></argument>, <argument><expr><name>index</name></expr></argument>, <argument><expr><name>base_addr</name></expr></argument>,
                                  <argument><expr><call><name>get_agtype_offset</name><argument_list>(<argument><expr><name>container</name></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <return>return <expr><name>result</name></expr>;</return>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><name>difference</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>stop_low</name> <operator>=</operator> <name>stop_middle</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
                <else>else<block type="pseudo"><block_content>
                    <expr_stmt><expr><name>stop_high</name> <operator>=</operator> <name>stop_middle</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></while>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Not found */</comment>
    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Get i-th value of an agtype array.
 *
 * Returns palloc()'d copy of the value, or NULL if it does not exist.
 */</comment>
<function><type><name>agtype_value</name> <modifier>*</modifier></type><name>get_ith_agtype_value_from_container</name><parameter_list>(<parameter><decl><type><name>agtype_container</name> <modifier>*</modifier></type><name>container</name></decl></parameter>,
                                                  <parameter><decl><type><name>uint32</name></type> <name>i</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>base_addr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type> <name>nelements</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AGTYPE_CONTAINER_IS_ARRAY</name><argument_list>(<argument><expr><name>container</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"container is not an agtype array"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>nelements</name> <operator>=</operator> <call><name>AGTYPE_CONTAINER_SIZE</name><argument_list>(<argument><expr><name>container</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>base_addr</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>container</name><operator>-&gt;</operator><name>children</name><index>[<expr><name>nelements</name></expr>]</index></name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;=</operator> <name>nelements</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>agtype_value</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>fill_agtype_value</name><argument_list>(<argument><expr><name>container</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>base_addr</name></expr></argument>, <argument><expr><call><name>get_agtype_offset</name><argument_list>(<argument><expr><name>container</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * A helper function to fill in an agtype_value to represent an element of an
 * array, or a key or value of an object.
 *
 * The node's agtentry is at container-&gt;children[index], and its variable-length
 * data is at base_addr + offset.  We make the caller determine the offset
 * since in many cases the caller can amortize that work across multiple
 * children.  When it can't, it can just call get_agtype_offset().
 *
 * A nested array or object will be returned as AGTV_BINARY, ie. it won't be
 * expanded.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>fill_agtype_value</name><parameter_list>(<parameter><decl><type><name>agtype_container</name> <modifier>*</modifier></type><name>container</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>index</name></decl></parameter>,
                              <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>base_addr</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>offset</name></decl></parameter>,
                              <parameter><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>result</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>agtentry</name></type> <name>entry</name> <init>= <expr><name><name>container</name><operator>-&gt;</operator><name>children</name><index>[<expr><name>index</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>AGTE_IS_NULL</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>AGTV_NULL</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><call><name>AGTE_IS_STRING</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>string_val</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>string_len</name></decl>;</decl_stmt>

        <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>AGTV_STRING</name></expr>;</expr_stmt>
        <comment type="block">/* get the position and length of the string */</comment>
        <expr_stmt><expr><name>string_val</name> <operator>=</operator> <name>base_addr</name> <operator>+</operator> <name>offset</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>string_len</name> <operator>=</operator> <call><name>get_agtype_length</name><argument_list>(<argument><expr><name>container</name></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* we need to do a deep copy of the string value */</comment>
        <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>val</name></name> <operator>=</operator> <call><name>pnstrdup</name><argument_list>(<argument><expr><name>string_val</name></expr></argument>, <argument><expr><name>string_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>len</name></name> <operator>=</operator> <name>string_len</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>result</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>len</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><call><name>AGTE_IS_NUMERIC</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Numeric</name></type> <name>numeric</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Numeric</name></type> <name>numeric_copy</name></decl>;</decl_stmt>

        <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>AGTV_NUMERIC</name></expr>;</expr_stmt>
        <comment type="block">/* we need to do a deep copy here */</comment>
        <expr_stmt><expr><name>numeric</name> <operator>=</operator> <operator>(</operator><name>Numeric</name><operator>)</operator><operator>(</operator><name>base_addr</name> <operator>+</operator> <call><name>INTALIGN</name><argument_list>(<argument><expr><name>offset</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>numeric_copy</name> <operator>=</operator> <operator>(</operator><name>Numeric</name><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><call><name>VARSIZE</name><argument_list>(<argument><expr><name>numeric</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>numeric_copy</name></expr></argument>, <argument><expr><name>numeric</name></expr></argument>, <argument><expr><call><name>VARSIZE</name><argument_list>(<argument><expr><name>numeric</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>numeric</name></name> <operator>=</operator> <name>numeric_copy</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <comment type="block">/*
     * If this is an agtype.
     * This is needed because we allow the original jsonb type to be
     * passed in.
     */</comment>
    <if type="elseif">else if <condition>(<expr><call><name>AGTE_IS_AGTYPE</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ag_deserialize_extended_type</name><argument_list>(<argument><expr><name>base_addr</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><call><name>AGTE_IS_BOOL_TRUE</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>AGTV_BOOL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>boolean</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><call><name>AGTE_IS_BOOL_FALSE</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>AGTV_BOOL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>boolean</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>AGTE_IS_CONTAINER</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>AGTV_BINARY</name></expr>;</expr_stmt>
        <comment type="block">/* Remove alignment padding from data pointer and length */</comment>
        <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>binary</name><operator>.</operator><name>data</name></name> <operator>=</operator>
            <operator>(</operator><name>agtype_container</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>base_addr</name> <operator>+</operator> <call><name>INTALIGN</name><argument_list>(<argument><expr><name>offset</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>binary</name><operator>.</operator><name>len</name></name> <operator>=</operator> <call><name>get_agtype_length</name><argument_list>(<argument><expr><name>container</name></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call> <operator>-</operator>
                                 <operator>(</operator><call><name>INTALIGN</name><argument_list>(<argument><expr><name>offset</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>offset</name><operator>)</operator></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Push agtype_value into agtype_parse_state.
 *
 * Used when parsing agtype tokens to form agtype, or when converting an
 * in-memory agtype_value to an agtype.
 *
 * Initial state of *agtype_parse_state is NULL, since it'll be allocated here
 * originally (caller will get agtype_parse_state back by reference).
 *
 * Only sequential tokens pertaining to non-container types should pass an
 * agtype_value.  There is one exception -- WAGT_BEGIN_ARRAY callers may pass a
 * "raw scalar" pseudo array to append it - the actual scalar should be passed
 * next and it will be added as the only member of the array.
 *
 * Values of type AGTV_BINARY, which are rolled up arrays and objects,
 * are unpacked before being added to the result.
 */</comment>
<function><type><name>agtype_value</name> <modifier>*</modifier></type><name>push_agtype_value</name><parameter_list>(<parameter><decl><type><name>agtype_parse_state</name> <modifier>*</modifier><modifier>*</modifier></type><name>pstate</name></decl></parameter>,
                                <parameter><decl><type><name>agtype_iterator_token</name></type> <name>seq</name></decl></parameter>,
                                <parameter><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>agtval</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>agtype_iterator</name> <modifier>*</modifier></type><name>it</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>res</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_value</name></type> <name>v</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_iterator_token</name></type> <name>tok</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>agtval</name> <operator>||</operator> <operator>(</operator><name>seq</name> <operator>!=</operator> <name>WAGT_ELEM</name> <operator>&amp;&amp;</operator> <name>seq</name> <operator>!=</operator> <name>WAGT_VALUE</name><operator>)</operator> <operator>||</operator>
        <name><name>agtval</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>AGTV_BINARY</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* drop through */</comment>
        <return>return <expr><call><name>push_agtype_value_scalar</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>seq</name></expr></argument>, <argument><expr><name>agtval</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* unpack the binary and add each piece to the pstate */</comment>
    <expr_stmt><expr><name>it</name> <operator>=</operator> <call><name>agtype_iterator_init</name><argument_list>(<argument><expr><name><name>agtval</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>binary</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while <condition>(<expr><operator>(</operator><name>tok</name> <operator>=</operator> <call><name>agtype_iterator_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name>it</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>v</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>WAGT_DONE</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>push_agtype_value_scalar</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>tok</name></expr></argument>,
                                       <argument><expr><ternary><condition><expr><name>tok</name> <operator>&lt;</operator> <name>WAGT_BEGIN_ARRAY</name></expr> ?</condition><then> <expr><operator>&amp;</operator><name>v</name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>

    <return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Do the actual pushing, with only scalar or pseudo-scalar-array values
 * accepted.
 */</comment>
<function><type><specifier>static</specifier> <name>agtype_value</name> <modifier>*</modifier></type><name>push_agtype_value_scalar</name><parameter_list>(<parameter><decl><type><name>agtype_parse_state</name> <modifier>*</modifier><modifier>*</modifier></type><name>pstate</name></decl></parameter>,
                                              <parameter><decl><type><name>agtype_iterator_token</name></type> <name>seq</name></decl></parameter>,
                                              <parameter><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>scalar_val</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <switch>switch <condition>(<expr><name>seq</name></expr>)</condition>
    <block>{<block_content>
    <case>case <expr><name>WAGT_BEGIN_ARRAY</name></expr>:</case>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>scalar_val</name> <operator>||</operator> <name><name>scalar_val</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>array</name><operator>.</operator><name>raw_scalar</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>pstate</name> <operator>=</operator> <call><name>push_state</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>&amp;</operator><name><operator>(</operator><operator>*</operator><name>pstate</name><operator>)</operator><operator>-&gt;</operator><name>cont_val</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><operator>(</operator><operator>*</operator><name>pstate</name><operator>)</operator><operator>-&gt;</operator><name><name>cont_val</name><operator>.</operator><name>type</name></name></name> <operator>=</operator> <name>AGTV_ARRAY</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><operator>(</operator><operator>*</operator><name>pstate</name><operator>)</operator><operator>-&gt;</operator><name><name>cont_val</name><operator>.</operator><name>val</name><operator>.</operator><name>array</name><operator>.</operator><name>num_elems</name></name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><operator>(</operator><operator>*</operator><name>pstate</name><operator>)</operator><operator>-&gt;</operator><name><name>cont_val</name><operator>.</operator><name>val</name><operator>.</operator><name>array</name><operator>.</operator><name>raw_scalar</name></name></name> <operator>=</operator>
            <operator>(</operator><name>scalar_val</name> <operator>&amp;&amp;</operator> <name><name>scalar_val</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>array</name><operator>.</operator><name>raw_scalar</name></name><operator>)</operator></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>scalar_val</name> <operator>&amp;&amp;</operator> <name><name>scalar_val</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>array</name><operator>.</operator><name>num_elems</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* Assume that this array is still really a scalar */</comment>
            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>scalar_val</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AGTV_ARRAY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><operator>(</operator><operator>*</operator><name>pstate</name><operator>)</operator><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <name><name>scalar_val</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>array</name><operator>.</operator><name>num_elems</name></name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><name><operator>(</operator><operator>*</operator><name>pstate</name><operator>)</operator><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><name><operator>(</operator><operator>*</operator><name>pstate</name><operator>)</operator><operator>-&gt;</operator><name><name>cont_val</name><operator>.</operator><name>val</name><operator>.</operator><name>array</name><operator>.</operator><name>elems</name></name></name> <operator>=</operator>
            <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>agtype_value</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><operator>(</operator><operator>*</operator><name>pstate</name><operator>)</operator><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><operator>(</operator><operator>*</operator><name>pstate</name><operator>)</operator><operator>-&gt;</operator><name>last_updated_value</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <break>break;</break>
    <case>case <expr><name>WAGT_BEGIN_OBJECT</name></expr>:</case>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>scalar_val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>pstate</name> <operator>=</operator> <call><name>push_state</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>&amp;</operator><name><operator>(</operator><operator>*</operator><name>pstate</name><operator>)</operator><operator>-&gt;</operator><name>cont_val</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><operator>(</operator><operator>*</operator><name>pstate</name><operator>)</operator><operator>-&gt;</operator><name><name>cont_val</name><operator>.</operator><name>type</name></name></name> <operator>=</operator> <name>AGTV_OBJECT</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><operator>(</operator><operator>*</operator><name>pstate</name><operator>)</operator><operator>-&gt;</operator><name><name>cont_val</name><operator>.</operator><name>val</name><operator>.</operator><name>object</name><operator>.</operator><name>num_pairs</name></name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><operator>(</operator><operator>*</operator><name>pstate</name><operator>)</operator><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><operator>(</operator><operator>*</operator><name>pstate</name><operator>)</operator><operator>-&gt;</operator><name><name>cont_val</name><operator>.</operator><name>val</name><operator>.</operator><name>object</name><operator>.</operator><name>pairs</name></name></name> <operator>=</operator>
            <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>agtype_pair</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><operator>(</operator><operator>*</operator><name>pstate</name><operator>)</operator><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><operator>(</operator><operator>*</operator><name>pstate</name><operator>)</operator><operator>-&gt;</operator><name>last_updated_value</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <break>break;</break>
    <case>case <expr><name>WAGT_KEY</name></expr>:</case>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>scalar_val</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AGTV_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>append_key</name><argument_list>(<argument><expr><operator>*</operator><name>pstate</name></expr></argument>, <argument><expr><name>scalar_val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
    <case>case <expr><name>WAGT_VALUE</name></expr>:</case>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IS_A_AGTYPE_SCALAR</name><argument_list>(<argument><expr><name>scalar_val</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>append_value</name><argument_list>(<argument><expr><operator>*</operator><name>pstate</name></expr></argument>, <argument><expr><name>scalar_val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
    <case>case <expr><name>WAGT_ELEM</name></expr>:</case>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IS_A_AGTYPE_SCALAR</name><argument_list>(<argument><expr><name>scalar_val</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>append_element</name><argument_list>(<argument><expr><operator>*</operator><name>pstate</name></expr></argument>, <argument><expr><name>scalar_val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
    <case>case <expr><name>WAGT_END_OBJECT</name></expr>:</case>
        <expr_stmt><expr><call><name>uniqueify_agtype_object</name><argument_list>(<argument><expr><operator>&amp;</operator><name><operator>(</operator><operator>*</operator><name>pstate</name><operator>)</operator><operator>-&gt;</operator><name>cont_val</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* fall through! */</comment>
    <case>case <expr><name>WAGT_END_ARRAY</name></expr>:</case>
        <comment type="block">/* Steps here common to WAGT_END_OBJECT case */</comment>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>scalar_val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <operator>&amp;</operator><name><operator>(</operator><operator>*</operator><name>pstate</name><operator>)</operator><operator>-&gt;</operator><name>cont_val</name></name></expr>;</expr_stmt>

        <comment type="block">/*
         * Pop stack and push current array/object as value in parent
         * array/object
         */</comment>
        <expr_stmt><expr><operator>*</operator><name>pstate</name> <operator>=</operator> <name><operator>(</operator><operator>*</operator><name>pstate</name><operator>)</operator><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>*</operator><name>pstate</name></expr>)</condition>
        <block>{<block_content>
            <switch>switch <condition>(<expr><name><operator>(</operator><operator>*</operator><name>pstate</name><operator>)</operator><operator>-&gt;</operator><name><name>cont_val</name><operator>.</operator><name>type</name></name></name></expr>)</condition>
            <block>{<block_content>
            <case>case <expr><name>AGTV_ARRAY</name></expr>:</case>
                <expr_stmt><expr><call><name>append_element</name><argument_list>(<argument><expr><operator>*</operator><name>pstate</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            <case>case <expr><name>AGTV_OBJECT</name></expr>:</case>
                <expr_stmt><expr><call><name>append_value</name><argument_list>(<argument><expr><operator>*</operator><name>pstate</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            <default>default:</default>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid agtype container type %d"</literal></expr></argument>,
                                       <argument><expr><name><operator>(</operator><operator>*</operator><name>pstate</name><operator>)</operator><operator>-&gt;</operator><name><name>cont_val</name><operator>.</operator><name>type</name></name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></switch>
        </block_content>}</block></if></if_stmt>
        <break>break;</break>
    <default>default:</default>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unrecognized agtype sequential processing token"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></switch>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * push_agtype_value() worker:  Iteration-like forming of agtype
 */</comment>
<function><type><specifier>static</specifier> <name>agtype_parse_state</name> <modifier>*</modifier></type><name>push_state</name><parameter_list>(<parameter><decl><type><name>agtype_parse_state</name> <modifier>*</modifier><modifier>*</modifier></type><name>pstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>agtype_parse_state</name> <modifier>*</modifier></type><name>ns</name> <init>= <expr><call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>agtype_parse_state</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>ns</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <operator>*</operator><name>pstate</name></expr>;</expr_stmt>
    <return>return <expr><name>ns</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * push_agtype_value() worker:  Append a pair key to state when generating
 *                              agtype
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>append_key</name><parameter_list>(<parameter><decl><type><name>agtype_parse_state</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>string</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>object</name> <init>= <expr><operator>&amp;</operator><name><name>pstate</name><operator>-&gt;</operator><name>cont_val</name></name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>object</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AGTV_OBJECT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>string</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AGTV_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>object</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>object</name><operator>.</operator><name>num_pairs</name></name> <operator>&gt;=</operator> <name>AGTYPE_MAX_PAIRS</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(
            <argument><expr><name>ERROR</name></expr></argument>,
            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROGRAM_LIMIT_EXCEEDED</name></expr></argument>)</argument_list></call><operator>,</operator>
             <call><name>errmsg</name><argument_list>(
                 <argument><expr><literal type="string">"number of agtype object pairs exceeds the maximum allowed (%zu)"</literal></expr></argument>,
                 <argument><expr><name>AGTYPE_MAX_PAIRS</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>object</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>object</name><operator>.</operator><name>num_pairs</name></name> <operator>&gt;=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>size</name></name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>object</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>object</name><operator>.</operator><name>pairs</name></name> <operator>=</operator> <call><name>repalloc</name><argument_list>(
            <argument><expr><name><name>object</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>object</name><operator>.</operator><name>pairs</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>agtype_pair</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>pstate</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name><name>object</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>object</name><operator>.</operator><name>pairs</name><index>[<expr><name><name>object</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>object</name><operator>.</operator><name>num_pairs</name></name></expr>]</index></name><operator>.</operator><name>key</name> <operator>=</operator> <operator>*</operator><name>string</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>object</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>object</name><operator>.</operator><name>pairs</name><index>[<expr><name><name>object</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>object</name><operator>.</operator><name>num_pairs</name></name></expr>]</index></name><operator>.</operator><name>order</name> <operator>=</operator>
        <name><name>object</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>object</name><operator>.</operator><name>num_pairs</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * push_agtype_value() worker:  Append a pair value to state when generating an
 *                              agtype
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>append_value</name><parameter_list>(<parameter><decl><type><name>agtype_parse_state</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>scalar_val</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>object</name> <init>= <expr><operator>&amp;</operator><name><name>pstate</name><operator>-&gt;</operator><name>cont_val</name></name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>object</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AGTV_OBJECT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>object</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>object</name><operator>.</operator><name>pairs</name><index>[<expr><name><name>object</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>object</name><operator>.</operator><name>num_pairs</name></name></expr>]</index></name><operator>.</operator><name>value</name> <operator>=</operator> <operator>*</operator><name>scalar_val</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>last_updated_value</name></name> <operator>=</operator>
        <operator>&amp;</operator><name><name>object</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>object</name><operator>.</operator><name>pairs</name><index>[<expr><name><name>object</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>object</name><operator>.</operator><name>num_pairs</name></name><operator>++</operator></expr>]</index></name><operator>.</operator><name>value</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * push_agtype_value() worker:  Append an element to state when generating an
 *                              agtype
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>append_element</name><parameter_list>(<parameter><decl><type><name>agtype_parse_state</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>,
                           <parameter><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>scalar_val</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>array</name> <init>= <expr><operator>&amp;</operator><name><name>pstate</name><operator>-&gt;</operator><name>cont_val</name></name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>array</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AGTV_ARRAY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>array</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>array</name><operator>.</operator><name>num_elems</name></name> <operator>&gt;=</operator> <name>AGTYPE_MAX_ELEMS</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(
            <argument><expr><name>ERROR</name></expr></argument>,
            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROGRAM_LIMIT_EXCEEDED</name></expr></argument>)</argument_list></call><operator>,</operator>
             <call><name>errmsg</name><argument_list>(
                 <argument><expr><literal type="string">"number of agtype array elements exceeds the maximum allowed (%zu)"</literal></expr></argument>,
                 <argument><expr><name>AGTYPE_MAX_ELEMS</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>array</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>array</name><operator>.</operator><name>num_elems</name></name> <operator>&gt;=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>size</name></name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>array</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>array</name><operator>.</operator><name>elems</name></name> <operator>=</operator> <call><name>repalloc</name><argument_list>(<argument><expr><name><name>array</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>array</name><operator>.</operator><name>elems</name></name></expr></argument>,
                                          <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>agtype_value</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>pstate</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name><name>array</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>array</name><operator>.</operator><name>elems</name><index>[<expr><name><name>array</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>array</name><operator>.</operator><name>num_elems</name></name></expr>]</index></name> <operator>=</operator> <operator>*</operator><name>scalar_val</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>last_updated_value</name></name> <operator>=</operator>
        <operator>&amp;</operator><name><name>array</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>array</name><operator>.</operator><name>elems</name><index>[<expr><name><name>array</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>array</name><operator>.</operator><name>num_elems</name></name><operator>++</operator></expr>]</index></name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Given an agtype_container, expand to agtype_iterator to iterate over items
 * fully expanded to in-memory representation for manipulation.
 *
 * See agtype_iterator_next() for notes on memory management.
 */</comment>
<function><type><name>agtype_iterator</name> <modifier>*</modifier></type><name>agtype_iterator_init</name><parameter_list>(<parameter><decl><type><name>agtype_container</name> <modifier>*</modifier></type><name>container</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>iterator_from_container</name><argument_list>(<argument><expr><name>container</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Get next agtype_value while iterating
 *
 * Caller should initially pass their own, original iterator.  They may get
 * back a child iterator palloc()'d here instead.  The function can be relied
 * on to free those child iterators, lest the memory allocated for highly
 * nested objects become unreasonable, but only if callers don't end iteration
 * early (by breaking upon having found something in a search, for example).
 *
 * Callers in such a scenario, that are particularly sensitive to leaking
 * memory in a long-lived context may walk the ancestral tree from the final
 * iterator we left them with to its oldest ancestor, pfree()ing as they go.
 * They do not have to free any other memory previously allocated for iterators
 * but not accessible as direct ancestors of the iterator they're last passed
 * back.
 *
 * Returns "agtype sequential processing" token value.  Iterator "state"
 * reflects the current stage of the process in a less granular fashion, and is
 * mostly used here to track things internally with respect to particular
 * iterators.
 *
 * Clients of this function should not have to handle any AGTV_BINARY values
 * (since recursive calls will deal with this), provided skip_nested is false.
 * It is our job to expand the AGTV_BINARY representation without bothering
 * them with it.  However, clients should not take it upon themselves to touch
 * array or Object element/pair buffers, since their element/pair pointers are
 * garbage.  Also, *val will not be set when returning WAGT_END_ARRAY or
 * WAGT_END_OBJECT, on the assumption that it's only useful to access values
 * when recursing in.
 */</comment>
<function><type><name>agtype_iterator_token</name></type> <name>agtype_iterator_next</name><parameter_list>(<parameter><decl><type><name>agtype_iterator</name> <modifier>*</modifier><modifier>*</modifier></type><name>it</name></decl></parameter>,
                                           <parameter><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>val</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>skip_nested</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>it</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>WAGT_DONE</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * When stepping into a nested container, we jump back here to start
     * processing the child. We will not recurse further in one call, because
     * processing the child will always begin in AGTI_ARRAY_START or
     * AGTI_OBJECT_START state.
     */</comment>
<label><name>recurse</name>:</label>
    <switch>switch <condition>(<expr><name><operator>(</operator><operator>*</operator><name>it</name><operator>)</operator><operator>-&gt;</operator><name>state</name></name></expr>)</condition>
    <block>{<block_content>
    <case>case <expr><name>AGTI_ARRAY_START</name></expr>:</case>
        <comment type="block">/* Set v to array on first array call */</comment>
        <expr_stmt><expr><name><name>val</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>AGTV_ARRAY</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>val</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>array</name><operator>.</operator><name>num_elems</name></name> <operator>=</operator> <name><operator>(</operator><operator>*</operator><name>it</name><operator>)</operator><operator>-&gt;</operator><name>num_elems</name></name></expr>;</expr_stmt>

        <comment type="block">/*
         * v-&gt;val.array.elems is not actually set, because we aren't doing
         * a full conversion
         */</comment>
        <expr_stmt><expr><name><name>val</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>array</name><operator>.</operator><name>raw_scalar</name></name> <operator>=</operator> <name><operator>(</operator><operator>*</operator><name>it</name><operator>)</operator><operator>-&gt;</operator><name>is_scalar</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><operator>(</operator><operator>*</operator><name>it</name><operator>)</operator><operator>-&gt;</operator><name>curr_index</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><operator>(</operator><operator>*</operator><name>it</name><operator>)</operator><operator>-&gt;</operator><name>curr_data_offset</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><operator>(</operator><operator>*</operator><name>it</name><operator>)</operator><operator>-&gt;</operator><name>curr_value_offset</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> <comment type="block">/* not actually used */</comment>
        <comment type="block">/* Set state for next call */</comment>
        <expr_stmt><expr><name><operator>(</operator><operator>*</operator><name>it</name><operator>)</operator><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>AGTI_ARRAY_ELEM</name></expr>;</expr_stmt>
        <return>return <expr><name>WAGT_BEGIN_ARRAY</name></expr>;</return>

    <case>case <expr><name>AGTI_ARRAY_ELEM</name></expr>:</case>
        <if_stmt><if>if <condition>(<expr><name><operator>(</operator><operator>*</operator><name>it</name><operator>)</operator><operator>-&gt;</operator><name>curr_index</name></name> <operator>&gt;=</operator> <name><operator>(</operator><operator>*</operator><name>it</name><operator>)</operator><operator>-&gt;</operator><name>num_elems</name></name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * All elements within array already processed.  Report this
             * to caller, and give it back original parent iterator (which
             * independently tracks iteration progress at its level of
             * nesting).
             */</comment>
            <expr_stmt><expr><operator>*</operator><name>it</name> <operator>=</operator> <call><name>free_and_get_parent</name><argument_list>(<argument><expr><operator>*</operator><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>WAGT_END_ARRAY</name></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>fill_agtype_value</name><argument_list>(<argument><expr><name><operator>(</operator><operator>*</operator><name>it</name><operator>)</operator><operator>-&gt;</operator><name>container</name></name></expr></argument>, <argument><expr><name><operator>(</operator><operator>*</operator><name>it</name><operator>)</operator><operator>-&gt;</operator><name>curr_index</name></name></expr></argument>,
                          <argument><expr><name><operator>(</operator><operator>*</operator><name>it</name><operator>)</operator><operator>-&gt;</operator><name>data_proper</name></name></expr></argument>, <argument><expr><name><operator>(</operator><operator>*</operator><name>it</name><operator>)</operator><operator>-&gt;</operator><name>curr_data_offset</name></name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>AGTE_ADVANCE_OFFSET</name><argument_list>(<argument><expr><name><operator>(</operator><operator>*</operator><name>it</name><operator>)</operator><operator>-&gt;</operator><name>curr_data_offset</name></name></expr></argument>,
                            <argument><expr><name><operator>(</operator><operator>*</operator><name>it</name><operator>)</operator><operator>-&gt;</operator><name>children</name></name><index>[<expr><name><operator>(</operator><operator>*</operator><name>it</name><operator>)</operator><operator>-&gt;</operator><name>curr_index</name></name></expr>]</index></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><operator>(</operator><operator>*</operator><name>it</name><operator>)</operator><operator>-&gt;</operator><name>curr_index</name></name><operator>++</operator></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IS_A_AGTYPE_SCALAR</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name>skip_nested</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* Recurse into container. */</comment>
            <expr_stmt><expr><operator>*</operator><name>it</name> <operator>=</operator> <call><name>iterator_from_container</name><argument_list>(<argument><expr><name><name>val</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>binary</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><operator>*</operator><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <goto>goto <name>recurse</name>;</goto>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="block">/*
             * Scalar item in array, or a container and caller didn't want
             * us to recurse into it.
             */</comment>
            <return>return <expr><name>WAGT_ELEM</name></expr>;</return>
        </block_content>}</block></else></if_stmt>

    <case>case <expr><name>AGTI_OBJECT_START</name></expr>:</case>
        <comment type="block">/* Set v to object on first object call */</comment>
        <expr_stmt><expr><name><name>val</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>AGTV_OBJECT</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>val</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>object</name><operator>.</operator><name>num_pairs</name></name> <operator>=</operator> <name><operator>(</operator><operator>*</operator><name>it</name><operator>)</operator><operator>-&gt;</operator><name>num_elems</name></name></expr>;</expr_stmt>

        <comment type="block">/*
         * v-&gt;val.object.pairs is not actually set, because we aren't
         * doing a full conversion
         */</comment>
        <expr_stmt><expr><name><operator>(</operator><operator>*</operator><name>it</name><operator>)</operator><operator>-&gt;</operator><name>curr_index</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><operator>(</operator><operator>*</operator><name>it</name><operator>)</operator><operator>-&gt;</operator><name>curr_data_offset</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><operator>(</operator><operator>*</operator><name>it</name><operator>)</operator><operator>-&gt;</operator><name>curr_value_offset</name></name> <operator>=</operator> <call><name>get_agtype_offset</name><argument_list>(<argument><expr><name><operator>(</operator><operator>*</operator><name>it</name><operator>)</operator><operator>-&gt;</operator><name>container</name></name></expr></argument>,
                                                     <argument><expr><name><operator>(</operator><operator>*</operator><name>it</name><operator>)</operator><operator>-&gt;</operator><name>num_elems</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* Set state for next call */</comment>
        <expr_stmt><expr><name><operator>(</operator><operator>*</operator><name>it</name><operator>)</operator><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>AGTI_OBJECT_KEY</name></expr>;</expr_stmt>
        <return>return <expr><name>WAGT_BEGIN_OBJECT</name></expr>;</return>

    <case>case <expr><name>AGTI_OBJECT_KEY</name></expr>:</case>
        <if_stmt><if>if <condition>(<expr><name><operator>(</operator><operator>*</operator><name>it</name><operator>)</operator><operator>-&gt;</operator><name>curr_index</name></name> <operator>&gt;=</operator> <name><operator>(</operator><operator>*</operator><name>it</name><operator>)</operator><operator>-&gt;</operator><name>num_elems</name></name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * All pairs within object already processed.  Report this to
             * caller, and give it back original containing iterator
             * (which independently tracks iteration progress at its level
             * of nesting).
             */</comment>
            <expr_stmt><expr><operator>*</operator><name>it</name> <operator>=</operator> <call><name>free_and_get_parent</name><argument_list>(<argument><expr><operator>*</operator><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>WAGT_END_OBJECT</name></expr>;</return>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="block">/* Return key of a key/value pair.  */</comment>
            <expr_stmt><expr><call><name>fill_agtype_value</name><argument_list>(<argument><expr><name><operator>(</operator><operator>*</operator><name>it</name><operator>)</operator><operator>-&gt;</operator><name>container</name></name></expr></argument>, <argument><expr><name><operator>(</operator><operator>*</operator><name>it</name><operator>)</operator><operator>-&gt;</operator><name>curr_index</name></name></expr></argument>,
                              <argument><expr><name><operator>(</operator><operator>*</operator><name>it</name><operator>)</operator><operator>-&gt;</operator><name>data_proper</name></name></expr></argument>, <argument><expr><name><operator>(</operator><operator>*</operator><name>it</name><operator>)</operator><operator>-&gt;</operator><name>curr_data_offset</name></name></expr></argument>,
                              <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><name><name>val</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>AGTV_STRING</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unexpected agtype type as object key %d"</literal></expr></argument>,
                                <argument><expr><name><name>val</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <comment type="block">/* Set state for next call */</comment>
            <expr_stmt><expr><name><operator>(</operator><operator>*</operator><name>it</name><operator>)</operator><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>AGTI_OBJECT_VALUE</name></expr>;</expr_stmt>
            <return>return <expr><name>WAGT_KEY</name></expr>;</return>
        </block_content>}</block></else></if_stmt>

    <case>case <expr><name>AGTI_OBJECT_VALUE</name></expr>:</case>
        <comment type="block">/* Set state for next call */</comment>
        <expr_stmt><expr><name><operator>(</operator><operator>*</operator><name>it</name><operator>)</operator><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>AGTI_OBJECT_KEY</name></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>fill_agtype_value</name><argument_list>(<argument><expr><name><operator>(</operator><operator>*</operator><name>it</name><operator>)</operator><operator>-&gt;</operator><name>container</name></name></expr></argument>,
                          <argument><expr><name><operator>(</operator><operator>*</operator><name>it</name><operator>)</operator><operator>-&gt;</operator><name>curr_index</name></name> <operator>+</operator> <name><operator>(</operator><operator>*</operator><name>it</name><operator>)</operator><operator>-&gt;</operator><name>num_elems</name></name></expr></argument>,
                          <argument><expr><name><operator>(</operator><operator>*</operator><name>it</name><operator>)</operator><operator>-&gt;</operator><name>data_proper</name></name></expr></argument>, <argument><expr><name><operator>(</operator><operator>*</operator><name>it</name><operator>)</operator><operator>-&gt;</operator><name>curr_value_offset</name></name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>AGTE_ADVANCE_OFFSET</name><argument_list>(<argument><expr><name><operator>(</operator><operator>*</operator><name>it</name><operator>)</operator><operator>-&gt;</operator><name>curr_data_offset</name></name></expr></argument>,
                            <argument><expr><name><operator>(</operator><operator>*</operator><name>it</name><operator>)</operator><operator>-&gt;</operator><name>children</name></name><index>[<expr><name><operator>(</operator><operator>*</operator><name>it</name><operator>)</operator><operator>-&gt;</operator><name>curr_index</name></name></expr>]</index></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>AGTE_ADVANCE_OFFSET</name><argument_list>(
            <argument><expr><name><operator>(</operator><operator>*</operator><name>it</name><operator>)</operator><operator>-&gt;</operator><name>curr_value_offset</name></name></expr></argument>,
            <argument><expr><name><operator>(</operator><operator>*</operator><name>it</name><operator>)</operator><operator>-&gt;</operator><name>children</name></name><index>[<expr><name><operator>(</operator><operator>*</operator><name>it</name><operator>)</operator><operator>-&gt;</operator><name>curr_index</name></name> <operator>+</operator> <name><operator>(</operator><operator>*</operator><name>it</name><operator>)</operator><operator>-&gt;</operator><name>num_elems</name></name></expr>]</index></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><operator>(</operator><operator>*</operator><name>it</name><operator>)</operator><operator>-&gt;</operator><name>curr_index</name></name><operator>++</operator></expr>;</expr_stmt>

        <comment type="block">/*
         * Value may be a container, in which case we recurse with new,
         * child iterator (unless the caller asked not to, by passing
         * skip_nested).
         */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IS_A_AGTYPE_SCALAR</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name>skip_nested</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><operator>*</operator><name>it</name> <operator>=</operator> <call><name>iterator_from_container</name><argument_list>(<argument><expr><name><name>val</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>binary</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><operator>*</operator><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <goto>goto <name>recurse</name>;</goto>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <return>return <expr><name>WAGT_VALUE</name></expr>;</return>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></switch>

    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid iterator state %d"</literal></expr></argument>, <argument><expr><name><operator>(</operator><operator>*</operator><name>it</name><operator>)</operator><operator>-&gt;</operator><name>state</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Initialize an iterator for iterating all elements in a container.
 */</comment>
<function><type><specifier>static</specifier> <name>agtype_iterator</name> <modifier>*</modifier></type><name>iterator_from_container</name><parameter_list>(<parameter><decl><type><name>agtype_container</name> <modifier>*</modifier></type><name>container</name></decl></parameter>,
                                                <parameter><decl><type><name>agtype_iterator</name> <modifier>*</modifier></type><name>parent</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>agtype_iterator</name> <modifier>*</modifier></type><name>it</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>it</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>agtype_iterator</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>it</name><operator>-&gt;</operator><name>container</name></name> <operator>=</operator> <name>container</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>it</name><operator>-&gt;</operator><name>parent</name></name> <operator>=</operator> <name>parent</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>it</name><operator>-&gt;</operator><name>num_elems</name></name> <operator>=</operator> <call><name>AGTYPE_CONTAINER_SIZE</name><argument_list>(<argument><expr><name>container</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Array starts just after header */</comment>
    <expr_stmt><expr><name><name>it</name><operator>-&gt;</operator><name>children</name></name> <operator>=</operator> <name><name>container</name><operator>-&gt;</operator><name>children</name></name></expr>;</expr_stmt>

    <switch>switch <condition>(<expr><name><name>container</name><operator>-&gt;</operator><name>header</name></name> <operator>&amp;</operator> <operator>(</operator><name>AGT_FARRAY</name> <operator>|</operator> <name>AGT_FOBJECT</name><operator>)</operator></expr>)</condition>
    <block>{<block_content>
    <case>case <expr><name>AGT_FARRAY</name></expr>:</case>
        <expr_stmt><expr><name><name>it</name><operator>-&gt;</operator><name>data_proper</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>it</name><operator>-&gt;</operator><name>children</name></name> <operator>+</operator>
                          <name><name>it</name><operator>-&gt;</operator><name>num_elems</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>agtentry</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>it</name><operator>-&gt;</operator><name>is_scalar</name></name> <operator>=</operator> <call><name>AGTYPE_CONTAINER_IS_SCALAR</name><argument_list>(<argument><expr><name>container</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* This is either a "raw scalar", or an array */</comment>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>it</name><operator>-&gt;</operator><name>is_scalar</name></name> <operator>||</operator> <name><name>it</name><operator>-&gt;</operator><name>num_elems</name></name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>it</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>AGTI_ARRAY_START</name></expr>;</expr_stmt>
        <break>break;</break>

    <case>case <expr><name>AGT_FOBJECT</name></expr>:</case>
        <expr_stmt><expr><name><name>it</name><operator>-&gt;</operator><name>data_proper</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>it</name><operator>-&gt;</operator><name>children</name></name> <operator>+</operator>
                          <name><name>it</name><operator>-&gt;</operator><name>num_elems</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>agtentry</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <literal type="number">2</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>it</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>AGTI_OBJECT_START</name></expr>;</expr_stmt>
        <break>break;</break>

    <default>default:</default>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unknown type of agtype container %d"</literal></expr></argument>,
                        <argument><expr><name><name>container</name><operator>-&gt;</operator><name>header</name></name> <operator>&amp;</operator> <operator>(</operator><name>AGT_FARRAY</name> <operator>|</operator> <name>AGT_FOBJECT</name><operator>)</operator></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></switch>

    <return>return <expr><name>it</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * agtype_iterator_next() worker: Return parent, while freeing memory for
 *                                current iterator
 */</comment>
<function><type><specifier>static</specifier> <name>agtype_iterator</name> <modifier>*</modifier></type><name>free_and_get_parent</name><parameter_list>(<parameter><decl><type><name>agtype_iterator</name> <modifier>*</modifier></type><name>it</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>agtype_iterator</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><name><name>it</name><operator>-&gt;</operator><name>parent</name></name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>v</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Worker for "contains" operator's function
 *
 * Formally speaking, containment is top-down, unordered subtree isomorphism.
 *
 * Takes iterators that belong to some container type.  These iterators
 * "belong" to those values in the sense that they've just been initialized in
 * respect of them by the caller (perhaps in a nested fashion).
 *
 * "val" is lhs agtype, and m_contained is rhs agtype when called from top
 * level. We determine if m_contained is contained within val.
 */</comment>
<function><type><name>bool</name></type> <name>agtype_deep_contains</name><parameter_list>(<parameter><decl><type><name>agtype_iterator</name> <modifier>*</modifier><modifier>*</modifier></type><name>val</name></decl></parameter>, <parameter><decl><type><name>agtype_iterator</name> <modifier>*</modifier><modifier>*</modifier></type><name>m_contained</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>agtype_value</name></type> <name>vval</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_value</name></type> <name>vcontained</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_iterator_token</name></type> <name>rval</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype_iterator_token</name></type> <name>rcont</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Guard against stack overflow due to overly complex agtype.
     *
     * Functions called here independently take this precaution, but that
     * might not be sufficient since this is also a recursive function.
     */</comment>
    <expr_stmt><expr><call><name>check_stack_depth</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>rval</name> <operator>=</operator> <call><name>agtype_iterator_next</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vval</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rcont</name> <operator>=</operator> <call><name>agtype_iterator_next</name><argument_list>(<argument><expr><name>m_contained</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vcontained</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>rval</name> <operator>!=</operator> <name>rcont</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * The differing return values can immediately be taken as indicating
         * two differing container types at this nesting level, which is
         * sufficient reason to give up entirely (but it should be the case
         * that they're both some container type).
         */</comment>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>rval</name> <operator>==</operator> <name>WAGT_BEGIN_OBJECT</name> <operator>||</operator> <name>rval</name> <operator>==</operator> <name>WAGT_BEGIN_ARRAY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>rcont</name> <operator>==</operator> <name>WAGT_BEGIN_OBJECT</name> <operator>||</operator> <name>rcont</name> <operator>==</operator> <name>WAGT_BEGIN_ARRAY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>rcont</name> <operator>==</operator> <name>WAGT_BEGIN_OBJECT</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>vval</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>AGTV_OBJECT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>vcontained</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>AGTV_OBJECT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * If the lhs has fewer pairs than the rhs, it can't possibly contain
         * the rhs.  (This conclusion is safe only because we de-duplicate
         * keys in all agtype objects; thus there can be no corresponding
         * optimization in the array case.)  The case probably won't arise
         * often, but since it's such a cheap check we may as well make it.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>vval</name><operator>.</operator><name>val</name><operator>.</operator><name>object</name><operator>.</operator><name>num_pairs</name></name> <operator>&lt;</operator> <name><name>vcontained</name><operator>.</operator><name>val</name><operator>.</operator><name>object</name><operator>.</operator><name>num_pairs</name></name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

        <comment type="block">/* Work through rhs "is it contained within?" object */</comment>
        <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>lhs_val</name></decl>;</decl_stmt> <comment type="block">/* lhs_val is from pair in lhs object */</comment>

            <expr_stmt><expr><name>rcont</name> <operator>=</operator> <call><name>agtype_iterator_next</name><argument_list>(<argument><expr><name>m_contained</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vcontained</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/*
             * When we get through caller's rhs "is it contained within?"
             * object without failing to find one of its values, it's
             * contained.
             */</comment>
            <if_stmt><if>if <condition>(<expr><name>rcont</name> <operator>==</operator> <name>WAGT_END_OBJECT</name></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>rcont</name> <operator>==</operator> <name>WAGT_KEY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* First, find value by key... */</comment>
            <expr_stmt><expr><name>lhs_val</name> <operator>=</operator> <call><name>find_agtype_value_from_container</name><argument_list>(
                <argument><expr><name><operator>(</operator><operator>*</operator><name>val</name><operator>)</operator><operator>-&gt;</operator><name>container</name></name></expr></argument>, <argument><expr><name>AGT_FOBJECT</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vcontained</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>lhs_val</name></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

            <comment type="block">/*
             * ...at this stage it is apparent that there is at least a key
             * match for this rhs pair.
             */</comment>
            <expr_stmt><expr><name>rcont</name> <operator>=</operator> <call><name>agtype_iterator_next</name><argument_list>(<argument><expr><name>m_contained</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vcontained</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>rcont</name> <operator>==</operator> <name>WAGT_VALUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/*
             * Compare rhs pair's value with lhs pair's value just found using
             * key
             */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>lhs_val</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name><name>vcontained</name><operator>.</operator><name>type</name></name></expr>)</condition>
            <block>{<block_content>
                <return>return <expr><name>false</name></expr>;</return>
            </block_content>}</block></if>
            <if type="elseif">else if <condition>(<expr><call><name>IS_A_AGTYPE_SCALAR</name><argument_list>(<argument><expr><name>lhs_val</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>equals_agtype_scalar_value</name><argument_list>(<argument><expr><name>lhs_val</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vcontained</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <comment type="block">/* Nested container value (object or array) */</comment>
                <decl_stmt><decl><type><name>agtype_iterator</name> <modifier>*</modifier></type><name>nestval</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>agtype_iterator</name> <modifier>*</modifier></type><name>nest_contained</name></decl>;</decl_stmt>

                <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>lhs_val</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AGTV_BINARY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>vcontained</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>AGTV_BINARY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><name>nestval</name> <operator>=</operator> <call><name>agtype_iterator_init</name><argument_list>(<argument><expr><name><name>lhs_val</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>binary</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>nest_contained</name> <operator>=</operator>
                    <call><name>agtype_iterator_init</name><argument_list>(<argument><expr><name><name>vcontained</name><operator>.</operator><name>val</name><operator>.</operator><name>binary</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/*
                 * Match "value" side of rhs datum object's pair recursively.
                 * It's a nested structure.
                 *
                 * Note that nesting still has to "match up" at the right
                 * nesting sub-levels.  However, there need only be zero or
                 * more matching pairs (or elements) at each nesting level
                 * (provided the *rhs* pairs/elements *all* match on each
                 * level), which enables searching nested structures for a
                 * single String or other primitive type sub-datum quite
                 * effectively (provided the user constructed the rhs nested
                 * structure such that we "know where to look").
                 *
                 * In other words, the mapping of container nodes in the rhs
                 * "vcontained" agtype to internal nodes on the lhs is
                 * injective, and parent-child edges on the rhs must be mapped
                 * to parent-child edges on the lhs to satisfy the condition
                 * of containment (plus of course the mapped nodes must be
                 * equal).
                 */</comment>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>agtype_deep_contains</name><argument_list>(<argument><expr><operator>&amp;</operator><name>nestval</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nest_contained</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>rcont</name> <operator>==</operator> <name>WAGT_BEGIN_ARRAY</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>lhs_conts</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>uint32</name></type> <name>num_lhs_elems</name> <init>= <expr><name><name>vval</name><operator>.</operator><name>val</name><operator>.</operator><name>array</name><operator>.</operator><name>num_elems</name></name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>vval</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>AGTV_ARRAY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>vcontained</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>AGTV_ARRAY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Handle distinction between "raw scalar" pseudo arrays, and real
         * arrays.
         *
         * A raw scalar may contain another raw scalar, and an array may
         * contain a raw scalar, but a raw scalar may not contain an array. We
         * don't do something like this for the object case, since objects can
         * only contain pairs, never raw scalars (a pair is represented by an
         * rhs object argument with a single contained pair).
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>vval</name><operator>.</operator><name>val</name><operator>.</operator><name>array</name><operator>.</operator><name>raw_scalar</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>vcontained</name><operator>.</operator><name>val</name><operator>.</operator><name>array</name><operator>.</operator><name>raw_scalar</name></name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

        <comment type="block">/* Work through rhs "is it contained within?" array */</comment>
        <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
        <block>{<block_content>
            <expr_stmt><expr><name>rcont</name> <operator>=</operator> <call><name>agtype_iterator_next</name><argument_list>(<argument><expr><name>m_contained</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vcontained</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/*
             * When we get through caller's rhs "is it contained within?"
             * array without failing to find one of its values, it's
             * contained.
             */</comment>
            <if_stmt><if>if <condition>(<expr><name>rcont</name> <operator>==</operator> <name>WAGT_END_ARRAY</name></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>rcont</name> <operator>==</operator> <name>WAGT_ELEM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><call><name>IS_A_AGTYPE_SCALAR</name><argument_list>(<argument><expr><operator>&amp;</operator><name>vcontained</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>find_agtype_value_from_container</name><argument_list>(<argument><expr><name><operator>(</operator><operator>*</operator><name>val</name><operator>)</operator><operator>-&gt;</operator><name>container</name></name></expr></argument>,
                                                      <argument><expr><name>AGT_FARRAY</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vcontained</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <decl_stmt><decl><type><name>uint32</name></type> <name>i</name></decl>;</decl_stmt>

                <comment type="block">/*
                 * If this is first container found in rhs array (at this
                 * depth), initialize temp lhs array of containers
                 */</comment>
                <if_stmt><if>if <condition>(<expr><name>lhs_conts</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>uint32</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

                    <comment type="block">/* Make room for all possible values */</comment>
                    <expr_stmt><expr><name>lhs_conts</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>agtype_value</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>num_lhs_elems</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_lhs_elems</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
                    <block>{<block_content>
                        <comment type="block">/* Store all lhs elements in temp array */</comment>
                        <expr_stmt><expr><name>rcont</name> <operator>=</operator> <call><name>agtype_iterator_next</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vval</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>rcont</name> <operator>==</operator> <name>WAGT_ELEM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                        <if_stmt><if>if <condition>(<expr><name><name>vval</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>AGTV_BINARY</name></expr>)</condition><block type="pseudo"><block_content>
                            <expr_stmt><expr><name><name>lhs_conts</name><index>[<expr><name>j</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>vval</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
                    </block_content>}</block></for>

                    <comment type="block">/* No container elements in temp array, so give up now */</comment>
                    <if_stmt><if>if <condition>(<expr><name>j</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

                    <comment type="block">/* We may have only partially filled array */</comment>
                    <expr_stmt><expr><name>num_lhs_elems</name> <operator>=</operator> <name>j</name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>

                <comment type="block">/* XXX: Nested array containment is O(N^2) */</comment>
                <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_lhs_elems</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
                <block>{<block_content>
                    <comment type="block">/* Nested container value (object or array) */</comment>
                    <decl_stmt><decl><type><name>agtype_iterator</name> <modifier>*</modifier></type><name>nestval</name></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>agtype_iterator</name> <modifier>*</modifier></type><name>nest_contained</name></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>bool</name></type> <name>contains</name></decl>;</decl_stmt>

                    <expr_stmt><expr><name>nestval</name> <operator>=</operator>
                        <call><name>agtype_iterator_init</name><argument_list>(<argument><expr><name><name>lhs_conts</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>val</name><operator>.</operator><name>binary</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>nest_contained</name> <operator>=</operator>
                        <call><name>agtype_iterator_init</name><argument_list>(<argument><expr><name><name>vcontained</name><operator>.</operator><name>val</name><operator>.</operator><name>binary</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <expr_stmt><expr><name>contains</name> <operator>=</operator> <call><name>agtype_deep_contains</name><argument_list>(<argument><expr><operator>&amp;</operator><name>nestval</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nest_contained</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <if_stmt><if>if <condition>(<expr><name>nestval</name></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>nestval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                    <if_stmt><if>if <condition>(<expr><name>nest_contained</name></expr>)</condition><block type="pseudo"><block_content>
                        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>nest_contained</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                    <if_stmt><if>if <condition>(<expr><name>contains</name></expr>)</condition><block type="pseudo"><block_content>
                        <break>break;</break></block_content></block></if></if_stmt>
                </block_content>}</block></for>

                <comment type="block">/*
                 * Report rhs container value is not contained if couldn't
                 * match rhs container to *some* lhs cont
                 */</comment>
                <if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <name>num_lhs_elems</name></expr>)</condition><block type="pseudo"><block_content>
                    <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid agtype container type"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unexpectedly fell off end of agtype container"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Hash an agtype_value scalar value, mixing the hash value into an existing
 * hash provided by the caller.
 *
 * Some callers may wish to independently XOR in AGT_FOBJECT and AGT_FARRAY
 * flags.
 */</comment>
<function><type><name>void</name></type> <name>agtype_hash_scalar_value</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>agtype_value</name> <modifier>*</modifier></type><name>scalar_val</name></decl></parameter>, <parameter><decl><type><name>uint32</name> <modifier>*</modifier></type><name>hash</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>uint32</name></type> <name>tmp</name></decl>;</decl_stmt>

    <comment type="block">/* Compute hash value for scalar_val */</comment>
    <switch>switch <condition>(<expr><name><name>scalar_val</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition>
    <block>{<block_content>
    <case>case <expr><name>AGTV_NULL</name></expr>:</case>
        <expr_stmt><expr><name>tmp</name> <operator>=</operator> <literal type="number">0x01</literal></expr>;</expr_stmt>
        <break>break;</break>
    <case>case <expr><name>AGTV_STRING</name></expr>:</case>
        <expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>DatumGetUInt32</name><argument_list>(
            <argument><expr><call><name>hash_any</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name><name>scalar_val</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>val</name></name></expr></argument>,
                     <argument><expr><name><name>scalar_val</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
    <case>case <expr><name>AGTV_NUMERIC</name></expr>:</case>
        <comment type="block">/* Must hash equal numerics to equal hash codes */</comment>
        <expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>DatumGetUInt32</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(
            <argument><expr><name>hash_numeric</name></expr></argument>, <argument><expr><call><name>NumericGetDatum</name><argument_list>(<argument><expr><name><name>scalar_val</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>numeric</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
    <case>case <expr><name>AGTV_BOOL</name></expr>:</case>
        <expr_stmt><expr><name>tmp</name> <operator>=</operator> <ternary><condition><expr><name><name>scalar_val</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>boolean</name></name></expr> ?</condition><then> <expr><literal type="number">0x02</literal></expr> </then><else>: <expr><literal type="number">0x04</literal></expr></else></ternary></expr>;</expr_stmt>
        <break>break;</break>
    <case>case <expr><name>AGTV_INTEGER</name></expr>:</case>
        <expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>DatumGetUInt32</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(
            <argument><expr><name>hashint8</name></expr></argument>, <argument><expr><call><name>Int64GetDatum</name><argument_list>(<argument><expr><name><name>scalar_val</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>int_value</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
    <case>case <expr><name>AGTV_FLOAT</name></expr>:</case>
        <expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>DatumGetUInt32</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(
            <argument><expr><name>hashfloat8</name></expr></argument>, <argument><expr><call><name>Float8GetDatum</name><argument_list>(<argument><expr><name><name>scalar_val</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>float_value</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
    <default>default:</default>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid agtype scalar type %d to compute hash"</literal></expr></argument>,
                               <argument><expr><name><name>scalar_val</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>tmp</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> <comment type="block">/* keep compiler quiet */</comment>
        <break>break;</break>
    </block_content>}</block></switch>

    <comment type="block">/*
     * Combine hash values of successive keys, values and elements by rotating
     * the previous value left 1 bit, then XOR'ing in the new
     * key/value/element's hash value.
     */</comment>
    <expr_stmt><expr><operator>*</operator><name>hash</name> <operator>=</operator> <operator>(</operator><operator>*</operator><name>hash</name> <operator>&lt;&lt;</operator> <literal type="number">1</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><operator>*</operator><name>hash</name> <operator>&gt;&gt;</operator> <literal type="number">31</literal><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>hash</name> <operator>^=</operator> <name>tmp</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Hash a value to a 64-bit value, with a seed. Otherwise, similar to
 * agtype_hash_scalar_value.
 */</comment>
<function><type><name>void</name></type> <name>agtype_hash_scalar_value_extended</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>agtype_value</name> <modifier>*</modifier></type><name>scalar_val</name></decl></parameter>,
                                       <parameter><decl><type><name>uint64</name> <modifier>*</modifier></type><name>hash</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>seed</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>uint64</name></type> <name>tmp</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <switch>switch <condition>(<expr><name><name>scalar_val</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition>
    <block>{<block_content>
    <case>case <expr><name>AGTV_NULL</name></expr>:</case>
        <expr_stmt><expr><name>tmp</name> <operator>=</operator> <name>seed</name> <operator>+</operator> <literal type="number">0x01</literal></expr>;</expr_stmt>
        <break>break;</break>
    <case>case <expr><name>AGTV_STRING</name></expr>:</case>
        <expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>DatumGetUInt64</name><argument_list>(<argument><expr><call><name>hash_any_extended</name><argument_list>(
            <argument><expr><operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name><name>scalar_val</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>val</name></name></expr></argument>,
            <argument><expr><name><name>scalar_val</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>len</name></name></expr></argument>, <argument><expr><name>seed</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
    <case>case <expr><name>AGTV_NUMERIC</name></expr>:</case>
        <expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>DatumGetUInt64</name><argument_list>(<argument><expr><call><name>DirectFunctionCall2</name><argument_list>(
            <argument><expr><name>hash_numeric_extended</name></expr></argument>, <argument><expr><call><name>NumericGetDatum</name><argument_list>(<argument><expr><name><name>scalar_val</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>numeric</name></name></expr></argument>)</argument_list></call></expr></argument>,
            <argument><expr><call><name>UInt64GetDatum</name><argument_list>(<argument><expr><name>seed</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
    <case>case <expr><name>AGTV_BOOL</name></expr>:</case>
        <if_stmt><if>if <condition>(<expr><name>seed</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>DatumGetUInt64</name><argument_list>(<argument><expr><call><name>DirectFunctionCall2</name><argument_list>(
                <argument><expr><name>hashcharextended</name></expr></argument>, <argument><expr><call><name>BoolGetDatum</name><argument_list>(<argument><expr><name><name>scalar_val</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>boolean</name></name></expr></argument>)</argument_list></call></expr></argument>,
                <argument><expr><call><name>UInt64GetDatum</name><argument_list>(<argument><expr><name>seed</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><name>tmp</name> <operator>=</operator> <ternary><condition><expr><name><name>scalar_val</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>boolean</name></name></expr> ?</condition><then> <expr><literal type="number">0x02</literal></expr> </then><else>: <expr><literal type="number">0x04</literal></expr></else></ternary></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <break>break;</break>
    <case>case <expr><name>AGTV_INTEGER</name></expr>:</case>
        <expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>DatumGetUInt64</name><argument_list>(<argument><expr><call><name>DirectFunctionCall2</name><argument_list>(
            <argument><expr><name>hashint8extended</name></expr></argument>, <argument><expr><call><name>Int64GetDatum</name><argument_list>(<argument><expr><name><name>scalar_val</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>int_value</name></name></expr></argument>)</argument_list></call></expr></argument>,
            <argument><expr><call><name>UInt64GetDatum</name><argument_list>(<argument><expr><name>seed</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
    <case>case <expr><name>AGTV_FLOAT</name></expr>:</case>
        <expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>DatumGetUInt64</name><argument_list>(<argument><expr><call><name>DirectFunctionCall2</name><argument_list>(
            <argument><expr><name>hashfloat8extended</name></expr></argument>, <argument><expr><call><name>Float8GetDatum</name><argument_list>(<argument><expr><name><name>scalar_val</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>float_value</name></name></expr></argument>)</argument_list></call></expr></argument>,
            <argument><expr><call><name>UInt64GetDatum</name><argument_list>(<argument><expr><name>seed</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
    <case>case <expr><name>AGTV_VERTEX</name></expr>:</case>
    <block>{<block_content>
        <decl_stmt><decl><type><name>graphid</name></type> <name>id</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>id_agt</name> <init>= <expr><call><name>GET_AGTYPE_VALUE_OBJECT_VALUE</name><argument_list>(<argument><expr><name>scalar_val</name></expr></argument>, <argument><expr><literal type="string">"id"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>id</name> <operator>=</operator> <name><name>id_agt</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>int_value</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>DatumGetUInt64</name><argument_list>(<argument><expr><call><name>DirectFunctionCall2</name><argument_list>(
            <argument><expr><name>hashint8extended</name></expr></argument>, <argument><expr><call><name>Float8GetDatum</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>UInt64GetDatum</name><argument_list>(<argument><expr><name>seed</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>AGTV_EDGE</name></expr>:</case>
    <block>{<block_content>
        <decl_stmt><decl><type><name>graphid</name></type> <name>id</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>id_agt</name> <init>= <expr><call><name>GET_AGTYPE_VALUE_OBJECT_VALUE</name><argument_list>(<argument><expr><name>scalar_val</name></expr></argument>, <argument><expr><literal type="string">"id"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>id</name> <operator>=</operator> <name><name>id_agt</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>int_value</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>DatumGetUInt64</name><argument_list>(<argument><expr><call><name>DirectFunctionCall2</name><argument_list>(
            <argument><expr><name>hashint8extended</name></expr></argument>, <argument><expr><call><name>Float8GetDatum</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>UInt64GetDatum</name><argument_list>(<argument><expr><name>seed</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
    </block_content>}</block>
    <case>case <expr><name>AGTV_PATH</name></expr>:</case>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>scalar_val</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>array</name><operator>.</operator><name>num_elems</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
        <block>{<block_content>
            <decl_stmt><decl><type><name>agtype_value</name></type> <name>v</name></decl>;</decl_stmt>
            <expr_stmt><expr><name>v</name> <operator>=</operator> <name><name>scalar_val</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>array</name><operator>.</operator><name>elems</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>agtype_hash_scalar_value_extended</name><argument_list>(<argument><expr><operator>&amp;</operator><name>v</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmp</name></expr></argument>, <argument><expr><name>seed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>
        <break>break;</break>
    </block_content>}</block>
    <default>default:</default>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(
            <argument><expr><name>ERROR</name></expr></argument>,
            <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid agtype scalar type %d to compute hash extended"</literal></expr></argument>,
                    <argument><expr><name><name>scalar_val</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
    </block_content>}</block></switch>

    <expr_stmt><expr><operator>*</operator><name>hash</name> <operator>=</operator> <call><name>ROTATE_HIGH_AND_LOW_32BITS</name><argument_list>(<argument><expr><operator>*</operator><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>hash</name> <operator>^=</operator> <name>tmp</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Function to compare two floats, obviously. However, there are a few
 * special cases that we need to cover with regards to NaN and +/-Infinity.
 * NaN is not equal to any other number, including itself. However, for
 * ordering, we need to allow NaN = NaN and NaN &gt; any number including
 * positive infinity -
 *
 *     -Infinity &lt; any number &lt; +Infinity &lt; NaN
 *
 * Note: This is copied from float8_cmp_internal.
 * Note: Special float values can cause exceptions, hence the order of the
 *       comparisons.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>compare_two_floats_orderability</name><parameter_list>(<parameter><decl><type><name>float8</name></type> <name>lhs</name></decl></parameter>, <parameter><decl><type><name>float8</name></type> <name>rhs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/*
     * We consider all NANs to be equal and larger than any non-NAN. This is
     * somewhat arbitrary; the important thing is to have a consistent sort
     * order.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>isnan</name><argument_list>(<argument><expr><name>lhs</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>isnan</name><argument_list>(<argument><expr><name>rhs</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if> <comment type="block">/* NAN = NAN */</comment>
        <else>else<block type="pseudo"><block_content>
            <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></else></if_stmt> <comment type="block">/* NAN &gt; non-NAN */</comment>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><call><name>isnan</name><argument_list>(<argument><expr><name>rhs</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return> <comment type="block">/* non-NAN &lt; NAN */</comment>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>lhs</name> <operator>&gt;</operator> <name>rhs</name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><name>lhs</name> <operator>&lt;</operator> <name>rhs</name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></else></if_stmt>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Are two scalar agtype_values of the same type a and b equal?
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type> <name>equals_agtype_scalar_value</name><parameter_list>(<parameter><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/* if the values are of the same type */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name><name>b</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition>
    <block>{<block_content>
        <switch>switch <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition>
        <block>{<block_content>
        <case>case <expr><name>AGTV_NULL</name></expr>:</case>
            <return>return <expr><name>true</name></expr>;</return>
        <case>case <expr><name>AGTV_STRING</name></expr>:</case>
            <return>return <expr><call><name>length_compare_agtype_string_value</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>;</return>
        <case>case <expr><name>AGTV_NUMERIC</name></expr>:</case>
            <return>return <expr><call><name>DatumGetBool</name><argument_list>(<argument><expr><call><name>DirectFunctionCall2</name><argument_list>(
                <argument><expr><name>numeric_eq</name></expr></argument>, <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name><name>a</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>numeric</name></name></expr></argument>)</argument_list></call></expr></argument>,
                <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name><name>b</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>numeric</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
        <case>case <expr><name>AGTV_BOOL</name></expr>:</case>
            <return>return <expr><name><name>a</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>boolean</name></name> <operator>==</operator> <name><name>b</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>boolean</name></name></expr>;</return>
        <case>case <expr><name>AGTV_INTEGER</name></expr>:</case>
            <return>return <expr><name><name>a</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>int_value</name></name> <operator>==</operator> <name><name>b</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>int_value</name></name></expr>;</return>
        <case>case <expr><name>AGTV_FLOAT</name></expr>:</case>
            <return>return <expr><name><name>a</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>float_value</name></name> <operator>==</operator> <name><name>b</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>float_value</name></name></expr>;</return>
        <case>case <expr><name>AGTV_VERTEX</name></expr>:</case>
        <block>{<block_content>
            <decl_stmt><decl><type><name>graphid</name></type> <name>a_graphid</name></decl>, <decl><type ref="prev"/><name>b_graphid</name></decl>;</decl_stmt>
            <expr_stmt><expr><name>a_graphid</name> <operator>=</operator> <name><name>a</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>object</name><operator>.</operator><name>pairs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name><name>value</name><operator>.</operator><name>val</name><operator>.</operator><name>int_value</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>b_graphid</name> <operator>=</operator> <name><name>b</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>object</name><operator>.</operator><name>pairs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name><name>value</name><operator>.</operator><name>val</name><operator>.</operator><name>int_value</name></name></expr>;</expr_stmt>

            <return>return <expr><name>a_graphid</name> <operator>==</operator> <name>b_graphid</name></expr>;</return>
        </block_content>}</block>

        <default>default:</default>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid agtype scalar type %d for equals"</literal></expr></argument>,
                                   <argument><expr><name><name>a</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></switch>
    </block_content>}</block></if>
    <comment type="block">/* otherwise, the values are of differing type */</comment>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"agtype input scalars must be of same type"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <comment type="block">/* execution will never reach this point due to the ereport call */</comment>
    <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Compare two scalar agtype_values, returning -1, 0, or 1.
 *
 * Strings are compared using the default collation.  Used by B-tree
 * operators, where a lexical sort order is generally expected.
 */</comment>
<function><type><name>int</name></type> <name>compare_agtype_scalar_values</name><parameter_list>(<parameter><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name><name>b</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition>
    <block>{<block_content>
        <switch>switch <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition>
        <block>{<block_content>
        <case>case <expr><name>AGTV_NULL</name></expr>:</case>
            <return>return <expr><literal type="number">0</literal></expr>;</return>
        <case>case <expr><name>AGTV_STRING</name></expr>:</case>
        <block>{<block_content>
            <comment type="block">/* varstr_cmp isn't guaranteed to return 1, 0, -1 */</comment>
            <decl_stmt><decl><type><name>int</name></type> <name>result</name> <init>= <expr><call><name>varstr_cmp</name><argument_list>(<argument><expr><name><name>a</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>val</name></name></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>len</name></name></expr></argument>,
                                    <argument><expr><name><name>b</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>val</name></name></expr></argument>, <argument><expr><name><name>b</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>len</name></name></expr></argument>,
                                    <argument><expr><name>DEFAULT_COLLATION_OID</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>result</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <return>return <expr><literal type="number">1</literal></expr>;</return>
            </block_content>}</block></if>
            <if type="elseif">else if <condition>(<expr><name>result</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <return>return <expr><literal type="number">0</literal></expr>;</return>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block>
        <case>case <expr><name>AGTV_NUMERIC</name></expr>:</case>
            <return>return <expr><call><name>DatumGetInt32</name><argument_list>(<argument><expr><call><name>DirectFunctionCall2</name><argument_list>(
                <argument><expr><name>numeric_cmp</name></expr></argument>, <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name><name>a</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>numeric</name></name></expr></argument>)</argument_list></call></expr></argument>,
                <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name><name>b</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>numeric</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
        <case>case <expr><name>AGTV_BOOL</name></expr>:</case>
            <if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>boolean</name></name> <operator>==</operator> <name><name>b</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>boolean</name></name></expr>)</condition>
            <block>{<block_content>
                <return>return <expr><literal type="number">0</literal></expr>;</return>
            </block_content>}</block></if>
            <if type="elseif">else if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>boolean</name></name> <operator>&gt;</operator> <name><name>b</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>boolean</name></name></expr>)</condition>
            <block>{<block_content>
                <return>return <expr><literal type="number">1</literal></expr>;</return>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
            </block_content>}</block></else></if_stmt>
        <case>case <expr><name>AGTV_INTEGER</name></expr>:</case>
            <if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>int_value</name></name> <operator>==</operator> <name><name>b</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>int_value</name></name></expr>)</condition>
            <block>{<block_content>
                <return>return <expr><literal type="number">0</literal></expr>;</return>
            </block_content>}</block></if>
            <if type="elseif">else if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>int_value</name></name> <operator>&gt;</operator> <name><name>b</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>int_value</name></name></expr>)</condition>
            <block>{<block_content>
                <return>return <expr><literal type="number">1</literal></expr>;</return>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
            </block_content>}</block></else></if_stmt>
        <case>case <expr><name>AGTV_FLOAT</name></expr>:</case>
            <return>return <expr><call><name>compare_two_floats_orderability</name><argument_list>(<argument><expr><name><name>a</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>float_value</name></name></expr></argument>,
                                                   <argument><expr><name><name>b</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>float_value</name></name></expr></argument>)</argument_list></call></expr>;</return>
        <case>case <expr><name>AGTV_VERTEX</name></expr>:</case>
        <case>case <expr><name>AGTV_EDGE</name></expr>:</case>
        <block>{<block_content>
            <decl_stmt><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>a_id</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>b_id</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>graphid</name></type> <name>a_graphid</name></decl>, <decl><type ref="prev"/><name>b_graphid</name></decl>;</decl_stmt>

            <expr_stmt><expr><name>a_id</name> <operator>=</operator> <call><name>GET_AGTYPE_VALUE_OBJECT_VALUE</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="string">"id"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>b_id</name> <operator>=</operator> <call><name>GET_AGTYPE_VALUE_OBJECT_VALUE</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><literal type="string">"id"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name>a_graphid</name> <operator>=</operator> <name><name>a_id</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>int_value</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>b_graphid</name> <operator>=</operator> <name><name>b_id</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>int_value</name></name></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name>a_graphid</name> <operator>==</operator> <name>b_graphid</name></expr>)</condition>
            <block>{<block_content>
                <return>return <expr><literal type="number">0</literal></expr>;</return>
            </block_content>}</block></if>
            <if type="elseif">else if <condition>(<expr><name>a_graphid</name> <operator>&gt;</operator> <name>b_graphid</name></expr>)</condition>
            <block>{<block_content>
                <return>return <expr><literal type="number">1</literal></expr>;</return>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block>
        <case>case <expr><name>AGTV_PATH</name></expr>:</case>
        <block>{<block_content>
            <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>array</name><operator>.</operator><name>num_elems</name></name> <operator>!=</operator> <name><name>b</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>array</name><operator>.</operator><name>num_elems</name></name></expr>)</condition><block type="pseudo"><block_content>
                <return>return  <expr><ternary><condition><expr><name><name>a</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>array</name><operator>.</operator><name>num_elems</name></name> <operator>&gt;</operator> <name><name>b</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>array</name><operator>.</operator><name>num_elems</name></name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr>;</return></block_content></block></if></if_stmt>

            <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>a</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>array</name><operator>.</operator><name>num_elems</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <decl_stmt><decl><type><name>agtype_value</name></type> <name>a_elem</name></decl>, <decl><type ref="prev"/><name>b_elem</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>

                <expr_stmt><expr><name>a_elem</name> <operator>=</operator> <name><name>a</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>array</name><operator>.</operator><name>elems</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
                <expr_stmt><expr><name>b_elem</name> <operator>=</operator> <name><name>b</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>array</name><operator>.</operator><name>elems</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

                <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>compare_agtype_scalar_values</name><argument_list>(<argument><expr><operator>&amp;</operator><name>a_elem</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>b_elem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <if_stmt><if>if <condition>(<expr><name>res</name></expr>)</condition>
                <block>{<block_content>
                    <return>return <expr><name>res</name></expr>;</return>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></for>

            <return>return <expr><literal type="number">0</literal></expr>;</return>
        </block_content>}</block>
        <default>default:</default>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid agtype scalar type %d for compare"</literal></expr></argument>,
                                   <argument><expr><name><name>a</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></switch>
    </block_content>}</block></if></if_stmt>
    <comment type="block">/* check for integer compared to float */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AGTV_INTEGER</name> <operator>&amp;&amp;</operator> <name><name>b</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AGTV_FLOAT</name></expr>)</condition>
    <block>{<block_content>
        <return>return <expr><call><name>compare_two_floats_orderability</name><argument_list>(<argument><expr><operator>(</operator><name>float8</name><operator>)</operator><name><name>a</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>int_value</name></name></expr></argument>,
                                               <argument><expr><name><name>b</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>float_value</name></name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <comment type="block">/* check for float compared to integer */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AGTV_FLOAT</name> <operator>&amp;&amp;</operator> <name><name>b</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AGTV_INTEGER</name></expr>)</condition>
    <block>{<block_content>
        <return>return <expr><call><name>compare_two_floats_orderability</name><argument_list>(<argument><expr><name><name>a</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>float_value</name></name></expr></argument>,
                                               <argument><expr><operator>(</operator><name>float8</name><operator>)</operator><name><name>b</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>int_value</name></name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <comment type="block">/* check for integer or float compared to numeric */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>is_numeric_result</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Datum</name></type> <name>numd</name></decl>, <decl><type ref="prev"/><name>lhsd</name></decl>, <decl><type ref="prev"/><name>rhsd</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>lhsd</name> <operator>=</operator> <call><name>get_numeric_datum_from_agtype_value</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rhsd</name> <operator>=</operator> <call><name>get_numeric_datum_from_agtype_value</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>numd</name> <operator>=</operator> <call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>numeric_cmp</name></expr></argument>, <argument><expr><name>lhsd</name></expr></argument>, <argument><expr><name>rhsd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <return>return <expr><call><name>DatumGetInt32</name><argument_list>(<argument><expr><name>numd</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"agtype input scalar type mismatch"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Functions for manipulating the resizeable buffer used by convert_agtype and
 * its subroutines.
 */</comment>

<comment type="block">/*
 * Reserve 'len' bytes, at the end of the buffer, enlarging it if necessary.
 * Returns the offset to the reserved area. The caller is expected to fill
 * the reserved area later with copy_to_buffer().
 */</comment>
<function><type><name>int</name></type> <name>reserve_from_buffer</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>offset</name></decl>;</decl_stmt>

    <comment type="block">/* Make more room if needed */</comment>
    <expr_stmt><expr><call><name>enlargeStringInfo</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* remember current offset */</comment>
    <expr_stmt><expr><name>offset</name> <operator>=</operator> <name><name>buffer</name><operator>-&gt;</operator><name>len</name></name></expr>;</expr_stmt>

    <comment type="block">/* reserve the space */</comment>
    <expr_stmt><expr><name><name>buffer</name><operator>-&gt;</operator><name>len</name></name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>

    <comment type="block">/*
     * Keep a trailing null in place, even though it's not useful for us; it
     * seems best to preserve the invariants of StringInfos.
     */</comment>
    <expr_stmt><expr><name><name>buffer</name><operator>-&gt;</operator><name>data</name><index>[<expr><name><name>buffer</name><operator>-&gt;</operator><name>len</name></name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

    <return>return <expr><name>offset</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Copy 'len' bytes to a previously reserved area in buffer.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>copy_to_buffer</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>offset</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>data</name></decl></parameter>,
                           <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>buffer</name><operator>-&gt;</operator><name>data</name></name> <operator>+</operator> <name>offset</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * A shorthand for reserve_from_buffer + copy_to_buffer.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>append_to_buffer</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>offset</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>offset</name> <operator>=</operator> <call><name>reserve_from_buffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>copy_to_buffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Append padding, so that the length of the StringInfo is int-aligned.
 * Returns the number of padding bytes appended.
 */</comment>
<function><type><name>short</name></type> <name>pad_buffer_to_int</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>buffer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>padlen</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>p</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>offset</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>padlen</name> <operator>=</operator> <call><name>INTALIGN</name><argument_list>(<argument><expr><name><name>buffer</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call> <operator>-</operator> <name><name>buffer</name><operator>-&gt;</operator><name>len</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><name>offset</name> <operator>=</operator> <call><name>reserve_from_buffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>padlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* padlen must be small, so this is probably faster than a memset */</comment>
    <for>for <control>(<init><expr><name>p</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>p</name> <operator>&lt;</operator> <name>padlen</name></expr>;</condition> <incr><expr><name>p</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>buffer</name><operator>-&gt;</operator><name>data</name><index>[<expr><name>offset</name> <operator>+</operator> <name>p</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt></block_content></block></for>

    <return>return <expr><name>padlen</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Given an agtype_value, convert to agtype. The result is palloc'd.
 */</comment>
<function><type><specifier>static</specifier> <name>agtype</name> <modifier>*</modifier></type><name>convert_to_agtype</name><parameter_list>(<parameter><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>val</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>StringInfoData</name></type> <name>buffer</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtentry</name></type> <name>aentry</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype</name> <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>

    <comment type="block">/* Should not already have binary representation */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>val</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>AGTV_BINARY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Allocate an output buffer. It will be enlarged as needed */</comment>
    <expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Make room for the varlena header */</comment>
    <expr_stmt><expr><call><name>reserve_from_buffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><name>VARHDRSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>convert_agtype_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>aentry</name></expr></argument>, <argument><expr><name>val</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Note: the agtentry of the root is discarded. Therefore the root
     * agtype_container struct must contain enough information to tell what
     * kind of value it is.
     */</comment>

    <expr_stmt><expr><name>res</name> <operator>=</operator> <operator>(</operator><name>agtype</name> <operator>*</operator><operator>)</operator><name><name>buffer</name><operator>.</operator><name>data</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name><name>buffer</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Subroutine of convert_agtype: serialize a single agtype_value into buffer.
 *
 * The agtentry header for this node is returned in *header.  It is filled in
 * with the length of this value and appropriate type bits.  If we wish to
 * store an end offset rather than a length, it is the caller's responsibility
 * to adjust for that.
 *
 * If the value is an array or an object, this recurses. 'level' is only used
 * for debugging purposes.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>convert_agtype_value</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><name>agtentry</name> <modifier>*</modifier></type><name>header</name></decl></parameter>,
                                 <parameter><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>val</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>level</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>check_stack_depth</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>val</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * An agtype_value passed as val should never have a type of AGTV_BINARY,
     * and neither should any of its sub-components. Those values will be
     * produced by convert_agtype_array and convert_agtype_object, the results
     * of which will not be passed back to this function as an argument.
     */</comment>

    <if_stmt><if>if <condition>(<expr><call><name>IS_A_AGTYPE_SCALAR</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>convert_agtype_scalar</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>header</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><name><name>val</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AGTV_ARRAY</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>convert_agtype_array</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>header</name></expr></argument>, <argument><expr><name>val</name></expr></argument>, <argument><expr><name>level</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><name><name>val</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AGTV_OBJECT</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>convert_agtype_object</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>header</name></expr></argument>, <argument><expr><name>val</name></expr></argument>, <argument><expr><name>level</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unknown agtype type %d to convert"</literal></expr></argument>, <argument><expr><name><name>val</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>convert_agtype_array</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><name>agtentry</name> <modifier>*</modifier></type><name>pheader</name></decl></parameter>,
                                 <parameter><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>val</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>level</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>base_offset</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>agtentry_offset</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>totallen</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type> <name>header</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>num_elems</name> <init>= <expr><name><name>val</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>array</name><operator>.</operator><name>num_elems</name></name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Remember where in the buffer this array starts. */</comment>
    <expr_stmt><expr><name>base_offset</name> <operator>=</operator> <name><name>buffer</name><operator>-&gt;</operator><name>len</name></name></expr>;</expr_stmt>

    <comment type="block">/* Align to 4-byte boundary (any padding counts as part of my data) */</comment>
    <expr_stmt><expr><call><name>pad_buffer_to_int</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Construct the header agtentry and store it in the beginning of the
     * variable-length payload.
     */</comment>
    <expr_stmt><expr><name>header</name> <operator>=</operator> <name>num_elems</name> <operator>|</operator> <name>AGT_FARRAY</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>val</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>array</name><operator>.</operator><name>raw_scalar</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>num_elems</name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>level</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>header</name> <operator>|=</operator> <name>AGT_FSCALAR</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>append_to_buffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>header</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Reserve space for the agtentrys of the elements. */</comment>
    <expr_stmt><expr><name>agtentry_offset</name> <operator>=</operator> <call><name>reserve_from_buffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>,
                                          <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>agtentry</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>num_elems</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>totallen</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_elems</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>elem</name> <init>= <expr><operator>&amp;</operator><name><name>val</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>array</name><operator>.</operator><name>elems</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>agtentry</name></type> <name>meta</name></decl>;</decl_stmt>

        <comment type="block">/*
         * Convert element, producing a agtentry and appending its
         * variable-length data to buffer
         */</comment>
        <expr_stmt><expr><call><name>convert_agtype_value</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>meta</name></expr></argument>, <argument><expr><name>elem</name></expr></argument>, <argument><expr><name>level</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>AGTE_OFFLENFLD</name><argument_list>(<argument><expr><name>meta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>totallen</name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>

        <comment type="block">/*
         * Bail out if total variable-length data exceeds what will fit in a
         * agtentry length field.  We check this in each iteration, not just
         * once at the end, to forestall possible integer overflow.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>totallen</name> <operator>&gt;</operator> <name>AGTENTRY_OFFLENMASK</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(
                <argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROGRAM_LIMIT_EXCEEDED</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(
                     <argument><expr><literal type="string">"total size of agtype array elements exceeds the maximum of %u bytes"</literal></expr></argument>,
                     <argument><expr><name>AGTENTRY_OFFLENMASK</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/*
         * Convert each AGT_OFFSET_STRIDE'th length to an offset.
         */</comment>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>i</name> <operator>%</operator> <name>AGT_OFFSET_STRIDE</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>meta</name> <operator>=</operator> <operator>(</operator><name>meta</name> <operator>&amp;</operator> <name>AGTENTRY_TYPEMASK</name><operator>)</operator> <operator>|</operator> <name>totallen</name> <operator>|</operator> <name>AGTENTRY_HAS_OFF</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><call><name>copy_to_buffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>agtentry_offset</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>meta</name></expr></argument>,
                       <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>agtentry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>agtentry_offset</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>agtentry</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    </block_content>}</block></for>

    <comment type="block">/* Total data size is everything we've appended to buffer */</comment>
    <expr_stmt><expr><name>totallen</name> <operator>=</operator> <name><name>buffer</name><operator>-&gt;</operator><name>len</name></name> <operator>-</operator> <name>base_offset</name></expr>;</expr_stmt>

    <comment type="block">/* Check length again, since we didn't include the metadata above */</comment>
    <if_stmt><if>if <condition>(<expr><name>totallen</name> <operator>&gt;</operator> <name>AGTENTRY_OFFLENMASK</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(
            <argument><expr><name>ERROR</name></expr></argument>,
            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROGRAM_LIMIT_EXCEEDED</name></expr></argument>)</argument_list></call><operator>,</operator>
             <call><name>errmsg</name><argument_list>(
                 <argument><expr><literal type="string">"total size of agtype array elements exceeds the maximum of %u bytes"</literal></expr></argument>,
                 <argument><expr><name>AGTENTRY_OFFLENMASK</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Initialize the header of this node in the container's agtentry array */</comment>
    <expr_stmt><expr><operator>*</operator><name>pheader</name> <operator>=</operator> <name>AGTENTRY_IS_CONTAINER</name> <operator>|</operator> <name>totallen</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>convert_extended_array</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><name>agtentry</name> <modifier>*</modifier></type><name>pheader</name></decl></parameter>,
                            <parameter><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>val</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>convert_agtype_array</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>pheader</name></expr></argument>, <argument><expr><name>val</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>convert_extended_object</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><name>agtentry</name> <modifier>*</modifier></type><name>pheader</name></decl></parameter>,
                             <parameter><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>val</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>convert_agtype_object</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>pheader</name></expr></argument>, <argument><expr><name>val</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>convert_agtype_object</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><name>agtentry</name> <modifier>*</modifier></type><name>pheader</name></decl></parameter>,
                                  <parameter><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>val</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>level</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>base_offset</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>agtentry_offset</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>totallen</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint32</name></type> <name>header</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>num_pairs</name> <init>= <expr><name><name>val</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>object</name><operator>.</operator><name>num_pairs</name></name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Remember where in the buffer this object starts. */</comment>
    <expr_stmt><expr><name>base_offset</name> <operator>=</operator> <name><name>buffer</name><operator>-&gt;</operator><name>len</name></name></expr>;</expr_stmt>

    <comment type="block">/* Align to 4-byte boundary (any padding counts as part of my data) */</comment>
    <expr_stmt><expr><call><name>pad_buffer_to_int</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Construct the header agtentry and store it in the beginning of the
     * variable-length payload.
     */</comment>
    <expr_stmt><expr><name>header</name> <operator>=</operator> <name>num_pairs</name> <operator>|</operator> <name>AGT_FOBJECT</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>append_to_buffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>header</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Reserve space for the agtentrys of the keys and values. */</comment>
    <expr_stmt><expr><name>agtentry_offset</name> <operator>=</operator> <call><name>reserve_from_buffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>,
                                          <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>agtentry</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>num_pairs</name> <operator>*</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Iterate over the keys, then over the values, since that is the ordering
     * we want in the on-disk representation.
     */</comment>
    <expr_stmt><expr><name>totallen</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_pairs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>agtype_pair</name> <modifier>*</modifier></type><name>pair</name> <init>= <expr><operator>&amp;</operator><name><name>val</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>object</name><operator>.</operator><name>pairs</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>agtentry</name></type> <name>meta</name></decl>;</decl_stmt>

        <comment type="block">/*
         * Convert key, producing an agtentry and appending its variable-length
         * data to buffer
         */</comment>
        <expr_stmt><expr><call><name>convert_agtype_scalar</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>meta</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pair</name><operator>-&gt;</operator><name>key</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>AGTE_OFFLENFLD</name><argument_list>(<argument><expr><name>meta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>totallen</name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>

        <comment type="block">/*
         * Bail out if total variable-length data exceeds what will fit in a
         * agtentry length field.  We check this in each iteration, not just
         * once at the end, to forestall possible integer overflow.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>totallen</name> <operator>&gt;</operator> <name>AGTENTRY_OFFLENMASK</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(
                <argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROGRAM_LIMIT_EXCEEDED</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(
                     <argument><expr><literal type="string">"total size of agtype object elements exceeds the maximum of %u bytes"</literal></expr></argument>,
                     <argument><expr><name>AGTENTRY_OFFLENMASK</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/*
         * Convert each AGT_OFFSET_STRIDE'th length to an offset.
         */</comment>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>i</name> <operator>%</operator> <name>AGT_OFFSET_STRIDE</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>meta</name> <operator>=</operator> <operator>(</operator><name>meta</name> <operator>&amp;</operator> <name>AGTENTRY_TYPEMASK</name><operator>)</operator> <operator>|</operator> <name>totallen</name> <operator>|</operator> <name>AGTENTRY_HAS_OFF</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><call><name>copy_to_buffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>agtentry_offset</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>meta</name></expr></argument>,
                       <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>agtentry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>agtentry_offset</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>agtentry</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    </block_content>}</block></for>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_pairs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>agtype_pair</name> <modifier>*</modifier></type><name>pair</name> <init>= <expr><operator>&amp;</operator><name><name>val</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>object</name><operator>.</operator><name>pairs</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>agtentry</name></type> <name>meta</name></decl>;</decl_stmt>

        <comment type="block">/*
         * Convert value, producing an agtentry and appending its
         * variable-length data to buffer
         */</comment>
        <expr_stmt><expr><call><name>convert_agtype_value</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>meta</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pair</name><operator>-&gt;</operator><name>value</name></name></expr></argument>, <argument><expr><name>level</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>AGTE_OFFLENFLD</name><argument_list>(<argument><expr><name>meta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>totallen</name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>

        <comment type="block">/*
         * Bail out if total variable-length data exceeds what will fit in a
         * agtentry length field.  We check this in each iteration, not just
         * once at the end, to forestall possible integer overflow.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>totallen</name> <operator>&gt;</operator> <name>AGTENTRY_OFFLENMASK</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(
                <argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROGRAM_LIMIT_EXCEEDED</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(
                     <argument><expr><literal type="string">"total size of agtype object elements exceeds the maximum of %u bytes"</literal></expr></argument>,
                     <argument><expr><name>AGTENTRY_OFFLENMASK</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/*
         * Convert each AGT_OFFSET_STRIDE'th length to an offset.
         */</comment>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>i</name> <operator>+</operator> <name>num_pairs</name><operator>)</operator> <operator>%</operator> <name>AGT_OFFSET_STRIDE</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>meta</name> <operator>=</operator> <operator>(</operator><name>meta</name> <operator>&amp;</operator> <name>AGTENTRY_TYPEMASK</name><operator>)</operator> <operator>|</operator> <name>totallen</name> <operator>|</operator> <name>AGTENTRY_HAS_OFF</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><call><name>copy_to_buffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>agtentry_offset</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>meta</name></expr></argument>,
                       <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>agtentry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>agtentry_offset</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>agtentry</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    </block_content>}</block></for>

    <comment type="block">/* Total data size is everything we've appended to buffer */</comment>
    <expr_stmt><expr><name>totallen</name> <operator>=</operator> <name><name>buffer</name><operator>-&gt;</operator><name>len</name></name> <operator>-</operator> <name>base_offset</name></expr>;</expr_stmt>

    <comment type="block">/* Check length again, since we didn't include the metadata above */</comment>
    <if_stmt><if>if <condition>(<expr><name>totallen</name> <operator>&gt;</operator> <name>AGTENTRY_OFFLENMASK</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(
            <argument><expr><name>ERROR</name></expr></argument>,
            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROGRAM_LIMIT_EXCEEDED</name></expr></argument>)</argument_list></call><operator>,</operator>
             <call><name>errmsg</name><argument_list>(
                 <argument><expr><literal type="string">"total size of agtype object elements exceeds the maximum of %u bytes"</literal></expr></argument>,
                 <argument><expr><name>AGTENTRY_OFFLENMASK</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Initialize the header of this node in the container's agtentry array */</comment>
    <expr_stmt><expr><operator>*</operator><name>pheader</name> <operator>=</operator> <name>AGTENTRY_IS_CONTAINER</name> <operator>|</operator> <name>totallen</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>convert_agtype_scalar</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><name>agtentry</name> <modifier>*</modifier></type><name>entry</name></decl></parameter>,
                                  <parameter><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>scalar_val</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>numlen</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>short</name></type> <name>padlen</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>status</name></decl>;</decl_stmt>

    <switch>switch <condition>(<expr><name><name>scalar_val</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition>
    <block>{<block_content>
    <case>case <expr><name>AGTV_NULL</name></expr>:</case>
        <expr_stmt><expr><operator>*</operator><name>entry</name> <operator>=</operator> <name>AGTENTRY_IS_NULL</name></expr>;</expr_stmt>
        <break>break;</break>

    <case>case <expr><name>AGTV_STRING</name></expr>:</case>
        <expr_stmt><expr><call><name>append_to_buffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name><name>scalar_val</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>val</name></name></expr></argument>,
                         <argument><expr><name><name>scalar_val</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><operator>*</operator><name>entry</name> <operator>=</operator> <name><name>scalar_val</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>len</name></name></expr>;</expr_stmt>
        <break>break;</break>

    <case>case <expr><name>AGTV_NUMERIC</name></expr>:</case>
        <expr_stmt><expr><name>numlen</name> <operator>=</operator> <call><name>VARSIZE_ANY</name><argument_list>(<argument><expr><name><name>scalar_val</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>numeric</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>padlen</name> <operator>=</operator> <call><name>pad_buffer_to_int</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>append_to_buffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>scalar_val</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>numeric</name></name></expr></argument>, <argument><expr><name>numlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><operator>*</operator><name>entry</name> <operator>=</operator> <name>AGTENTRY_IS_NUMERIC</name> <operator>|</operator> <operator>(</operator><name>padlen</name> <operator>+</operator> <name>numlen</name><operator>)</operator></expr>;</expr_stmt>
        <break>break;</break>

    <case>case <expr><name>AGTV_BOOL</name></expr>:</case>
        <expr_stmt><expr><operator>*</operator><name>entry</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>scalar_val</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>boolean</name></name><operator>)</operator></expr> ?</condition><then> <expr><name>AGTENTRY_IS_BOOL_TRUE</name></expr> </then><else>:
                                             <expr><name>AGTENTRY_IS_BOOL_FALSE</name></expr></else></ternary></expr>;</expr_stmt>
        <break>break;</break>

    <default>default:</default>
        <comment type="block">/* returns true if there was a valid extended type processed */</comment>
        <expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>ag_serialize_extended_type</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>entry</name></expr></argument>, <argument><expr><name>scalar_val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* if nothing was found, error log out */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>status</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid agtype scalar type %d to convert"</literal></expr></argument>,
                                   <argument><expr><name><name>scalar_val</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 * Compare two AGTV_STRING agtype_value values, a and b.
 *
 * This is a special qsort() comparator used to sort strings in certain
 * internal contexts where it is sufficient to have a well-defined sort order.
 * In particular, object pair keys are sorted according to this criteria to
 * facilitate cheap binary searches where we don't care about lexical sort
 * order.
 *
 * a and b are first sorted based on their length.  If a tie-breaker is
 * required, only then do we consider string binary equality.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>length_compare_agtype_string_value</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>agtype_value</name> <modifier>*</modifier></type><name>va</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>agtype_value</name> <operator>*</operator><operator>)</operator><name>a</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>agtype_value</name> <modifier>*</modifier></type><name>vb</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>agtype_value</name> <operator>*</operator><operator>)</operator><name>b</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>va</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AGTV_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>vb</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AGTV_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>va</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>len</name></name> <operator>==</operator> <name><name>vb</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>len</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>memcmp</name><argument_list>(<argument><expr><name><name>va</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>val</name></name></expr></argument>, <argument><expr><name><name>vb</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>val</name></name></expr></argument>,
                     <argument><expr><name><name>va</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name>res</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>va</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>len</name></name> <operator>&gt;</operator> <name><name>vb</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>len</name></name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * qsort_arg() comparator to compare agtype_pair values.
 *
 * Third argument 'binequal' may point to a bool. If it's set, *binequal is set
 * to true iff a and b have full binary equality, since some callers have an
 * interest in whether the two values are equal or merely equivalent.
 *
 * N.B: String comparisons here are "length-wise"
 *
 * Pairs with equals keys are ordered such that the order field is respected.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>length_compare_agtype_pair</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>,
                                      <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>binequal</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>agtype_pair</name> <modifier>*</modifier></type><name>pa</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>agtype_pair</name> <operator>*</operator><operator>)</operator><name>a</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>agtype_pair</name> <modifier>*</modifier></type><name>pb</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>agtype_pair</name> <operator>*</operator><operator>)</operator><name>b</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>length_compare_agtype_string_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pa</name><operator>-&gt;</operator><name>key</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pb</name><operator>-&gt;</operator><name>key</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>res</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>binequal</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>*</operator><operator>(</operator><operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator><name>binequal</name><operator>)</operator> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Guarantee keeping order of equal pair.  Unique algorithm will prefer
     * first element as value.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>res</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>res</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>pa</name><operator>-&gt;</operator><name>order</name></name> <operator>&gt;</operator> <name><name>pb</name><operator>-&gt;</operator><name>order</name></name><operator>)</operator></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Sort and unique-ify pairs in agtype_value object
 */</comment>
<function><type><name>void</name></type> <name>uniqueify_agtype_object</name><parameter_list>(<parameter><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>object</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>bool</name></type> <name>has_non_uniq</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>object</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AGTV_OBJECT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>object</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>object</name><operator>.</operator><name>num_pairs</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>qsort_arg</name><argument_list>(<argument><expr><name><name>object</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>object</name><operator>.</operator><name>pairs</name></name></expr></argument>, <argument><expr><name><name>object</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>object</name><operator>.</operator><name>num_pairs</name></name></expr></argument>,
                  <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>agtype_pair</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>length_compare_agtype_pair</name></expr></argument>,
                  <argument><expr><operator>&amp;</operator><name>has_non_uniq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>has_non_uniq</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>agtype_pair</name> <modifier>*</modifier></type><name>ptr</name> <init>= <expr><name><name>object</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>object</name><operator>.</operator><name>pairs</name></name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>agtype_pair</name> <modifier>*</modifier></type><name>res</name> <init>= <expr><name><name>object</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>object</name><operator>.</operator><name>pairs</name></name></expr></init></decl>;</decl_stmt>

        <while>while <condition>(<expr><name>ptr</name> <operator>-</operator> <name><name>object</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>object</name><operator>.</operator><name>pairs</name></name> <operator>&lt;</operator> <name><name>object</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>object</name><operator>.</operator><name>num_pairs</name></name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* Avoid copying over duplicate */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>length_compare_agtype_string_value</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>res</name><operator>++</operator></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>!=</operator> <name>res</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>agtype_pair</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
            <expr_stmt><expr><name>ptr</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></while>

        <expr_stmt><expr><name><name>object</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>object</name><operator>.</operator><name>num_pairs</name></name> <operator>=</operator> <name>res</name> <operator>+</operator> <literal type="number">1</literal> <operator>-</operator> <name><name>object</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>object</name><operator>.</operator><name>pairs</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>char</name> <modifier>*</modifier></type><name>agtype_value_type_to_string</name><parameter_list>(<parameter><decl><type><name><name>enum</name> <name>agtype_value_type</name></name></type> <name>type</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <switch>switch <condition>(<expr><name>type</name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>AGTV_NULL</name></expr>:</case>
            <return>return <expr><literal type="string">"NULL"</literal></expr>;</return>
        <case>case <expr><name>AGTV_STRING</name></expr>:</case>
            <return>return <expr><literal type="string">"string"</literal></expr>;</return>
        <case>case <expr><name>AGTV_NUMERIC</name></expr>:</case>
            <return>return <expr><literal type="string">"numeric"</literal></expr>;</return>
        <case>case <expr><name>AGTV_INTEGER</name></expr>:</case>
            <return>return <expr><literal type="string">"integer"</literal></expr>;</return>
        <case>case <expr><name>AGTV_FLOAT</name></expr>:</case>
            <return>return <expr><literal type="string">"float"</literal></expr>;</return>
        <case>case <expr><name>AGTV_BOOL</name></expr>:</case>
            <return>return <expr><literal type="string">"boolean"</literal></expr>;</return>
        <case>case <expr><name>AGTV_VERTEX</name></expr>:</case>
            <return>return <expr><literal type="string">"vertex"</literal></expr>;</return>
        <case>case <expr><name>AGTV_EDGE</name></expr>:</case>
            <return>return <expr><literal type="string">"edge"</literal></expr>;</return>
        <case>case <expr><name>AGTV_ARRAY</name></expr>:</case>
            <return>return <expr><literal type="string">"array"</literal></expr>;</return>
        <case>case <expr><name>AGTV_OBJECT</name></expr>:</case>
            <return>return <expr><literal type="string">"map"</literal></expr>;</return>
        <case>case <expr><name>AGTV_BINARY</name></expr>:</case>
            <return>return <expr><literal type="string">"binary"</literal></expr>;</return>
        <default>default:</default>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                            <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unknown agtype"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></switch>

    <return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>
</unit>
