<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/workspace/age/src/backend/parser/cypher_parse_agg.c"><comment type="block">/*
 * For PostgreSQL Database Management System:
 * (formerly known as Postgres, then as Postgres95)
 *
 * Portions Copyright (c) 1996-2010, The PostgreSQL Global Development Group
 *
 * Portions Copyright (c) 1994, The Regents of the University of California
 *
 * Permission to use, copy, modify, and distribute this software and its documentation for any purpose,
 * without fee, and without a written agreement is hereby granted, provided that the above copyright notice
 * and this paragraph and the following two paragraphs appear in all copies.
 *
 * IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR DIRECT,
 * INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS,
 * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF THE UNIVERSITY
 * OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
 * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 *
 * THE SOFTWARE PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND THE UNIVERSITY OF CALIFORNIA
 * HAS NO OBLIGATIONS TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_constraint.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodeFuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/tlist.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/var.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/cypher_parse_agg.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parsetree.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"rewrite/rewriteManip.h"</cpp:file></cpp:include>

<typedef>typedef <type><struct>struct
<block>{
    <decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>min_varlevel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>min_agglevel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>sublevels_up</name></decl>;</decl_stmt>
}</block></struct></type> <name>check_agg_arguments_context</name>;</typedef>

<typedef>typedef <type><struct>struct
<block>{
    <decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>qry</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>groupClauses</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>groupClauseCommonVars</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>have_non_var_grouping</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>func_grouped_rels</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>sublevels_up</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>in_agg_direct_args</name></decl>;</decl_stmt>
}</block></struct></type> <name>check_ungrouped_columns_context</name>;</typedef>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>check_ungrouped_columns</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>qry</name></decl></parameter>,
                                    <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>groupClauses</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>groupClauseVars</name></decl></parameter>,
                                    <parameter><decl><type><name>bool</name></type> <name>have_non_var_grouping</name></decl></parameter>,
                                    <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>func_grouped_rels</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>check_ungrouped_columns_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
                                           <parameter><decl><type><name>check_ungrouped_columns_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>finalize_grouping_exprs</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>qry</name></decl></parameter>,
                                    <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>groupClauses</name></decl></parameter>, <parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
                                    <parameter><decl><type><name>bool</name></type> <name>have_non_var_grouping</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>finalize_grouping_exprs_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
                                           <parameter><decl><type><name>check_ungrouped_columns_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>expand_groupingset_node</name><parameter_list>(<parameter><decl><type><name>GroupingSet</name> <modifier>*</modifier></type><name>gs</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>expand_grouping_sets</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>groupingSets</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>limit</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * From PG's parseCheckAggregates
 *
 * Check for aggregates where they shouldn't be and improper grouping.
 * This function should be called after the target list and qualifications
 * are finalized.
 *
 * Misplaced aggregates are now mostly detected in transformAggregateCall,
 * but it seems more robust to check for aggregates in recursive queries
 * only after everything is finalized.  In any case it's hard to detect
 * improper grouping on-the-fly, so we have to make another pass over the
 * query for that.
 */</comment>
<function><type><name>void</name></type> <name>parse_check_aggregates</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>qry</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>gset_common</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>groupClauses</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>groupClauseCommonVars</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>have_non_var_grouping</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>func_grouped_rels</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>hasJoinRTEs</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>hasSelfRefRTEs</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>clause</name></decl>;</decl_stmt>

    <comment type="block">/* This should only be called if we found aggregates or grouping */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_hasAggs</name></name> <operator>||</operator> <name><name>qry</name><operator>-&gt;</operator><name>groupClause</name></name> <operator>||</operator> <name><name>qry</name><operator>-&gt;</operator><name>havingQual</name></name> <operator>||</operator> <name><name>qry</name><operator>-&gt;</operator><name>groupingSets</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * If we have grouping sets, expand them and find the intersection of all
     * sets.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>qry</name><operator>-&gt;</operator><name>groupingSets</name></name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * The limit of 4096 is arbitrary and exists simply to avoid resource
         * issues from pathological constructs.
         */</comment>
        <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>gsets</name> <init>= <expr><call><name>expand_grouping_sets</name><argument_list>(<argument><expr><name><name>qry</name><operator>-&gt;</operator><name>groupingSets</name></name></expr></argument>, <argument><expr><literal type="number">4096</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>gsets</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_STATEMENT_TOO_COMPLEX</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"too many grouping sets present (maximum 4096)"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
                                        <argument><expr><ternary><condition><expr><name><name>qry</name><operator>-&gt;</operator><name>groupClause</name></name></expr> ?</condition><then>
                                        <expr><call><name>exprLocation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>qry</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>)</argument_list></call></expr> </then><else>:
                                        <expr><call><name>exprLocation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>qry</name><operator>-&gt;</operator><name>groupingSets</name></name></expr></argument>)</argument_list></call></expr></else></ternary></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <comment type="block">/*
         * The intersection will often be empty, so help things along by
         * seeding the intersect with the smallest set.
         */</comment>
        <expr_stmt><expr><name>gset_common</name> <operator>=</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>gsets</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>gset_common</name></expr>)</condition>
        <block>{<block_content>
            <macro><name>for_each_cell</name><argument_list>(<argument>l</argument>, <argument>lnext(list_head(gsets))</argument>)</argument_list></macro>
            <block>{<block_content>
                <expr_stmt><expr><name>gset_common</name> <operator>=</operator> <call><name>list_intersection_int</name><argument_list>(<argument><expr><name>gset_common</name></expr></argument>, <argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><operator>!</operator><name>gset_common</name></expr>)</condition><block type="pseudo"><block_content>
                    <break>break;</break></block_content></block></if></if_stmt>
            </block_content>}</block>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/*
         * If there was only one grouping set in the expansion, AND if the
         * groupClause is non-empty (meaning that the grouping set is not
         * empty either), then we can ditch the grouping set and pretend we
         * just had a normal GROUP BY.
         */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>gsets</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>qry</name><operator>-&gt;</operator><name>groupClause</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>groupingSets</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Scan the range table to see if there are JOIN or self-reference CTE
     * entries.  We'll need this info below.
     */</comment>
    <expr_stmt><expr><name>hasJoinRTEs</name> <operator>=</operator> <name>hasSelfRefRTEs</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>pstate-&gt;p_rtable</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><operator>(</operator><name>RangeTblEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_JOIN</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>hasJoinRTEs</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_CTE</name> <operator>&amp;&amp;</operator> <name><name>rte</name><operator>-&gt;</operator><name>self_reference</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>hasSelfRefRTEs</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block>

    <comment type="block">/*
     * Build a list of the acceptable GROUP BY expressions for use by
     * check_ungrouped_columns().
     *
     * We get the TLE, not just the expr, because GROUPING wants to know the
     * sortgroupref.
     */</comment>
    <macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>qry-&gt;groupClause</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>SortGroupClause</name> <modifier>*</modifier></type><name>grpcl</name> <init>= <expr><operator>(</operator><name>SortGroupClause</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>expr</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>expr</name> <operator>=</operator> <call><name>get_sortgroupclause_tle</name><argument_list>(<argument><expr><name>grpcl</name></expr></argument>, <argument><expr><name><name>qry</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>expr</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt> <comment type="block">/* probably cannot happen */</comment>

        <expr_stmt><expr><name>groupClauses</name> <operator>=</operator> <call><name>lcons</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>groupClauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>

    <comment type="block">/*
     * If there are join alias vars involved, we have to flatten them to the
     * underlying vars, so that aliased and unaliased vars will be correctly
     * taken as equal.  We can skip the expense of doing this if no rangetable
     * entries are RTE_JOIN kind. We use the planner's flatten_join_alias_vars
     * routine to do the flattening; it wants a PlannerInfo root node, which
     * fortunately can be mostly dummy.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>hasJoinRTEs</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>root</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>PlannerInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>parse</name></name> <operator>=</operator> <name>qry</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>planner_cxt</name></name> <operator>=</operator> <name>CurrentMemoryContext</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>hasJoinRTEs</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

        <expr_stmt><expr><name>groupClauses</name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>flatten_join_alias_vars</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
                                                        <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>groupClauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Detect whether any of the grouping expressions aren't simple Vars; if
     * they're all Vars then we don't have to work so hard in the recursive
     * scans.  (Note we have to flatten aliases before this.)
     *
     * Track Vars that are included in all grouping sets separately in
     * groupClauseCommonVars, since these are the only ones we can use to
     * check for functional dependencies.
     */</comment>
    <expr_stmt><expr><name>have_non_var_grouping</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>groupClauses</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>have_non_var_grouping</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><operator>!</operator><name><name>qry</name><operator>-&gt;</operator><name>groupingSets</name></name> <operator>||</operator>
                 <call><name>list_member_int</name><argument_list>(<argument><expr><name>gset_common</name></expr></argument>, <argument><expr><name><name>tle</name><operator>-&gt;</operator><name>ressortgroupref</name></name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>groupClauseCommonVars</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>groupClauseCommonVars</name></expr></argument>, <argument><expr><name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block>

    <comment type="block">/*
     * Check the targetlist and HAVING clause for ungrouped variables.
     *
     * Note: because we check resjunk tlist elements as well as regular ones,
     * this will also find ungrouped variables that came from ORDER BY and
     * WINDOW clauses.  For that matter, it's also going to examine the
     * grouping expressions themselves --- but they'll all pass the test ...
     *
     * We also finalize GROUPING expressions, but for that we need to traverse
     * the original (unflattened) clause in order to modify nodes.
     */</comment>
    <expr_stmt><expr><name>clause</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>qry</name><operator>-&gt;</operator><name>targetList</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>finalize_grouping_exprs</name><argument_list>(<argument><expr><name>clause</name></expr></argument>, <argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>qry</name></expr></argument>, <argument><expr><name>groupClauses</name></expr></argument>, <argument><expr><name>root</name></expr></argument>,
                            <argument><expr><name>have_non_var_grouping</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>hasJoinRTEs</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>clause</name> <operator>=</operator> <call><name>flatten_join_alias_vars</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>clause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>check_ungrouped_columns</name><argument_list>(<argument><expr><name>clause</name></expr></argument>, <argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>qry</name></expr></argument>, <argument><expr><name>groupClauses</name></expr></argument>,
                            <argument><expr><name>groupClauseCommonVars</name></expr></argument>, <argument><expr><name>have_non_var_grouping</name></expr></argument>,
                            <argument><expr><operator>&amp;</operator><name>func_grouped_rels</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>clause</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>qry</name><operator>-&gt;</operator><name>havingQual</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>finalize_grouping_exprs</name><argument_list>(<argument><expr><name>clause</name></expr></argument>, <argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>qry</name></expr></argument>, <argument><expr><name>groupClauses</name></expr></argument>, <argument><expr><name>root</name></expr></argument>,
                            <argument><expr><name>have_non_var_grouping</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>hasJoinRTEs</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>clause</name> <operator>=</operator> <call><name>flatten_join_alias_vars</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>clause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>check_ungrouped_columns</name><argument_list>(<argument><expr><name>clause</name></expr></argument>, <argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>qry</name></expr></argument>, <argument><expr><name>groupClauses</name></expr></argument>,
                            <argument><expr><name>groupClauseCommonVars</name></expr></argument>, <argument><expr><name>have_non_var_grouping</name></expr></argument>,
                            <argument><expr><operator>&amp;</operator><name>func_grouped_rels</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Per spec, aggregates can't appear in a recursive term.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>pstate</name><operator>-&gt;</operator><name>p_hasAggs</name></name> <operator>&amp;&amp;</operator> <name>hasSelfRefRTEs</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_RECURSION</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"aggregate functions are not allowed in a recursive query's recursive term"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><call><name>locate_agg_of_level</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>qry</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * check_ungrouped_columns -
 *
 * Scan the given expression tree for ungrouped variables (variables
 * that are not listed in the groupClauses list and are not within
 * the arguments of aggregate functions).  Emit a suitable error message
 * if any are found.
 *
 * NOTE: we assume that the given clause has been transformed suitably for
 * parser output.  This means we can use expression_tree_walker.
 *
 * NOTE: we recognize grouping expressions in the main query, but only
 * grouping Vars in subqueries.  For example, this will be rejected,
 * although it could be allowed:
 *    SELECT (SELECT x FROM bar where y = (foo.a + foo.b))
 *    FROM foo
 *    GROUP BY a + b;
 * The difficulty is the need to account for different sublevels_up.
 * This appears to require a whole custom version of equal(), which is
 * way more pain than the feature seems worth.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>check_ungrouped_columns</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>qry</name></decl></parameter>,
                                    <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>groupClauses</name></decl></parameter>,
                                    <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>groupClauseCommonVars</name></decl></parameter>,
                                    <parameter><decl><type><name>bool</name></type> <name>have_non_var_grouping</name></decl></parameter>,
                                    <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>func_grouped_rels</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>check_ungrouped_columns_context</name></type> <name>context</name></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>context</name><operator>.</operator><name>pstate</name></name> <operator>=</operator> <name>pstate</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>context</name><operator>.</operator><name>qry</name></name> <operator>=</operator> <name>qry</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>context</name><operator>.</operator><name>root</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>context</name><operator>.</operator><name>groupClauses</name></name> <operator>=</operator> <name>groupClauses</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>context</name><operator>.</operator><name>groupClauseCommonVars</name></name> <operator>=</operator> <name>groupClauseCommonVars</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>context</name><operator>.</operator><name>have_non_var_grouping</name></name> <operator>=</operator> <name>have_non_var_grouping</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>context</name><operator>.</operator><name>func_grouped_rels</name></name> <operator>=</operator> <name>func_grouped_rels</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>context</name><operator>.</operator><name>sublevels_up</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>context</name><operator>.</operator><name>in_agg_direct_args</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>check_ungrouped_columns_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>check_ungrouped_columns_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>check_ungrouped_columns_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>gl</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Param</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt> <comment type="block">/* constants are always acceptable */</comment>

    <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Aggref</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Aggref</name> <modifier>*</modifier></type><name>agg</name> <init>= <expr><operator>(</operator><name>Aggref</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>agg</name><operator>-&gt;</operator><name>agglevelsup</name></name> <operator>==</operator> <name><name>context</name><operator>-&gt;</operator><name>sublevels_up</name></name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * If we find an aggregate call of the original level, do not
             * recurse into its normal arguments, ORDER BY arguments, or
             * filter; ungrouped vars there are not an error.  But we should
             * check direct arguments as though they weren't in an aggregate.
             * We set a special flag in the context to help produce a useful
             * error message for ungrouped vars in direct arguments.
             */</comment>
            <decl_stmt><decl><type><name>bool</name></type> <name>result</name></decl>;</decl_stmt>

            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>context</name><operator>-&gt;</operator><name>in_agg_direct_args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>in_agg_direct_args</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>check_ungrouped_columns_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>agg</name><operator>-&gt;</operator><name>aggdirectargs</name></name></expr></argument>,
                                                    <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>in_agg_direct_args</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            <return>return <expr><name>result</name></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/*
         * We can skip recursing into aggregates of higher levels altogether,
         * since they could not possibly contain Vars of concern to us (see
         * transformAggregateCall).  We do need to look at aggregates of lower
         * levels, however.
         */</comment>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>agg</name><operator>-&gt;</operator><name>agglevelsup</name></name> <operator>&gt;</operator> <name><name>context</name><operator>-&gt;</operator><name>sublevels_up</name></name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>GroupingFunc</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>GroupingFunc</name> <modifier>*</modifier></type><name>grp</name> <init>= <expr><operator>(</operator><name>GroupingFunc</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

        <comment type="block">/* handled GroupingFunc separately, no need to recheck at this level */</comment>

        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>grp</name><operator>-&gt;</operator><name>agglevelsup</name></name> <operator>&gt;=</operator> <name><name>context</name><operator>-&gt;</operator><name>sublevels_up</name></name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * If we have any GROUP BY items that are not simple Vars, check to see if
     * subexpression as a whole matches any GROUP BY item. We need to do this
     * at every recursion level so that we recognize GROUPed-BY expressions
     * before reaching variables within them. But this only works at the outer
     * query level, as noted above.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>have_non_var_grouping</name></name> <operator>&amp;&amp;</operator> <name><name>context</name><operator>-&gt;</operator><name>sublevels_up</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <macro><name>foreach</name><argument_list>(<argument>gl</argument>, <argument>context-&gt;groupClauses</argument>)</argument_list></macro>
        <block>{<block_content>
            <decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>gl</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><call><name>equal</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt> <comment type="block">/* acceptable, do not descend more */</comment>
        </block_content>}</block>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * If we have an ungrouped Var of the original query level, we have a
     * failure.  Vars below the original query level are not a problem, and
     * neither are Vars from above it.  (If such Vars are ungrouped as far as
     * their own query level is concerned, that's someone else's problem...)
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>var</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>attname</name></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>varlevelsup</name></name> <operator>!=</operator> <name><name>context</name><operator>-&gt;</operator><name>sublevels_up</name></name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt> <comment type="block">/* it's not local to my query, ignore */</comment>

        <comment type="block">/*
         * Check for a match, if we didn't do it above.
         */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>context</name><operator>-&gt;</operator><name>have_non_var_grouping</name></name> <operator>||</operator> <name><name>context</name><operator>-&gt;</operator><name>sublevels_up</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <macro><name>foreach</name><argument_list>(<argument>gl</argument>, <argument>context-&gt;groupClauses</argument>)</argument_list></macro>
            <block>{<block_content>
                <decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>gvar</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>gl</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>expr</name></expr></init></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>gvar</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
                    <name><name>gvar</name><operator>-&gt;</operator><name>varno</name></name> <operator>==</operator> <name><name>var</name><operator>-&gt;</operator><name>varno</name></name> <operator>&amp;&amp;</operator>
                    <name><name>gvar</name><operator>-&gt;</operator><name>varattno</name></name> <operator>==</operator> <name><name>var</name><operator>-&gt;</operator><name>varattno</name></name> <operator>&amp;&amp;</operator>
                    <name><name>gvar</name><operator>-&gt;</operator><name>varlevelsup</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                    <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt> <comment type="block">/* acceptable, we're okay */</comment>
            </block_content>}</block>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/*
         * Check whether the Var is known functionally dependent on the GROUP
         * BY columns.  If so, we can allow the Var to be used, because the
         * grouping is really a no-op for this table.  However, this deduction
         * depends on one or more constraints of the table, so we have to add
         * those constraints to the query's constraintDeps list, because it's
         * not semantically valid anymore if the constraint(s) get dropped.
         * (Therefore, this check must be the last-ditch effort before raising
         * error: we don't want to add dependencies unnecessarily.)
         *
         * Because this is a pretty expensive check, and will have the same
         * outcome for all columns of a table, we remember which RTEs we've
         * already proven functional dependency for in the func_grouped_rels
         * list.  This test also prevents us from adding duplicate entries to
         * the constraintDeps list.
         */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>list_member_int</name><argument_list>(<argument><expr><operator>*</operator><name><name>context</name><operator>-&gt;</operator><name>func_grouped_rels</name></name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varno</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt> <comment type="block">/* previously proven acceptable */</comment>

        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>varno</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
               <operator>(</operator><name>int</name><operator>)</operator> <name><name>var</name><operator>-&gt;</operator><name>varno</name></name> <operator>&lt;=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>pstate</name><operator>-&gt;</operator><name>p_rtable</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>rt_fetch</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>varno</name></name></expr></argument>, <argument><expr><name><name>context</name><operator>-&gt;</operator><name>pstate</name><operator>-&gt;</operator><name>p_rtable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_RELATION</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name>check_functional_grouping</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varno</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
                                          <argument><expr><name><name>context</name><operator>-&gt;</operator><name>groupClauseCommonVars</name></name></expr></argument>,
                                          <argument><expr><operator>&amp;</operator><name><name>context</name><operator>-&gt;</operator><name>qry</name><operator>-&gt;</operator><name>constraintDeps</name></name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><operator>*</operator><name><name>context</name><operator>-&gt;</operator><name>func_grouped_rels</name></name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><operator>*</operator><name><name>context</name><operator>-&gt;</operator><name>func_grouped_rels</name></name></expr></argument>,
                                                          <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><name>false</name></expr>;</return> <comment type="block">/* acceptable */</comment>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Found an ungrouped local variable; generate error message */</comment>
        <expr_stmt><expr><name>attname</name> <operator>=</operator> <call><name>get_rte_attribute_name</name><argument_list>(<argument><expr><name>rte</name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>sublevels_up</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_GROUPING_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                            <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\" must be either part of an explicitly listed key or used inside an aggregate function"</literal></expr></argument>,
                                   <argument><expr><name>attname</name></expr></argument>)</argument_list></call><operator>,</operator> <ternary><condition><expr><name><name>context</name><operator>-&gt;</operator><name>in_agg_direct_args</name></name></expr> ?</condition><then>
                                       <expr><call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Direct arguments of an ordered-set aggregate must use only grouped columns."</literal></expr></argument>)</argument_list></call></expr> </then><else>:
                                       <expr><literal type="number">0</literal></expr></else></ternary><operator>,</operator> <call><name>parser_errposition</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>pstate</name></name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_GROUPING_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                            <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"subquery uses ungrouped column \"%s.%s\" from outer query"</literal></expr></argument>,
                                   <argument><expr><name><name>rte</name><operator>-&gt;</operator><name>eref</name><operator>-&gt;</operator><name>aliasname</name></name></expr></argument>, <argument><expr><name>attname</name></expr></argument>)</argument_list></call><operator>,</operator>
                                   <call><name>parser_errposition</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>pstate</name></name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Recurse into subselects */</comment>
        <decl_stmt><decl><type><name>bool</name></type> <name>result</name></decl>;</decl_stmt>

        <expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>sublevels_up</name></name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>query_tree_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
                                   <argument><expr><name>check_ungrouped_columns_walker</name></expr></argument>,
                                   <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>context</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>sublevels_up</name></name><operator>--</operator></expr>;</expr_stmt>
        <return>return <expr><name>result</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>check_ungrouped_columns_walker</name></expr></argument>,
                                  <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>context</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * finalize_grouping_exprs -
 *	  Scan the given expression tree for GROUPING() and related calls,
 *	  and validate and process their arguments.
 *
 * This is split out from check_ungrouped_columns above because it needs
 * to modify the nodes (which it does in-place, not via a mutator) while
 * check_ungrouped_columns may see only a copy of the original thanks to
 * flattening of join alias vars. So here, we flatten each individual
 * GROUPING argument as we see it before comparing it.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>finalize_grouping_exprs</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>qry</name></decl></parameter>,
                                    <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>groupClauses</name></decl></parameter>, <parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
                                    <parameter><decl><type><name>bool</name></type> <name>have_non_var_grouping</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>check_ungrouped_columns_context</name></type> <name>context</name></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>context</name><operator>.</operator><name>pstate</name></name> <operator>=</operator> <name>pstate</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>context</name><operator>.</operator><name>qry</name></name> <operator>=</operator> <name>qry</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>context</name><operator>.</operator><name>root</name></name> <operator>=</operator> <name>root</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>context</name><operator>.</operator><name>groupClauses</name></name> <operator>=</operator> <name>groupClauses</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>context</name><operator>.</operator><name>groupClauseCommonVars</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>context</name><operator>.</operator><name>have_non_var_grouping</name></name> <operator>=</operator> <name>have_non_var_grouping</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>context</name><operator>.</operator><name>func_grouped_rels</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>context</name><operator>.</operator><name>sublevels_up</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>context</name><operator>.</operator><name>in_agg_direct_args</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>finalize_grouping_exprs_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>finalize_grouping_exprs_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
                                           <parameter><decl><type><name>check_ungrouped_columns_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>gl</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Param</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt> <comment type="block">/* constants are always acceptable */</comment>

    <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Aggref</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Aggref</name> <modifier>*</modifier></type><name>agg</name> <init>= <expr><operator>(</operator><name>Aggref</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>agg</name><operator>-&gt;</operator><name>agglevelsup</name></name> <operator>==</operator> <name><name>context</name><operator>-&gt;</operator><name>sublevels_up</name></name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/*
             * If we find an aggregate call of the original level, do not
             * recurse into its normal arguments, ORDER BY arguments, or
             * filter; GROUPING exprs of this level are not allowed there. But
             * check direct arguments as though they weren't in an aggregate.
             */</comment>
            <decl_stmt><decl><type><name>bool</name></type> <name>result</name></decl>;</decl_stmt>

            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>context</name><operator>-&gt;</operator><name>in_agg_direct_args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>in_agg_direct_args</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>finalize_grouping_exprs_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>agg</name><operator>-&gt;</operator><name>aggdirectargs</name></name></expr></argument>,
                                                <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>in_agg_direct_args</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            <return>return <expr><name>result</name></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/*
         * We can skip recursing into aggregates of higher levels altogether,
         * since they could not possibly contain exprs of concern to us (see
         * transformAggregateCall).  We do need to look at aggregates of lower
         * levels, however.
         */</comment>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>agg</name><operator>-&gt;</operator><name>agglevelsup</name></name> <operator>&gt;</operator> <name><name>context</name><operator>-&gt;</operator><name>sublevels_up</name></name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>GroupingFunc</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>GroupingFunc</name> <modifier>*</modifier></type><name>grp</name> <init>= <expr><operator>(</operator><name>GroupingFunc</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

        <comment type="block">/*
         * We only need to check GroupingFunc nodes at the exact level to
         * which they belong, since they cannot mix levels in arguments.
         */</comment>

        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>grp</name><operator>-&gt;</operator><name>agglevelsup</name></name> <operator>==</operator> <name><name>context</name><operator>-&gt;</operator><name>sublevels_up</name></name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>ref_list</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

            <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>grp-&gt;args</argument>)</argument_list></macro>
            <block>{<block_content>
                <decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>expr</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>Index</name></type> <name>ref</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>root</name></name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>expr</name> <operator>=</operator> <call><name>flatten_join_alias_vars</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>root</name></name></expr></argument>, <argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                <comment type="block">/*
                 * Each expression must match a grouping entry at the current
                 * query level. Unlike the general expression case, we don't
                 * allow functional dependencies or outer references.
                 */</comment>

                <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>var</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></init></decl>;</decl_stmt>

                    <if_stmt><if>if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>varlevelsup</name></name> <operator>==</operator> <name><name>context</name><operator>-&gt;</operator><name>sublevels_up</name></name></expr>)</condition>
                    <block>{<block_content>
                        <macro><name>foreach</name><argument_list>(<argument>gl</argument>, <argument>context-&gt;groupClauses</argument>)</argument_list></macro>
                        <block>{<block_content>
                            <decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>gl</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                            <decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>gvar</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></init></decl>;</decl_stmt>

                            <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>gvar</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
                                <name><name>gvar</name><operator>-&gt;</operator><name>varno</name></name> <operator>==</operator> <name><name>var</name><operator>-&gt;</operator><name>varno</name></name> <operator>&amp;&amp;</operator>
                                <name><name>gvar</name><operator>-&gt;</operator><name>varattno</name></name> <operator>==</operator> <name><name>var</name><operator>-&gt;</operator><name>varattno</name></name> <operator>&amp;&amp;</operator>
                                <name><name>gvar</name><operator>-&gt;</operator><name>varlevelsup</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
                            <block>{<block_content>
                                <expr_stmt><expr><name>ref</name> <operator>=</operator> <name><name>tle</name><operator>-&gt;</operator><name>ressortgroupref</name></name></expr>;</expr_stmt>
                                <break>break;</break>
                            </block_content>}</block></if></if_stmt>
                        </block_content>}</block>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></if>
                <if type="elseif">else if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>have_non_var_grouping</name></name> <operator>&amp;&amp;</operator>
                         <name><name>context</name><operator>-&gt;</operator><name>sublevels_up</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
                <block>{<block_content>
                    <macro><name>foreach</name><argument_list>(<argument>gl</argument>, <argument>context-&gt;groupClauses</argument>)</argument_list></macro>
                    <block>{<block_content>
                        <decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>gl</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                        <if_stmt><if>if <condition>(<expr><call><name>equal</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>)</condition>
                        <block>{<block_content>
                           <expr_stmt><expr><name>ref</name> <operator>=</operator> <name><name>tle</name><operator>-&gt;</operator><name>ressortgroupref</name></name></expr>;</expr_stmt>
                           <break>break;</break>
                        </block_content>}</block></if></if_stmt>
                    </block_content>}</block>
                </block_content>}</block></if></if_stmt>

                <if_stmt><if>if <condition>(<expr><name>ref</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_GROUPING_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"arguments to GROUPING must be grouping expressions of the associated query level"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>parser_errposition</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>pstate</name></name></expr></argument>,
                             <argument><expr><call><name>exprLocation</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

                <expr_stmt><expr><name>ref_list</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>ref_list</name></expr></argument>, <argument><expr><name>ref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block>

            <expr_stmt><expr><name><name>grp</name><operator>-&gt;</operator><name>refs</name></name> <operator>=</operator> <name>ref_list</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>grp</name><operator>-&gt;</operator><name>agglevelsup</name></name> <operator>&gt;</operator> <name><name>context</name><operator>-&gt;</operator><name>sublevels_up</name></name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Recurse into subselects */</comment>
        <decl_stmt><decl><type><name>bool</name></type> <name>result</name></decl>;</decl_stmt>

        <expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>sublevels_up</name></name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>query_tree_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
                                   <argument><expr><name>finalize_grouping_exprs_walker</name></expr></argument>,
                                   <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>context</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>sublevels_up</name></name><operator>--</operator></expr>;</expr_stmt>
        <return>return <expr><name>result</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>finalize_grouping_exprs_walker</name></expr></argument>,
                                  <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>context</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Given a GroupingSet node, expand it and return a list of lists.
 *
 * For EMPTY nodes, return a list of one empty list.
 *
 * For SIMPLE nodes, return a list of one list, which is the node content.
 *
 * For CUBE and ROLLUP nodes, return a list of the expansions.
 *
 * For SET nodes, recursively expand contained CUBE and ROLLUP.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>expand_groupingset_node</name><parameter_list>(<parameter><decl><type><name>GroupingSet</name> <modifier>*</modifier></type><name>gs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

    <switch>switch <condition>(<expr><name><name>gs</name><operator>-&gt;</operator><name>kind</name></name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>GROUPING_SET_EMPTY</name></expr>:</case>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>GROUPING_SET_SIMPLE</name></expr>:</case>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name><name>gs</name><operator>-&gt;</operator><name>content</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><name>GROUPING_SET_ROLLUP</name></expr>:</case>
        <block>{<block_content>
            <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>rollup_val</name> <init>= <expr><name><name>gs</name><operator>-&gt;</operator><name>content</name></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>curgroup_size</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>gs</name><operator>-&gt;</operator><name>content</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <while>while <condition>(<expr><name>curgroup_size</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>current_result</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><name>curgroup_size</name></expr></init></decl>;</decl_stmt>

                <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>rollup_val</argument>)</argument_list></macro>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>GroupingSet</name> <modifier>*</modifier></type><name>gs_current</name> <init>= <expr><operator>(</operator><name>GroupingSet</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>gs_current</name><operator>-&gt;</operator><name>kind</name></name> <operator>==</operator> <name>GROUPING_SET_SIMPLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <expr_stmt><expr><name>current_result</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>current_result</name></expr></argument>,
                                                 <argument><expr><call><name>list_copy</name><argument_list>(<argument><expr><name><name>gs_current</name><operator>-&gt;</operator><name>content</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <comment type="block">/* If we are done with making the current group, break */</comment>
                    <if_stmt><if>if <condition>(<expr><operator>--</operator><name>i</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                        <break>break;</break></block_content></block></if></if_stmt>
                </block_content>}</block>

                <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>current_result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><operator>--</operator><name>curgroup_size</name></expr>;</expr_stmt>
            </block_content>}</block></while>

            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>
            <break>break;</break>

        <case>case <expr><name>GROUPING_SET_CUBE</name></expr>:</case>
        <block>{<block_content>
            <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>cube_list</name> <init>= <expr><name><name>gs</name><operator>-&gt;</operator><name>content</name></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>number_bits</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name>cube_list</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>uint32</name></type> <name>num_sets</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>uint32</name></type> <name>i</name></decl>;</decl_stmt>

            <comment type="block">/* parser should cap this much lower */</comment>
            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>number_bits</name> <operator>&lt;</operator> <literal type="number">31</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name>num_sets</name> <operator>=</operator> <operator>(</operator><literal type="number">1U</literal> <operator>&lt;&lt;</operator> <name>number_bits</name><operator>)</operator></expr>;</expr_stmt>

            <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_sets</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
            <block>{<block_content>
                <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>current_result</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>uint32</name></type> <name>mask</name> <init>= <expr><literal type="number">1U</literal></expr></init></decl>;</decl_stmt>

                <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>cube_list</argument>)</argument_list></macro>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>GroupingSet</name> <modifier>*</modifier></type><name>gs_current</name> <init>= <expr><operator>(</operator><name>GroupingSet</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>gs_current</name><operator>-&gt;</operator><name>kind</name></name> <operator>==</operator> <name>GROUPING_SET_SIMPLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <if_stmt><if>if <condition>(<expr><name>mask</name> <operator>&amp;</operator> <name>i</name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><name>current_result</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>current_result</name></expr></argument>,
                                                     <argument><expr><call><name>list_copy</name><argument_list>(<argument><expr><name><name>gs_current</name><operator>-&gt;</operator><name>content</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>

                    <expr_stmt><expr><name>mask</name> <operator>&lt;&lt;=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
                </block_content>}</block>

                <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>current_result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></for>
        </block_content>}</block>
            <break>break;</break>

        <case>case <expr><name>GROUPING_SET_SETS</name></expr>:</case>
        <block>{<block_content>
            <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

            <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>gs-&gt;content</argument>)</argument_list></macro>
            <block>{<block_content>
                <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>current_result</name> <init>= <expr><call><name>expand_groupingset_node</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>current_result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block>
        </block_content>}</block>
            <break>break;</break>
    </block_content>}</block></switch>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>cmp_list_len_asc</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>la</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><operator>*</operator><operator>(</operator><name>List</name> <operator>*</operator><specifier>const</specifier> <operator>*</operator><operator>)</operator> <name>a</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>lb</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><operator>*</operator><operator>(</operator><name>List</name> <operator>*</operator><specifier>const</specifier> <operator>*</operator><operator>)</operator> <name>b</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <return>return <expr><ternary><condition><expr><operator>(</operator><name>la</name> <operator>&gt;</operator> <name>lb</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><ternary><condition><expr><operator>(</operator><name>la</name> <operator>==</operator> <name>lb</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Expand a groupingSets clause to a flat list of grouping sets.
 * The returned list is sorted by length, shortest sets first.
 *
 * This is mainly for the planner, but we use it here too to do
 * some consistency checks.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>expand_grouping_sets</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>groupingSets</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>limit</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>expanded_groups</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type> <name>numsets</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>groupingSets</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>NIL</name></expr>;</return></block_content></block></if></if_stmt>

    <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>groupingSets</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>current_result</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>GroupingSet</name> <modifier>*</modifier></type><name>gs</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name>current_result</name> <operator>=</operator> <call><name>expand_groupingset_node</name><argument_list>(<argument><expr><name>gs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>current_result</name> <operator>!=</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>numsets</name> <operator>*=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>current_result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>limit</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>numsets</name> <operator>&gt;</operator> <name>limit</name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>NIL</name></expr>;</return></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>expanded_groups</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>expanded_groups</name></expr></argument>, <argument><expr><name>current_result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>

    <comment type="block">/*
     * Do cartesian product between sublists of expanded_groups. While at it,
     * remove any duplicate elements from individual grouping sets (we must
     * NOT change the number of sets though)
     */</comment>

    <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>(List *) linitial(expanded_groups)</argument>)</argument_list></macro>
    <block>{<block_content>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><call><name>list_union_int</name><argument_list>(<argument><expr><name>NIL</name></expr></argument>, <argument><expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>

    <macro><name>for_each_cell</name><argument_list>(<argument>lc</argument>, <argument>lnext(list_head(expanded_groups))</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>new_result</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc2</name></decl>;</decl_stmt>

        <macro><name>foreach</name><argument_list>(<argument>lc2</argument>, <argument>result</argument>)</argument_list></macro>
        <block>{<block_content>
            <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>q</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc3</name></decl>;</decl_stmt>

            <macro><name>foreach</name><argument_list>(<argument>lc3</argument>, <argument>p</argument>)</argument_list></macro>
            <block>{<block_content>
                <expr_stmt><expr><name>new_result</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>new_result</name></expr></argument>,
                                     <argument><expr><call><name>list_union_int</name><argument_list>(<argument><expr><name>q</name></expr></argument>,<argument><expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc3</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block>
        </block_content>}</block>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <name>new_result</name></expr>;</expr_stmt>
    </block_content>}</block>

    <if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>			<name>result_len</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>List</name>	  <modifier>*</modifier><modifier>*</modifier></type><name>buf</name> <init>= <expr><call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>List</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>result_len</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>List</name>	  <modifier>*</modifier><modifier>*</modifier></type><name>ptr</name> <init>= <expr><name>buf</name></expr></init></decl>;</decl_stmt>

        <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>result</argument>)</argument_list></macro>
        <block>{<block_content>
            <expr_stmt><expr><operator>*</operator><name>ptr</name><operator>++</operator> <operator>=</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block>

        <expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>result_len</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>List</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>cmp_list_len_asc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>result</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>ptr</name> <operator>=</operator> <name>buf</name></expr>;</expr_stmt>

        <while>while <condition>(<expr><name>result_len</name><operator>--</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><operator>*</operator><name>ptr</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>

        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>
</unit>
