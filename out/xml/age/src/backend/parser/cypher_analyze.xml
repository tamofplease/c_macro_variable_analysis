<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/builded_projects/age/src/backend/parser/cypher_analyze.c"><comment type="block">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type_d.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodeFuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/parsenodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/pg_list.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/primnodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/analyze.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_coerce.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_collate.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_node.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_relation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_target.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parsetree.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/ag_graph.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/ag_nodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/cypher_analyze.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/cypher_clause.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/cypher_parse_node.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/cypher_parser.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/ag_func.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/age_session_info.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/agtype.h"</cpp:file></cpp:include>

<comment type="block">/*
 * extra_node is a global variable to this source to store, at the moment, the
 * explain stmt node passed up by the parser. The return value from the parser
 * contains an 'extra' value, hence the name.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>extra_node</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<comment type="block">/*
 * Takes a query node and builds an explain stmt query node. It then replaces
 * the passed query node with the new explain stmt query node.
 */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>build_explain_query</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>explain_node</name></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><specifier>static</specifier> <name>post_parse_analyze_hook_type</name></type> <name>prev_post_parse_analyze_hook</name></decl>;</decl_stmt>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>post_parse_analyze</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>convert_cypher_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>is_rte_cypher</name><parameter_list>(<parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>is_func_cypher</name><parameter_list>(<parameter><decl><type><name>FuncExpr</name> <modifier>*</modifier></type><name>funcexpr</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>convert_cypher_to_subquery</name><parameter_list>(<parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>, <parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Name</name></type> <name>expr_get_const_name</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>expr_get_const_cstring</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>source_str</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>get_query_location</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>location</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>source_str</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Query</name> <modifier>*</modifier></type><name>analyze_cypher</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>, <parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>parent_pstate</name></decl></parameter>,
                             <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>query_str</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>query_loc</name></decl></parameter>,
                             <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>graph_name</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>graph_oid</name></decl></parameter>, <parameter><decl><type><name>Param</name> <modifier>*</modifier></type><name>params</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Query</name> <modifier>*</modifier></type><name>analyze_cypher_and_coerce</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>, <parameter><decl><type><name>RangeTblFunction</name> <modifier>*</modifier></type><name>rtfunc</name></decl></parameter>,
                                        <parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>parent_pstate</name></decl></parameter>,
                                        <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>query_str</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>query_loc</name></decl></parameter>,
                                        <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>graph_name</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>graph_oid</name></decl></parameter>,
                                        <parameter><decl><type><name>Param</name> <modifier>*</modifier></type><name>params</name></decl></parameter>)</parameter_list>;</function_decl>


<function><type><name>void</name></type> <name>post_parse_analyze_init</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><name>prev_post_parse_analyze_hook</name> <operator>=</operator> <name>post_parse_analyze_hook</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>post_parse_analyze_hook</name> <operator>=</operator> <name>post_parse_analyze</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>post_parse_analyze_fini</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><name>post_parse_analyze_hook</name> <operator>=</operator> <name>prev_post_parse_analyze_hook</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>post_parse_analyze</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>prev_post_parse_analyze_hook</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>prev_post_parse_analyze_hook</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * extra_node is set in the parsing stage to keep track of EXPLAIN.
     * So it needs to be set to NULL prior to any cypher parsing.
     */</comment>
    <expr_stmt><expr><name>extra_node</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>convert_cypher_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name>query</name></expr></argument>, <argument><expr><name>pstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * If there is an extra_node returned, we need to check to see if
     * it is an EXPLAIN.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>extra_node</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* process the EXPLAIN node */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>extra_node</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>T_ExplainStmt</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>build_explain_query</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>extra_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* reset extra_node */</comment>
        <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>extra_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>extra_node</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="line">// find cypher() calls in FROM clauses and convert them to SELECT subqueries</comment>
<function><type><specifier>static</specifier> <name>bool</name></type> <name>convert_cypher_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>node</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>RangeTblEntry</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><operator>(</operator><name>RangeTblEntry</name> <operator>*</operator><operator>)</operator><name>node</name></expr></init></decl>;</decl_stmt>

        <switch>switch <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name></expr>)</condition>
        <block>{<block_content>
        <case>case <expr><name>RTE_SUBQUERY</name></expr>:</case>
            <comment type="line">// traverse other RTE_SUBQUERYs</comment>
            <return>return <expr><call><name>convert_cypher_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name><name>rte</name><operator>-&gt;</operator><name>subquery</name></name></expr></argument>, <argument><expr><name>pstate</name></expr></argument>)</argument_list></call></expr>;</return>
        <case>case <expr><name>RTE_FUNCTION</name></expr>:</case>
            <if_stmt><if>if <condition>(<expr><call><name>is_rte_cypher</name><argument_list>(<argument><expr><name>rte</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><call><name>convert_cypher_to_subquery</name><argument_list>(<argument><expr><name>rte</name></expr></argument>, <argument><expr><name>pstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
            <return>return <expr><name>false</name></expr>;</return>
        <default>default:</default>
            <return>return <expr><name>false</name></expr>;</return>
        </block_content>}</block></switch>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * This handles a cypher() call with other function calls in a ROWS FROM
     * expression. We can let the FuncExpr case below handle it but do this
     * here to throw a better error message.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>RangeTblFunction</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>RangeTblFunction</name> <modifier>*</modifier></type><name>rtfunc</name> <init>= <expr><operator>(</operator><name>RangeTblFunction</name> <operator>*</operator><operator>)</operator><name>node</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>FuncExpr</name> <modifier>*</modifier></type><name>funcexpr</name> <init>= <expr><operator>(</operator><name>FuncExpr</name> <operator>*</operator><operator>)</operator><name><name>rtfunc</name><operator>-&gt;</operator><name>funcexpr</name></name></expr></init></decl>;</decl_stmt>

        <comment type="block">/*
         * It is better to throw a kind error message here instead of the
         * internal error message that cypher() throws later when it is called.
         */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>is_func_cypher</name><argument_list>(<argument><expr><name>funcexpr</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cypher(...) in ROWS FROM is not supported"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><call><name>exprLocation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name>funcexpr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <return>return <expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name><name>funcexpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>,
                                      <argument><expr><name>convert_cypher_walker</name></expr></argument>, <argument><expr><name>pstate</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * This handles cypher() calls in expressions. Those in RTE_FUNCTIONs are
     * handled by either convert_cypher_to_subquery() or the RangeTblFunction
     * case above.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>FuncExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>FuncExpr</name> <modifier>*</modifier></type><name>funcexpr</name> <init>= <expr><operator>(</operator><name>FuncExpr</name> <operator>*</operator><operator>)</operator><name>node</name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>is_func_cypher</name><argument_list>(<argument><expr><name>funcexpr</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cypher(...) in expressions is not supported"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Use subquery instead if possible."</literal></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><call><name>exprLocation</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <return>return <expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name><name>funcexpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>,
                                      <argument><expr><name>convert_cypher_walker</name></expr></argument>, <argument><expr><name>pstate</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>flags</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type> <name>result</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name> <init>= <expr><operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator><name>node</name></expr></init></decl>;</decl_stmt>

        <comment type="block">/*
         * QTW_EXAMINE_RTES
         *     We convert RTE_FUNCTION (cypher()) to RTE_SUBQUERY (SELECT)
         *     in-place.
         *
         * QTW_IGNORE_RT_SUBQUERIES
         *     After the conversion, we don't need to traverse the resulting
         *     RTE_SUBQUERY. However, we need to traverse other RTE_SUBQUERYs.
         *     This is done manually by the RTE_SUBQUERY case above.
         *
         * QTW_IGNORE_JOINALIASES
         *     We are not interested in this.
         */</comment>
        <expr_stmt><expr><name>flags</name> <operator>=</operator> <name>QTW_EXAMINE_RTES</name> <operator>|</operator> <name>QTW_IGNORE_RT_SUBQUERIES</name> <operator>|</operator>
                <name>QTW_IGNORE_JOINALIASES</name></expr>;</expr_stmt>

        <comment type="block">/* recurse on query */</comment>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>query_tree_walker</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>convert_cypher_walker</name></expr></argument>, <argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <return>return <expr><name>result</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>convert_cypher_walker</name></expr></argument>, <argument><expr><name>pstate</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Takes a query node and builds an explain stmt query node. It then replaces
 * the passed query node with the new explain stmt query node.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>build_explain_query</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>explain_node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ExplainStmt</name> <modifier>*</modifier></type><name>estmt</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>query_copy</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>query_node</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/*
     * Create a copy of the query node. This is purposely a shallow copy
     * because we are only moving the contents to another pointer.
     */</comment>
    <expr_stmt><expr><name>query_copy</name> <operator>=</operator> <operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Query</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>query_copy</name></expr></argument>, <argument><expr><name>query</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Query</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* build our Explain node and store the query node copy in it */</comment>
    <expr_stmt><expr><name>estmt</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>ExplainStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>estmt</name><operator>-&gt;</operator><name>query</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name>query_copy</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>estmt</name><operator>-&gt;</operator><name>options</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>ExplainStmt</name> <operator>*</operator><operator>)</operator><name>explain_node</name><operator>)</operator><operator>-&gt;</operator><name>options</name></expr>;</expr_stmt>

    <comment type="block">/* build our replacement query node */</comment>
    <expr_stmt><expr><name>query_node</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>query_node</name><operator>-&gt;</operator><name>commandType</name></name> <operator>=</operator> <name>CMD_UTILITY</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>query_node</name><operator>-&gt;</operator><name>utilityStmt</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name>estmt</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>query_node</name><operator>-&gt;</operator><name>canSetTag</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

    <comment type="block">/* now replace the top query node with our replacement query node */</comment>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>query_node</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Query</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * We need to free and clear the global variable when done. But, not
     * the ExplainStmt options. Those will get freed by PG when the
     * query is deleted.
     */</comment>
    <expr_stmt><expr><operator>(</operator><operator>(</operator><name>ExplainStmt</name> <operator>*</operator><operator>)</operator><name>explain_node</name><operator>)</operator><operator>-&gt;</operator><name>options</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

    <comment type="block">/* we need to free query_node as it is no longer needed */</comment>
    <expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>query_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>is_rte_cypher</name><parameter_list>(<parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>RangeTblFunction</name> <modifier>*</modifier></type><name>rtfunc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>FuncExpr</name> <modifier>*</modifier></type><name>funcexpr</name></decl>;</decl_stmt>

    <comment type="block">/*
     * The planner expects RangeTblFunction nodes in rte-&gt;functions list.
     * We cannot replace one of them to a SELECT subquery.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>functions</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * A plain function call or a ROWS FROM expression with one function call
     * reaches here. At this point, it is impossible to distinguish between the
     * two. However, it doesn't matter because they are identical in terms of
     * their meaning.
     */</comment>

    <expr_stmt><expr><name>rtfunc</name> <operator>=</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>functions</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>funcexpr</name> <operator>=</operator> <operator>(</operator><name>FuncExpr</name> <operator>*</operator><operator>)</operator><name><name>rtfunc</name><operator>-&gt;</operator><name>funcexpr</name></name></expr>;</expr_stmt>
    <return>return <expr><call><name>is_func_cypher</name><argument_list>(<argument><expr><name>funcexpr</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Return true if the qualified name of the given function is
 * &lt;"ag_catalog"."cypher"&gt;. Otherwise, return false.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type> <name>is_func_cypher</name><parameter_list>(<parameter><decl><type><name>FuncExpr</name> <modifier>*</modifier></type><name>funcexpr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>is_oid_ag_func</name><argument_list>(<argument><expr><name><name>funcexpr</name><operator>-&gt;</operator><name>funcid</name></name></expr></argument>, <argument><expr><literal type="string">"cypher"</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="line">// convert cypher() call to SELECT subquery in-place</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>convert_cypher_to_subquery</name><parameter_list>(<parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>, <parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>RangeTblFunction</name> <modifier>*</modifier></type><name>rtfunc</name> <init>= <expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>functions</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>FuncExpr</name> <modifier>*</modifier></type><name>funcexpr</name> <init>= <expr><operator>(</operator><name>FuncExpr</name> <operator>*</operator><operator>)</operator><name><name>rtfunc</name><operator>-&gt;</operator><name>funcexpr</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>arg1</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>arg2</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>arg3</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Name</name></type> <name>graph_name</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>graph_name_str</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type> <name>graph_oid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>query_str</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>query_loc</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Param</name> <modifier>*</modifier></type><name>params</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>errpos_ecb_state</name></type> <name>ecb_state</name> <init>= <expr><block>{<expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr>}</block></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/*
     * We cannot apply this feature directly to SELECT subquery because the
     * planner does not support it. Adding a "row_number() OVER ()" expression
     * to the subquery as a result target might be a workaround but we throw an
     * error for now.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>funcordinality</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"WITH ORDINALITY is not supported"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><call><name>exprLocation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name>funcexpr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* get our first 2 arguments */</comment>
    <expr_stmt><expr><name>arg1</name> <operator>=</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>funcexpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>arg2</name> <operator>=</operator> <call><name>lsecond</name><argument_list>(<argument><expr><name><name>funcexpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>exprType</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NAMEOID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>exprType</name><argument_list>(<argument><expr><name>arg2</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>CSTRINGOID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>graph_name</name> <operator>=</operator> <call><name>expr_get_const_name</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Since cypher() function is nothing but an interface to get a Cypher
     * query, it must take a string constant as an argument so that the query
     * can be parsed and analyzed at this point to create a Query tree of it.
     *
     * Also, only dollar-quoted string constants are allowed because of the
     * following reasons.
     *
     * * If other kinds of string constants are used, the actual values of them
     *   may differ from what they are shown. This will confuse users.
     * * In the case above, the error position may not be accurate.
     */</comment>
    <expr_stmt><expr><name>query_str</name> <operator>=</operator> <call><name>expr_get_const_cstring</name><argument_list>(<argument><expr><name>arg2</name></expr></argument>, <argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_sourcetext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Validate appropriate cypher function usage -
     *
     * Session info OVERRIDES ANY INPUT PASSED and if any is passed, it will
     * cause the cypher function to error out.
     *
     * If this is using session info, both of the first 2 input parameters need
     * to be NULL, in addition to the session info being set up. Furthermore,
     * the input parameters passed in by session info need to both be non-NULL.
     *
     * If this is not using session info, both input parameters need to be
     * non-NULL.
     *
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>is_session_info_prepared</name><argument_list>()</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* check to see if either input parameter is non-NULL*/</comment>
        <if_stmt><if>if <condition>(<expr><name>graph_name</name> <operator>!=</operator> <name>NULL</name> <operator>||</operator> <name>query_str</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>arg</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>graph_name</name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr> ?</condition><then> <expr><name>arg1</name></expr> </then><else>: <expr><name>arg2</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

            <comment type="block">/*
             * Make sure to clean up session info because the ereport will
             * cause the function to exit.
             */</comment>
            <expr_stmt><expr><call><name>reset_session_info</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"session info requires cypher(NULL, NULL) to be passed"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><call><name>exprLocation</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <comment type="block">/* get our input parameters from session info */</comment>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><name>graph_name_str</name> <operator>=</operator> <call><name>get_session_info_graph_name</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>query_str</name> <operator>=</operator> <call><name>get_session_info_cypher_statement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* check to see if either are NULL */</comment>
            <if_stmt><if>if <condition>(<expr><name>graph_name_str</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>query_str</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/*
                 * Make sure to clean up session info because the ereport will
                 * cause the function to exit.
                 */</comment>
                <expr_stmt><expr><call><name>reset_session_info</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"both session info parameters need to be non-NULL"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if>
    <comment type="block">/* otherwise, we get the parameters from the passed function input */</comment>
    <else>else
    <block>{<block_content>
        <comment type="block">/* get the graph name string from the passed parameters */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>graph_name</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"a name constant is expected"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><call><name>exprLocation</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><name>graph_name_str</name> <operator>=</operator> <call><name>NameStr</name><argument_list>(<argument><expr><operator>*</operator><name>graph_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <comment type="block">/* get the query string from the passed parameters */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>query_str</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"a dollar-quoted string constant is expected"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><call><name>exprLocation</name><argument_list>(<argument><expr><name>arg2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/*
     * The session info is only valid for one cypher call. Now that we are done
     * with it, if it was used, we need to reset it to free the memory used.
     * Additionally, the query location is dependent on how we got the query
     * string, so set the location accordingly.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>is_session_info_prepared</name><argument_list>()</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>reset_session_info</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>query_loc</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/* this call will crash if we use session info */</comment>
        <expr_stmt><expr><name>query_loc</name> <operator>=</operator> <call><name>get_query_location</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator><name>arg2</name><operator>)</operator><operator>-&gt;</operator><name>location</name></expr></argument>,
                                       <argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_sourcetext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* validate the graph exists */</comment>
    <expr_stmt><expr><name>graph_oid</name> <operator>=</operator> <call><name>get_graph_oid</name><argument_list>(<argument><expr><name>graph_name_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>graph_oid</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_SCHEMA</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"graph \"%s\" does not exist"</literal></expr></argument>, <argument><expr><name>graph_name_str</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><call><name>exprLocation</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Check to see if the cypher function had a third parameter passed to it,
     * if so make sure Postgres parsed the second argument to a Param node.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>funcexpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">3</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>arg3</name> <operator>=</operator> <call><name>lthird</name><argument_list>(<argument><expr><name><name>funcexpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>arg3</name></expr></argument>, <argument><expr><name>Param</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"third argument of cypher function must be a parameter"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><call><name>exprLocation</name><argument_list>(<argument><expr><name>arg3</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>params</name> <operator>=</operator> <operator>(</operator><name>Param</name> <operator>*</operator><operator>)</operator><name>arg3</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name>params</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/*
     * install error context callback to adjust an error position for
     * parse_cypher() since locations that parse_cypher() stores are 0 based
     */</comment>
    <expr_stmt><expr><call><name>setup_errpos_ecb</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ecb_state</name></expr></argument>, <argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>query_loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>stmt</name> <operator>=</operator> <call><name>parse_cypher</name><argument_list>(<argument><expr><name>query_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Extract any extra node passed up and assign it to the global variable
     * 'extra_node' - if it wasn't already set. It will be at the end of the
     * stmt list and needs to be removed for normal processing, regardless.
     * It is done this way to allow utility commands to be processed against the
     * AGE query tree. Currently, only EXPLAIN is passed here. But, it need not
     * just be EXPLAIN - so long as it is carefully documented and carefully
     * done.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>extra_node</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>extra_node</name> <operator>=</operator> <call><name>llast</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>list_delete_ptr</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>extra_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>temp</name> <init>= <expr><call><name>llast</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"too many extra_nodes passed from parser"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>list_delete_ptr</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><call><name>cancel_errpos_ecb</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ecb_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_expr_kind</name></name> <operator>==</operator> <name>EXPR_KIND_NONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_expr_kind</name></name> <operator>=</operator> <name>EXPR_KIND_FROM_SUBSELECT</name></expr>;</expr_stmt>
    <comment type="line">// transformRangeFunction() always sets p_lateral_active to true.</comment>
    <comment type="line">// FYI, rte is RTE_FUNCTION and is being converted to RTE_SUBQUERY here.</comment>
    <expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_lateral_active</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

    <comment type="block">/*
     * Cypher queries that end with CREATE clause do not need to have the
     * coercion logic applied to them because we are forcing the column
     * definition list to be a particular way in this case.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>is_ag_node</name><argument_list>(<argument><expr><call><name>llast</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>cypher_create</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>is_ag_node</name><argument_list>(<argument><expr><call><name>llast</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>cypher_set</name></expr></argument>)</argument_list></call> <operator>||</operator>
        <call><name>is_ag_node</name><argument_list>(<argument><expr><call><name>llast</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>cypher_delete</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>is_ag_node</name><argument_list>(<argument><expr><call><name>llast</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>cypher_merge</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <comment type="line">// column definition list must be ... AS relname(colname agtype) ...</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>rtfunc</name><operator>-&gt;</operator><name>funccolcount</name></name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator>
              <call><name>linitial_oid</name><argument_list>(<argument><expr><name><name>rtfunc</name><operator>-&gt;</operator><name>funccoltypes</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>AGTYPEOID</name><operator>)</operator></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column definition list for CREATE clause must contain a single agtype attribute"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"... cypher($$ ... CREATE ... $$) AS t(c agtype) ..."</literal></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><call><name>exprLocation</name><argument_list>(<argument><expr><name><name>rtfunc</name><operator>-&gt;</operator><name>funcexpr</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>analyze_cypher</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>query_str</name></expr></argument>, <argument><expr><name>query_loc</name></expr></argument>,
                               <argument><expr><name>graph_name_str</name></expr></argument>, <argument><expr><name>graph_oid</name></expr></argument>, <argument><expr><name>params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>analyze_cypher_and_coerce</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>rtfunc</name></expr></argument>, <argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>query_str</name></expr></argument>,
                                          <argument><expr><name>query_loc</name></expr></argument>, <argument><expr><name>graph_name_str</name></expr></argument>, <argument><expr><name>graph_oid</name></expr></argument>,
                                          <argument><expr><name>params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_lateral_active</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_expr_kind</name></name> <operator>=</operator> <name>EXPR_KIND_NONE</name></expr>;</expr_stmt>

    <comment type="line">// rte-&gt;functions and rte-&gt;funcordinality are kept for debugging.</comment>
    <comment type="line">// rte-&gt;alias, rte-&gt;eref, and rte-&gt;lateral need to be the same.</comment>
    <comment type="line">// rte-&gt;inh is always false for both RTE_FUNCTION and RTE_SUBQUERY.</comment>
    <comment type="line">// rte-&gt;inFromCl is always true for RTE_FUNCTION.</comment>
    <expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>=</operator> <name>RTE_SUBQUERY</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>subquery</name></name> <operator>=</operator> <name>query</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Name</name></type> <name>expr_get_const_name</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Const</name> <modifier>*</modifier></type><name>con</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>con</name> <operator>=</operator> <operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator><name>expr</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>con</name><operator>-&gt;</operator><name>constisnull</name></name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

    <return>return <expr><call><name>DatumGetName</name><argument_list>(<argument><expr><name><name>con</name><operator>-&gt;</operator><name>constvalue</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>expr_get_const_cstring</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>source_str</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Const</name> <modifier>*</modifier></type><name>con</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>con</name> <operator>=</operator> <operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator><name>expr</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>con</name><operator>-&gt;</operator><name>constisnull</name></name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>con</name><operator>-&gt;</operator><name>location</name></name> <operator>&gt;</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>p</name> <operator>=</operator> <name>source_str</name> <operator>+</operator> <name><name>con</name><operator>-&gt;</operator><name>location</name></name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>!=</operator> <literal type="char">'$'</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

    <return>return <expr><call><name>DatumGetCString</name><argument_list>(<argument><expr><name><name>con</name><operator>-&gt;</operator><name>constvalue</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>get_query_location</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>location</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>source_str</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>location</name> <operator>&gt;</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>p</name> <operator>=</operator> <name>source_str</name> <operator>+</operator> <name>location</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'$'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><call><name>strchr</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="char">'$'</literal></expr></argument>)</argument_list></call> <operator>-</operator> <name>source_str</name> <operator>+</operator> <literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Query</name> <modifier>*</modifier></type><name>analyze_cypher</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>, <parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>parent_pstate</name></decl></parameter>,
                             <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>query_str</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>query_loc</name></decl></parameter>,
                             <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>graph_name</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>graph_oid</name></decl></parameter>, <parameter><decl><type><name>Param</name> <modifier>*</modifier></type><name>params</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>cypher_clause</name> <modifier>*</modifier></type><name>clause</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>cypher_parsestate</name></type> <name>parent_cpstate</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>errpos_ecb_state</name></type> <name>ecb_state</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Since the first clause in stmt is the innermost subquery, the order of
     * the clauses is inverted.
     */</comment>
    <expr_stmt><expr><name>clause</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>stmt</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>cypher_clause</name> <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>next</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>next</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>next</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>next</name><operator>-&gt;</operator><name>self</name></name> <operator>=</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>next</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name>clause</name></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>clause</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>clause</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>next</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>clause</name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>
    </block_content>}</block>

    <comment type="block">/*
     * convert ParseState into cypher_parsestate temporarily to pass it to
     * make_cypher_parsestate()
     */</comment>
    <expr_stmt><expr><name><name>parent_cpstate</name><operator>.</operator><name>pstate</name></name> <operator>=</operator> <operator>*</operator><name>parent_pstate</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>parent_cpstate</name><operator>.</operator><name>graph_name</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>parent_cpstate</name><operator>.</operator><name>params</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>cpstate</name> <operator>=</operator> <call><name>make_cypher_parsestate</name><argument_list>(<argument><expr><operator>&amp;</operator><name>parent_cpstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>pstate</name> <operator>=</operator> <operator>(</operator><name>ParseState</name> <operator>*</operator><operator>)</operator><name>cpstate</name></expr>;</expr_stmt>

    <comment type="block">/* we don't want functions that go up the pstate parent chain to access the
     * original SQL query pstate.
     */</comment>
    <expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>parentParseState</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <comment type="block">/*
     * override p_sourcetext with query_str to make parser_errposition() work
     * correctly with errpos_ecb()
     */</comment>
    <expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_sourcetext</name></name> <operator>=</operator> <name>query_str</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>cpstate</name><operator>-&gt;</operator><name>graph_name</name></name> <operator>=</operator> <name>graph_name</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cpstate</name><operator>-&gt;</operator><name>graph_oid</name></name> <operator>=</operator> <name>graph_oid</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cpstate</name><operator>-&gt;</operator><name>params</name></name> <operator>=</operator> <name>params</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cpstate</name><operator>-&gt;</operator><name>default_alias_num</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cpstate</name><operator>-&gt;</operator><name>entities</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
    <comment type="block">/*
     * install error context callback to adjust an error position since
     * locations in stmt are 0 based
     */</comment>
    <expr_stmt><expr><call><name>setup_errpos_ecb</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ecb_state</name></expr></argument>, <argument><expr><name>parent_pstate</name></expr></argument>, <argument><expr><name>query_loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>transform_cypher_clause</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>, <argument><expr><name>clause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>cancel_errpos_ecb</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ecb_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>free_cypher_parsestate</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>query</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Since some target entries of subquery may be referenced for sorting (ORDER
 * BY), we cannot apply the coercion directly to the expressions of the target
 * entries. Therefore, we do the coercion by doing SELECT over subquery.
 */</comment>
<function><type><specifier>static</specifier> <name>Query</name> <modifier>*</modifier></type><name>analyze_cypher_and_coerce</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>, <parameter><decl><type><name>RangeTblFunction</name> <modifier>*</modifier></type><name>rtfunc</name></decl></parameter>,
                                        <parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>parent_pstate</name></decl></parameter>,
                                        <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>query_str</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>query_loc</name></decl></parameter>,
                                        <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>graph_name</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>graph_oid</name></decl></parameter>,
                                        <parameter><decl><type><name>Param</name> <modifier>*</modifier></type><name>params</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>lateral</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>subquery</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>rtindex</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lt</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc1</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc2</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc3</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>int</name></type> <name>attr_count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>pstate</name> <operator>=</operator> <call><name>make_parsestate</name><argument_list>(<argument><expr><name>parent_pstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>commandType</name></name> <operator>=</operator> <name>CMD_SELECT</name></expr>;</expr_stmt>

    <comment type="block">/*
     * Below is similar to transform_prev_cypher_clause().
     */</comment>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_expr_kind</name></name> <operator>==</operator> <name>EXPR_KIND_NONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_expr_kind</name></name> <operator>=</operator> <name>EXPR_KIND_FROM_SUBSELECT</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_lateral_active</name></name> <operator>=</operator> <name>lateral</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>subquery</name> <operator>=</operator> <call><name>analyze_cypher</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>query_str</name></expr></argument>, <argument><expr><name>query_loc</name></expr></argument>, <argument><expr><name>graph_name</name></expr></argument>,
                              <argument><expr><name>graph_oid</name></expr></argument>, <argument><expr><operator>(</operator><name>Param</name> <operator>*</operator><operator>)</operator><name>params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_lateral_active</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_expr_kind</name></name> <operator>=</operator> <name>EXPR_KIND_NONE</name></expr>;</expr_stmt>

    <comment type="line">// ALIAS Syntax makes `RESJUNK`. So, It must be skipping.</comment>
    <macro><name>foreach</name><argument_list>(<argument>lt</argument>, <argument>subquery-&gt;targetList</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>te</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>te</name><operator>-&gt;</operator><name>resjunk</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>attr_count</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block>

    <comment type="line">// check the number of attributes first</comment>
    <if_stmt><if>if <condition>(<expr><name>attr_count</name> <operator>!=</operator> <name><name>rtfunc</name><operator>-&gt;</operator><name>funccolcount</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"return row and column definition list do not match"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><call><name>exprLocation</name><argument_list>(<argument><expr><name><name>rtfunc</name><operator>-&gt;</operator><name>funcexpr</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>addRangeTableEntryForSubquery</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>subquery</name></expr></argument>, <argument><expr><call><name>makeAlias</name><argument_list>(<argument><expr><literal type="string">"_"</literal></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr></argument>,
                                        <argument><expr><name>lateral</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rtindex</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_rtable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>rtindex</name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// rte is the only RangeTblEntry in pstate</comment>
    <expr_stmt><expr><call><name>addRTEtoQuery</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <call><name>expandRelAttrs</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>, <argument><expr><name>rtindex</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>markTargetListOrigins</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// do the type coercion for each target entry</comment>
    <expr_stmt><expr><name>lc1</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name><name>rtfunc</name><operator>-&gt;</operator><name>funccolnames</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>lc2</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name><name>rtfunc</name><operator>-&gt;</operator><name>funccoltypes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>lc3</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name><name>rtfunc</name><operator>-&gt;</operator><name>funccoltypmods</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <macro><name>foreach</name> <argument_list>(<argument>lt</argument>, <argument>query-&gt;targetList</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>te</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name><name>te</name><operator>-&gt;</operator><name>expr</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Oid</name></type> <name>current_type</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Oid</name></type> <name>target_type</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>te</name><operator>-&gt;</operator><name>resjunk</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>current_type</name> <operator>=</operator> <call><name>exprType</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>target_type</name> <operator>=</operator> <call><name>lfirst_oid</name><argument_list>(<argument><expr><name>lc2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>current_type</name> <operator>!=</operator> <name>target_type</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>int32</name></type> <name>target_typmod</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>lc3</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>new_expr</name></decl>;</decl_stmt>

            <comment type="block">/*
             * The coercion context of this coercion is COERCION_EXPLICIT
             * because the target type is explicitly metioned in the column
             * definition list and we need to do this by looking up all
             * possible coercion.
             */</comment>
            <expr_stmt><expr><name>new_expr</name> <operator>=</operator> <call><name>coerce_to_target_type</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name>current_type</name></expr></argument>,
                                             <argument><expr><name>target_type</name></expr></argument>, <argument><expr><name>target_typmod</name></expr></argument>,
                                             <argument><expr><name>COERCION_EXPLICIT</name></expr></argument>,
                                             <argument><expr><name>COERCE_EXPLICIT_CAST</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name>new_expr</name></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>colname</name> <init>= <expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CANNOT_COERCE</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot cast type %s to %s for column \"%s\""</literal></expr></argument>,
                                <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>current_type</name></expr></argument>)</argument_list></call></expr></argument>,
                                <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>target_type</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>colname</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
                                            <argument><expr><call><name>exprLocation</name><argument_list>(<argument><expr><name><name>rtfunc</name><operator>-&gt;</operator><name>funcexpr</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <expr_stmt><expr><name><name>te</name><operator>-&gt;</operator><name>expr</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator><name>new_expr</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>lc1</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>lc1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>lc2</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>lc2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>lc3</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>lc3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>

    <expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>rtable</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_rtable</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>jointree</name></name> <operator>=</operator> <call><name>makeFromExpr</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_joinlist</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>assign_query_collations</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>free_parsestate</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>query</name></expr>;</return>
</block_content>}</block></function>
</unit>
