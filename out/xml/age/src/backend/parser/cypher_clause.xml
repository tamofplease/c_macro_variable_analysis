<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/age/src/backend/parser/cypher_clause.c"><comment type="block">/*
 * For PostgreSQL Database Management System:
 * (formerly known as Postgres, then as Postgres95)
 *
 * Portions Copyright (c) 1996-2010, The PostgreSQL Global Development Group
 *
 * Portions Copyright (c) 1994, The Regents of the University of California
 *
 * Permission to use, copy, modify, and distribute this software and its documentation for any purpose,
 * without fee, and without a written agreement is hereby granted, provided that the above copyright notice
 * and this paragraph and the following two paragraphs appear in all copies.
 *
 * IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR DIRECT,
 * INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS,
 * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF THE UNIVERSITY
 * OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
 * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 *
 * THE SOFTWARE PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND THE UNIVERSITY OF CALIFORNIA
 * HAS NO OBLIGATIONS TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/sysattr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type_d.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodeFuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/parsenodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/pg_list.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/primnodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/var.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_clause.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_coerce.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_collate.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_expr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_func.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_node.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_oper.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_relation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_target.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parsetree.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"rewrite/rewriteHandler.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/typcache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/ag_graph.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/ag_label.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/label_commands.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/ag_nodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/cypher_nodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/cypher_clause.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/cypher_expr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/cypher_item.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/cypher_parse_agg.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/cypher_parse_node.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/cypher_transform_entity.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/ag_cache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/ag_func.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/agtype.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/graphid.h"</cpp:file></cpp:include>

<comment type="block">/*
 * Variable string names for makeTargetEntry. As they are going to be variable
 * names that will be hidden from the user, we need to do our best to make sure
 * they won't be picked by mistake. Additionally, their form needs to be easily
 * determined as ours. For now, prefix them as follows -
 *
 *     #define AGE_VARNAME_SOMETHING AGE_DEFAULT_VARNAME_PREFIX"something"
 *
 * We should probably make an automated variable generator, like for aliases,
 * for this.
 *
 * Also, keep these here as nothing outside of this file needs to know these.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AGE_VARNAME_CREATE_CLAUSE</name></cpp:macro> <cpp:value>AGE_DEFAULT_VARNAME_PREFIX"create_clause"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AGE_VARNAME_CREATE_NULL_VALUE</name></cpp:macro> <cpp:value>AGE_DEFAULT_VARNAME_PREFIX"create_null_value"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AGE_VARNAME_DELETE_CLAUSE</name></cpp:macro> <cpp:value>AGE_DEFAULT_VARNAME_PREFIX"delete_clause"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AGE_VARNAME_MERGE_CLAUSE</name></cpp:macro> <cpp:value>AGE_DEFAULT_VARNAME_PREFIX"merge_clause"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AGE_VARNAME_ID</name></cpp:macro> <cpp:value>AGE_DEFAULT_VARNAME_PREFIX"id"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AGE_VARNAME_SET_CLAUSE</name></cpp:macro> <cpp:value>AGE_DEFAULT_VARNAME_PREFIX"set_clause"</cpp:value></cpp:define>

<comment type="block">/*
 * Rules to determine if a node must be included:
 *
 *      1. the node is in a path variable
 *      2. the node is a variable
 *      3. the node contains filter properties
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INCLUDE_NODE_IN_JOIN_TREE</name><parameter_list>(<parameter><type><name>path</name></type></parameter>, <parameter><type><name>node</name></type></parameter>)</parameter_list></cpp:macro> \
    <cpp:value>(path-&gt;var_name || node-&gt;name || node-&gt;props)</cpp:value></cpp:define>

<typedef>typedef <function_decl><type><name>Query</name> <modifier>*</modifier></type>(<modifier>*</modifier><name>transform_method</name>)<parameter_list>(<parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl></parameter>,
                                   <parameter><decl><type><name>cypher_clause</name> <modifier>*</modifier></type><name>clause</name></decl></parameter>)</parameter_list>;</function_decl></typedef>

<comment type="line">// projection</comment>
<function_decl><type><specifier>static</specifier> <name>Query</name> <modifier>*</modifier></type><name>transform_cypher_return</name><parameter_list>(<parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl></parameter>,
                                      <parameter><decl><type><name>cypher_clause</name> <modifier>*</modifier></type><name>clause</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>transform_cypher_order_by</name><parameter_list>(<parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl></parameter>,
                                       <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>sort_items</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>target_list</name></decl></parameter>,
                                       <parameter><decl><type><name>ParseExprKind</name></type> <name>expr_kind</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>TargetEntry</name> <modifier>*</modifier></type><name>find_target_list_entry</name><parameter_list>(<parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl></parameter>,
                                           <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>target_list</name></decl></parameter>,
                                           <parameter><decl><type><name>ParseExprKind</name></type> <name>expr_kind</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>transform_cypher_limit</name><parameter_list>(<parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
                                    <parameter><decl><type><name>ParseExprKind</name></type> <name>expr_kind</name></decl></parameter>,
                                    <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>construct_name</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Query</name> <modifier>*</modifier></type><name>transform_cypher_with</name><parameter_list>(<parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl></parameter>,
                                    <parameter><decl><type><name>cypher_clause</name> <modifier>*</modifier></type><name>clause</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Query</name> <modifier>*</modifier></type><name>transform_cypher_clause_with_where</name><parameter_list>(<parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl></parameter>,
                                                 <parameter><decl><type><name>transform_method</name></type> <name>transform</name></decl></parameter>,
                                                 <parameter><decl><type><name>cypher_clause</name> <modifier>*</modifier></type><name>clause</name></decl></parameter>)</parameter_list>;</function_decl>
<comment type="line">// match clause</comment>
<function_decl><type><specifier>static</specifier> <name>Query</name> <modifier>*</modifier></type><name>transform_cypher_match</name><parameter_list>(<parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl></parameter>,
                                     <parameter><decl><type><name>cypher_clause</name> <modifier>*</modifier></type><name>clause</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Query</name> <modifier>*</modifier></type><name>transform_cypher_match_pattern</name><parameter_list>(<parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl></parameter>,
                                             <parameter><decl><type><name>cypher_clause</name> <modifier>*</modifier></type><name>clause</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>transform_match_entities</name><parameter_list>(<parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>,
                                      <parameter><decl><type><name>cypher_path</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>transform_match_pattern</name><parameter_list>(<parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>,
                                    <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>pattern</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>where</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>transform_match_path</name><parameter_list>(<parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>,
                                  <parameter><decl><type><name>cypher_path</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Expr</name> <modifier>*</modifier></type><name>transform_cypher_edge</name><parameter_list>(<parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl></parameter>,
                                   <parameter><decl><type><name>cypher_relationship</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>,
                                   <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>target_list</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>valid_label</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Expr</name> <modifier>*</modifier></type><name>transform_cypher_node</name><parameter_list>(<parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl></parameter>,
                                   <parameter><decl><type><name>cypher_node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>target_list</name></decl></parameter>,
                                   <parameter><decl><type><name>bool</name></type> <name>output_node</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>valid_label</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>make_vertex_expr</name><parameter_list>(<parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl></parameter>, <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>,
                              <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>label</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>make_edge_expr</name><parameter_list>(<parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl></parameter>, <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>,
                            <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>label</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>make_qual</name><parameter_list>(<parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl></parameter>,
                           <parameter><decl><type><name>transform_entity</name> <modifier>*</modifier></type><name>entity</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>TargetEntry</name> <modifier>*</modifier></type>
<name>transform_match_create_path_variable</name><parameter_list>(<parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl></parameter>,
                                     <parameter><decl><type><name>cypher_path</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>entities</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>make_path_join_quals</name><parameter_list>(<parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>entities</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>make_directed_edge_join_conditions</name><parameter_list>(
    <parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl></parameter>, <parameter><decl><type><name>transform_entity</name> <modifier>*</modifier></type><name>prev_entity</name></decl></parameter>,
    <parameter><decl><type><name>transform_entity</name> <modifier>*</modifier></type><name>next_entity</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>prev_qual</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>next_qual</name></decl></parameter>,
    <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>prev_node_label</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>next_node_label</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>join_to_entity</name><parameter_list>(<parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl></parameter>,
                            <parameter><decl><type><name>transform_entity</name> <modifier>*</modifier></type><name>entity</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>qual</name></decl></parameter>,
                            <parameter><decl><type><name><name>enum</name> <name>transform_entity_join_side</name></name></type> <name>side</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>make_join_condition_for_edge</name><parameter_list>(<parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl></parameter>,
                                          <parameter><decl><type><name>transform_entity</name> <modifier>*</modifier></type><name>prev_edge</name></decl></parameter>,
                                          <parameter><decl><type><name>transform_entity</name> <modifier>*</modifier></type><name>prev_node</name></decl></parameter>,
                                          <parameter><decl><type><name>transform_entity</name> <modifier>*</modifier></type><name>entity</name></decl></parameter>,
                                          <parameter><decl><type><name>transform_entity</name> <modifier>*</modifier></type><name>next_node</name></decl></parameter>,
                                          <parameter><decl><type><name>transform_entity</name> <modifier>*</modifier></type><name>next_edge</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>make_edge_quals</name><parameter_list>(<parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl></parameter>,
                             <parameter><decl><type><name>transform_entity</name> <modifier>*</modifier></type><name>edge</name></decl></parameter>,
                             <parameter><decl><type><name><name>enum</name> <name>transform_entity_join_side</name></name></type> <name>side</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>A_Expr</name> <modifier>*</modifier></type><name>filter_vertices_on_label_id</name><parameter_list>(<parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl></parameter>,
                                           <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>id_field</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>label</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>create_property_constraints</name><parameter_list>(<parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl></parameter>,
                                         <parameter><decl><type><name>transform_entity</name> <modifier>*</modifier></type><name>entity</name></decl></parameter>,
                                         <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>property_constraints</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>TargetEntry</name> <modifier>*</modifier></type><name>findTarget</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>targetList</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>resname</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>transform_entity</name> <modifier>*</modifier></type><name>transform_VLE_edge_entity</name><parameter_list>(<parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl></parameter>,
                                                   <parameter><decl><type><name>cypher_relationship</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>,
                                                   <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list>;</function_decl>
<comment type="line">// create clause</comment>
<function_decl><type><specifier>static</specifier> <name>Query</name> <modifier>*</modifier></type><name>transform_cypher_create</name><parameter_list>(<parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl></parameter>,
                                      <parameter><decl><type><name>cypher_clause</name> <modifier>*</modifier></type><name>clause</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>transform_cypher_create_pattern</name><parameter_list>(<parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl></parameter>,
                                             <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>pattern</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>cypher_create_path</name> <modifier>*</modifier></type>
<name>transform_cypher_create_path</name><parameter_list>(<parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>target_list</name></decl></parameter>,
                             <parameter><decl><type><name>cypher_path</name> <modifier>*</modifier></type><name>cp</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>cypher_target_node</name> <modifier>*</modifier></type>
<name>transform_create_cypher_node</name><parameter_list>(<parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>target_list</name></decl></parameter>,
                             <parameter><decl><type><name>cypher_node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>cypher_target_node</name> <modifier>*</modifier></type>
<name>transform_create_cypher_new_node</name><parameter_list>(<parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl></parameter>,
                                 <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>target_list</name></decl></parameter>, <parameter><decl><type><name>cypher_node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>cypher_target_node</name> <modifier>*</modifier></type><name>transform_create_cypher_existing_node</name><parameter_list>(
    <parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>target_list</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>declared_in_current_clause</name></decl></parameter>,
    <parameter><decl><type><name>cypher_node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>cypher_target_node</name> <modifier>*</modifier></type>
<name>transform_create_cypher_edge</name><parameter_list>(<parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>target_list</name></decl></parameter>,
                             <parameter><decl><type><name>cypher_relationship</name> <modifier>*</modifier></type><name>edge</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Expr</name> <modifier>*</modifier></type><name>cypher_create_properties</name><parameter_list>(<parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl></parameter>,
                                      <parameter><decl><type><name>cypher_target_node</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>,
                                      <parameter><decl><type><name>Relation</name></type> <name>label_relation</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>props</name></decl></parameter>,
                                      <parameter><decl><type><name><name>enum</name> <name>transform_entity_type</name></name></type> <name>type</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Expr</name> <modifier>*</modifier></type><name>add_volatile_wrapper</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>variable_exists</name><parameter_list>(<parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>get_target_entry_resno</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>target_list</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>handle_prev_clause</name><parameter_list>(<parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>,
                               <parameter><decl><type><name>cypher_clause</name> <modifier>*</modifier></type><name>clause</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>first_rte</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>TargetEntry</name> <modifier>*</modifier></type><name>placeholder_target_entry</name><parameter_list>(<parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl></parameter>,
                                             <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>makeTargetListFromRTE</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>Query</name> <modifier>*</modifier></type><name>transform_cypher_sub_pattern</name><parameter_list>(<parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl></parameter>,
                                           <parameter><decl><type><name>cypher_clause</name> <modifier>*</modifier></type><name>clause</name></decl></parameter>)</parameter_list>;</function_decl>
<comment type="line">// set and remove clause</comment>
<function_decl><type><specifier>static</specifier> <name>Query</name> <modifier>*</modifier></type><name>transform_cypher_set</name><parameter_list>(<parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl></parameter>,
                                   <parameter><decl><type><name>cypher_clause</name> <modifier>*</modifier></type><name>clause</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>cypher_update_information</name> <modifier>*</modifier></type><name>transform_cypher_set_item_list</name><parameter_list>(<parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl></parameter>,
                                                                 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>set_item_list</name></decl></parameter>,
                                                                 <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>cypher_update_information</name> <modifier>*</modifier></type><name>transform_cypher_remove_item_list</name><parameter_list>(<parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl></parameter>,
                                                                    <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>remove_item_list</name></decl></parameter>,
                                                                    <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list>;</function_decl>
<comment type="line">// delete</comment>
<function_decl><type><specifier>static</specifier> <name>Query</name> <modifier>*</modifier></type><name>transform_cypher_delete</name><parameter_list>(<parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl></parameter>,
                                      <parameter><decl><type><name>cypher_clause</name> <modifier>*</modifier></type><name>clause</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>transform_cypher_delete_item_list</name><parameter_list>(<parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl></parameter>,
                                               <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>delete_item_list</name></decl></parameter>,
                                               <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list>;</function_decl>
<comment type="line">//set operators</comment>
<function_decl><type><specifier>static</specifier> <name>Query</name> <modifier>*</modifier></type><name>transform_cypher_union</name><parameter_list>(<parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl></parameter>,
                                     <parameter><decl><type><name>cypher_clause</name> <modifier>*</modifier></type><name>clause</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type> <name>transform_cypher_union_tree</name><parameter_list>(<parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl></parameter>,
                                          <parameter><decl><type><name>cypher_clause</name> <modifier>*</modifier></type><name>clause</name></decl></parameter>,
                                          <parameter><decl><type><name>bool</name></type> <name>isTopLevel</name></decl></parameter>,
                                          <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>targetlist</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>Query</name> <modifier>*</modifier></type><name>cypher_parse_sub_analyze_union</name><parameter_list>(<parameter><decl><type><name>cypher_clause</name> <modifier>*</modifier></type><name>clause</name></decl></parameter>,
                                      <parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl></parameter>,
                                      <parameter><decl><type><name>CommonTableExpr</name> <modifier>*</modifier></type><name>parentCTE</name></decl></parameter>,
                                      <parameter><decl><type><name>bool</name></type> <name>locked_from_parent</name></decl></parameter>,
                                      <parameter><decl><type><name>bool</name></type> <name>resolve_unknowns</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>get_res_cols</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>l_rte</name></decl></parameter>,
                         <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>r_rte</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>res_colnames</name></decl></parameter>,
                         <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>res_colvars</name></decl></parameter>)</parameter_list>;</function_decl>
<comment type="line">// unwind</comment>
<function_decl><type><specifier>static</specifier> <name>Query</name> <modifier>*</modifier></type><name>transform_cypher_unwind</name><parameter_list>(<parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl></parameter>,
                                      <parameter><decl><type><name>cypher_clause</name> <modifier>*</modifier></type><name>clause</name></decl></parameter>)</parameter_list>;</function_decl>
<comment type="line">// merge</comment>
<function_decl><type><specifier>static</specifier> <name>Query</name> <modifier>*</modifier></type><name>transform_cypher_merge</name><parameter_list>(<parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl></parameter>,
                                     <parameter><decl><type><name>cypher_clause</name> <modifier>*</modifier></type><name>clause</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>cypher_create_path</name> <modifier>*</modifier></type>
<name>transform_merge_make_lateral_join</name><parameter_list>(<parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>,
                                  <parameter><decl><type><name>cypher_clause</name> <modifier>*</modifier></type><name>clause</name></decl></parameter>,
                                  <parameter><decl><type><name>cypher_clause</name> <modifier>*</modifier></type><name>isolated_merge_clause</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>cypher_create_path</name> <modifier>*</modifier></type>
<name>transform_cypher_merge_path</name><parameter_list>(<parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>target_list</name></decl></parameter>,
                            <parameter><decl><type><name>cypher_path</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>cypher_target_node</name> <modifier>*</modifier></type>
<name>transform_merge_cypher_edge</name><parameter_list>(<parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>target_list</name></decl></parameter>,
                            <parameter><decl><type><name>cypher_relationship</name> <modifier>*</modifier></type><name>edge</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>cypher_target_node</name> <modifier>*</modifier></type>
<name>transform_merge_cypher_node</name><parameter_list>(<parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>target_list</name></decl></parameter>,
                            <parameter><decl><type><name>cypher_node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>transform_clause_for_join</name><parameter_list>(<parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl></parameter>,
                                       <parameter><decl><type><name>cypher_clause</name> <modifier>*</modifier></type><name>clause</name></decl></parameter>,
                                       <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier><modifier>*</modifier></type><name>rte</name></decl></parameter>,
                                       <parameter><decl><type><name>ParseNamespaceItem</name> <modifier>*</modifier><modifier>*</modifier></type><name>nsitem</name></decl></parameter>,
                                       <parameter><decl><type><name>Alias</name><modifier>*</modifier></type> <name>alias</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>cypher_clause</name> <modifier>*</modifier></type><name>convert_merge_to_match</name><parameter_list>(<parameter><decl><type><name>cypher_merge</name> <modifier>*</modifier></type><name>merge</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type>
<name>transform_cypher_merge_mark_tuple_position</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>target_list</name></decl></parameter>,
                                           <parameter><decl><type><name>cypher_create_path</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="line">//call...[yield]</comment>
<function_decl><type><specifier>static</specifier> <name>Query</name> <modifier>*</modifier></type><name>transform_cypher_call_stmt</name><parameter_list>(<parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl></parameter>,
                                      <parameter><decl><type><name>cypher_clause</name> <modifier>*</modifier></type><name>clause</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Query</name> <modifier>*</modifier></type><name>transform_cypher_call_subquery</name><parameter_list>(<parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl></parameter>,
                                          <parameter><decl><type><name>cypher_clause</name> <modifier>*</modifier></type><name>clause</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="line">// transform</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PREV_CYPHER_CLAUSE_ALIAS</name></cpp:macro>    <cpp:value>"_"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CYPHER_OPT_RIGHT_ALIAS</name></cpp:macro>      <cpp:value>"_R"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>transform_prev_cypher_clause</name><parameter_list>(<parameter><type><name>cpstate</name></type></parameter>, <parameter><type><name>prev_clause</name></type></parameter>, <parameter><type><name>add_rte_to_query</name></type></parameter>)</parameter_list></cpp:macro> \
    <cpp:value>transform_cypher_clause_as_subquery(cpstate, transform_cypher_clause, \
                                        prev_clause, NULL, add_rte_to_query)</cpp:value></cpp:define>
<function_decl><type><specifier>static</specifier> <name>RangeTblEntry</name> <modifier>*</modifier></type><name>transform_cypher_clause_as_subquery</name><parameter_list>(<parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl></parameter>,
                                                          <parameter><decl><type><name>transform_method</name></type> <name>transform</name></decl></parameter>,
                                                          <parameter><decl><type><name>cypher_clause</name> <modifier>*</modifier></type><name>clause</name></decl></parameter>,
                                                          <parameter><decl><type><name>Alias</name> <modifier>*</modifier></type><name>alias</name></decl></parameter>,
                                                          <parameter><decl><type><name>bool</name></type> <name>add_rte_to_query</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Query</name> <modifier>*</modifier></type><name>analyze_cypher_clause</name><parameter_list>(<parameter><decl><type><name>transform_method</name></type> <name>transform</name></decl></parameter>,
                                    <parameter><decl><type><name>cypher_clause</name> <modifier>*</modifier></type><name>clause</name></decl></parameter>,
                                    <parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>parent_cpstate</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>transform_group_clause</name><parameter_list>(<parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl></parameter>,
                                    <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>grouplist</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>groupingSets</name></decl></parameter>,
                                    <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>targetlist</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>sortClause</name></decl></parameter>,
                                    <parameter><decl><type><name>ParseExprKind</name></type> <name>exprKind</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>flatten_grouping_sets</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>toplevel</name></decl></parameter>,
                                   <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>hasGroupingSets</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Index</name></type> <name>transform_group_clause_expr</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>flatresult</name></decl></parameter>,
                                         <parameter><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>seen_local</name></decl></parameter>,
                                         <parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl></parameter>,
                                         <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>gexpr</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>targetlist</name></decl></parameter>,
                                         <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>sortClause</name></decl></parameter>,
                                         <parameter><decl><type><name>ParseExprKind</name></type> <name>exprKind</name></decl></parameter>,
                                         <parameter><decl><type><name>bool</name></type> <name>toplevel</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>add_target_to_group_list</name><parameter_list>(<parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl></parameter>,
                                      <parameter><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>grouplist</name></decl></parameter>,
                                      <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>targetlist</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>location</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>advance_transform_entities_to_next_clause</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>entities</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>ParseNamespaceItem</name> <modifier>*</modifier></type><name>create_namespace_item</name><parameter_list>(<parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>p_rel_visible</name></decl></parameter>,
                                             <parameter><decl><type><name>bool</name></type> <name>p_cols_visible</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>p_lateral_only</name></decl></parameter>,
                                             <parameter><decl><type><name>bool</name></type> <name>p_lateral_ok</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>make_target_list_from_join</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>,
                                    <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Expr</name> <modifier>*</modifier></type><name>add_volatile_wrapper</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>FuncExpr</name> <modifier>*</modifier></type><name>make_clause_func_expr</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>function_name</name></decl></parameter>,
                                       <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>clause_information</name></decl></parameter>)</parameter_list>;</function_decl>
<comment type="block">/* for VLE support */</comment>
<function_decl><type><specifier>static</specifier> <name>RangeTblEntry</name> <modifier>*</modifier></type><name>transform_RangeFunction</name><parameter_list>(<parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl></parameter>,
                                              <parameter><decl><type><name>RangeFunction</name> <modifier>*</modifier></type><name>r</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>transform_VLE_Function</name><parameter_list>(<parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>n</name></decl></parameter>,
                                    <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier><modifier>*</modifier></type><name>top_rte</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>top_rti</name></decl></parameter>,
                                    <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>namespace</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>RangeTblEntry</name> <modifier>*</modifier></type><name>append_VLE_Func_to_FromClause</name><parameter_list>(<parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl></parameter>,
                                                    <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>n</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>setNamespaceLateralState</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>namespace</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>lateral_only</name></decl></parameter>,
                                     <parameter><decl><type><name>bool</name></type> <name>lateral_ok</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>isa_special_VLE_case</name><parameter_list>(<parameter><decl><type><name>cypher_path</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * transform a cypher_clause
 */</comment>
<function><type><name>Query</name> <modifier>*</modifier></type><name>transform_cypher_clause</name><parameter_list>(<parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl></parameter>,
                               <parameter><decl><type><name>cypher_clause</name> <modifier>*</modifier></type><name>clause</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>self</name> <init>= <expr><name><name>clause</name><operator>-&gt;</operator><name>self</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

    <comment type="line">// examine the type of clause and call the transform logic for it</comment>
    <if_stmt><if>if <condition>(<expr><call><name>is_ag_node</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>cypher_return</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>cypher_return</name> <modifier>*</modifier></type><name>n</name> <init>= <expr><operator>(</operator><name>cypher_return</name> <operator>*</operator><operator>)</operator> <name>self</name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>n</name><operator>-&gt;</operator><name>op</name></name> <operator>==</operator> <name>SETOP_NONE</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>transform_cypher_return</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>, <argument><expr><name>clause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name><name>n</name><operator>-&gt;</operator><name>op</name></name> <operator>==</operator> <name>SETOP_UNION</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>transform_cypher_union</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>, <argument><expr><name>clause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"unexpected Node for cypher_return"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><call><name>is_ag_node</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>cypher_with</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>transform_cypher_with</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>, <argument><expr><name>clause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><call><name>is_ag_node</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>cypher_match</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>transform_cypher_match</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>, <argument><expr><name>clause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><call><name>is_ag_node</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>cypher_create</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>transform_cypher_create</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>, <argument><expr><name>clause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><call><name>is_ag_node</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>cypher_set</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>transform_cypher_set</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>, <argument><expr><name>clause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><call><name>is_ag_node</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>cypher_delete</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>transform_cypher_delete</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>, <argument><expr><name>clause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><call><name>is_ag_node</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>cypher_merge</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>transform_cypher_merge</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>, <argument><expr><name>clause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><call><name>is_ag_node</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>cypher_sub_pattern</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>transform_cypher_sub_pattern</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>, <argument><expr><name>clause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><call><name>is_ag_node</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>cypher_unwind</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>transform_cypher_unwind</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>, <argument><expr><name>clause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><call><name>is_ag_node</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>cypher_call</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>transform_cypher_call_stmt</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>, <argument><expr><name>clause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"unexpected Node for cypher_clause"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>querySource</name></name> <operator>=</operator> <name>QSRC_ORIGINAL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>canSetTag</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Transform the UNION operator/clause. Creates a cypher_union
 * node and the necessary information needed in the execution
 * phase
 */</comment>

<function><type><specifier>static</specifier> <name>cypher_clause</name> <modifier>*</modifier></type><name>make_cypher_clause</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>cypher_clause</name> <modifier>*</modifier></type><name>clause</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Since the first clause in stmt is the innermost subquery, the order of
     * the clauses is inverted.
     */</comment>
    <expr_stmt><expr><name>clause</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>stmt</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>cypher_clause</name> <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>next</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>next</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>next</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>next</name><operator>-&gt;</operator><name>self</name></name> <operator>=</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>next</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name>clause</name></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>clause</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>clause</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>clause</name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>
    </block_content>}</block>
    <return>return <expr><name>clause</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * transform_cypher_union -
 *    transforms a union tree, derived from postgresql's
 *    transformSetOperationStmt. A lot of the general logic is similar,
 *    with adjustments made for AGE.
 *
 * A union tree is just a return, but with UNION structure to it.
 * We must transform each leaf SELECT and build up a top-level Query
 * that contains the leaf SELECTs as subqueries in its rangetable.
 * The tree of unions is converted into the setOperations field of
 * the top-level Query.
 */</comment>

<function><type><specifier>static</specifier> <name>Query</name> <modifier>*</modifier></type><name>transform_cypher_union</name><parameter_list>(<parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl></parameter>,
                                     <parameter><decl><type><name>cypher_clause</name> <modifier>*</modifier></type><name>clause</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name> <init>= <expr><operator>(</operator><name>ParseState</name> <operator>*</operator><operator>)</operator><name>cpstate</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>qry</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>leftmostRTI</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>leftmostQuery</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SetOperationStmt</name> <modifier>*</modifier></type><name>cypher_union_statement</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>skip</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt> <comment type="block">/* equivalent to postgres limitOffset */</comment>
    <decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>limit</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt> <comment type="block">/* equivalent to postgres limitCount */</comment>
    <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>order_by</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>cypher_return</name> <modifier>*</modifier></type><name>self</name> <init>= <expr><operator>(</operator><name>cypher_return</name> <operator>*</operator><operator>)</operator><name><name>clause</name><operator>-&gt;</operator><name>self</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>left_tlist</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>lct</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>lcm</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>lcc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>targetvars</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>targetnames</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>sv_namespace</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>sv_rtable_length</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>jrte</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>tllen</name></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>commandType</name></name> <operator>=</operator> <name>CMD_SELECT</name></expr>;</expr_stmt>

    <comment type="block">/*
     * Union is a node that should never have a previous node because
     * of where it is used in the parse logic. The query parts around it
     * are children located in larg or rarg. Something went wrong if the
     * previous clause field is not null.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>clause</name><operator>-&gt;</operator><name>prev</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                        <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Union is a parent node, there are no previous"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                        <call><name>parser_errposition</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cpstate</name><operator>-&gt;</operator><name>pstate</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>order_by</name> <operator>=</operator> <name><name>self</name><operator>-&gt;</operator><name>order_by</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>skip</name> <operator>=</operator> <name><name>self</name><operator>-&gt;</operator><name>skip</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>limit</name> <operator>=</operator> <name><name>self</name><operator>-&gt;</operator><name>limit</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>self</name><operator>-&gt;</operator><name>order_by</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>self</name><operator>-&gt;</operator><name>skip</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>self</name><operator>-&gt;</operator><name>limit</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

    <comment type="block">/*
     * Recursively transform the components of the tree.
     */</comment>
    <expr_stmt><expr><name>cypher_union_statement</name> <operator>=</operator> <operator>(</operator><name>SetOperationStmt</name> <operator>*</operator><operator>)</operator> <call><name>transform_cypher_union_tree</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>,
                                                                <argument><expr><name>clause</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>cypher_union_statement</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>setOperations</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>cypher_union_statement</name></expr>;</expr_stmt>

    <comment type="block">/*
     * Re-find leftmost return (now it's a sub-query in rangetable)
     */</comment>
    <expr_stmt><expr><name>node</name> <operator>=</operator> <name><name>cypher_union_statement</name><operator>-&gt;</operator><name>larg</name></name></expr>;</expr_stmt>
    <while>while <condition>(<expr><name>node</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>SetOperationStmt</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>node</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>SetOperationStmt</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>larg</name></expr>;</expr_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>node</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>RangeTblRef</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>leftmostRTI</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>RangeTblRef</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>rtindex</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>leftmostQuery</name> <operator>=</operator> <call><name>rt_fetch</name><argument_list>(<argument><expr><name>leftmostRTI</name></expr></argument>, <argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_rtable</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>subquery</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>leftmostQuery</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Generate dummy targetlist for outer query using column names of
     * leftmost return and common datatypes/collations of topmost set
     * operation.  Also make lists of the dummy vars and their names for use
     * in parsing ORDER BY.
     *
     * Note: we use leftmostRTI as the varno of the dummy variables. It
     * shouldn't matter too much which RT index they have, as long as they
     * have one that corresponds to a real RT entry; else funny things may
     * happen when the tree is mashed by rule rewriting.
     */</comment>
    <expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>targetvars</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>targetnames</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>left_tlist</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name><name>leftmostQuery</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <macro><name>forthree</name><argument_list>(<argument>lct</argument>, <argument>cypher_union_statement-&gt;colTypes</argument>,
             <argument>lcm</argument>, <argument>cypher_union_statement-&gt;colTypmods</argument>,
             <argument>lcc</argument>, <argument>cypher_union_statement-&gt;colCollations</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Oid</name></type> <name>colType</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>lct</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int32</name></type> <name>colTypmod</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>lcm</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Oid</name></type> <name>colCollation</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>lcc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>lefttle</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>left_tlist</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>colName</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>var</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>lefttle</name><operator>-&gt;</operator><name>resjunk</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>colName</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name><name>lefttle</name><operator>-&gt;</operator><name>resname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>var</name> <operator>=</operator> <call><name>makeVar</name><argument_list>(<argument><expr><name>leftmostRTI</name></expr></argument>,
                      <argument><expr><name><name>lefttle</name><operator>-&gt;</operator><name>resno</name></name></expr></argument>,
                      <argument><expr><name>colType</name></expr></argument>,
                      <argument><expr><name>colTypmod</name></expr></argument>,
                      <argument><expr><name>colCollation</name></expr></argument>,
                      <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <call><name>exprLocation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>lefttle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>tle</name> <operator>=</operator> <call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>var</name></expr></argument>,
                              <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_next_resno</name></name><operator>++</operator></expr></argument>,
                               <argument><expr><name>colName</name></expr></argument>,
                               <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>qry</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>, <argument><expr><name>tle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>targetvars</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>targetvars</name></expr></argument>, <argument><expr><name>var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>targetnames</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>targetnames</name></expr></argument>, <argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name>colName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>left_tlist</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>left_tlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>

    <comment type="block">/*
     * As a first step towards supporting sort clauses that are expressions
     * using the output columns, generate a namespace entry that makes the
     * output columns visible.  A Join RTE node is handy for this, since we
     * can easily control the Vars generated upon matches.
     *
     * Note: we don't yet do anything useful with such cases, but at least
     * "ORDER BY upper(foo)" will draw the right error message rather than
     * "foo not found".
     */</comment>
    <expr_stmt><expr><name>sv_rtable_length</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_rtable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>jrte</name> <operator>=</operator> <call><name>addRangeTableEntryForJoin</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
                                     <argument><expr><name>targetnames</name></expr></argument>,
                                     <argument><expr><name>JOIN_INNER</name></expr></argument>,
                                     <argument><expr><name>targetvars</name></expr></argument>,
                                     <argument><expr><name>NULL</name></expr></argument>,
                                     <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>sv_namespace</name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_namespace</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_namespace</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

    <comment type="block">/* add jrte to column namespace only */</comment>
    <expr_stmt><expr><call><name>addRTEtoQuery</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>jrte</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>tllen</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>qry</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>sortClause</name></name> <operator>=</operator> <call><name>transformSortClause</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
                                          <argument><expr><name>order_by</name></expr></argument>,
                                          <argument><expr><operator>&amp;</operator><name><name>qry</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>,
                                          <argument><expr><name>EXPR_KIND_ORDER_BY</name></expr></argument>,
                                          <argument><expr><name>false</name></expr></argument> <comment type="block">/* allow SQL92 rules */</comment> )</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* restore namespace, remove jrte from rtable */</comment>
    <expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_namespace</name></name> <operator>=</operator> <name>sv_namespace</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_rtable</name></name> <operator>=</operator> <call><name>list_truncate</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_rtable</name></name></expr></argument>, <argument><expr><name>sv_rtable_length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>tllen</name> <operator>!=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>qry</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid UNION ORDER BY clause"</literal></expr></argument>)</argument_list></call><operator>,</operator>
             <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Only result column names can be used, not expressions or functions."</literal></expr></argument>)</argument_list></call><operator>,</operator>
             <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
                                <argument><expr><call><name>exprLocation</name><argument_list>(<argument><expr><call><name>list_nth</name><argument_list>(<argument><expr><name><name>qry</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>, <argument><expr><name>tllen</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>limitOffset</name></name> <operator>=</operator> <call><name>transform_cypher_limit</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>, <argument><expr><name>skip</name></expr></argument>,
                                              <argument><expr><name>EXPR_KIND_OFFSET</name></expr></argument>, <argument><expr><literal type="string">"OFFSET"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>limitCount</name></name> <operator>=</operator> <call><name>transform_cypher_limit</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>, <argument><expr><name>limit</name></expr></argument>,
                                              <argument><expr><name>EXPR_KIND_LIMIT</name></expr></argument>, <argument><expr><literal type="string">"LIMIT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>rtable</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_rtable</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>jointree</name></name> <operator>=</operator> <call><name>makeFromExpr</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_joinlist</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>hasAggs</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_hasAggs</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>assign_query_collations</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>qry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* this must be done after collations, for reliable comparison of exprs */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>pstate</name><operator>-&gt;</operator><name>p_hasAggs</name></name> <operator>||</operator>
        <name><name>qry</name><operator>-&gt;</operator><name>groupClause</name></name> <operator>||</operator> <name><name>qry</name><operator>-&gt;</operator><name>groupingSets</name></name> <operator>||</operator> <name><name>qry</name><operator>-&gt;</operator><name>havingQual</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>parse_check_aggregates</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>qry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>qry</name></expr>;</return>

</block_content>}</block></function>

<comment type="block">/*
 * transform_cypher_union_tree
 *      Recursively transform leaves and internal nodes of a set-op tree,
 *      derived from postgresql's transformSetOperationTree. A lot of
 *      the general logic is similar, with adjustments made for AGE.
 *
 * In addition to returning the transformed node, if targetlist isn't NULL
 * then we return a list of its non-resjunk TargetEntry nodes.  For a leaf
 * set-op node these are the actual targetlist entries; otherwise they are
 * dummy entries created to carry the type, typmod, collation, and location
 * (for error messages) of each output column of the set-op node.  This info
 * is needed only during the internal recursion of this function, so outside
 * callers pass NULL for targetlist.  Note: the reason for passing the
 * actual targetlist entries of a leaf node is so that upper levels can
 * replace UNKNOWN Consts with properly-coerced constants.
 */</comment>
<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>transform_cypher_union_tree</name><parameter_list>(<parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl></parameter>, <parameter><decl><type><name>cypher_clause</name> <modifier>*</modifier></type><name>clause</name></decl></parameter>,
                            <parameter><decl><type><name>bool</name></type> <name>isTopLevel</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>targetlist</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>bool</name></type> <name>isLeaf</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name> <init>= <expr><operator>(</operator><name>ParseState</name> <operator>*</operator><operator>)</operator><name>cpstate</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>cypher_return</name> <modifier>*</modifier></type><name>cmp</name></decl>;</decl_stmt>

    <comment type="block">/* Guard against stack overflow due to overly complex set-expressions */</comment>
    <expr_stmt><expr><call><name>check_stack_depth</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>clause</name></expr></argument>, <argument><expr><name>List</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>clause</name> <operator>=</operator> <call><name>make_cypher_clause</name><argument_list>(<argument><expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator><name>clause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>is_ag_node</name><argument_list>(<argument><expr><name><name>clause</name><operator>-&gt;</operator><name>self</name></name></expr></argument>, <argument><expr><name>cypher_return</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>cmp</name> <operator>=</operator> <operator>(</operator><name>cypher_return</name> <operator>*</operator><operator>)</operator> <name><name>clause</name><operator>-&gt;</operator><name>self</name></name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Cypher found an unsupported node"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>


    <if_stmt><if>if <condition>(<expr><name><name>cmp</name><operator>-&gt;</operator><name>op</name></name> <operator>==</operator> <name>SETOP_NONE</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>cmp</name><operator>-&gt;</operator><name>larg</name></name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>cmp</name><operator>-&gt;</operator><name>rarg</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>isLeaf</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name><name>cmp</name><operator>-&gt;</operator><name>op</name></name> <operator>==</operator> <name>SETOP_UNION</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>cmp</name><operator>-&gt;</operator><name>larg</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>cmp</name><operator>-&gt;</operator><name>rarg</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>cmp</name><operator>-&gt;</operator><name>order_by</name></name> <operator>||</operator> <name><name>cmp</name><operator>-&gt;</operator><name>limit</name></name> <operator>||</operator> <name><name>cmp</name><operator>-&gt;</operator><name>skip</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>isLeaf</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><name>isLeaf</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Cypher found an unsupported SETOP"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>isLeaf</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*process leaf return */</comment>
        <decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>returnQuery</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name></type> <name><name>returnName</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier><name>rte</name></type> <name>PG_USED_FOR_ASSERTS_ONLY</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>RangeTblRef</name> <modifier>*</modifier></type><name>rtr</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>tl</name></decl>;</decl_stmt>

        <comment type="block">/*
         * Transform SelectStmt into a Query.
         *
         * This works the same as RETURN transformation normally would, except
         * that we prevent resolving unknown-type outputs as TEXT.  This does
         * not change the subquery's semantics since if the column type
         * matters semantically, it would have been resolved to something else
         * anyway.  Doing this lets us resolve such outputs using
         * select_common_type(), below.
         *
         * Note: previously transformed sub-queries don't affect the parsing
         * of this sub-query, because they are not in the toplevel pstate's
         * namespace list.
         */</comment>

        <comment type="block">/*
         * Convert the List * that the grammar gave us to a cypher_clause.
         * cypher_analyze doesn't do this because the cypher_union clause
         * is hiding it.
         */</comment>

        <expr_stmt><expr><name>returnQuery</name> <operator>=</operator> <call><name>cypher_parse_sub_analyze_union</name><argument_list>(<argument><expr><operator>(</operator><name>cypher_clause</name> <operator>*</operator><operator>)</operator> <name>clause</name></expr></argument>, <argument><expr><name>cpstate</name></expr></argument>,
                                                     <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/*
         * Check for bogus references to Vars on the current query level (but
         * upper-level references are okay). Normally this can't happen
         * because the namespace will be empty, but it could happen if we are
         * inside a rule.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>pstate</name><operator>-&gt;</operator><name>p_namespace</name></name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name>contain_vars_of_level</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>returnQuery</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_COLUMN_REFERENCE</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"UNION member statement cannot refer to other relations of same query level"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
                                            <argument><expr><call><name>locate_var_of_level</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>returnQuery</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/*
         * Extract a list of the non-junk TLEs for upper-level processing.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>targetlist</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><operator>*</operator><name>targetlist</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
            <macro><name>foreach</name><argument_list>(<argument>tl</argument>, <argument>returnQuery-&gt;targetList</argument>)</argument_list></macro>
            <block>{<block_content>
                <decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>tl</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>tle</name><operator>-&gt;</operator><name>resjunk</name></name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><operator>*</operator><name>targetlist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><operator>*</operator><name>targetlist</name></expr></argument>, <argument><expr><name>tle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/*
         * Make the leaf query be a subquery in the top-level rangetable.
         */</comment>
        <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>returnName</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>returnName</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"*SELECT* %d "</literal></expr></argument>,
                 <argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_rtable</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>addRangeTableEntryForSubquery</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
                                            <argument><expr><name>returnQuery</name></expr></argument>,
                                            <argument><expr><call><name>makeAlias</name><argument_list>(<argument><expr><name>returnName</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr></argument>,
                                            <argument><expr><name>false</name></expr></argument>,
                                            <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>rtr</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>RangeTblRef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* assume new rte is at end */</comment>
        <expr_stmt><expr><name><name>rtr</name><operator>-&gt;</operator><name>rtindex</name></name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_rtable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>rte</name> <operator>==</operator> <call><name>rt_fetch</name><argument_list>(<argument><expr><name><name>rtr</name><operator>-&gt;</operator><name>rtindex</name></name></expr></argument>, <argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_rtable</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>rtr</name></expr>;</return>
    </block_content>}</block></if>
    <else>else <comment type="block">/*is not a leaf */</comment>
    <block>{<block_content>
        <comment type="block">/* Process an internal node (set operation node) */</comment>
        <decl_stmt><decl><type><name>SetOperationStmt</name> <modifier>*</modifier></type><name>op</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>SetOperationStmt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>ltargetlist</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>rtargetlist</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>ltl</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>rtl</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>cypher_return</name> <modifier>*</modifier></type><name>self</name> <init>= <expr><operator>(</operator><name>cypher_return</name> <operator>*</operator><operator>)</operator> <name><name>clause</name><operator>-&gt;</operator><name>self</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>context</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>context</name> <operator>=</operator> <literal type="string">"UNION"</literal></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>op</name></name> <operator>=</operator> <name><name>self</name><operator>-&gt;</operator><name>op</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>all</name></name> <operator>=</operator> <name><name>self</name><operator>-&gt;</operator><name>all_or_distinct</name></name></expr>;</expr_stmt>

        <comment type="block">/*
         * Recursively transform the left child node.
         */</comment>
        <expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>larg</name></name> <operator>=</operator> <call><name>transform_cypher_union_tree</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>,
                                               <argument><expr><operator>(</operator><name>cypher_clause</name> <operator>*</operator><operator>)</operator> <name><name>self</name><operator>-&gt;</operator><name>larg</name></name></expr></argument>,
                                               <argument><expr><name>false</name></expr></argument>,
                                               <argument><expr><operator>&amp;</operator><name>ltargetlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * If we find ourselves processing a recursive CTE here something
         * went horribly wrong. That is an SQL contruct with no parallel in
         * cypher.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>isTopLevel</name> <operator>&amp;&amp;</operator>
            <name><name>pstate</name><operator>-&gt;</operator><name>p_parent_cte</name></name> <operator>&amp;&amp;</operator>
            <name><name>pstate</name><operator>-&gt;</operator><name>p_parent_cte</name><operator>-&gt;</operator><name>cterecursive</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                    <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Cypher does not support recursive CTEs"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                    <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/*
         * Recursively transform the right child node.
         */</comment>
        <expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>rarg</name></name> <operator>=</operator> <call><name>transform_cypher_union_tree</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>,
                                               <argument><expr><operator>(</operator><name>cypher_clause</name> <operator>*</operator><operator>)</operator> <name><name>self</name><operator>-&gt;</operator><name>rarg</name></name></expr></argument>,
                                               <argument><expr><name>false</name></expr></argument>,
                                               <argument><expr><operator>&amp;</operator><name>rtargetlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Verify that the two children have the same number of non-junk
         * columns, and determine the types of the merged output columns.
         */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>ltargetlist</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>rtargetlist</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"each %s query must have the same number of columns"</literal></expr></argument>,
                            <argument><expr><name>context</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
                                        <argument><expr><call><name>exprLocation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>rtargetlist</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>targetlist</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><operator>*</operator><name>targetlist</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>colTypes</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>colTypmods</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>colCollations</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>groupClauses</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

        <macro><name>forboth</name><argument_list>(<argument>ltl</argument>, <argument>ltargetlist</argument>, <argument>rtl</argument>, <argument>rtargetlist</argument>)</argument_list></macro>
        <block>{<block_content>
            <decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>ltle</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>ltl</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>rtle</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>rtl</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>lcolnode</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>ltle</name><operator>-&gt;</operator><name>expr</name></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>rcolnode</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>rtle</name><operator>-&gt;</operator><name>expr</name></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Oid</name></type> <name>lcoltype</name> <init>= <expr><call><name>exprType</name><argument_list>(<argument><expr><name>lcolnode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Oid</name></type> <name>rcoltype</name> <init>= <expr><call><name>exprType</name><argument_list>(<argument><expr><name>rcolnode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int32</name></type> <name>lcoltypmod</name> <init>= <expr><call><name>exprTypmod</name><argument_list>(<argument><expr><name>lcolnode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int32</name></type> <name>rcoltypmod</name> <init>= <expr><call><name>exprTypmod</name><argument_list>(<argument><expr><name>rcolnode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>bestexpr</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>bestlocation</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Oid</name></type> <name>rescoltype</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int32</name></type> <name>rescoltypmod</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Oid</name></type> <name>rescolcoll</name></decl>;</decl_stmt>

            <comment type="block">/* select common type, same as CASE et al */</comment>
            <expr_stmt><expr><name>rescoltype</name> <operator>=</operator> <call><name>select_common_type</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
                                            <argument><expr><call><name>list_make2</name><argument_list>(<argument><expr><name>lcolnode</name></expr></argument>, <argument><expr><name>rcolnode</name></expr></argument>)</argument_list></call></expr></argument>,
                                            <argument><expr><name>context</name></expr></argument>,
                                            <argument><expr><operator>&amp;</operator><name>bestexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>bestlocation</name> <operator>=</operator> <call><name>exprLocation</name><argument_list>(<argument><expr><name>bestexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* if same type and same typmod, use typmod; else default */</comment>
            <if_stmt><if>if <condition>(<expr><name>lcoltype</name> <operator>==</operator> <name>rcoltype</name> <operator>&amp;&amp;</operator> <name>lcoltypmod</name> <operator>==</operator> <name>rcoltypmod</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>rescoltypmod</name> <operator>=</operator> <name>lcoltypmod</name></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><name>rescoltypmod</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>

            <comment type="block">/*
             * Verify the coercions are actually possible.  If not, we'd fail
             * later anyway, but we want to fail now while we have sufficient
             * context to produce an error cursor position.
             *
             * For all non-UNKNOWN-type cases, we verify coercibility but we
             * don't modify the child's expression, for fear of changing the
             * child query's semantics.
             *
             * If a child expression is an UNKNOWN-type Const or Param, we
             * want to replace it with the coerced expression.  This can only
             * happen when the child is a leaf set-op node.  It's safe to
             * replace the expression because if the child query's semantics
             * depended on the type of this output column, it'd have already
             * coerced the UNKNOWN to something else.  We want to do this
             * because (a) we want to verify that a Const is valid for the
             * target type, or resolve the actual type of an UNKNOWN Param,
             * and (b) we want to avoid unnecessary discrepancies between the
             * output type of the child query and the resolved target type.
             * Such a discrepancy would disable optimization in the planner.
             *
             * If it's some other UNKNOWN-type node, eg a Var, we do nothing
             * (knowing that coerce_to_common_type would fail).  The planner
             * is sometimes able to fold an UNKNOWN Var to a constant before
             * it has to coerce the type, so failing now would just break
             * cases that might work.
             */</comment>
            <if_stmt><if>if <condition>(<expr><name>lcoltype</name> <operator>!=</operator> <name>UNKNOWNOID</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>lcolnode</name> <operator>=</operator> <call><name>coerce_to_common_type</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>lcolnode</name></expr></argument>,
                                                 <argument><expr><name>rescoltype</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>lcolnode</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>lcolnode</name></expr></argument>, <argument><expr><name>Param</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>lcolnode</name> <operator>=</operator> <call><name>coerce_to_common_type</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>lcolnode</name></expr></argument>,
                                                 <argument><expr><name>rescoltype</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>ltle</name><operator>-&gt;</operator><name>expr</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>lcolnode</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <if_stmt><if>if <condition>(<expr><name>rcoltype</name> <operator>!=</operator> <name>UNKNOWNOID</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>rcolnode</name> <operator>=</operator> <call><name>coerce_to_common_type</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>rcolnode</name></expr></argument>,
                                                 <argument><expr><name>rescoltype</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>rcolnode</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>rcolnode</name></expr></argument>, <argument><expr><name>Param</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>rcolnode</name> <operator>=</operator> <call><name>coerce_to_common_type</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>rcolnode</name></expr></argument>,
                                                 <argument><expr><name>rescoltype</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>rtle</name><operator>-&gt;</operator><name>expr</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>rcolnode</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <comment type="block">/*
             * Select common collation.  A common collation is required for
             * all set operators except UNION ALL; see SQL:2008 7.13 &lt;query
             * expression&gt; Syntax Rule 15c.  (If we fail to identify a common
             * collation for a UNION ALL column, the curCollations element
             * will be set to InvalidOid, which may result in a runtime error
             * if something at a higher query level wants to use the column's
             * collation.)
             */</comment>
            <expr_stmt><expr><name>rescolcoll</name> <operator>=</operator> <call><name>select_common_collation</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
                                                 <argument><expr><call><name>list_make2</name><argument_list>(<argument><expr><name>lcolnode</name></expr></argument>, <argument><expr><name>rcolnode</name></expr></argument>)</argument_list></call></expr></argument>,
                                                 <argument><expr><operator>(</operator><name><name>op</name><operator>-&gt;</operator><name>op</name></name> <operator>==</operator> <name>SETOP_UNION</name> <operator>&amp;&amp;</operator> <name><name>op</name><operator>-&gt;</operator><name>all</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* emit results */</comment>
            <expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>colTypes</name></name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>colTypes</name></name></expr></argument>, <argument><expr><name>rescoltype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>colTypmods</name></name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>colTypmods</name></name></expr></argument>, <argument><expr><name>rescoltypmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>colCollations</name></name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>colCollations</name></name></expr></argument>, <argument><expr><name>rescolcoll</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/*
             * For all cases except UNION ALL, identify the grouping operators
             * (and, if available, sorting operators) that will be used to
             * eliminate duplicates.
             */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>op</name></name> <operator>!=</operator> <name>SETOP_UNION</name> <operator>||</operator> <operator>!</operator><name><name>op</name><operator>-&gt;</operator><name>all</name></name></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>SortGroupClause</name> <modifier>*</modifier></type><name>grpcl</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>SortGroupClause</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>Oid</name></type> <name>sortop</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>Oid</name></type> <name>eqop</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>bool</name></type> <name>hashable</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>ParseCallbackState</name></type> <name>pcbstate</name></decl>;</decl_stmt>

                <expr_stmt><expr><call><name>setup_parser_errposition_callback</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pcbstate</name></expr></argument>, <argument><expr><name>pstate</name></expr></argument>,
                                                  <argument><expr><name>bestlocation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/*
                 * determine the eqop and optional sortop
                 *
                 * NOTE: for UNION, we set hashable to false and pass a NULL to
                 * isHashable in get_sort_group_operators to prevent a logic error
                 * where UNION fails to exclude duplicate results.
                 *
                 */</comment>
                <expr_stmt><expr><call><name>get_sort_group_operators</name><argument_list>(<argument><expr><name>rescoltype</name></expr></argument>,
                                         <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
                                         <argument><expr><operator>&amp;</operator><name>sortop</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>eqop</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                         <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><call><name>cancel_parser_errposition_callback</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pcbstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/* we don't have a tlist yet, so can't assign sortgrouprefs */</comment>
                <expr_stmt><expr><name><name>grpcl</name><operator>-&gt;</operator><name>tleSortGroupRef</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>grpcl</name><operator>-&gt;</operator><name>eqop</name></name> <operator>=</operator> <name>eqop</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>grpcl</name><operator>-&gt;</operator><name>sortop</name></name> <operator>=</operator> <name>sortop</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>grpcl</name><operator>-&gt;</operator><name>nulls_first</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt> <comment type="block">/* OK with or without sortop */</comment>
                <expr_stmt><expr><name><name>grpcl</name><operator>-&gt;</operator><name>hashable</name></name> <operator>=</operator> <name>hashable</name></expr>;</expr_stmt>

                <expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>groupClauses</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>groupClauses</name></name></expr></argument>, <argument><expr><name>grpcl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <comment type="block">/*
             * Construct a dummy tlist entry to return.  We use a SetToDefault
             * node for the expression, since it carries exactly the fields
             * needed, but any other expression node type would do as well.
             */</comment>
            <if_stmt><if>if <condition>(<expr><name>targetlist</name></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>SetToDefault</name> <modifier>*</modifier></type><name>rescolnode</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>SetToDefault</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>restle</name></decl>;</decl_stmt>

                <expr_stmt><expr><name><name>rescolnode</name><operator>-&gt;</operator><name>typeId</name></name> <operator>=</operator> <name>rescoltype</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>rescolnode</name><operator>-&gt;</operator><name>typeMod</name></name> <operator>=</operator> <name>rescoltypmod</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>rescolnode</name><operator>-&gt;</operator><name>collation</name></name> <operator>=</operator> <name>rescolcoll</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>rescolnode</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <name>bestlocation</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>restle</name> <operator>=</operator> <call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>rescolnode</name></expr></argument>,
                                         <argument><expr><literal type="number">0</literal></expr></argument>, <comment type="block">/* no need to set resno */</comment>
                                         <argument><expr><name>NULL</name></expr></argument>,
                                         <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><operator>*</operator><name>targetlist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><operator>*</operator><name>targetlist</name></expr></argument>, <argument><expr><name>restle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block>

        <return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name>op</name></expr>;</return>
    </block_content>}</block></else></if_stmt><comment type="line">//end else (is not leaf)</comment>
</block_content>}</block></function>

<comment type="block">/*
 * Function that takes a cypher call and returns the yielded result
 * This function also catches some cases that should fail that could not
 * be picked up by the grammar. transform_cypher_call_subquery handles the
 * call transformation itself.
 */</comment>
<function><type><specifier>static</specifier> <name>Query</name> <modifier>*</modifier></type> <name>transform_cypher_call_stmt</name><parameter_list>(<parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl></parameter>,
                                          <parameter><decl><type><name>cypher_clause</name> <modifier>*</modifier></type><name>clause</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name> <init>= <expr><operator>(</operator><name>ParseState</name> <operator>*</operator><operator>)</operator><name>cpstate</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>cypher_call</name> <modifier>*</modifier></type><name>self</name> <init>= <expr><operator>(</operator><name>cypher_call</name> <operator>*</operator><operator>)</operator><name><name>clause</name><operator>-&gt;</operator><name>self</name></name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>clause</name><operator>-&gt;</operator><name>prev</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>clause</name><operator>-&gt;</operator><name>next</name></name></expr>)</condition> <comment type="block">/* CALL [YIELD] -- the most simple call */</comment>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>self</name><operator>-&gt;</operator><name>where</name></name></expr>)</condition> <comment type="block">/* Error check for WHERE clause after YIELD without RETURN */</comment>
        <block>{<block_content>
            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>self</name><operator>-&gt;</operator><name>yield_items</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Cannot use standalone CALL with WHERE"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Instead use `CALL ... WITH * WHERE ... RETURN *`"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
                                        <argument><expr><call><name>exprLocation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>self</name><operator>-&gt;</operator><name>where</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <return>return <expr><call><name>transform_cypher_call_subquery</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>, <argument><expr><name>clause</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></if>
    <else>else <comment type="block">/* subqueries */</comment>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>self</name><operator>-&gt;</operator><name>yield_items</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Procedure call inside a query does not support naming results implicitly"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Name explicitly using `YIELD` instead"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
                                        <argument><expr><call><name>exprLocation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>self</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>self</name><operator>-&gt;</operator><name>yield_items</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>clause</name><operator>-&gt;</operator><name>next</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Query cannot conclude with CALL"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Must be RETURN or an update clause"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
                                        <argument><expr><call><name>exprLocation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>self</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <return>return <expr><call><name>transform_cypher_clause_with_where</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>,
                                                  <argument><expr><name>transform_cypher_call_subquery</name></expr></argument>,
                                                  <argument><expr><name>clause</name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></else></if_stmt>

    <return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Helper routine for transform_cypher_call_stmt. This routine transforms the
 * call statement and handles the YIELD clause.
 */</comment>
<function><type><specifier>static</specifier> <name>Query</name> <modifier>*</modifier></type><name>transform_cypher_call_subquery</name><parameter_list>(<parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl></parameter>,
                                             <parameter><decl><type><name>cypher_clause</name> <modifier>*</modifier></type><name>clause</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name> <init>= <expr><operator>(</operator><name>ParseState</name> <operator>*</operator><operator>)</operator><name>cpstate</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>p_child_parse_state</name> <init>= <expr><call><name>make_parsestate</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>cypher_call</name> <modifier>*</modifier></type><name>self</name> <init>= <expr><operator>(</operator><name>cypher_call</name> <operator>*</operator><operator>)</operator><name><name>clause</name><operator>-&gt;</operator><name>self</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>colName</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>FuncExpr</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>where_qual</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>commandType</name></name> <operator>=</operator> <name>CMD_SELECT</name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>clause</name><operator>-&gt;</operator><name>prev</name></name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* we want to retain all previous range table entries */</comment>
        <expr_stmt><expr><call><name>handle_prev_clause</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>, <argument><expr><name>query</name></expr></argument>, <argument><expr><name><name>clause</name><operator>-&gt;</operator><name>prev</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* transform the funccall and store it in a funcexpr node */</comment>
    <expr_stmt><expr><name>node</name> <operator>=</operator> <call><name>castNode</name><argument_list>( <argument><expr><name>FuncExpr</name></expr></argument>, <argument><expr><call><name>transform_cypher_expr</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>self</name><operator>-&gt;</operator><name>funccall</name></name></expr></argument>,
                                                     <argument><expr><name>EXPR_KIND_FROM_FUNCTION</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* retrieve the column name from funccall */</comment>
    <expr_stmt><expr><name>colName</name> <operator>=</operator> <call><name>strVal</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>self</name><operator>-&gt;</operator><name>funccall</name><operator>-&gt;</operator><name>funcname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* make a targetentry from the funcexpr node */</comment>
    <expr_stmt><expr><name>tle</name> <operator>=</operator> <call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
                          <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <name><name>p_child_parse_state</name><operator>-&gt;</operator><name>p_next_resno</name></name><operator>++</operator></expr></argument>,
                           <argument><expr><name>colName</name></expr></argument>,
                           <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>self</name><operator>-&gt;</operator><name>yield_items</name></name></expr>)</condition> <comment type="block">/* if there are yield items, we need to check them */</comment>
    <block>{<block_content>
        <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>yield_targetList</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>yield_targetList</name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>tle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>self-&gt;yield_items</argument>)</argument_list></macro>
        <block>{<block_content>
            <decl_stmt><decl><type><name>ResTarget</name> <modifier>*</modifier></type><name>target</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>ColumnRef</name> <modifier>*</modifier></type><name>var</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>yielded_tle</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><name>target</name> <operator>=</operator> <operator>(</operator><name>ResTarget</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name><name>target</name><operator>-&gt;</operator><name>val</name></name></expr></argument>, <argument><expr><name>ColumnRef</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                                <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"YIELD item must be ColumnRef"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                                <call><name>parser_errposition</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cpstate</name><operator>-&gt;</operator><name>pstate</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <expr_stmt><expr><name>var</name> <operator>=</operator> <operator>(</operator><name>ColumnRef</name> <operator>*</operator><operator>)</operator> <name><name>target</name><operator>-&gt;</operator><name>val</name></name></expr>;</expr_stmt>

            <comment type="block">/* check if the restarget variable exists in the yield_targetList*/</comment>
            <if_stmt><if>if <condition>(<expr><call><name>findTarget</name><argument_list>(<argument><expr><name>yield_targetList</name></expr></argument>, <argument><expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>fields</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/* check if an alias exists. if one does, we check if it is
                   already declared in the targetlist */</comment>
                <if_stmt><if>if <condition>(<expr><name><name>target</name><operator>-&gt;</operator><name>name</name></name></expr>)</condition>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><call><name>findTarget</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>, <argument><expr><name><name>target</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DUPLICATE_ALIAS</name></expr></argument>)</argument_list></call><operator>,</operator>
                                        <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"duplicate variable \"%s\""</literal></expr></argument>, <argument><expr><name><name>target</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call><operator>,</operator>
                                        <call><name>parser_errposition</name><argument_list>(<argument><expr><operator>(</operator><name>ParseState</name> <operator>*</operator><operator>)</operator> <name>cpstate</name></expr></argument>, <argument><expr><call><name>exprLocation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>target</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if>
                    <else>else
                    <block>{<block_content>
                        <expr_stmt><expr><name>yielded_tle</name> <operator>=</operator> <call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
                                                      <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_next_resno</name></name><operator>++</operator></expr></argument>,
                                                       <argument><expr><name><name>target</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,
                                                       <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>, <argument><expr><name>yielded_tle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></else></if_stmt>
                </block_content>}</block></if>
                <else>else<comment type="block">/* if there is no alias, we check if the variable is already declared */</comment>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><call><name>findTarget</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>, <argument><expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>fields</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DUPLICATE_ALIAS</name></expr></argument>)</argument_list></call><operator>,</operator>
                                        <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"duplicate variable \"%s\""</literal></expr></argument>, <argument><expr><name>colName</name></expr></argument>)</argument_list></call><operator>,</operator>
                                        <call><name>parser_errposition</name><argument_list>(<argument><expr><operator>(</operator><name>ParseState</name> <operator>*</operator><operator>)</operator> <name>cpstate</name></expr></argument>, <argument><expr><call><name>exprLocation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>target</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if>
                    <else>else
                    <block>{<block_content>
                        <expr_stmt><expr><name>yielded_tle</name> <operator>=</operator> <call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
                                                      <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_next_resno</name></name><operator>++</operator></expr></argument>,
                                                       <argument><expr><name>colName</name></expr></argument>,
                                                       <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>, <argument><expr><name>yielded_tle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></else></if_stmt>
                </block_content>}</block></else></if_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <comment type="block">/* if the yield_item is not found and we return an error */</comment>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_COLUMN_REFERENCE</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Unknown CALL output"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><call><name>exprLocation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>target</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block>
    </block_content>}</block></if>
    <else>else <comment type="block">/* if there are no yield items this must be a solo call */</comment>
    <block>{<block_content>
        <expr_stmt><expr><name>tle</name> <operator>=</operator> <call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>,
                                    <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_next_resno</name></name><operator>++</operator></expr></argument>,
                                     <argument><expr><name>colName</name></expr></argument>,
                                     <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator>  <call><name>list_make1</name><argument_list>(<argument><expr><name>tle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>



    <expr_stmt><expr><call><name>markTargetListOrigins</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>rtable</name></name> <operator>=</operator> <name><name>cpstate</name><operator>-&gt;</operator><name>pstate</name><operator>.</operator><name>p_rtable</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>jointree</name></name> <operator>=</operator> <call><name>makeFromExpr</name><argument_list>(<argument><expr><name><name>cpstate</name><operator>-&gt;</operator><name>pstate</name><operator>.</operator><name>p_joinlist</name></name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name>where_qual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>hasAggs</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_hasAggs</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>assign_query_collations</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* this must be done after collations, for reliable comparison of exprs */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>pstate</name><operator>-&gt;</operator><name>p_hasAggs</name></name> <operator>||</operator>
        <name><name>query</name><operator>-&gt;</operator><name>groupClause</name></name> <operator>||</operator> <name><name>query</name><operator>-&gt;</operator><name>groupingSets</name></name> <operator>||</operator> <name><name>query</name><operator>-&gt;</operator><name>havingQual</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>parse_check_aggregates</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>free_parsestate</name><argument_list>(<argument><expr><name>p_child_parse_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>query</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Transform the Delete clause. Creates a _cypher_delete_clause
 * and passes the necessary information that is needed in the
 * execution phase.
 */</comment>
<function><type><specifier>static</specifier> <name>Query</name> <modifier>*</modifier></type><name>transform_cypher_delete</name><parameter_list>(<parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl></parameter>,
                                      <parameter><decl><type><name>cypher_clause</name> <modifier>*</modifier></type><name>clause</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name> <init>= <expr><operator>(</operator><name>ParseState</name> <operator>*</operator><operator>)</operator><name>cpstate</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>cypher_delete</name> <modifier>*</modifier></type><name>self</name> <init>= <expr><operator>(</operator><name>cypher_delete</name> <operator>*</operator><operator>)</operator><name><name>clause</name><operator>-&gt;</operator><name>self</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>FuncExpr</name> <modifier>*</modifier></type><name>func_expr</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>cypher_delete_information</name> <modifier>*</modifier></type><name>delete_data</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>delete_data</name> <operator>=</operator> <call><name>make_ag_node</name><argument_list>(<argument><expr><name>cypher_delete_information</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>commandType</name></name> <operator>=</operator> <name>CMD_SELECT</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>clause</name><operator>-&gt;</operator><name>prev</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"DELETE cannot be the first clause in a Cypher query"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>self</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><call><name>handle_prev_clause</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>, <argument><expr><name>query</name></expr></argument>, <argument><expr><name><name>clause</name><operator>-&gt;</operator><name>prev</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><name><name>delete_data</name><operator>-&gt;</operator><name>delete_items</name></name> <operator>=</operator> <call><name>transform_cypher_delete_item_list</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>,
                                                                  <argument><expr><name><name>self</name><operator>-&gt;</operator><name>exprs</name></name></expr></argument>,
                                                                  <argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>delete_data</name><operator>-&gt;</operator><name>graph_name</name></name> <operator>=</operator> <name><name>cpstate</name><operator>-&gt;</operator><name>graph_name</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>delete_data</name><operator>-&gt;</operator><name>graph_oid</name></name> <operator>=</operator> <name><name>cpstate</name><operator>-&gt;</operator><name>graph_oid</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>delete_data</name><operator>-&gt;</operator><name>detach</name></name> <operator>=</operator> <name><name>self</name><operator>-&gt;</operator><name>detach</name></name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>clause</name><operator>-&gt;</operator><name>next</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>delete_data</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>CYPHER_CLAUSE_FLAG_TERMINAL</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>func_expr</name> <operator>=</operator> <call><name>make_clause_func_expr</name><argument_list>(<argument><expr><name>DELETE_CLAUSE_FUNCTION_NAME</name></expr></argument>,
                                      <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name>delete_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Create the target entry</comment>
    <expr_stmt><expr><name>tle</name> <operator>=</operator> <call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator><name>func_expr</name></expr></argument>, <argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_next_resno</name></name><operator>++</operator></expr></argument>,
                          <argument><expr><name>AGE_VARNAME_DELETE_CLAUSE</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>, <argument><expr><name>tle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>rtable</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_rtable</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>jointree</name></name> <operator>=</operator> <call><name>makeFromExpr</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_joinlist</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>query</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * transform_cypher_unwind
 *      It contains logic to convert the form of an array into a row. Here, we
 *      are simply calling `age_unnest` function, and the actual transformation
 *      is handled by `age_unnest` function.
 */</comment>
<function><type><specifier>static</specifier> <name>Query</name> <modifier>*</modifier></type><name>transform_cypher_unwind</name><parameter_list>(<parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl></parameter>,
                                      <parameter><decl><type><name>cypher_clause</name> <modifier>*</modifier></type><name>clause</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name> <init>= <expr><operator>(</operator><name>ParseState</name> <operator>*</operator><operator>)</operator> <name>cpstate</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>cypher_unwind</name> <modifier>*</modifier></type><name>self</name> <init>= <expr><operator>(</operator><name>cypher_unwind</name> <operator>*</operator><operator>)</operator> <name><name>clause</name><operator>-&gt;</operator><name>self</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>target_syntax_loc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>expr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>FuncCall</name> <modifier>*</modifier></type><name>unwind</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ParseExprKind</name></type> <name>old_expr_kind</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>funcexpr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>te</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>commandType</name></name> <operator>=</operator> <name>CMD_SELECT</name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>clause</name><operator>-&gt;</operator><name>prev</name></name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>rtindex</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>transform_prev_cypher_clause</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>, <argument><expr><name><name>clause</name><operator>-&gt;</operator><name>prev</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rtindex</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_rtable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>rtindex</name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// rte is the first RangeTblEntry in pstate</comment>
        <expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <call><name>expandRelAttrs</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>, <argument><expr><name>rtindex</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>target_syntax_loc</name> <operator>=</operator> <call><name>exprLocation</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>Node</name> <operator>*</operator><operator>)</operator> <name><name>self</name><operator>-&gt;</operator><name>target</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>findTarget</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>, <argument><expr><name><name>self</name><operator>-&gt;</operator><name>target</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DUPLICATE_ALIAS</name></expr></argument>)</argument_list></call><operator>,</operator>
                        <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"duplicate variable \"%s\""</literal></expr></argument>, <argument><expr><name><name>self</name><operator>-&gt;</operator><name>target</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call><operator>,</operator>
                        <call><name>parser_errposition</name><argument_list>(<argument><expr><operator>(</operator><name>ParseState</name> <operator>*</operator><operator>)</operator> <name>cpstate</name></expr></argument>, <argument><expr><name>target_syntax_loc</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>expr</name> <operator>=</operator> <call><name>transform_cypher_expr</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>, <argument><expr><name><name>self</name><operator>-&gt;</operator><name>target</name><operator>-&gt;</operator><name>val</name></name></expr></argument>, <argument><expr><name>EXPR_KIND_SELECT_TARGET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>unwind</name> <operator>=</operator> <call><name>makeFuncCall</name><argument_list>(<argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><literal type="string">"age_unnest"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NIL</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


    <expr_stmt><expr><name>old_expr_kind</name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_expr_kind</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_expr_kind</name></name> <operator>=</operator> <name>EXPR_KIND_SELECT_TARGET</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>funcexpr</name> <operator>=</operator> <call><name>ParseFuncOrColumn</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>unwind</name><operator>-&gt;</operator><name>funcname</name></name></expr></argument>,
                                 <argument><expr><call><name>list_make2</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><call><name>makeBoolConst</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                                 <argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_last_srf</name></name></expr></argument>, <argument><expr><name>unwind</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
                                 <argument><expr><name>target_syntax_loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_expr_kind</name></name> <operator>=</operator> <name>old_expr_kind</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>te</name> <operator>=</operator> <call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>funcexpr</name></expr></argument>,
                         <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_next_resno</name></name><operator>++</operator></expr></argument>,
                         <argument><expr><name><name>self</name><operator>-&gt;</operator><name>target</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>, <argument><expr><name>te</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>rtable</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_rtable</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>jointree</name></name> <operator>=</operator> <call><name>makeFromExpr</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_joinlist</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>hasTargetSRFs</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_hasTargetSRFs</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>assign_query_collations</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>query</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Iterate through the list of items to delete and extract the variable name.
 * Then find the resno that the variable name belongs to.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>transform_cypher_delete_item_list</name><parameter_list>(<parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl></parameter>,
                                               <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>delete_item_list</name></decl></parameter>,
                                               <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name> <init>= <expr><operator>(</operator><name>ParseState</name> <operator>*</operator><operator>)</operator><name>cpstate</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>items</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

    <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>delete_item_list</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>expr</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ColumnRef</name> <modifier>*</modifier></type><name>col</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Value</name> <modifier>*</modifier></type><name>val</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pos</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>resno</name></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>cypher_delete_item</name> <modifier>*</modifier></type><name>item</name> <init>= <expr><call><name>make_ag_node</name><argument_list>(<argument><expr><name>cypher_delete_item</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>ColumnRef</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"unexpected Node for cypher_clause"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>col</name> <operator>=</operator> <operator>(</operator><name>ColumnRef</name> <operator>*</operator><operator>)</operator><name>expr</name></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>col</name><operator>-&gt;</operator><name>fields</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"unexpected Node for cypher_clause"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>col</name><operator>-&gt;</operator><name>fields</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name>String</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"unexpected Node for cypher_clause"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>resno</name> <operator>=</operator> <call><name>get_target_entry_resno</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>, <argument><expr><name><name>val</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>str</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>resno</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_COLUMN_REFERENCE</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"undefined reference to variable %s in DELETE clause"</literal></expr></argument>,
                            <argument><expr><name><name>val</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>str</name></name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>col</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>pos</name> <operator>=</operator> <call><name>makeInteger</name><argument_list>(<argument><expr><name>resno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>var_name</name></name> <operator>=</operator> <name><name>val</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>str</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>entity_position</name></name> <operator>=</operator> <name>pos</name></expr>;</expr_stmt>

        <expr_stmt><expr><name>items</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>items</name></expr></argument>, <argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>

    <return>return <expr><name>items</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Query</name> <modifier>*</modifier></type><name>transform_cypher_set</name><parameter_list>(<parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl></parameter>,
                                   <parameter><decl><type><name>cypher_clause</name> <modifier>*</modifier></type><name>clause</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name> <init>= <expr><operator>(</operator><name>ParseState</name> <operator>*</operator><operator>)</operator><name>cpstate</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>cypher_set</name> <modifier>*</modifier></type><name>self</name> <init>= <expr><operator>(</operator><name>cypher_set</name> <operator>*</operator><operator>)</operator><name><name>clause</name><operator>-&gt;</operator><name>self</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>cypher_update_information</name> <modifier>*</modifier></type><name>set_items_target_list</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>FuncExpr</name> <modifier>*</modifier></type><name>func_expr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>clause_name</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>commandType</name></name> <operator>=</operator> <name>CMD_SELECT</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>self</name><operator>-&gt;</operator><name>is_remove</name></name> <operator>==</operator> <name>true</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>clause_name</name> <operator>=</operator> <name>UPDATE_CLAUSE_REMOVE</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name>clause_name</name> <operator>=</operator> <name>UPDATE_CLAUSE_SET</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>clause</name><operator>-&gt;</operator><name>prev</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s cannot be the first clause in a Cypher query"</literal></expr></argument>,
                        <argument><expr><name>clause_name</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>self</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><call><name>handle_prev_clause</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>, <argument><expr><name>query</name></expr></argument>, <argument><expr><name><name>clause</name><operator>-&gt;</operator><name>prev</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>self</name><operator>-&gt;</operator><name>is_remove</name></name> <operator>==</operator> <name>true</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>set_items_target_list</name> <operator>=</operator> <call><name>transform_cypher_remove_item_list</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>,
                                                                  <argument><expr><name><name>self</name><operator>-&gt;</operator><name>items</name></name></expr></argument>,
                                                                  <argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name>set_items_target_list</name> <operator>=</operator> <call><name>transform_cypher_set_item_list</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>,
                                                               <argument><expr><name><name>self</name><operator>-&gt;</operator><name>items</name></name></expr></argument>,
                                                               <argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><name><name>set_items_target_list</name><operator>-&gt;</operator><name>clause_name</name></name> <operator>=</operator> <name>clause_name</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>set_items_target_list</name><operator>-&gt;</operator><name>graph_name</name></name> <operator>=</operator> <name><name>cpstate</name><operator>-&gt;</operator><name>graph_name</name></name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>clause</name><operator>-&gt;</operator><name>next</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>set_items_target_list</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>CYPHER_CLAUSE_FLAG_TERMINAL</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>func_expr</name> <operator>=</operator> <call><name>make_clause_func_expr</name><argument_list>(<argument><expr><name>SET_CLAUSE_FUNCTION_NAME</name></expr></argument>,
                                      <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name>set_items_target_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Create the target entry</comment>
    <expr_stmt><expr><name>tle</name> <operator>=</operator> <call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator><name>func_expr</name></expr></argument>, <argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_next_resno</name></name><operator>++</operator></expr></argument>,
                          <argument><expr><name>AGE_VARNAME_SET_CLAUSE</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>, <argument><expr><name>tle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>rtable</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_rtable</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>jointree</name></name> <operator>=</operator> <call><name>makeFromExpr</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_joinlist</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>query</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>cypher_update_information</name> <modifier>*</modifier></type><name>transform_cypher_remove_item_list</name><parameter_list>(
    <parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>remove_item_list</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name> <init>= <expr><operator>(</operator><name>ParseState</name> <operator>*</operator><operator>)</operator><name>cpstate</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>li</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>cypher_update_information</name> <modifier>*</modifier></type><name>info</name> <init>= <expr><call><name>make_ag_node</name><argument_list>(<argument><expr><name>cypher_update_information</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>set_items</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <macro><name>foreach</name> <argument_list>(<argument>li</argument>, <argument>remove_item_list</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>cypher_set_item</name> <modifier>*</modifier></type><name>set_item</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>li</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>cypher_update_item</name> <modifier>*</modifier></type><name>item</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ColumnRef</name> <modifier>*</modifier></type><name>ref</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>A_Indirection</name> <modifier>*</modifier></type><name>ind</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>variable_name</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>property_name</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Value</name> <modifier>*</modifier></type><name>property_node</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>variable_node</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>item</name> <operator>=</operator> <call><name>make_ag_node</name><argument_list>(<argument><expr><name>cypher_update_item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_ag_node</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>li</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>cypher_set_item</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unexpected node in cypher update list"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>set_item</name><operator>-&gt;</operator><name>is_add</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"REMOVE clause does not support adding propereties from maps"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>set_item</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>remove_item</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>


        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name><name>set_item</name><operator>-&gt;</operator><name>prop</name></name></expr></argument>, <argument><expr><name>A_Indirection</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"REMOVE clause must be in the format: REMOVE variable.property_name"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>set_item</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>ind</name> <operator>=</operator> <operator>(</operator><name>A_Indirection</name> <operator>*</operator><operator>)</operator><name><name>set_item</name><operator>-&gt;</operator><name>prop</name></name></expr>;</expr_stmt>

        <comment type="line">// extract variable name</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name><name>ind</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>, <argument><expr><name>ColumnRef</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"REMOVE clause must be in the format: REMOVE variable.property_name"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>set_item</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>ref</name> <operator>=</operator> <operator>(</operator><name>ColumnRef</name> <operator>*</operator><operator>)</operator><name><name>ind</name><operator>-&gt;</operator><name>arg</name></name></expr>;</expr_stmt>

        <expr_stmt><expr><name>variable_node</name> <operator>=</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>ref</name><operator>-&gt;</operator><name>fields</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>variable_name</name> <operator>=</operator> <name><name>variable_node</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>str</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>var_name</name></name> <operator>=</operator> <name>variable_name</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>entity_position</name></name> <operator>=</operator> <call><name>get_target_entry_resno</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>,
                                                       <argument><expr><name>variable_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>item</name><operator>-&gt;</operator><name>entity_position</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_COLUMN_REFERENCE</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"undefined reference to variable %s in REMOVE clause"</literal></expr></argument>,
                            <argument><expr><name>variable_name</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>set_item</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="line">// extract property name</comment>
        <if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>ind</name><operator>-&gt;</operator><name>indirection</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"REMOVE clause must be in the format: REMOVE variable.property_name"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>set_item</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>property_node</name> <operator>=</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>ind</name><operator>-&gt;</operator><name>indirection</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>property_node</name></expr></argument>, <argument><expr><name>String</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_COLUMN_REFERENCE</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"REMOVE clause expects a property name"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>set_item</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>property_name</name> <operator>=</operator> <name><name>property_node</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>str</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>prop_name</name></name> <operator>=</operator> <name>property_name</name></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>set_items</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>info</name><operator>-&gt;</operator><name>set_items</name></name></expr></argument>, <argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>

    <return>return <expr><name>info</name></expr>;</return>
</block_content>}</block></function>


<function><type><name>cypher_update_information</name> <modifier>*</modifier></type><name>transform_cypher_set_item_list</name><parameter_list>(
    <parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>set_item_list</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name> <init>= <expr><operator>(</operator><name>ParseState</name> <operator>*</operator><operator>)</operator><name>cpstate</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>li</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>cypher_update_information</name> <modifier>*</modifier></type><name>info</name> <init>= <expr><call><name>make_ag_node</name><argument_list>(<argument><expr><name>cypher_update_information</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>set_items</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <macro><name>foreach</name> <argument_list>(<argument>li</argument>, <argument>set_item_list</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>cypher_set_item</name> <modifier>*</modifier></type><name>set_item</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>li</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>target_item</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>cypher_update_item</name> <modifier>*</modifier></type><name>item</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ColumnRef</name> <modifier>*</modifier></type><name>ref</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>A_Indirection</name> <modifier>*</modifier></type><name>ind</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>variable_name</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>property_name</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Value</name> <modifier>*</modifier></type><name>property_node</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>variable_node</name></decl>;</decl_stmt>

        <comment type="line">// ColumnRef may come according to the Parser rule.</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name><name>set_item</name><operator>-&gt;</operator><name>prop</name></name></expr></argument>, <argument><expr><name>A_Indirection</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_COLUMN_REFERENCE</name></expr></argument>)</argument_list></call><operator>,</operator>
                            <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"SET clause expects a variable name"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                            <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>set_item</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>ind</name> <operator>=</operator> <operator>(</operator><name>A_Indirection</name> <operator>*</operator><operator>)</operator><name><name>set_item</name><operator>-&gt;</operator><name>prop</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>item</name> <operator>=</operator> <call><name>make_ag_node</name><argument_list>(<argument><expr><name>cypher_update_item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_ag_node</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>li</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>cypher_set_item</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unexpected node in cypher update list"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>set_item</name><operator>-&gt;</operator><name>is_add</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"SET clause does not yet support adding propereties from maps"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>set_item</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>remove_item</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

        <comment type="line">// extract variable name</comment>
        <expr_stmt><expr><name>ref</name> <operator>=</operator> <operator>(</operator><name>ColumnRef</name> <operator>*</operator><operator>)</operator><name><name>ind</name><operator>-&gt;</operator><name>arg</name></name></expr>;</expr_stmt>

        <expr_stmt><expr><name>variable_node</name> <operator>=</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>ref</name><operator>-&gt;</operator><name>fields</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>variable_node</name></expr></argument>, <argument><expr><name>String</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_COLUMN_REFERENCE</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"SET clause expects a variable name"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>set_item</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>variable_name</name> <operator>=</operator> <name><name>variable_node</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>str</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>var_name</name></name> <operator>=</operator> <name>variable_name</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>entity_position</name></name> <operator>=</operator> <call><name>get_target_entry_resno</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>,
                                                       <argument><expr><name>variable_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>item</name><operator>-&gt;</operator><name>entity_position</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_COLUMN_REFERENCE</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"undefined reference to variable %s in SET clause"</literal></expr></argument>,
                            <argument><expr><name>variable_name</name></expr></argument>)</argument_list></call><operator>,</operator>
                            <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>set_item</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="line">// extract property name</comment>
        <if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>ind</name><operator>-&gt;</operator><name>indirection</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"SET clause doesnt not support updating maps or lists in a property"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>set_item</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>property_node</name> <operator>=</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>ind</name><operator>-&gt;</operator><name>indirection</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>property_node</name></expr></argument>, <argument><expr><name>String</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_COLUMN_REFERENCE</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"SET clause expects a property name"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>set_item</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>property_name</name> <operator>=</operator> <name><name>property_node</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>str</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>prop_name</name></name> <operator>=</operator> <name>property_name</name></expr>;</expr_stmt>

        <comment type="line">// create target entry for the new property value</comment>
        <expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>prop_position</name></name> <operator>=</operator> <operator>(</operator><name>AttrNumber</name><operator>)</operator><name><name>pstate</name><operator>-&gt;</operator><name>p_next_resno</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>target_item</name> <operator>=</operator> <call><name>transform_cypher_item</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>, <argument><expr><name><name>set_item</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                            <argument><expr><name>EXPR_KIND_SELECT_TARGET</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                            <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>target_item</name><operator>-&gt;</operator><name>expr</name></name> <operator>=</operator> <call><name>add_volatile_wrapper</name><argument_list>(<argument><expr><name><name>target_item</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>, <argument><expr><name>target_item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>set_items</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>info</name><operator>-&gt;</operator><name>set_items</name></name></expr></argument>, <argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>

    <return>return <expr><name>info</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* from PG's static helper function */</comment>
<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>flatten_grouping_sets</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>toplevel</name></decl></parameter>,
                                   <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>hasGroupingSets</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/* just in case of pathological input */</comment>
    <expr_stmt><expr><call><name>check_stack_depth</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>expr</name> <operator>==</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>NIL</name></expr>)</condition>
    <block>{<block_content>
        <return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>NIL</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <switch>switch <condition>(<expr><name><name>expr</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>T_RowExpr</name></expr>:</case>
        <block>{<block_content>
            <decl_stmt><decl><type><name>RowExpr</name> <modifier>*</modifier></type><name>r</name> <init>= <expr><operator>(</operator><name>RowExpr</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>r</name><operator>-&gt;</operator><name>row_format</name></name> <operator>==</operator> <name>COERCE_IMPLICIT_CAST</name></expr>)</condition>
            <block>{<block_content>
                <return>return <expr><call><name>flatten_grouping_sets</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>r</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
            </block_content>}</block></if></if_stmt>
            <break>break;</break>
        </block_content>}</block>
        <case>case <expr><name>T_GroupingSet</name></expr>:</case>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"flattening of GroupingSet is not implemented"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        <case>case <expr><name>T_List</name></expr>:</case>
        <block>{<block_content>
            <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

            <macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>(List *) expr</argument>)</argument_list></macro>
            <block>{<block_content>
                <decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>n</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

                <expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>flatten_grouping_sets</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>toplevel</name></expr></argument>, <argument><expr><name>hasGroupingSets</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <if_stmt><if>if <condition>(<expr><name>n</name> <operator>!=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>NIL</name></expr>)</condition>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>List</name></expr></argument>)</argument_list></call></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if>
                    <else>else
                    <block>{<block_content>
                        <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></else></if_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block>
            <return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>result</name></expr>;</return>
        </block_content>}</block>
        <default>default:</default>
            <break>break;</break>
    </block_content>}</block></switch>
    <return>return <expr><name>expr</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* from PG's addTargetToGroupList */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>add_target_to_group_list</name><parameter_list>(<parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl></parameter>,
                                      <parameter><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>grouplist</name></decl></parameter>,
                                      <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>targetlist</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>location</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name> <init>= <expr><operator>&amp;</operator><name><name>cpstate</name><operator>-&gt;</operator><name>pstate</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type> <name>restype</name> <init>= <expr><call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block">/* if tlist item is an UNKNOWN literal, change it to TEXT */</comment>
    <if_stmt><if>if <condition>(<expr><name>restype</name> <operator>==</operator> <name>UNKNOWNOID</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>tle</name><operator>-&gt;</operator><name>expr</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>coerce_type</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>restype</name></expr></argument>,
                                         <argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>COERCION_IMPLICIT</name></expr></argument>,
                                         <argument><expr><name>COERCE_IMPLICIT_CAST</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>restype</name> <operator>=</operator> <name>TEXTOID</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* avoid making duplicate grouplist entries */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>targetIsInSortList</name><argument_list>(<argument><expr><name>tle</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>grouplist</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>SortGroupClause</name> <modifier>*</modifier></type><name>grpcl</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>SortGroupClause</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Oid</name></type> <name>sortop</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Oid</name></type> <name>eqop</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type> <name>hashable</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ParseCallbackState</name></type> <name>pcbstate</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>setup_parser_errposition_callback</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pcbstate</name></expr></argument>, <argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* determine the eqop and optional sortop */</comment>
        <expr_stmt><expr><call><name>get_sort_group_operators</name><argument_list>(<argument><expr><name>restype</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sortop</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>eqop</name></expr></argument>,
                                 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hashable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>cancel_parser_errposition_callback</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pcbstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>grpcl</name><operator>-&gt;</operator><name>tleSortGroupRef</name></name> <operator>=</operator> <call><name>assignSortGroupRef</name><argument_list>(<argument><expr><name>tle</name></expr></argument>, <argument><expr><name>targetlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>grpcl</name><operator>-&gt;</operator><name>eqop</name></name> <operator>=</operator> <name>eqop</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>grpcl</name><operator>-&gt;</operator><name>sortop</name></name> <operator>=</operator> <name>sortop</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>grpcl</name><operator>-&gt;</operator><name>nulls_first</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt> <comment type="block">/* OK with or without sortop */</comment>
        <expr_stmt><expr><name><name>grpcl</name><operator>-&gt;</operator><name>hashable</name></name> <operator>=</operator> <name>hashable</name></expr>;</expr_stmt>

        <expr_stmt><expr><name>grouplist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>grouplist</name></expr></argument>, <argument><expr><name>grpcl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>grouplist</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* from PG's transformGroupClauseExpr */</comment>
<function><type><specifier>static</specifier> <name>Index</name></type> <name>transform_group_clause_expr</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>flatresult</name></decl></parameter>,
                                         <parameter><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>seen_local</name></decl></parameter>,
                                         <parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl></parameter>,
                                         <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>gexpr</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>targetlist</name></decl></parameter>,
                                         <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>sortClause</name></decl></parameter>,
                                         <parameter><decl><type><name>ParseExprKind</name></type> <name>exprKind</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>toplevel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>tle</name> <operator>=</operator> <call><name>find_target_list_entry</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>, <argument><expr><name>gexpr</name></expr></argument>, <argument><expr><name>targetlist</name></expr></argument>, <argument><expr><name>exprKind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>tle</name><operator>-&gt;</operator><name>ressortgroupref</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>sl</name></decl>;</decl_stmt>

        <comment type="block">/*
         * Eliminate duplicates (GROUP BY x, x) but only at local level.
         * (Duplicates in grouping sets can affect the number of returned
         * rows, so can't be dropped indiscriminately.)
         *
         * Since we don't care about anything except the sortgroupref, we can
         * use a bitmapset rather than scanning lists.
         */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>bms_is_member</name><argument_list>(<argument><expr><name><name>tle</name><operator>-&gt;</operator><name>ressortgroupref</name></name></expr></argument>, <argument><expr><name>seen_local</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <return>return <expr><literal type="number">0</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/*
         * If we're already in the flat clause list, we don't need to consider
         * adding ourselves again.
         */</comment>
        <expr_stmt><expr><name>found</name> <operator>=</operator> <call><name>targetIsInSortList</name><argument_list>(<argument><expr><name>tle</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><operator>*</operator><name>flatresult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition>
        <block>{<block_content>
            <return>return <expr><name><name>tle</name><operator>-&gt;</operator><name>ressortgroupref</name></name></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/*
         * If the GROUP BY tlist entry also appears in ORDER BY, copy operator
         * info from the (first) matching ORDER BY item.  This means that if
         * you write something like "GROUP BY foo ORDER BY foo USING &lt;&lt;&lt;", the
         * GROUP BY operation silently takes on the equality semantics implied
         * by the ORDER BY.  There are two reasons to do this: it improves the
         * odds that we can implement both GROUP BY and ORDER BY with a single
         * sort step, and it allows the user to choose the equality semantics
         * used by GROUP BY, should she be working with a datatype that has
         * more than one equality operator.
         *
         * If we're in a grouping set, though, we force our requested ordering
         * to be NULLS LAST, because if we have any hope of using a sorted agg
         * for the job, we're going to be tacking on generated NULL values
         * after the corresponding groups. If the user demands nulls first,
         * another sort step is going to be inevitable, but that's the
         * planner's problem.
         */</comment>


         <macro><name>foreach</name><argument_list>(<argument>sl</argument>, <argument>sortClause</argument>)</argument_list></macro>
         <block>{<block_content>
             <decl_stmt><decl><type><name>SortGroupClause</name> <modifier>*</modifier></type><name>sc</name> <init>= <expr><operator>(</operator><name>SortGroupClause</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>sl</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

             <if_stmt><if>if <condition>(<expr><name><name>sc</name><operator>-&gt;</operator><name>tleSortGroupRef</name></name> <operator>==</operator> <name><name>tle</name><operator>-&gt;</operator><name>ressortgroupref</name></name></expr>)</condition>
             <block>{<block_content>
                 <decl_stmt><decl><type><name>SortGroupClause</name> <modifier>*</modifier></type><name>grpc</name> <init>= <expr><call><name>copyObject</name><argument_list>(<argument><expr><name>sc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                 <if_stmt><if>if <condition>(<expr><operator>!</operator><name>toplevel</name></expr>)</condition>
                 <block>{<block_content>
                     <expr_stmt><expr><name><name>grpc</name><operator>-&gt;</operator><name>nulls_first</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
                 </block_content>}</block></if></if_stmt>
                 <expr_stmt><expr><operator>*</operator><name>flatresult</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><operator>*</operator><name>flatresult</name></expr></argument>, <argument><expr><name>grpc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                 <expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                 <break>break;</break>
             </block_content>}</block></if></if_stmt>
         </block_content>}</block>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * If no match in ORDER BY, just add it to the result using default
     * sort/group semantics.
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>flatresult</name> <operator>=</operator> <call><name>add_target_to_group_list</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>, <argument><expr><name>tle</name></expr></argument>, <argument><expr><operator>*</operator><name>flatresult</name></expr></argument>,
                                               <argument><expr><operator>*</operator><name>targetlist</name></expr></argument>, <argument><expr><call><name>exprLocation</name><argument_list>(<argument><expr><name>gexpr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* _something_ must have assigned us a sortgroupref by now... */</comment>

    <return>return <expr><name><name>tle</name><operator>-&gt;</operator><name>ressortgroupref</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* from PG's transformGroupClause */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type> <name>transform_group_clause</name><parameter_list>(<parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl></parameter>,
                                     <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>grouplist</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>groupingSets</name></decl></parameter>,
                                     <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>targetlist</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>sortClause</name></decl></parameter>,
                                     <parameter><decl><type><name>ParseExprKind</name></type> <name>exprKind</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>flat_grouplist</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>gsets</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>gl</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>hasGroupingSets</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>seen_local</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/*
     * Recursively flatten implicit RowExprs. (Technically this is only needed
     * for GROUP BY, per the syntax rules for grouping sets, but we do it
     * anyway.)
     */</comment>
    <expr_stmt><expr><name>flat_grouplist</name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>flatten_grouping_sets</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>grouplist</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
                                                    <argument><expr><operator>&amp;</operator><name>hasGroupingSets</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <macro><name>foreach</name><argument_list>(<argument>gl</argument>, <argument>flat_grouplist</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Node</name>       <modifier>*</modifier></type><name>gexpr</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>gl</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>gexpr</name></expr></argument>, <argument><expr><name>GroupingSet</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                            <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"GroupingSet is not implemented"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <decl_stmt><decl><type><name>Index</name></type> <name>ref</name> <init>= <expr><call><name>transform_group_clause_expr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>, <argument><expr><name>seen_local</name></expr></argument>,
                                                    <argument><expr><name>cpstate</name></expr></argument>, <argument><expr><name>gexpr</name></expr></argument>, <argument><expr><name>targetlist</name></expr></argument>,
                                                    <argument><expr><name>sortClause</name></expr></argument>, <argument><expr><name>exprKind</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if_stmt><if>if <condition>(<expr><name>ref</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>seen_local</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name>seen_local</name></expr></argument>, <argument><expr><name>ref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>hasGroupingSets</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
                            <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"GroupingSet is not implemented"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block>

    <comment type="block">/* parser should prevent this */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>gsets</name> <operator>==</operator> <name>NIL</name> <operator>||</operator> <name>groupingSets</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>groupingSets</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>groupingSets</name> <operator>=</operator> <name>gsets</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Query</name> <modifier>*</modifier></type><name>transform_cypher_return</name><parameter_list>(<parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl></parameter>,
                                      <parameter><decl><type><name>cypher_clause</name> <modifier>*</modifier></type><name>clause</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name> <init>= <expr><operator>(</operator><name>ParseState</name> <operator>*</operator><operator>)</operator><name>cpstate</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>cypher_return</name> <modifier>*</modifier></type><name>self</name> <init>= <expr><operator>(</operator><name>cypher_return</name> <operator>*</operator><operator>)</operator><name><name>clause</name><operator>-&gt;</operator><name>self</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>groupClause</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>commandType</name></name> <operator>=</operator> <name>CMD_SELECT</name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>clause</name><operator>-&gt;</operator><name>prev</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>transform_prev_cypher_clause</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>, <argument><expr><name><name>clause</name><operator>-&gt;</operator><name>prev</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <call><name>transform_cypher_item_list</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>, <argument><expr><name><name>self</name><operator>-&gt;</operator><name>items</name></name></expr></argument>,
                                                   <argument><expr><operator>&amp;</operator><name>groupClause</name></expr></argument>,
                                                   <argument><expr><name>EXPR_KIND_SELECT_TARGET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>markTargetListOrigins</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// ORDER BY</comment>
    <expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>sortClause</name></name> <operator>=</operator> <call><name>transform_cypher_order_by</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>, <argument><expr><name><name>self</name><operator>-&gt;</operator><name>order_by</name></name></expr></argument>,
                                                  <argument><expr><operator>&amp;</operator><name><name>query</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>,
                                                  <argument><expr><name>EXPR_KIND_ORDER_BY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* 'auto' GROUP BY (from PG's transformGroupClause) */</comment>
    <expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>groupClause</name></name> <operator>=</operator> <call><name>transform_group_clause</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>, <argument><expr><name>groupClause</name></expr></argument>,
                                                <argument><expr><operator>&amp;</operator><name><name>query</name><operator>-&gt;</operator><name>groupingSets</name></name></expr></argument>,
                                                <argument><expr><operator>&amp;</operator><name><name>query</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>,
                                                <argument><expr><name><name>query</name><operator>-&gt;</operator><name>sortClause</name></name></expr></argument>,
                                                <argument><expr><name>EXPR_KIND_GROUP_BY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// DISTINCT</comment>
    <if_stmt><if>if <condition>(<expr><name><name>self</name><operator>-&gt;</operator><name>distinct</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>distinctClause</name></name> <operator>=</operator> <call><name>transformDistinctClause</name><argument_list>(
            <argument><expr><name>pstate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>query</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>sortClause</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>hasDistinctOn</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>distinctClause</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>hasDistinctOn</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="line">// SKIP and LIMIT</comment>
    <expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>limitOffset</name></name> <operator>=</operator> <call><name>transform_cypher_limit</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>, <argument><expr><name><name>self</name><operator>-&gt;</operator><name>skip</name></name></expr></argument>,
                                                <argument><expr><name>EXPR_KIND_OFFSET</name></expr></argument>, <argument><expr><literal type="string">"SKIP"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>limitCount</name></name> <operator>=</operator> <call><name>transform_cypher_limit</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>, <argument><expr><name><name>self</name><operator>-&gt;</operator><name>limit</name></name></expr></argument>,
                                               <argument><expr><name>EXPR_KIND_LIMIT</name></expr></argument>, <argument><expr><literal type="string">"LIMIT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>rtable</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_rtable</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>jointree</name></name> <operator>=</operator> <call><name>makeFromExpr</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_joinlist</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>hasAggs</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_hasAggs</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>assign_query_collations</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* this must be done after collations, for reliable comparison of exprs */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>pstate</name><operator>-&gt;</operator><name>p_hasAggs</name></name> <operator>||</operator>
        <name><name>query</name><operator>-&gt;</operator><name>groupClause</name></name> <operator>||</operator> <name><name>query</name><operator>-&gt;</operator><name>groupingSets</name></name> <operator>||</operator> <name><name>query</name><operator>-&gt;</operator><name>havingQual</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>parse_check_aggregates</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>query</name></expr>;</return>
</block_content>}</block></function>

<comment type="line">// see transformSortClause()</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>transform_cypher_order_by</name><parameter_list>(<parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl></parameter>,
                                       <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>sort_items</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>target_list</name></decl></parameter>,
                                       <parameter><decl><type><name>ParseExprKind</name></type> <name>expr_kind</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name> <init>= <expr><operator>(</operator><name>ParseState</name> <operator>*</operator><operator>)</operator><name>cpstate</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>sort_list</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>li</name></decl>;</decl_stmt>

    <macro><name>foreach</name> <argument_list>(<argument>li</argument>, <argument>sort_items</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>SortBy</name> <modifier>*</modifier></type><name>sort_by</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>li</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>te</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>te</name> <operator>=</operator> <call><name>find_target_list_entry</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>, <argument><expr><name><name>sort_by</name><operator>-&gt;</operator><name>node</name></name></expr></argument>, <argument><expr><name>target_list</name></expr></argument>,
                                    <argument><expr><name>expr_kind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>sort_list</name> <operator>=</operator> <call><name>addTargetToSortList</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>te</name></expr></argument>, <argument><expr><name>sort_list</name></expr></argument>, <argument><expr><operator>*</operator><name>target_list</name></expr></argument>,
                                        <argument><expr><name>sort_by</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>

    <return>return <expr><name>sort_list</name></expr>;</return>
</block_content>}</block></function>

<comment type="line">// see findTargetlistEntrySQL99()</comment>
<function><type><specifier>static</specifier> <name>TargetEntry</name> <modifier>*</modifier></type><name>find_target_list_entry</name><parameter_list>(<parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl></parameter>,
                                           <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>target_list</name></decl></parameter>,
                                           <parameter><decl><type><name>ParseExprKind</name></type> <name>expr_kind</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>expr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lt</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>te</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>expr</name> <operator>=</operator> <call><name>transform_cypher_expr</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>expr_kind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <macro><name>foreach</name> <argument_list>(<argument>lt</argument>, <argument>*target_list</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>te_expr</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>te</name> <operator>=</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>te_expr</name> <operator>=</operator> <call><name>strip_implicit_coercions</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name><name>te</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>equal</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>te_expr</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <return>return <expr><name>te</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block>

    <expr_stmt><expr><name>te</name> <operator>=</operator> <call><name>transform_cypher_item</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name>expr_kind</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><operator>*</operator><name>target_list</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><operator>*</operator><name>target_list</name></expr></argument>, <argument><expr><name>te</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>te</name></expr>;</return>
</block_content>}</block></function>

<comment type="line">// see transformLimitClause()</comment>
<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>transform_cypher_limit</name><parameter_list>(<parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
                                    <parameter><decl><type><name>ParseExprKind</name></type> <name>expr_kind</name></decl></parameter>,
                                    <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>construct_name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name> <init>= <expr><operator>(</operator><name>ParseState</name> <operator>*</operator><operator>)</operator><name>cpstate</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>qual</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>node</name></expr>)</condition>
    <block>{<block_content>
        <return>return <expr><name>NULL</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>qual</name> <operator>=</operator> <call><name>transform_cypher_expr</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>expr_kind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>qual</name> <operator>=</operator> <call><name>coerce_to_specific_type</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>qual</name></expr></argument>, <argument><expr><name>INT8OID</name></expr></argument>, <argument><expr><name>construct_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// LIMIT can't refer to any variables of the current query.</comment>
    <if_stmt><if>if <condition>(<expr><call><name>contain_vars_of_level</name><argument_list>(<argument><expr><name>qual</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_COLUMN_REFERENCE</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"argument of %s must not contain variables"</literal></expr></argument>,
                        <argument><expr><name>construct_name</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><call><name>locate_var_of_level</name><argument_list>(<argument><expr><name>qual</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>qual</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Query</name> <modifier>*</modifier></type><name>transform_cypher_with</name><parameter_list>(<parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl></parameter>,
                                    <parameter><decl><type><name>cypher_clause</name> <modifier>*</modifier></type><name>clause</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>cypher_with</name> <modifier>*</modifier></type><name>self</name> <init>= <expr><operator>(</operator><name>cypher_with</name> <operator>*</operator><operator>)</operator><name><name>clause</name><operator>-&gt;</operator><name>self</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>cypher_return</name> <modifier>*</modifier></type><name>return_clause</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>cypher_clause</name> <modifier>*</modifier></type><name>wrapper</name></decl>;</decl_stmt>

    <comment type="line">// TODO: check that all items have an alias for each</comment>

    <comment type="line">// WITH clause is basically RETURN clause with optional WHERE subclause</comment>
    <expr_stmt><expr><name>return_clause</name> <operator>=</operator> <call><name>make_ag_node</name><argument_list>(<argument><expr><name>cypher_return</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>return_clause</name><operator>-&gt;</operator><name>distinct</name></name> <operator>=</operator> <name><name>self</name><operator>-&gt;</operator><name>distinct</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>return_clause</name><operator>-&gt;</operator><name>items</name></name> <operator>=</operator> <name><name>self</name><operator>-&gt;</operator><name>items</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>return_clause</name><operator>-&gt;</operator><name>order_by</name></name> <operator>=</operator> <name><name>self</name><operator>-&gt;</operator><name>order_by</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>return_clause</name><operator>-&gt;</operator><name>skip</name></name> <operator>=</operator> <name><name>self</name><operator>-&gt;</operator><name>skip</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>return_clause</name><operator>-&gt;</operator><name>limit</name></name> <operator>=</operator> <name><name>self</name><operator>-&gt;</operator><name>limit</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><name>wrapper</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>wrapper</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>wrapper</name><operator>-&gt;</operator><name>self</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name>return_clause</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>wrapper</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name><name>clause</name><operator>-&gt;</operator><name>prev</name></name></expr>;</expr_stmt>

    <return>return <expr><call><name>transform_cypher_clause_with_where</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>, <argument><expr><name>transform_cypher_return</name></expr></argument>,
                                              <argument><expr><name>wrapper</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>match_check_valid_label</name><parameter_list>(<parameter><decl><type><name>cypher_match</name> <modifier>*</modifier></type><name>match</name></decl></parameter>,
                                    <parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>cell1</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>cell2</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>cypher_path</name> <modifier>*</modifier></type><name>path</name></decl>;</decl_stmt>

    <macro><name>foreach</name><argument_list>(<argument>cell1</argument>, <argument>match-&gt;pattern</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>path</name> <operator>=</operator> <operator>(</operator><name>cypher_path</name><operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>cell1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <macro><name>foreach</name><argument_list>(<argument>cell2</argument>, <argument>path-&gt;path</argument>)</argument_list></macro>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>i</name> <operator>%</operator> <literal type="number">2</literal> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>cypher_node</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

                <expr_stmt><expr><name>node</name> <operator>=</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>cell2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>label</name></name></expr>)</condition>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>label_cache_data</name> <modifier>*</modifier></type><name>lcd</name> <init>=
                        <expr><call><name>search_label_name_graph_cache</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>label</name></name></expr></argument>,
                                                      <argument><expr><name><name>cpstate</name><operator>-&gt;</operator><name>graph_oid</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                    <if_stmt><if>if <condition>(<expr><name>lcd</name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
                        <name><name>lcd</name><operator>-&gt;</operator><name>kind</name></name> <operator>!=</operator> <name>LABEL_KIND_VERTEX</name></expr>)</condition>
                    <block>{<block_content>
                        <return>return <expr><name>false</name></expr>;</return>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <decl_stmt><decl><type><name>cypher_relationship</name> <modifier>*</modifier></type><name>rel</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

                <expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>cell2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>label</name></name></expr>)</condition>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>label_cache_data</name> <modifier>*</modifier></type><name>lcd</name> <init>=
                        <expr><call><name>search_label_name_graph_cache</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>label</name></name></expr></argument>,
                                                      <argument><expr><name><name>cpstate</name><operator>-&gt;</operator><name>graph_oid</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                    <if_stmt><if>if <condition>(<expr><name>lcd</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>lcd</name><operator>-&gt;</operator><name>kind</name></name> <operator>!=</operator> <name>LABEL_KIND_EDGE</name></expr>)</condition>
                    <block>{<block_content>
                        <return>return <expr><name>false</name></expr>;</return>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></else></if_stmt>
            <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block>
    </block_content>}</block>

    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Query</name> <modifier>*</modifier></type><name>transform_cypher_clause_with_where</name><parameter_list>(<parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl></parameter>,
                                                 <parameter><decl><type><name>transform_method</name></type> <name>transform</name></decl></parameter>,
                                                 <parameter><decl><type><name>cypher_clause</name> <modifier>*</modifier></type><name>clause</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name> <init>= <expr><operator>(</operator><name>ParseState</name> <operator>*</operator><operator>)</operator><name>cpstate</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>self</name> <init>= <expr><name><name>clause</name><operator>-&gt;</operator><name>self</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>cypher_match</name> <modifier>*</modifier></type><name>match_self</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>cypher_call</name> <modifier>*</modifier></type><name>call_self</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>where</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>is_ag_node</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>cypher_call</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>call_self</name> <operator>=</operator> <operator>(</operator><name>cypher_call</name><operator>*</operator><operator>)</operator> <name><name>clause</name><operator>-&gt;</operator><name>self</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>where</name> <operator>=</operator> <name><name>call_self</name><operator>-&gt;</operator><name>where</name></name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name>match_self</name> <operator>=</operator> <operator>(</operator><name>cypher_match</name><operator>*</operator><operator>)</operator> <name><name>clause</name><operator>-&gt;</operator><name>self</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>where</name> <operator>=</operator> <name><name>match_self</name><operator>-&gt;</operator><name>where</name></name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>where</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>rtindex</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>commandType</name></name> <operator>=</operator> <name>CMD_SELECT</name></expr>;</expr_stmt>

        <expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>transform_cypher_clause_as_subquery</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>, <argument><expr><name>transform</name></expr></argument>, <argument><expr><name>clause</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>rtindex</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_rtable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>rtindex</name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// rte is the only RangeTblEntry in pstate</comment>

        <expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <call><name>expandRelAttrs</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>, <argument><expr><name>rtindex</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>markTargetListOrigins</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>rtable</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_rtable</name></name></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>is_ag_node</name><argument_list>(<argument><expr><name><name>clause</name><operator>-&gt;</operator><name>self</name></name></expr></argument>, <argument><expr><name>cypher_call</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>cypher_call</name> <modifier>*</modifier></type><name>call</name> <init>= <expr><operator>(</operator><name>cypher_call</name> <operator>*</operator><operator>)</operator><name><name>clause</name><operator>-&gt;</operator><name>self</name></name></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>call</name><operator>-&gt;</operator><name>where</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>where_qual</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

                <expr_stmt><expr><name>where_qual</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator><call><name>transform_cypher_expr</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>, <argument><expr><name><name>call</name><operator>-&gt;</operator><name>where</name></name></expr></argument>,
                                                           <argument><expr><name>EXPR_KIND_WHERE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><name>where_qual</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator><call><name>coerce_to_boolean</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name>where_qual</name></expr></argument>,
                                               <argument><expr><literal type="string">"WHERE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>jointree</name></name> <operator>=</operator> <call><name>makeFromExpr</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_joinlist</name></name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name>where_qual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>jointree</name></name> <operator>=</operator> <call><name>makeFromExpr</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_joinlist</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><call><name>assign_query_collations</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>transform</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>, <argument><expr><name>clause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>hasSubLinks</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_hasSubLinks</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>hasTargetSRFs</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_hasTargetSRFs</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>hasAggs</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_hasAggs</name></name></expr>;</expr_stmt>

    <return>return <expr><name>query</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Query</name> <modifier>*</modifier></type><name>transform_cypher_match</name><parameter_list>(<parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl></parameter>,
                                     <parameter><decl><type><name>cypher_clause</name> <modifier>*</modifier></type><name>clause</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>cypher_match</name> <modifier>*</modifier></type><name>match_self</name> <init>= <expr><operator>(</operator><name>cypher_match</name><operator>*</operator><operator>)</operator> <name><name>clause</name><operator>-&gt;</operator><name>self</name></name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>match_check_valid_label</name><argument_list>(<argument><expr><name>match_self</name></expr></argument>, <argument><expr><name>cpstate</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>cypher_bool_const</name> <modifier>*</modifier></type><name>l</name> <init>= <expr><call><name>make_ag_node</name><argument_list>(<argument><expr><name>cypher_bool_const</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>cypher_bool_const</name> <modifier>*</modifier></type><name>r</name> <init>= <expr><call><name>make_ag_node</name><argument_list>(<argument><expr><name>cypher_bool_const</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name><name>l</name><operator>-&gt;</operator><name>boolean</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>l</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>r</name><operator>-&gt;</operator><name>boolean</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>r</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

        <comment type="block">/*if the label is invalid, create a paradoxical where to get null*/</comment>
        <expr_stmt><expr><name><name>match_self</name><operator>-&gt;</operator><name>where</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><call><name>makeSimpleA_Expr</name><argument_list>(<argument><expr><name>AEXPR_OP</name></expr></argument>, <argument><expr><literal type="string">"="</literal></expr></argument>,
                                                     <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name>l</name></expr></argument>,
                                                     <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name>r</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><call><name>transform_cypher_clause_with_where</name><argument_list>(
        <argument><expr><name>cpstate</name></expr></argument>, <argument><expr><name>transform_cypher_match_pattern</name></expr></argument>, <argument><expr><name>clause</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Transform the clause into a subquery. This subquery will be used
 * in a join so setup the namespace item and the created the rtr
 * for the join to use.
 */</comment>
<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>transform_clause_for_join</name><parameter_list>(<parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl></parameter>,
                                       <parameter><decl><type><name>cypher_clause</name> <modifier>*</modifier></type><name>clause</name></decl></parameter>,
                                       <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier><modifier>*</modifier></type><name>rte</name></decl></parameter>,
                                       <parameter><decl><type><name>ParseNamespaceItem</name> <modifier>*</modifier><modifier>*</modifier></type><name>nsitem</name></decl></parameter>,
                                       <parameter><decl><type><name>Alias</name><modifier>*</modifier></type> <name>alias</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name> <init>= <expr><operator>(</operator><name>ParseState</name> <operator>*</operator><operator>)</operator><name>cpstate</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RangeTblRef</name> <modifier>*</modifier></type><name>rtr</name></decl>;</decl_stmt>

    <expr_stmt><expr><operator>*</operator><name>rte</name> <operator>=</operator> <call><name>transform_cypher_clause_as_subquery</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>,
                                               <argument><expr><name>transform_cypher_clause</name></expr></argument>,
                                               <argument><expr><name>clause</name></expr></argument>, <argument><expr><name>alias</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><operator>*</operator><name>nsitem</name> <operator>=</operator> <call><name>create_namespace_item</name><argument_list>(<argument><expr><operator>*</operator><name>rte</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>rtr</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>RangeTblRef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rtr</name><operator>-&gt;</operator><name>rtindex</name></name> <operator>=</operator> <call><name>RTERangeTablePosn</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><operator>*</operator><name>rte</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>rtr</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * For cases where we need to join two subqueries together (OPTIONAL MATCH and
 * MERGE) we need to take the columns available in each rte and merge them
 * together. The l_rte has precedence when there is a conflict, because that
 * means that the pattern create in the current clause is referencing a
 * variable declared in a previous clause (the l_rte). The output is the
 * res_colnames and res_colvars that are passed in.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>get_res_cols</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>l_rte</name></decl></parameter>,
                         <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>r_rte</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>res_colnames</name></decl></parameter>,
                         <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>res_colvars</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>l_colnames</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>l_colvars</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>r_colnames</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>r_colvars</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>r_lname</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>r_lvar</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>colnames</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>colvars</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>expandRTE</name><argument_list>(<argument><expr><name>l_rte</name></expr></argument>, <argument><expr><call><name>RTERangeTablePosn</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>l_rte</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>,
              <argument><expr><operator>&amp;</operator><name>l_colnames</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>l_colvars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>expandRTE</name><argument_list>(<argument><expr><name>r_rte</name></expr></argument>, <argument><expr><call><name>RTERangeTablePosn</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>r_rte</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>,
              <argument><expr><operator>&amp;</operator><name>r_colnames</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>r_colvars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// add in all colnames and colvars from the l_rte.</comment>
    <expr_stmt><expr><operator>*</operator><name>res_colnames</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><operator>*</operator><name>res_colnames</name></expr></argument>, <argument><expr><name>l_colnames</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>res_colvars</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><operator>*</operator><name>res_colvars</name></expr></argument>, <argument><expr><name>l_colvars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// find new columns and if they are a var, pass them in.</comment>
    <macro><name>forboth</name><argument_list>(<argument>r_lname</argument>, <argument>r_colnames</argument>, <argument>r_lvar</argument>, <argument>r_colvars</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>r_colname</name> <init>= <expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>r_lname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lname</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lvar</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>var</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

        <macro><name>forboth</name><argument_list>(<argument>lname</argument>, <argument>*res_colnames</argument>, <argument>lvar</argument>, <argument>*res_colvars</argument>)</argument_list></macro>
        <block>{<block_content>
            <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>colname</name> <init>= <expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>r_colname</name></expr></argument>, <argument><expr><name>colname</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>var</name> <operator>=</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lvar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block>

        <if_stmt><if>if <condition>(<expr><name>var</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>colnames</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>colnames</name></expr></argument>, <argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>r_lname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>colvars</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>colvars</name></expr></argument>, <argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>r_lvar</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block>

    <expr_stmt><expr><operator>*</operator><name>res_colnames</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><operator>*</operator><name>res_colnames</name></expr></argument>, <argument><expr><name>colnames</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>res_colvars</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><operator>*</operator><name>res_colvars</name></expr></argument>, <argument><expr><name>colvars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * transform_cypher_optional_match_clause
 *      Transform the previous clauses and OPTIONAL MATCH clauses to be LATERAL LEFT JOIN
 *   transform_cypher_optional_match_clause   to construct a result value.
 */</comment>
<function><type><specifier>static</specifier> <name>RangeTblEntry</name> <modifier>*</modifier></type><name>transform_cypher_optional_match_clause</name><parameter_list>(<parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl></parameter>,
                                                             <parameter><decl><type><name>cypher_clause</name> <modifier>*</modifier></type><name>clause</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>cypher_clause</name> <modifier>*</modifier></type><name>prevclause</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>l_rte</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>r_rte</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ParseNamespaceItem</name> <modifier>*</modifier></type><name>l_nsitem</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>r_nsitem</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name> <init>= <expr><operator>(</operator><name>ParseState</name> <operator>*</operator><operator>)</operator> <name>cpstate</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JoinExpr</name><modifier>*</modifier></type> <name>j</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>JoinExpr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>res_colnames</name> <init>= <expr><name>NIL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>res_colvars</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Alias</name> <modifier>*</modifier></type><name>l_alias</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>r_alias</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ParseNamespaceItem</name> <modifier>*</modifier></type><name>nsitem</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>j</name><operator>-&gt;</operator><name>jointype</name></name> <operator>=</operator> <name>JOIN_LEFT</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>l_alias</name> <operator>=</operator> <call><name>makeAlias</name><argument_list>(<argument><expr><name>PREV_CYPHER_CLAUSE_ALIAS</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>r_alias</name> <operator>=</operator> <call><name>makeAlias</name><argument_list>(<argument><expr><name>CYPHER_OPT_RIGHT_ALIAS</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>j</name><operator>-&gt;</operator><name>larg</name></name> <operator>=</operator> <call><name>transform_clause_for_join</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>, <argument><expr><name><name>clause</name><operator>-&gt;</operator><name>prev</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>l_rte</name></expr></argument>,
                                        <argument><expr><operator>&amp;</operator><name>l_nsitem</name></expr></argument>, <argument><expr><name>l_alias</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_namespace</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_namespace</name></name></expr></argument>, <argument><expr><name>l_nsitem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Remove the previous clause so when the transform_clause_for_join function
     * transforms the OPTIONAL MATCH, the previous clause will not be transformed
     * again.
     */</comment>
    <expr_stmt><expr><name>prevclause</name> <operator>=</operator> <name><name>clause</name><operator>-&gt;</operator><name>prev</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>clause</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

    <comment type="line">//set the lateral flag to true</comment>
    <expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_lateral_active</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>j</name><operator>-&gt;</operator><name>rarg</name></name> <operator>=</operator> <call><name>transform_clause_for_join</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>, <argument><expr><name>clause</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>r_rte</name></expr></argument>,
                                        <argument><expr><operator>&amp;</operator><name>r_nsitem</name></expr></argument>, <argument><expr><name>r_alias</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// we are done transform the lateral left join</comment>
    <expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_lateral_active</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

    <comment type="block">/*
     * We are done with the previous clause in the transform phase, but
     * reattach the previous clause for semantics.
     */</comment>
    <expr_stmt><expr><name><name>clause</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name>prevclause</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_namespace</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

    <comment type="line">// get the colnames and colvars from the rtes</comment>
    <expr_stmt><expr><call><name>get_res_cols</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>l_rte</name></expr></argument>, <argument><expr><name>r_rte</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>res_colnames</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>res_colvars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>addRangeTableEntryForJoin</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>res_colnames</name></expr></argument>, <argument><expr><name><name>j</name><operator>-&gt;</operator><name>jointype</name></name></expr></argument>,
                                    <argument><expr><name>res_colvars</name></expr></argument>, <argument><expr><name><name>j</name><operator>-&gt;</operator><name>alias</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>j</name><operator>-&gt;</operator><name>rtindex</name></name> <operator>=</operator> <call><name>RTERangeTablePosn</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_joinexprs</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>j</name><operator>-&gt;</operator><name>rtindex</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_joinexprs</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_joinexprs</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_joinexprs</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_joinexprs</name></name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_joinexprs</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name><name>j</name><operator>-&gt;</operator><name>rtindex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_joinlist</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_joinlist</name></name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>nsitem</name> <operator>=</operator> <call><name>create_namespace_item</name><argument_list>(<argument><expr><name>rte</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_namespace</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_namespace</name></name></expr></argument>, <argument><expr><name>nsitem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>rte</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Query</name> <modifier>*</modifier></type><name>transform_cypher_match_pattern</name><parameter_list>(<parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl></parameter>,
                                             <parameter><decl><type><name>cypher_clause</name> <modifier>*</modifier></type><name>clause</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name> <init>= <expr><operator>(</operator><name>ParseState</name> <operator>*</operator><operator>)</operator><name>cpstate</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>cypher_match</name> <modifier>*</modifier></type><name>self</name> <init>= <expr><operator>(</operator><name>cypher_match</name> <operator>*</operator><operator>)</operator><name><name>clause</name><operator>-&gt;</operator><name>self</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>where</name> <init>= <expr><name><name>self</name><operator>-&gt;</operator><name>where</name></name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>commandType</name></name> <operator>=</operator> <name>CMD_SELECT</name></expr>;</expr_stmt>

    <comment type="line">// If there is no previous clause, transform to a general MATCH clause.</comment>
    <if_stmt><if>if <condition>(<expr><name><name>self</name><operator>-&gt;</operator><name>optional</name></name> <operator>==</operator> <name>true</name> <operator>&amp;&amp;</operator> <name><name>clause</name><operator>-&gt;</operator><name>prev</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><call><name>transform_cypher_optional_match_clause</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>, <argument><expr><name>clause</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <call><name>make_target_list_from_join</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>rtable</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_rtable</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>jointree</name></name> <operator>=</operator> <call><name>makeFromExpr</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_joinlist</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>clause</name><operator>-&gt;</operator><name>prev</name></name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>rtindex</name></decl>;</decl_stmt>

            <expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>transform_prev_cypher_clause</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>, <argument><expr><name><name>clause</name><operator>-&gt;</operator><name>prev</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>rtindex</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_rtable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>rtindex</name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// rte is the first RangeTblEntry in pstate</comment>

            <comment type="block">/*
             * add all the target entries in rte to the current target list to pass
             * all the variables that are introduced in the previous clause to the
             * next clause
             */</comment>
            <expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <call><name>expandRelAttrs</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>, <argument><expr><name>rtindex</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>transform_match_pattern</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>, <argument><expr><name>query</name></expr></argument>, <argument><expr><name><name>self</name><operator>-&gt;</operator><name>pattern</name></name></expr></argument>, <argument><expr><name>where</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><call><name>markTargetListOrigins</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>hasSubLinks</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_hasSubLinks</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>hasWindowFuncs</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_hasWindowFuncs</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>hasTargetSRFs</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_hasTargetSRFs</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>hasAggs</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_hasAggs</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>assign_query_collations</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>query</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Function to make a target list from an RTE. Taken from AgensGraph and PG
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>make_target_list_from_join</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>targetlist</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lt</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>ln</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_JOIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <macro><name>forboth</name><argument_list>(<argument>lt</argument>, <argument>rte-&gt;joinaliasvars</argument>, <argument>ln</argument>, <argument>rte-&gt;eref-&gt;colnames</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>varnode</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>resname</name> <init>= <expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>ln</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tmp</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>varnode</name></expr></argument>,
                              <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_next_resno</name></name><operator>++</operator></expr></argument>,
                              <argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><name>resname</name></expr></argument>)</argument_list></call></expr></argument>,
                              <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>targetlist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>targetlist</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>

    <return>return <expr><name>targetlist</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Function to make a target list from an RTE. Borrowed from AgensGraph and PG
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>makeTargetListFromRTE</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>targetlist</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>rtindex</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>varattno</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>ln</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lt</name></decl>;</decl_stmt>

    <comment type="block">/* right now this is only for subqueries */</comment>
    <expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_SUBQUERY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>rtindex</name> <operator>=</operator> <call><name>RTERangeTablePosn</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>varattno</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>ln</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>eref</name><operator>-&gt;</operator><name>colnames</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <macro><name>foreach</name><argument_list>(<argument>lt</argument>, <argument>rte-&gt;subquery-&gt;targetList</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>te</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>varnode</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>resname</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tmp</name></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>te</name><operator>-&gt;</operator><name>resjunk</name></name></expr>)</condition>
        <block>{<block_content>
            <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>varattno</name> <operator>==</operator> <name><name>te</name><operator>-&gt;</operator><name>resno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* no transform here, just use `te-&gt;expr` */</comment>
        <expr_stmt><expr><name>varnode</name> <operator>=</operator> <call><name>makeVar</name><argument_list>(<argument><expr><name>rtindex</name></expr></argument>, <argument><expr><name>varattno</name></expr></argument>, <argument><expr><call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>te</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr></argument>,
                          <argument><expr><call><name>exprTypmod</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>te</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr></argument>,
                          <argument><expr><call><name>exprCollation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>te</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>resname</name> <operator>=</operator> <call><name>strVal</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>ln</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator><name>varnode</name></expr></argument>,
                              <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator><name><name>pstate</name><operator>-&gt;</operator><name>p_next_resno</name></name><operator>++</operator></expr></argument>, <argument><expr><name>resname</name></expr></argument>,
                              <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>targetlist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>targetlist</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>varattno</name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>ln</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>ln</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>

    <return>return <expr><name>targetlist</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Transform a cypher sub pattern. This is put here because it is a sub clause.
 * This works in tandem with transform_Sublink in cypher_expr.c
 */</comment>
<function><type><specifier>static</specifier> <name>Query</name> <modifier>*</modifier></type><name>transform_cypher_sub_pattern</name><parameter_list>(<parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl></parameter>,
                                           <parameter><decl><type><name>cypher_clause</name> <modifier>*</modifier></type><name>clause</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>cypher_match</name> <modifier>*</modifier></type><name>match</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>cypher_clause</name> <modifier>*</modifier></type><name>c</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>qry</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name> <init>= <expr><operator>(</operator><name>ParseState</name> <operator>*</operator><operator>)</operator><name>cpstate</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>cypher_sub_pattern</name> <modifier>*</modifier></type><name>subpat</name> <init>= <expr><operator>(</operator><name>cypher_sub_pattern</name><operator>*</operator><operator>)</operator><name><name>clause</name><operator>-&gt;</operator><name>self</name></name></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>child_parse_state</name> <init>= <expr><call><name>make_cypher_parsestate</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>p_child_parse_state</name> <init>= <expr><operator>(</operator><name>ParseState</name> <operator>*</operator><operator>)</operator> <name>child_parse_state</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>p_child_parse_state</name><operator>-&gt;</operator><name>p_expr_kind</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_expr_kind</name></name></expr>;</expr_stmt>

    <comment type="block">/* create a cypher match node and assign it the sub pattern */</comment>
    <expr_stmt><expr><name>match</name> <operator>=</operator> <call><name>make_ag_node</name><argument_list>(<argument><expr><name>cypher_match</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>match</name><operator>-&gt;</operator><name>pattern</name></name> <operator>=</operator> <name><name>subpat</name><operator>-&gt;</operator><name>pattern</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>match</name><operator>-&gt;</operator><name>where</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <comment type="block">/* wrap it in a clause */</comment>
    <expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>cypher_clause</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>self</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name>match</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

    <comment type="block">/* set up a select query and run it as a sub query to the parent match */</comment>
    <expr_stmt><expr><name>qry</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>commandType</name></name> <operator>=</operator> <name>CMD_SELECT</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>transform_cypher_clause_as_subquery</name><argument_list>(<argument><expr><name>child_parse_state</name></expr></argument>,
                                              <argument><expr><name>transform_cypher_clause</name></expr></argument>, <argument><expr><name>c</name></expr></argument>,
                                              <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <call><name>makeTargetListFromRTE</name><argument_list>(<argument><expr><name>p_child_parse_state</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>markTargetListOrigins</name><argument_list>(<argument><expr><name>p_child_parse_state</name></expr></argument>, <argument><expr><name><name>qry</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>rtable</name></name> <operator>=</operator> <name><name>p_child_parse_state</name><operator>-&gt;</operator><name>p_rtable</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>jointree</name></name> <operator>=</operator> <call><name>makeFromExpr</name><argument_list>(<argument><expr><name><name>p_child_parse_state</name><operator>-&gt;</operator><name>p_joinlist</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* the state will be destroyed so copy the data we need */</comment>
    <expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>hasSubLinks</name></name> <operator>=</operator> <name><name>p_child_parse_state</name><operator>-&gt;</operator><name>p_hasSubLinks</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>hasTargetSRFs</name></name> <operator>=</operator> <name><name>p_child_parse_state</name><operator>-&gt;</operator><name>p_hasTargetSRFs</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>qry</name><operator>-&gt;</operator><name>hasAggs</name></name> <operator>=</operator> <name><name>p_child_parse_state</name><operator>-&gt;</operator><name>p_hasAggs</name></name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>qry</name><operator>-&gt;</operator><name>hasAggs</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>parse_check_aggregates</name><argument_list>(<argument><expr><name>p_child_parse_state</name></expr></argument>, <argument><expr><name>qry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>assign_query_collations</name><argument_list>(<argument><expr><name>p_child_parse_state</name></expr></argument>, <argument><expr><name>qry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>free_cypher_parsestate</name><argument_list>(<argument><expr><name>child_parse_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>qry</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Code borrowed and inspired by PG's transformFromClauseItem. This function
 * will transform the VLE function, depending on type. Currently, only
 * RangeFunctions are supported. But, others may be in the future.
 */</comment>
<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>transform_VLE_Function</name><parameter_list>(<parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>n</name></decl></parameter>,
                                    <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier><modifier>*</modifier></type><name>top_rte</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>top_rti</name></decl></parameter>,
                                    <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>namespace</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name> <init>= <expr><operator>&amp;</operator><name><name>cpstate</name><operator>-&gt;</operator><name>pstate</name></name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* we only care about RangeFunctions at this time */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>RangeFunction</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>RangeFunction</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* function is like a plain relation */</comment>
        <decl_stmt><decl><type><name>RangeTblRef</name> <modifier>*</modifier></type><name>rtr</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>rtindex</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>transform_RangeFunction</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>, <argument><expr><operator>(</operator><name>RangeFunction</name> <operator>*</operator><operator>)</operator> <name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* assume new rte is at end */</comment>
        <expr_stmt><expr><name>rtindex</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_rtable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>rte</name> <operator>==</operator> <call><name>rt_fetch</name><argument_list>(<argument><expr><name>rtindex</name></expr></argument>, <argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_rtable</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>top_rte</name> <operator>=</operator> <name>rte</name></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>top_rti</name> <operator>=</operator> <name>rtindex</name></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>namespace</name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><call><name>create_namespace_item</name><argument_list>(<argument><expr><name>rte</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
                                                      <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rtr</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>RangeTblRef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>rtr</name><operator>-&gt;</operator><name>rtindex</name></name> <operator>=</operator> <name>rtindex</name></expr>;</expr_stmt>
        <return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>rtr</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* if it isn't a RangeFunction, return NULL */</comment>
    <return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * static function borrowed from PG.
 *
 * setNamespaceLateralState -
 * Convenience subroutine to update LATERAL flags in a namespace list.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>setNamespaceLateralState</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>namespace</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>lateral_only</name></decl></parameter>,
                                     <parameter><decl><type><name>bool</name></type> <name>lateral_ok</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

    <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>namespace</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ParseNamespaceItem</name> <modifier>*</modifier></type><name>nsitem</name> <init>= <expr><operator>(</operator><name>ParseNamespaceItem</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name><name>nsitem</name><operator>-&gt;</operator><name>p_lateral_only</name></name> <operator>=</operator> <name>lateral_only</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>nsitem</name><operator>-&gt;</operator><name>p_lateral_ok</name></name> <operator>=</operator> <name>lateral_ok</name></expr>;</expr_stmt>
    </block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 * Code borrowed and inspired by PG's transformFromClauseItem. Static function
 * to add in the VLE function as a FROM clause entry.
 */</comment>
<function><type><specifier>static</specifier> <name>RangeTblEntry</name> <modifier>*</modifier></type><name>append_VLE_Func_to_FromClause</name><parameter_list>(<parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl></parameter>,
                                                    <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>n</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name> <init>= <expr><operator>&amp;</operator><name><name>cpstate</name><operator>-&gt;</operator><name>pstate</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>namespace</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>rtindex</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Following PG's FROM clause logic, just in case we need to expand it in
     * the future, we process the items in another function.
     */</comment>
    <expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>transform_VLE_Function</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rte</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rtindex</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>namespace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* this should not happen */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>n</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* verify there aren't any conflicts */</comment>
    <expr_stmt><expr><call><name>checkNameSpaceConflicts</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_namespace</name></name></expr></argument>, <argument><expr><name>namespace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* mark the new namespace items as visible only to LATERAL */</comment>
    <expr_stmt><expr><call><name>setNamespaceLateralState</name><argument_list>(<argument><expr><name>namespace</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* add the entry to the joinlist and namespace */</comment>
    <expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_joinlist</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_joinlist</name></name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_namespace</name></name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_namespace</name></name></expr></argument>, <argument><expr><name>namespace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* make all namespace items unconditionally visible */</comment>
    <expr_stmt><expr><call><name>setNamespaceLateralState</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_namespace</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>rte</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Code borrowed from PG's transformRangeFunction
 *
 * --- transform a function call appearing in FROM
 */</comment>
<function><type><specifier>static</specifier> <name>RangeTblEntry</name> <modifier>*</modifier></type><name>transform_RangeFunction</name><parameter_list>(<parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl></parameter>,
                                              <parameter><decl><type><name>RangeFunction</name> <modifier>*</modifier></type><name>r</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>funcexprs</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>funcnames</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>coldeflists</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>is_lateral</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>pstate</name> <operator>=</operator> <operator>&amp;</operator><name><name>cpstate</name><operator>-&gt;</operator><name>pstate</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>pstate</name><operator>-&gt;</operator><name>p_lateral_active</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_lateral_active</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

    <comment type="block">/* transform the raw expressions */</comment>
    <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>r-&gt;functions</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>pair</name> <init>= <expr><operator>(</operator><name>List</name><operator>*</operator><operator>)</operator><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>fexpr</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>coldeflist</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>newfexpr</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>last_srf</name></decl>;</decl_stmt>

        <comment type="block">/* Disassemble the function-call/column-def-list pairs */</comment>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>pair</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>fexpr</name> <operator>=</operator> <operator>(</operator><name>Node</name><operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>pair</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>coldeflist</name> <operator>=</operator> <operator>(</operator><name>List</name><operator>*</operator><operator>)</operator> <call><name>lsecond</name><argument_list>(<argument><expr><name>pair</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* normal case ... */</comment>
        <expr_stmt><expr><name>last_srf</name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_last_srf</name></name></expr>;</expr_stmt>

        <comment type="block">/* transform the function expression */</comment>
        <expr_stmt><expr><name>newfexpr</name> <operator>=</operator> <call><name>transform_cypher_expr</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>, <argument><expr><name>fexpr</name></expr></argument>,
                                         <argument><expr><name>EXPR_KIND_FROM_FUNCTION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* nodeFunctionscan.c requires SRFs to be at top level */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>pstate</name><operator>-&gt;</operator><name>p_last_srf</name></name> <operator>!=</operator> <name>last_srf</name> <operator>&amp;&amp;</operator>
            <name><name>pstate</name><operator>-&gt;</operator><name>p_last_srf</name></name> <operator>!=</operator> <name>newfexpr</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"set-returning functions must appear at top level of FROM"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
                                        <argument><expr><call><name>exprLocation</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_last_srf</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>funcexprs</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>funcexprs</name></expr></argument>, <argument><expr><name>newfexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>funcnames</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>funcnames</name></expr></argument>, <argument><expr><call><name>FigureColname</name><argument_list>(<argument><expr><name>fexpr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>coldeflist</name> <operator>&amp;&amp;</operator> <name><name>r</name><operator>-&gt;</operator><name>coldeflist</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"multiple column definition lists are not allowed for the same function"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
                                        <argument><expr><call><name>exprLocation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>r</name><operator>-&gt;</operator><name>coldeflist</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>coldeflists</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>coldeflists</name></expr></argument>, <argument><expr><name>coldeflist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>

    <expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_lateral_active</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

    <comment type="block">/*
     * We must assign collations now so that the RTE exposes correct collation
     * info for Vars created from it.
     */</comment>
    <expr_stmt><expr><call><name>assign_list_collations</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>funcexprs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* currently this is not used by the VLE */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>r</name><operator>-&gt;</operator><name>coldeflist</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* mark the RTE as LATERAL */</comment>
    <expr_stmt><expr><name>is_lateral</name> <operator>=</operator> <name><name>r</name><operator>-&gt;</operator><name>lateral</name></name> <operator>||</operator> <call><name>contain_vars_of_level</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>funcexprs</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* build an RTE for the function */</comment>
    <expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>addRangeTableEntryForFunction</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>funcnames</name></expr></argument>, <argument><expr><name>funcexprs</name></expr></argument>,
                                        <argument><expr><name>coldeflists</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>is_lateral</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>rte</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>transform_match_pattern</name><parameter_list>(<parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>,
                                    <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>pattern</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>where</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name> <init>= <expr><operator>(</operator><name>ParseState</name> <operator>*</operator><operator>)</operator><name>cpstate</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>quals</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>q</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>expr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/*
     * Loop through a comma separated list of paths like (u)-[e]-(v), (w), (x)
     */</comment>
    <macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>pattern</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>qual</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>cypher_path</name> <modifier>*</modifier></type><name>path</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

        <comment type="block">/* get the path and transform it */</comment>
        <expr_stmt><expr><name>path</name> <operator>=</operator> <operator>(</operator><name>cypher_path</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>qual</name> <operator>=</operator> <call><name>transform_match_path</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>, <argument><expr><name>query</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>quals</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>quals</name></expr></argument>, <argument><expr><name>qual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>

    <if_stmt><if>if <condition>(<expr><name>quals</name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>q</name> <operator>=</operator> <call><name>makeBoolExpr</name><argument_list>(<argument><expr><name>AND_EXPR</name></expr></argument>, <argument><expr><name>quals</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>expr</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator><call><name>transformExpr</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cpstate</name><operator>-&gt;</operator><name>pstate</name></name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name>q</name></expr></argument>,
                                     <argument><expr><name>EXPR_KIND_WHERE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>cpstate</name><operator>-&gt;</operator><name>property_constraint_quals</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>prop_qual</name> <init>= <expr><call><name>makeBoolExpr</name><argument_list>(<argument><expr><name>AND_EXPR</name></expr></argument>,
                                       <argument><expr><name><name>cpstate</name><operator>-&gt;</operator><name>property_constraint_quals</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>expr</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>expr</name> <operator>=</operator> <name>prop_qual</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><name>expr</name> <operator>=</operator> <call><name>makeBoolExpr</name><argument_list>(<argument><expr><name>AND_EXPR</name></expr></argument>, <argument><expr><call><name>list_make2</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>prop_qual</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="line">// transform the where clause quals and add to the quals,</comment>
    <if_stmt><if>if <condition>(<expr><name>where</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>where_qual</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>where_qual</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator><call><name>transform_cypher_expr</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>, <argument><expr><name>where</name></expr></argument>,
                                                   <argument><expr><name>EXPR_KIND_WHERE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>expr</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>expr</name> <operator>=</operator> <name>where_qual</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <comment type="block">/*
             * coerce the WHERE clause to a boolean before AND with the property
             * contraints, otherwise there could be evaluation issues.
             */</comment>
            <expr_stmt><expr><name>where_qual</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator><call><name>coerce_to_boolean</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name>where_qual</name></expr></argument>,
                                                   <argument><expr><literal type="string">"WHERE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name>expr</name> <operator>=</operator> <call><name>makeBoolExpr</name><argument_list>(<argument><expr><name>AND_EXPR</name></expr></argument>, <argument><expr><call><name>list_make2</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>where_qual</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Coerce to WHERE clause to a bool, denoting whether the constructed
     * clause is true or false.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>expr</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>expr</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator><call><name>coerce_to_boolean</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name>expr</name></expr></argument>, <argument><expr><literal type="string">"WHERE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>rtable</name></name> <operator>=</operator> <name><name>cpstate</name><operator>-&gt;</operator><name>pstate</name><operator>.</operator><name>p_rtable</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>jointree</name></name> <operator>=</operator> <call><name>makeFromExpr</name><argument_list>(<argument><expr><name><name>cpstate</name><operator>-&gt;</operator><name>pstate</name><operator>.</operator><name>p_joinlist</name></name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Creates a FuncCall node that will prevent an edge from being joined
 * to twice.
 */</comment>
<function><type><specifier>static</specifier> <name>FuncCall</name> <modifier>*</modifier></type><name>prevent_duplicate_edges</name><parameter_list>(<parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl></parameter>,
                                         <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>entities</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>edges</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>qualified_function_name</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Value</name> <modifier>*</modifier></type><name>ag_catalog</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>edge_fn</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>ag_catalog</name> <operator>=</operator> <call><name>makeString</name><argument_list>(<argument><expr><literal type="string">"ag_catalog"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>edge_fn</name> <operator>=</operator> <call><name>makeString</name><argument_list>(<argument><expr><literal type="string">"_ag_enforce_edge_uniqueness"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>qualified_function_name</name> <operator>=</operator> <call><name>list_make2</name><argument_list>(<argument><expr><name>ag_catalog</name></expr></argument>, <argument><expr><name>edge_fn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// iterate through each entity, collecting the access node for each edge</comment>
    <macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>entities</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>transform_entity</name> <modifier>*</modifier></type><name>entity</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>edge</name></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>entity</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>ENT_EDGE</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>edge</name> <operator>=</operator> <call><name>make_qual</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>, <argument><expr><name>entity</name></expr></argument>, <argument><expr><name>AG_EDGE_COLNAME_ID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name>edges</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>edges</name></expr></argument>, <argument><expr><name>edge</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name><name>entity</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>ENT_VLE_EDGE</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>edges</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>edges</name></expr></argument>, <argument><expr><name><name>entity</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block>

    <return>return <expr><call><name>makeFuncCall</name><argument_list>(<argument><expr><name>qualified_function_name</name></expr></argument>, <argument><expr><name>edges</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * For any given edge, the previous entity is joined with the edge
 * via the prev_qual node, and the next entity is join with the
 * next_qual node. If there is a filter on the previous vertex label,
 * create a filter, same with the next node.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>make_directed_edge_join_conditions</name><parameter_list>(
    <parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl></parameter>, <parameter><decl><type><name>transform_entity</name> <modifier>*</modifier></type><name>prev_entity</name></decl></parameter>,
    <parameter><decl><type><name>transform_entity</name> <modifier>*</modifier></type><name>next_entity</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>prev_qual</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>next_qual</name></decl></parameter>,
    <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>prev_node_filter</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>next_node_filter</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>quals</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>prev_entity</name><operator>-&gt;</operator><name>in_join_tree</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>quals</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>quals</name></expr></argument>, <argument><expr><call><name>join_to_entity</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>, <argument><expr><name>prev_entity</name></expr></argument>,
                                                  <argument><expr><name>prev_qual</name></expr></argument>, <argument><expr><name>JOIN_SIDE_LEFT</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>next_entity</name><operator>-&gt;</operator><name>in_join_tree</name></name> <operator>&amp;&amp;</operator> <name><name>next_entity</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>ENT_VLE_EDGE</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>quals</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>quals</name></expr></argument>, <argument><expr><call><name>join_to_entity</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>, <argument><expr><name>next_entity</name></expr></argument>,
                                                  <argument><expr><name>next_qual</name></expr></argument>, <argument><expr><name>JOIN_SIDE_RIGHT</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>prev_node_filter</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>IS_DEFAULT_LABEL_VERTEX</name><argument_list>(<argument><expr><name>prev_node_filter</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>A_Expr</name> <modifier>*</modifier></type><name>qual</name></decl>;</decl_stmt>
        <expr_stmt><expr><name>qual</name> <operator>=</operator> <call><name>filter_vertices_on_label_id</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>, <argument><expr><name>prev_qual</name></expr></argument>,
                                           <argument><expr><name>prev_node_filter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>quals</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>quals</name></expr></argument>, <argument><expr><name>qual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>next_node_filter</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>IS_DEFAULT_LABEL_VERTEX</name><argument_list>(<argument><expr><name>next_node_filter</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>A_Expr</name> <modifier>*</modifier></type><name>qual</name></decl>;</decl_stmt>
        <expr_stmt><expr><name>qual</name> <operator>=</operator> <call><name>filter_vertices_on_label_id</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>, <argument><expr><name>next_qual</name></expr></argument>,
                                           <argument><expr><name>next_node_filter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>quals</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>quals</name></expr></argument>, <argument><expr><name>qual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>quals</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * The joins are driven by edges. Under specific conditions, it becomes
 * necessary to have knowledge about the previous edge and vertex and
 * the next vertex and edge.
 *
 * [prev_edge]-(prev_node)-[edge]-(next_node)-[next_edge]
 *
 * prev_edge and next_edge are allowed to be null.
 * prev_node and next_node are not allowed to be null.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>make_join_condition_for_edge</name><parameter_list>(<parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl></parameter>,
                                          <parameter><decl><type><name>transform_entity</name> <modifier>*</modifier></type><name>prev_edge</name></decl></parameter>,
                                          <parameter><decl><type><name>transform_entity</name> <modifier>*</modifier></type><name>prev_node</name></decl></parameter>,
                                          <parameter><decl><type><name>transform_entity</name> <modifier>*</modifier></type><name>entity</name></decl></parameter>,
                                          <parameter><decl><type><name>transform_entity</name> <modifier>*</modifier></type><name>next_node</name></decl></parameter>,
                                          <parameter><decl><type><name>transform_entity</name> <modifier>*</modifier></type><name>next_edge</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>next_label_name_to_filter</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>prev_label_name_to_filter</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>transform_entity</name> <modifier>*</modifier></type><name>next_entity</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>transform_entity</name> <modifier>*</modifier></type><name>prev_entity</name></decl>;</decl_stmt>

    <comment type="block">/*
     * When this edge is a vle edge, pass the prev and next
     * node to the match_vle_terminal_edge function to process
     * which rows match.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>entity</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>ENT_VLE_EDGE</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>left_id</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>right_id</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Value</name> <modifier>*</modifier></type><name>ag_catalog</name> <init>= <expr><call><name>makeString</name><argument_list>(<argument><expr><literal type="string">"ag_catalog"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Value</name> <modifier>*</modifier></type><name>func_name</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>qualified_func_name</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>args</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>quals</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

        <comment type="block">/*
         * If the next node is not in the join tree, we don't need to make any
         * quals.
         */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>next_node</name><operator>-&gt;</operator><name>in_join_tree</name></name></expr>)</condition>
        <block>{<block_content>
            <return>return <expr><name>NIL</name></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/*
         * If the previous node and the next node are in the join tree, we need
         * to create the age_match_vle_terminal_edge to compare the vle returned
         * results against the two nodes.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>prev_node</name><operator>-&gt;</operator><name>in_join_tree</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>func_name</name> <operator>=</operator> <call><name>makeString</name><argument_list>(<argument><expr><literal type="string">"age_match_vle_terminal_edge"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>qualified_func_name</name> <operator>=</operator> <call><name>list_make2</name><argument_list>(<argument><expr><name>ag_catalog</name></expr></argument>, <argument><expr><name>func_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/*
             * Get the vertex's id and pass to the function. Pass in NULL
             * otherwise.
             */</comment>
            <expr_stmt><expr><name>left_id</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><call><name>make_qual</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>, <argument><expr><name>prev_node</name></expr></argument>, <argument><expr><literal type="string">"id"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>right_id</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><call><name>make_qual</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>, <argument><expr><name>next_node</name></expr></argument>, <argument><expr><literal type="string">"id"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="line">// create the argument list</comment>
            <expr_stmt><expr><name>args</name> <operator>=</operator> <call><name>list_make3</name><argument_list>(<argument><expr><name>left_id</name></expr></argument>, <argument><expr><name>right_id</name></expr></argument>, <argument><expr><name><name>entity</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="line">// add to quals</comment>
            <expr_stmt><expr><name>quals</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>quals</name></expr></argument>, <argument><expr><call><name>makeFuncCall</name><argument_list>(<argument><expr><name>qualified_func_name</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/*
         * When the previous node is not in the join tree, but there is a vle
         * edge before that join, then we need to compare this vle's start node
         * against the previous vle's end node. No need to check the next edge,
         * because that would be redundent.
         */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>prev_node</name><operator>-&gt;</operator><name>in_join_tree</name></name> <operator>&amp;&amp;</operator>
            <name>prev_edge</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
            <name><name>prev_edge</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>ENT_VLE_EDGE</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>qualified_name</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>args</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Value</name> <modifier>*</modifier></type><name>match_qual</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>FuncCall</name> <modifier>*</modifier></type><name>fc</name></decl>;</decl_stmt>

            <expr_stmt><expr><name>match_qual</name> <operator>=</operator> <call><name>makeString</name><argument_list>(<argument><expr><literal type="string">"age_match_two_vle_edges"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="line">// make the qualified function name</comment>
            <expr_stmt><expr><name>qualified_name</name> <operator>=</operator> <call><name>list_make2</name><argument_list>(<argument><expr><name>ag_catalog</name></expr></argument>, <argument><expr><name>match_qual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="line">// make the args</comment>
            <expr_stmt><expr><name>args</name> <operator>=</operator> <call><name>list_make2</name><argument_list>(<argument><expr><name><name>prev_edge</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name><name>entity</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="line">// create the function call</comment>
            <expr_stmt><expr><name>fc</name> <operator>=</operator> <call><name>makeFuncCall</name><argument_list>(<argument><expr><name>qualified_name</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name>quals</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>quals</name></expr></argument>, <argument><expr><name>fc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <return>return <expr><name>quals</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     *  If the previous node is not in the join tree, set the previous
     *  label filter.
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>prev_node</name><operator>-&gt;</operator><name>in_join_tree</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>prev_label_name_to_filter</name> <operator>=</operator> <name><name>prev_node</name><operator>-&gt;</operator><name>entity</name><operator>.</operator><name>node</name><operator>-&gt;</operator><name>label</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * If the next node is not in the join tree and there is not
     * another edge, set the label filter. When there is another
     * edge, we don't need to set it, because that edge will set the
     * filter for that node.
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>next_node</name><operator>-&gt;</operator><name>in_join_tree</name></name> <operator>&amp;&amp;</operator> <name>next_edge</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>next_label_name_to_filter</name> <operator>=</operator> <name><name>next_node</name><operator>-&gt;</operator><name>entity</name><operator>.</operator><name>node</name><operator>-&gt;</operator><name>label</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * When the previous node is not in the join tree, and there
     * is a previous edge, set the previous entity to that edge.
     * Otherwise, use the previous node/
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>prev_node</name><operator>-&gt;</operator><name>in_join_tree</name></name> <operator>&amp;&amp;</operator> <name>prev_edge</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>prev_entity</name> <operator>=</operator> <name>prev_edge</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name>prev_entity</name> <operator>=</operator> <name>prev_node</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/*
     * When the next node is not in the join tree, and there
     * is a next edge, set the next entity to that edge.
     * Otherwise, use the next node.
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>next_node</name><operator>-&gt;</operator><name>in_join_tree</name></name> <operator>&amp;&amp;</operator> <name>next_edge</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>next_entity</name> <operator>=</operator> <name>next_edge</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name>next_entity</name> <operator>=</operator> <name>next_node</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <switch>switch <condition>(<expr><name><name>entity</name><operator>-&gt;</operator><name>entity</name><operator>.</operator><name>rel</name><operator>-&gt;</operator><name>dir</name></name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>CYPHER_REL_DIR_RIGHT</name></expr>:</case>
        <block>{<block_content>
            <decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>prev_qual</name> <init>= <expr><call><name>make_qual</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>, <argument><expr><name>entity</name></expr></argument>,
                                        <argument><expr><name>AG_EDGE_COLNAME_START_ID</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>next_qual</name> <init>= <expr><call><name>make_qual</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>, <argument><expr><name>entity</name></expr></argument>,
                                        <argument><expr><name>AG_EDGE_COLNAME_END_ID</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <return>return <expr><call><name>make_directed_edge_join_conditions</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>, <argument><expr><name>prev_entity</name></expr></argument>,
                                                      <argument><expr><name>next_node</name></expr></argument>, <argument><expr><name>prev_qual</name></expr></argument>,
                                                      <argument><expr><name>next_qual</name></expr></argument>,
                                                      <argument><expr><name>prev_label_name_to_filter</name></expr></argument>,
                                                      <argument><expr><name>next_label_name_to_filter</name></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block>
        <case>case <expr><name>CYPHER_REL_DIR_LEFT</name></expr>:</case>
        <block>{<block_content>
            <decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>prev_qual</name> <init>= <expr><call><name>make_qual</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>, <argument><expr><name>entity</name></expr></argument>,
                                        <argument><expr><name>AG_EDGE_COLNAME_END_ID</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>next_qual</name> <init>= <expr><call><name>make_qual</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>, <argument><expr><name>entity</name></expr></argument>,
                                        <argument><expr><name>AG_EDGE_COLNAME_START_ID</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <return>return <expr><call><name>make_directed_edge_join_conditions</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>, <argument><expr><name>prev_entity</name></expr></argument>,
                                                      <argument><expr><name>next_node</name></expr></argument>, <argument><expr><name>prev_qual</name></expr></argument>,
                                                      <argument><expr><name>next_qual</name></expr></argument>,
                                                      <argument><expr><name>prev_label_name_to_filter</name></expr></argument>,
                                                      <argument><expr><name>next_label_name_to_filter</name></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block>
        <case>case <expr><name>CYPHER_REL_DIR_NONE</name></expr>:</case>
        <block>{<block_content>
            <comment type="block">/*
             * For undirected relationships, we can use the left directed
             * relationship OR'd by the right directed relationship.
             */</comment>
            <decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>start_id_expr</name> <init>= <expr><call><name>make_qual</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>, <argument><expr><name>entity</name></expr></argument>,
                                            <argument><expr><name>AG_EDGE_COLNAME_START_ID</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>end_id_expr</name> <init>= <expr><call><name>make_qual</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>, <argument><expr><name>entity</name></expr></argument>,
                                          <argument><expr><name>AG_EDGE_COLNAME_END_ID</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>first_join_quals</name> <init>= <expr><name>NIL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>second_join_quals</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>first_qual</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>second_qual</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>or_qual</name></decl>;</decl_stmt>

            <expr_stmt><expr><name>first_join_quals</name> <operator>=</operator> <call><name>make_directed_edge_join_conditions</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>,
                                                                  <argument><expr><name>prev_entity</name></expr></argument>,
                                                                  <argument><expr><name>next_entity</name></expr></argument>,
                                                                  <argument><expr><name>start_id_expr</name></expr></argument>,
                                                                  <argument><expr><name>end_id_expr</name></expr></argument>,
                                                                  <argument><expr><name>prev_label_name_to_filter</name></expr></argument>,
                                                                  <argument><expr><name>next_label_name_to_filter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name>second_join_quals</name> <operator>=</operator> <call><name>make_directed_edge_join_conditions</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>,
                                                                   <argument><expr><name>prev_entity</name></expr></argument>,
                                                                   <argument><expr><name>next_entity</name></expr></argument>,
                                                                   <argument><expr><name>end_id_expr</name></expr></argument>,
                                                                   <argument><expr><name>start_id_expr</name></expr></argument>,
                                                                   <argument><expr><name>prev_label_name_to_filter</name></expr></argument>,
                                                                   <argument><expr><name>next_label_name_to_filter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name>first_qual</name> <operator>=</operator> <call><name>makeBoolExpr</name><argument_list>(<argument><expr><name>AND_EXPR</name></expr></argument>, <argument><expr><name>first_join_quals</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>second_qual</name> <operator>=</operator> <call><name>makeBoolExpr</name><argument_list>(<argument><expr><name>AND_EXPR</name></expr></argument>, <argument><expr><name>second_join_quals</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name>or_qual</name> <operator>=</operator> <call><name>makeBoolExpr</name><argument_list>(<argument><expr><name>OR_EXPR</name></expr></argument>, <argument><expr><call><name>list_make2</name><argument_list>(<argument><expr><name>first_qual</name></expr></argument>, <argument><expr><name>second_qual</name></expr></argument>)</argument_list></call></expr></argument>,
                               <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <return>return <expr><call><name>list_make1</name><argument_list>(<argument><expr><name>or_qual</name></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block>
        <default>default:</default>
            <return>return <expr><name>NULL</name></expr>;</return>
    </block_content>}</block></switch>
</block_content>}</block></function>

<comment type="line">// creates a type cast node to agtype</comment>
<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>make_type_cast_to_agtype</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>TypeCast</name> <modifier>*</modifier></type><name>n</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>TypeCast</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Value</name> <modifier>*</modifier></type><name>ag_catalog</name> <init>= <expr><call><name>makeString</name><argument_list>(<argument><expr><literal type="string">"ag_catalog"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Value</name> <modifier>*</modifier></type><name>agtype_str</name> <init>= <expr><call><name>makeString</name><argument_list>(<argument><expr><literal type="string">"agtype"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>qualified_name</name> <init>= <expr><call><name>list_make2</name><argument_list>(<argument><expr><name>ag_catalog</name></expr></argument>, <argument><expr><name>agtype_str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>arg</name></name> <operator>=</operator> <name>arg</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>typeName</name></name> <operator>=</operator> <call><name>makeTypeNameFromNameList</name><argument_list>(<argument><expr><name>qualified_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>n</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Makes an agtype bool node that Postgres' transform expression logic
 * can handle. Used when contructed the join quals for building the paths
 */</comment>
<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>make_bool_a_const</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>A_Const</name> <modifier>*</modifier></type><name>n</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>A_Const</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>T_String</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>val</name><operator>.</operator><name>str</name></name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name>state</name></expr> ?</condition><then> <expr><literal type="string">"true"</literal></expr> </then><else>: <expr><literal type="string">"false"</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

    <comment type="line">// typecast to agtype</comment>
    <return>return <expr><call><name>make_type_cast_to_agtype</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name>n</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * For the given entity, join it to the current edge, via the passed
 * qual node. The side denotes if the entity is on the right
 * or left of the current edge. Which we will need to know if the
 * passed entity is a directed edge.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>join_to_entity</name><parameter_list>(<parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl></parameter>,
                            <parameter><decl><type><name>transform_entity</name> <modifier>*</modifier></type><name>entity</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>qual</name></decl></parameter>,
                            <parameter><decl><type><name><name>enum</name> <name>transform_entity_join_side</name></name></type> <name>side</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name> <init>= <expr><operator>(</operator><name>ParseState</name> <operator>*</operator><operator>)</operator><name>cpstate</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>A_Expr</name> <modifier>*</modifier></type><name>expr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>quals</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>entity</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>ENT_VERTEX</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>id_qual</name> <init>= <expr><call><name>make_qual</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>, <argument><expr><name>entity</name></expr></argument>, <argument><expr><name>AG_EDGE_COLNAME_ID</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name>expr</name> <operator>=</operator> <call><name>makeSimpleA_Expr</name><argument_list>(<argument><expr><name>AEXPR_OP</name></expr></argument>, <argument><expr><literal type="string">"="</literal></expr></argument>, <argument><expr><name>qual</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name>id_qual</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>quals</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>quals</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name><name>entity</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>ENT_EDGE</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>edge_quals</name> <init>= <expr><call><name>make_edge_quals</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>, <argument><expr><name>entity</name></expr></argument>, <argument><expr><name>side</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>edge_quals</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>expr</name> <operator>=</operator> <call><name>makeSimpleA_Expr</name><argument_list>(<argument><expr><name>AEXPR_IN</name></expr></argument>, <argument><expr><literal type="string">"="</literal></expr></argument>, <argument><expr><name>qual</name></expr></argument>,
                                    <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name>edge_quals</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><name>expr</name> <operator>=</operator> <call><name>makeSimpleA_Expr</name><argument_list>(<argument><expr><name>AEXPR_OP</name></expr></argument>, <argument><expr><literal type="string">"="</literal></expr></argument>, <argument><expr><name>qual</name></expr></argument>,
                                    <argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name>edge_quals</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <expr_stmt><expr><name>quals</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>quals</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name><name>entity</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>ENT_VLE_EDGE</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>qualified_name</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>args</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Value</name> <modifier>*</modifier></type><name>ag_catalog</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>match_qual</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type> <name>is_left_side</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>FuncCall</name> <modifier>*</modifier></type><name>fc</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>ag_catalog</name> <operator>=</operator> <call><name>makeString</name><argument_list>(<argument><expr><literal type="string">"ag_catalog"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>match_qual</name> <operator>=</operator> <call><name>makeString</name><argument_list>(<argument><expr><literal type="string">"age_match_vle_edge_to_id_qual"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         *  tells the function the location of the vle relative to the
         * edge we are joining it against.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>side</name> <operator>==</operator> <name>JOIN_SIDE_LEFT</name></expr>)</condition>
        <block>{<block_content>
            <comment type="line">// [vle_edge]-()-[regular_edge]</comment>
            <expr_stmt><expr><name>is_left_side</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name>side</name> <operator>==</operator> <name>JOIN_SIDE_RIGHT</name></expr>)</condition>
        <block>{<block_content>
            <comment type="line">// [edge]-()-[vle_edge]</comment>
            <expr_stmt><expr><name>is_left_side</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unknown join side found"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>entity</name><operator>-&gt;</operator><name>entity</name><operator>.</operator><name>rel</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <comment type="line">// make the qualified function name</comment>
        <expr_stmt><expr><name>qualified_name</name> <operator>=</operator> <call><name>list_make2</name><argument_list>(<argument><expr><name>ag_catalog</name></expr></argument>, <argument><expr><name>match_qual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// make the args</comment>
        <expr_stmt><expr><name>args</name> <operator>=</operator> <call><name>list_make3</name><argument_list>(<argument><expr><name><name>entity</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>qual</name></expr></argument>, <argument><expr><call><name>make_bool_a_const</name><argument_list>(<argument><expr><name>is_left_side</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// create the function call</comment>
        <expr_stmt><expr><name>fc</name> <operator>=</operator> <call><name>makeFuncCall</name><argument_list>(<argument><expr><name>qualified_name</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>quals</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>quals</name></expr></argument>, <argument><expr><name>fc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unknown entity type to join to"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <return>return <expr><name>quals</name></expr>;</return>
</block_content>}</block></function>

<comment type="line">// makes the quals neccessary when an edge is joining to another edge.</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>make_edge_quals</name><parameter_list>(<parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl></parameter>,
                             <parameter><decl><type><name>transform_entity</name> <modifier>*</modifier></type><name>edge</name></decl></parameter>,
                             <parameter><decl><type><name><name>enum</name> <name>transform_entity_join_side</name></name></type> <name>side</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name> <init>= <expr><operator>(</operator><name>ParseState</name> <operator>*</operator><operator>)</operator><name>cpstate</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>left_dir</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>right_dir</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>edge</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>ENT_EDGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * When the rel is on the left side in a pattern, then a left directed path
     * is concerned with the start id and a right directed path is concerned
     * with the end id. When the rel is on the right side of a pattern, the
     * above statement is inverted.
     */</comment>
    <switch>switch <condition>(<expr><name>side</name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>JOIN_SIDE_LEFT</name></expr>:</case>
        <block>{<block_content>
            <expr_stmt><expr><name>left_dir</name> <operator>=</operator> <name>AG_EDGE_COLNAME_START_ID</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>right_dir</name> <operator>=</operator> <name>AG_EDGE_COLNAME_END_ID</name></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block>
        <case>case <expr><name>JOIN_SIDE_RIGHT</name></expr>:</case>
        <block>{<block_content>
            <expr_stmt><expr><name>left_dir</name> <operator>=</operator> <name>AG_EDGE_COLNAME_END_ID</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>right_dir</name> <operator>=</operator> <name>AG_EDGE_COLNAME_START_ID</name></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block>
        <default>default:</default>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unknown join type found"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>edge</name><operator>-&gt;</operator><name>entity</name><operator>.</operator><name>rel</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></switch>

    <switch>switch <condition>(<expr><name><name>edge</name><operator>-&gt;</operator><name>entity</name><operator>.</operator><name>rel</name><operator>-&gt;</operator><name>dir</name></name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>CYPHER_REL_DIR_LEFT</name></expr>:</case>
        <block>{<block_content>
            <return>return <expr><call><name>list_make1</name><argument_list>(<argument><expr><call><name>make_qual</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>, <argument><expr><name>edge</name></expr></argument>, <argument><expr><name>left_dir</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block>
        <case>case <expr><name>CYPHER_REL_DIR_RIGHT</name></expr>:</case>
        <block>{<block_content>
            <return>return <expr><call><name>list_make1</name><argument_list>(<argument><expr><call><name>make_qual</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>, <argument><expr><name>edge</name></expr></argument>, <argument><expr><name>right_dir</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block>
        <case>case <expr><name>CYPHER_REL_DIR_NONE</name></expr>:</case>
        <block>{<block_content>
            <return>return <expr><call><name>list_make2</name><argument_list>(<argument><expr><call><name>make_qual</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>, <argument><expr><name>edge</name></expr></argument>, <argument><expr><name>left_dir</name></expr></argument>)</argument_list></call></expr></argument>,
                              <argument><expr><call><name>make_qual</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>, <argument><expr><name>edge</name></expr></argument>, <argument><expr><name>right_dir</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block>
        <default>default:</default>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Unknown relationship direction"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></switch>
    <return>return <expr><name>NIL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Creates a node that will create a filter on the passed field node
 * that removes all labels that do not have the same label_id
 */</comment>
<function><type><specifier>static</specifier> <name>A_Expr</name> <modifier>*</modifier></type><name>filter_vertices_on_label_id</name><parameter_list>(<parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl></parameter>,
                                           <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>id_field</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>label</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>label_cache_data</name> <modifier>*</modifier></type><name>lcd</name> <init>= <expr><call><name>search_label_name_graph_cache</name><argument_list>(<argument><expr><name>label</name></expr></argument>,
                                                          <argument><expr><name><name>cpstate</name><operator>-&gt;</operator><name>graph_oid</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>A_Const</name> <modifier>*</modifier></type><name>n</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>FuncCall</name> <modifier>*</modifier></type><name>fc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Value</name> <modifier>*</modifier></type><name>ag_catalog</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>extract_label_id</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int32</name></type> <name>label_id</name> <init>= <expr><name><name>lcd</name><operator>-&gt;</operator><name>id</name></name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>A_Const</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>T_Integer</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>val</name><operator>.</operator><name>ival</name></name> <operator>=</operator> <name>label_id</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

    <expr_stmt><expr><name>ag_catalog</name> <operator>=</operator> <call><name>makeString</name><argument_list>(<argument><expr><literal type="string">"ag_catalog"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>extract_label_id</name> <operator>=</operator> <call><name>makeString</name><argument_list>(<argument><expr><literal type="string">"_extract_label_id"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>fc</name> <operator>=</operator> <call><name>makeFuncCall</name><argument_list>(<argument><expr><call><name>list_make2</name><argument_list>(<argument><expr><name>ag_catalog</name></expr></argument>, <argument><expr><name>extract_label_id</name></expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name>id_field</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><call><name>makeSimpleA_Expr</name><argument_list>(<argument><expr><name>AEXPR_OP</name></expr></argument>, <argument><expr><literal type="string">"="</literal></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name>fc</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name>n</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Creates the Contains operator to process property contraints for a vertex/
 * edge in a MATCH clause. creates the agtype @&gt; with the enitity's properties
 * on the right and the contraints in the MATCH clause on the left.
 */</comment>
<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>create_property_constraints</name><parameter_list>(<parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl></parameter>,
                                         <parameter><decl><type><name>transform_entity</name> <modifier>*</modifier></type><name>entity</name></decl></parameter>,
                                         <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>property_constraints</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name> <init>= <expr><operator>(</operator><name>ParseState</name> <operator>*</operator><operator>)</operator><name>cpstate</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>entity_name</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ColumnRef</name> <modifier>*</modifier></type><name>cr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>prop_expr</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>const_expr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>last_srf</name> <init>= <expr><name><name>pstate</name><operator>-&gt;</operator><name>p_last_srf</name></name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>cr</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>ColumnRef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>entity_name</name> <operator>=</operator> <call><name>get_entity_name</name><argument_list>(<argument><expr><name>entity</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>cr</name><operator>-&gt;</operator><name>fields</name></name> <operator>=</operator> <call><name>list_make2</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name>entity_name</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>makeString</name><argument_list>(<argument><expr><literal type="string">"properties"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// use Postgres to get the properties' transform node</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>rte</name> <operator>=</operator> <call><name>find_rte</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>, <argument><expr><name>entity_name</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>prop_expr</name> <operator>=</operator> <call><name>scanRTEForColumn</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>, <argument><expr><name>AG_VERTEX_COLNAME_PROPERTIES</name></expr></argument>,
                                     <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name>prop_expr</name> <operator>=</operator> <call><name>transformExpr</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name>cr</name></expr></argument>, <argument><expr><name>EXPR_KIND_WHERE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="line">// use cypher to get the constraints' transform node</comment>
    <expr_stmt><expr><name>const_expr</name> <operator>=</operator> <call><name>transform_cypher_expr</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>, <argument><expr><name>property_constraints</name></expr></argument>,
                                       <argument><expr><name>EXPR_KIND_WHERE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><call><name>make_op</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><literal type="string">"@&gt;"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>prop_expr</name></expr></argument>,
                           <argument><expr><name>const_expr</name></expr></argument>, <argument><expr><name>last_srf</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * For the given path, transform each entity within the path, create
 * the path variable if needed, and construct the quals to enforce the
 * correct join tree, and enforce edge uniqueness.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>transform_match_path</name><parameter_list>(<parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>,
                                  <parameter><decl><type><name>cypher_path</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>qual</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>entities</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>FuncCall</name> <modifier>*</modifier></type><name>duplicate_edge_qual</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>join_quals</name></decl>;</decl_stmt>

    <comment type="line">// transform the entities in the path</comment>
    <expr_stmt><expr><name>entities</name> <operator>=</operator> <call><name>transform_match_entities</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>, <argument><expr><name>query</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// create the path variable, if needed.</comment>
    <if_stmt><if>if <condition>(<expr><name><name>path</name><operator>-&gt;</operator><name>var_name</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>path_te</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>path_te</name> <operator>=</operator> <call><name>transform_match_create_path_variable</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>, <argument><expr><name>path</name></expr></argument>,
                                                       <argument><expr><name>entities</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>, <argument><expr><name>path_te</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="line">// construct the quals for the join tree</comment>
    <expr_stmt><expr><name>join_quals</name> <operator>=</operator> <call><name>make_path_join_quals</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>, <argument><expr><name>entities</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>qual</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>qual</name></expr></argument>, <argument><expr><name>join_quals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// construct the qual to prevent duplicate edges</comment>
    <if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>entities</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">3</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>duplicate_edge_qual</name> <operator>=</operator> <call><name>prevent_duplicate_edges</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>, <argument><expr><name>entities</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>qual</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>qual</name></expr></argument>, <argument><expr><name>duplicate_edge_qual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>qual</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>transform_entity</name> <modifier>*</modifier></type><name>transform_VLE_edge_entity</name><parameter_list>(<parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl></parameter>,
                                                   <parameter><decl><type><name>cypher_relationship</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>,
                                                   <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>te</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RangeFunction</name> <modifier>*</modifier></type><name>rf</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>FuncCall</name> <modifier>*</modifier></type><name>func</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Alias</name> <modifier>*</modifier></type><name>alias</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>var</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>transform_entity</name> <modifier>*</modifier></type><name>vle_entity</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* it better be a function call node */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>varlen</name></name></expr></argument>, <argument><expr><name>FuncCall</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* get the function */</comment>
    <expr_stmt><expr><name>func</name> <operator>=</operator> <operator>(</operator><name>FuncCall</name><operator>*</operator><operator>)</operator><name><name>rel</name><operator>-&gt;</operator><name>varlen</name></name></expr>;</expr_stmt>

    <comment type="block">/* only our functions are supported here */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>func</name><operator>-&gt;</operator><name>funcname</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"only AGE functions are supported here"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* set the pstate */</comment>
    <expr_stmt><expr><name>pstate</name> <operator>=</operator> <operator>&amp;</operator><name><name>cpstate</name><operator>-&gt;</operator><name>pstate</name></name></expr>;</expr_stmt>

    <comment type="block">/* make a RangeFunction node */</comment>
    <expr_stmt><expr><name>rf</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>RangeFunction</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rf</name><operator>-&gt;</operator><name>lateral</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rf</name><operator>-&gt;</operator><name>ordinality</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rf</name><operator>-&gt;</operator><name>is_rowsfrom</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rf</name><operator>-&gt;</operator><name>functions</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><call><name>list_make2</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>varlen</name></name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Build an alias for the RangeFunction. This is needed so we
     * can chain VLEs together
     */</comment>
    <expr_stmt><expr><name>alias</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>Alias</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>alias</name><operator>-&gt;</operator><name>aliasname</name></name> <operator>=</operator> <call><name>get_next_default_alias</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>alias</name><operator>-&gt;</operator><name>colnames</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rf</name><operator>-&gt;</operator><name>alias</name></name> <operator>=</operator> <name>alias</name></expr>;</expr_stmt>

    <comment type="block">/*
     * Add the RangeFunction to the FROM clause
     */</comment>
    <expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>append_VLE_Func_to_FromClause</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name><operator>*</operator><operator>)</operator><name>rf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>rte</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Get the var node for the VLE functions column name. */</comment>
    <expr_stmt><expr><name>var</name> <operator>=</operator> <call><name>scanRTEForColumn</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>, <argument><expr><literal type="string">"edges"</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>var</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * If we have a variable name (rel name), make the target entry. Otherwise,
     * there isn't a reason to create one.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>name</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>FuncExpr</name> <modifier>*</modifier></type><name>fexpr</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>args</name> <init>= <expr><call><name>list_make1</name><argument_list>(<argument><expr><name>var</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Oid</name></type> <name>func_oid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>

        <comment type="block">/*
         * Get the oid for the materialize function that returns a list of
         * edges. For a VLE edge variable we need to return a list of edges,
         * not a path.
         */</comment>
        <expr_stmt><expr><name>func_oid</name> <operator>=</operator> <call><name>get_ag_func_oid</name><argument_list>(<argument><expr><literal type="string">"age_materialize_vle_edges"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>AGTYPEOID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* build the expr node for the function */</comment>
        <expr_stmt><expr><name>fexpr</name> <operator>=</operator> <call><name>makeFuncExpr</name><argument_list>(<argument><expr><name>func_oid</name></expr></argument>, <argument><expr><name>AGTYPEOID</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>,
                             <argument><expr><name>COERCE_EXPLICIT_CALL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* make the target entry and apply the provided variable */</comment>
        <expr_stmt><expr><name>te</name> <operator>=</operator> <call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name><operator>*</operator><operator>)</operator><name>fexpr</name></expr></argument>, <argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_next_resno</name></name><operator>++</operator></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,
                             <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* add it to the query */</comment>
        <expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>, <argument><expr><name>te</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* Make a transform entity for the vle. */</comment>
    <expr_stmt><expr><name>vle_entity</name> <operator>=</operator> <call><name>make_transform_entity</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>, <argument><expr><name>ENT_VLE_EDGE</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name>rel</name></expr></argument>,
                                       <argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator><name>var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* return the vle entity */</comment>
    <return>return <expr><name>vle_entity</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* helper function to check for specific VLE cases */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type> <name>isa_special_VLE_case</name><parameter_list>(<parameter><decl><type><name>cypher_path</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>cypher_relationship</name> <modifier>*</modifier></type><name>cr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>path</name><operator>-&gt;</operator><name>var_name</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>path</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">3</literal></expr>)</condition>
    <block>{<block_content>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>cr</name> <operator>=</operator> <operator>(</operator><name>cypher_relationship</name><operator>*</operator><operator>)</operator><call><name>lfirst</name><argument_list>(<argument><expr><call><name>lnext</name><argument_list>(<argument><expr><call><name>list_head</name><argument_list>(<argument><expr><name><name>path</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>cr</name><operator>-&gt;</operator><name>varlen</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <return>return <expr><name>true</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>path_check_valid_label</name><parameter_list>(<parameter><decl><type><name>cypher_path</name> <modifier>*</modifier></type><name>path</name></decl></parameter>,
                                   <parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>path-&gt;path</argument>)</argument_list></macro>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>i</name> <operator>%</operator> <literal type="number">2</literal> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>cypher_node</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><name>node</name> <operator>=</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>label</name></name></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>label_cache_data</name> <modifier>*</modifier></type><name>lcd</name> <init>=
                    <expr><call><name>search_label_name_graph_cache</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>label</name></name></expr></argument>,
                                                  <argument><expr><name><name>cpstate</name><operator>-&gt;</operator><name>graph_oid</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><name>lcd</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>lcd</name><operator>-&gt;</operator><name>kind</name></name> <operator>!=</operator> <name>LABEL_KIND_VERTEX</name></expr>)</condition>
                <block>{<block_content>
                    <return>return <expr><name>false</name></expr>;</return>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <decl_stmt><decl><type><name>cypher_relationship</name> <modifier>*</modifier></type><name>rel</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>label</name></name></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>label_cache_data</name> <modifier>*</modifier></type><name>lcd</name> <init>=
                    <expr><call><name>search_label_name_graph_cache</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>label</name></name></expr></argument>,
                                                  <argument><expr><name><name>cpstate</name><operator>-&gt;</operator><name>graph_oid</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <if_stmt><if>if <condition>(<expr><name>lcd</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>lcd</name><operator>-&gt;</operator><name>kind</name></name> <operator>!=</operator> <name>LABEL_KIND_EDGE</name></expr>)</condition>
                <block>{<block_content>
                    <return>return <expr><name>false</name></expr>;</return>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block>

    <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Iterate through the path and construct all edges and necessary vertices
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>transform_match_entities</name><parameter_list>(<parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>,
                                      <parameter><decl><type><name>cypher_path</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name> <init>= <expr><operator>(</operator><name>ParseState</name> <operator>*</operator><operator>)</operator><name>cpstate</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>entities</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>node_declared_in_prev_clause</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>transform_entity</name> <modifier>*</modifier></type><name>prev_entity</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>special_VLE_case</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>valid_label</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>special_VLE_case</name> <operator>=</operator> <call><name>isa_special_VLE_case</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>valid_label</name> <operator>=</operator> <call><name>path_check_valid_label</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>cpstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Iterate through every node in the path, construct the expr node
     * that is needed for the remaining steps
     */</comment>

    <macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>path-&gt;path</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>expr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>transform_entity</name> <modifier>*</modifier></type><name>entity</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>


        <comment type="block">/* even increments of i are vertices */</comment>
        <if_stmt><if>if <condition>(<expr><name>i</name> <operator>%</operator> <literal type="number">2</literal> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>cypher_node</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>bool</name></type> <name>output_node</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><name>node</name> <operator>=</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/*
             * The vle needs to know if the start vertex was
             * created in a previous clause. Check to see if it
             * was so the edge logic can handle changing its argument
             * if necessary.
             */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>name</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/*
                 * Checks the previous clauses to see if the variable already
                 * exists.
                 */</comment>
                <decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>expr</name> <init>= <expr><call><name>colNameToVar</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
                                          <argument><expr><name><name>node</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><name>expr</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>node_declared_in_prev_clause</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if></if_stmt>

            <comment type="block">/* should we make the node available */</comment>
            <expr_stmt><expr><name>output_node</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>special_VLE_case</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>node</name><operator>-&gt;</operator><name>name</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>node</name><operator>-&gt;</operator><name>props</name></name><operator>)</operator></expr> ?</condition><then>
                          <expr><name>false</name></expr> </then><else>:
                          <expr><call><name>INCLUDE_NODE_IN_JOIN_TREE</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>

            <comment type="block">/* transform vertex */</comment>
            <expr_stmt><expr><name>expr</name> <operator>=</operator> <call><name>transform_cypher_node</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>query</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>,
                                         <argument><expr><name>output_node</name></expr></argument>, <argument><expr><name>valid_label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name>entity</name> <operator>=</operator> <call><name>make_transform_entity</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>, <argument><expr><name>ENT_VERTEX</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name>node</name></expr></argument>,
                                           <argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* transform properties if they exist */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>props</name></name></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>n</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

                <expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>create_property_constraints</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>, <argument><expr><name>entity</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>props</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><name><name>cpstate</name><operator>-&gt;</operator><name>property_constraint_quals</name></name> <operator>=</operator>
                    <call><name>lappend</name><argument_list>(<argument><expr><name><name>cpstate</name><operator>-&gt;</operator><name>property_constraint_quals</name></name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <expr_stmt><expr><name><name>cpstate</name><operator>-&gt;</operator><name>entities</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>cpstate</name><operator>-&gt;</operator><name>entities</name></name></expr></argument>, <argument><expr><name>entity</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>entities</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>entities</name></expr></argument>, <argument><expr><name>entity</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name>prev_entity</name> <operator>=</operator> <name>entity</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <comment type="block">/* odd increments of i are edges */</comment>
        <else>else
        <block>{<block_content>
            <decl_stmt><decl><type><name>cypher_relationship</name> <modifier>*</modifier></type><name>rel</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/*
             * There are 2 edge cases - 1) a regular edge and 2) a VLE edge.
             * A VLE edge is not added like a regular edge - it is a function.
             */</comment>

            <comment type="block">/* if it is a regular edge */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>varlen</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/*
                 * In the case where the MATCH is one edge and two vertices, the
                 * edge is bidirectional, and neither vertex is included in the
                 * join tree, we need to force one of the vertices into the join
                 * tree to ensure the output is generated correctly.
                 */</comment>
                <if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>path</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">3</literal> <operator>&amp;&amp;</operator>
                        <name><name>rel</name><operator>-&gt;</operator><name>dir</name></name> <operator>==</operator> <name>CYPHER_REL_DIR_NONE</name> <operator>&amp;&amp;</operator>
                        <operator>!</operator><name><name>prev_entity</name><operator>-&gt;</operator><name>in_join_tree</name></name></expr>)</condition>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>cypher_node</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><operator>(</operator><name>cypher_node</name> <operator>*</operator><operator>)</operator><call><name>lfirst</name><argument_list>(<argument><expr><call><name>lnext</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>INCLUDE_NODE_IN_JOIN_TREE</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition>
                    <block>{<block_content>
                        <comment type="block">/*
                         * Assigning a variable name here will ensure that when
                         * the next vertex is processed, the vertex will be
                         * included in the join tree.
                         */</comment>
                        <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <call><name>get_next_default_alias</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    </block_content>}</block></if></if_stmt>
                </block_content>}</block></if></if_stmt>

                <expr_stmt><expr><name>expr</name> <operator>=</operator> <call><name>transform_cypher_edge</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>query</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>,
                                             <argument><expr><name>valid_label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><name>entity</name> <operator>=</operator> <call><name>make_transform_entity</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>, <argument><expr><name>ENT_EDGE</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name>rel</name></expr></argument>,
                                               <argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><name><name>cpstate</name><operator>-&gt;</operator><name>entities</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>cpstate</name><operator>-&gt;</operator><name>entities</name></name></expr></argument>, <argument><expr><name>entity</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>props</name></name></expr>)</condition>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>n</name> <init>= <expr><call><name>create_property_constraints</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>, <argument><expr><name>entity</name></expr></argument>,
                                                          <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>props</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><name><name>cpstate</name><operator>-&gt;</operator><name>property_constraint_quals</name></name> <operator>=</operator>
                        <call><name>lappend</name><argument_list>(<argument><expr><name><name>cpstate</name><operator>-&gt;</operator><name>property_constraint_quals</name></name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>

                <expr_stmt><expr><name>entities</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>entities</name></expr></argument>, <argument><expr><name>entity</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><name>prev_entity</name> <operator>=</operator> <name>entity</name></expr>;</expr_stmt>
            </block_content>}</block></if>
            <comment type="block">/* if we have a VLE edge */</comment>
            <else>else
            <block>{<block_content>
                <decl_stmt><decl><type><name>transform_entity</name> <modifier>*</modifier></type><name>vle_entity</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

                <comment type="block">/*
                 * Check to see if the previous node was originally created
                 * in a predecessing clause. If it was, then remove the id field
                 * from the column ref. Just reference the agtype vertex
                 * variable that the prev clause created and the vle will handle
                 * extracting the id.
                 */</comment>
                <if_stmt><if>if <condition>(<expr><name>node_declared_in_prev_clause</name></expr>)</condition>
                <block>{<block_content>
                    <decl_stmt><decl><type><name>FuncCall</name> <modifier>*</modifier></type><name>func</name> <init>= <expr><operator>(</operator><name>FuncCall</name><operator>*</operator><operator>)</operator><name><name>rel</name><operator>-&gt;</operator><name>varlen</name></name></expr></init></decl>;</decl_stmt>

                    <decl_stmt><decl><type><name>ColumnRef</name> <modifier>*</modifier></type><name>cr</name> <init>= <expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>func</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>cr</name></expr></argument>, <argument><expr><name>ColumnRef</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>cr</name><operator>-&gt;</operator><name>fields</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <expr_stmt><expr><name><name>cr</name><operator>-&gt;</operator><name>fields</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>cr</name><operator>-&gt;</operator><name>fields</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>

                <comment type="block">/* make a transform entity for the vle */</comment>
                <expr_stmt><expr><name>vle_entity</name> <operator>=</operator> <call><name>transform_VLE_edge_entity</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/* add the entity in */</comment>
                <expr_stmt><expr><name><name>cpstate</name><operator>-&gt;</operator><name>entities</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>cpstate</name><operator>-&gt;</operator><name>entities</name></name></expr></argument>, <argument><expr><name>vle_entity</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>entities</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>entities</name></expr></argument>, <argument><expr><name>vle_entity</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><name>prev_entity</name> <operator>=</operator> <name>entity</name></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>

            <expr_stmt><expr><name>node_declared_in_prev_clause</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block>
    <return>return <expr><name>entities</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Iterate through the list of entities setup the join conditions. Joins
 * are driven through edges. To correctly setup the joins, we must
 * aquire information about the previous edge and vertex, and the next
 * edge and vertex.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>make_path_join_quals</name><parameter_list>(<parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>entities</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>transform_entity</name> <modifier>*</modifier></type><name>prev_node</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>prev_edge</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>edge</name> <init>= <expr><name>NULL</name></expr></init></decl>,
                     <decl><type ref="prev"><modifier>*</modifier></type><name>next_node</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>next_edge</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>quals</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>join_quals</name></decl>;</decl_stmt>

    <comment type="line">// for vertex only queries, there is no work to do</comment>
    <if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>entities</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">3</literal></expr>)</condition>
    <block>{<block_content>
        <return>return <expr><name>NIL</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>lc</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name>entities</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
    <block>{<block_content>
        <comment type="block">/*
         * Initial setup, set the initial vertex as the previous vertex
         * and get the first edge
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>prev_node</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>prev_node</name> <operator>=</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>lc</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>edge</name> <operator>=</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="line">// Retrieve the next node and edge in the pattern.</comment>
        <if_stmt><if>if <condition>(<expr><call><name>lnext</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>lc</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>next_node</name> <operator>=</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><call><name>lnext</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>lc</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>next_edge</name> <operator>=</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="line">// create the join quals for the node</comment>
        <expr_stmt><expr><name>join_quals</name> <operator>=</operator> <call><name>make_join_condition_for_edge</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>, <argument><expr><name>prev_edge</name></expr></argument>, <argument><expr><name>prev_node</name></expr></argument>,
                                                  <argument><expr><name>edge</name></expr></argument>, <argument><expr><name>next_node</name></expr></argument>, <argument><expr><name>next_edge</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>quals</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>quals</name></expr></argument>, <argument><expr><name>join_quals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Set the edge as the previous edge and the next edge as
         * the current edge. If there is not a new edge, exit the
         * for loop.
         */</comment>
        <expr_stmt><expr><name>prev_edge</name> <operator>=</operator> <name>edge</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>prev_node</name> <operator>=</operator> <name>next_node</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>edge</name> <operator>=</operator> <name>next_edge</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>next_node</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>next_edge</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>edge</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <return>return <expr><name>quals</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * Create the path variable. Takes the list of entities, extracts the variable
 * and passes as the argument list for the _agtype_build_path function.
 */</comment>
<function><type><specifier>static</specifier> <name>TargetEntry</name> <modifier>*</modifier></type>
<name>transform_match_create_path_variable</name><parameter_list>(<parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl></parameter>,
                                     <parameter><decl><type><name>cypher_path</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>entities</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name> <init>= <expr><operator>(</operator><name>ParseState</name> <operator>*</operator><operator>)</operator><name>cpstate</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type> <name>build_path_oid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>FuncExpr</name> <modifier>*</modifier></type><name>fexpr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>resno</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>entity_exprs</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>entities</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"paths require at least 1 vertex"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>path</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="line">// extract the expr for each entity</comment>
    <macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>entities</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>transform_entity</name> <modifier>*</modifier></type><name>entity</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>entity</name><operator>-&gt;</operator><name>expr</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>entity_exprs</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>entity_exprs</name></expr></argument>, <argument><expr><name><name>entity</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block>

    <comment type="line">// get the oid for the path creation function</comment>
    <expr_stmt><expr><name>build_path_oid</name> <operator>=</operator> <call><name>get_ag_func_oid</name><argument_list>(<argument><expr><literal type="string">"_agtype_build_path"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>ANYOID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// build the expr node for the function</comment>
    <expr_stmt><expr><name>fexpr</name> <operator>=</operator> <call><name>makeFuncExpr</name><argument_list>(<argument><expr><name>build_path_oid</name></expr></argument>, <argument><expr><name>AGTYPEOID</name></expr></argument>, <argument><expr><name>entity_exprs</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>,
                         <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>COERCE_EXPLICIT_CALL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>resno</name> <operator>=</operator> <name><name>cpstate</name><operator>-&gt;</operator><name>pstate</name><operator>.</operator><name>p_next_resno</name></name><operator>++</operator></expr>;</expr_stmt>

    <comment type="line">// create the target entry</comment>
    <return>return <expr><call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator><name>fexpr</name></expr></argument>, <argument><expr><name>resno</name></expr></argument>, <argument><expr><name><name>path</name><operator>-&gt;</operator><name>var_name</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Maps a column name to the a function access name. In others word when
 * passed the name for the vertex's id column name, return the function name
 * for the vertex's agtype id element, etc.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>get_accessor_function_name</name><parameter_list>(<parameter><decl><type><name><name>enum</name> <name>transform_entity_type</name></name></type> <name>type</name></decl></parameter>,
                                        <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>ENT_VERTEX</name></expr>)</condition>
    <block>{<block_content>
        <comment type="line">// id</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>AG_VERTEX_COLNAME_ID</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <return>return <expr><name>AG_VERTEX_ACCESS_FUNCTION_ID</name></expr>;</return>
        </block_content>}</block></if>
        <comment type="line">// props</comment>
        <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>AG_VERTEX_COLNAME_PROPERTIES</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <return>return <expr><name>AG_VERTEX_ACCESS_FUNCTION_PROPERTIES</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>ENT_EDGE</name></expr>)</condition>
    <block>{<block_content>
        <comment type="line">// id</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>AG_EDGE_COLNAME_ID</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <return>return <expr><name>AG_EDGE_ACCESS_FUNCTION_ID</name></expr>;</return>
        </block_content>}</block></if>
        <comment type="line">// start id</comment>
        <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>AG_EDGE_COLNAME_START_ID</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <return>return <expr><name>AG_EDGE_ACCESS_FUNCTION_START_ID</name></expr>;</return>
        </block_content>}</block></if>
        <comment type="line">// end id</comment>
        <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>AG_EDGE_COLNAME_END_ID</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <return>return <expr><name>AG_EDGE_ACCESS_FUNCTION_END_ID</name></expr>;</return>
        </block_content>}</block></if>
        <comment type="line">// props</comment>
        <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>AG_VERTEX_COLNAME_PROPERTIES</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <return>return <expr><name>AG_VERTEX_ACCESS_FUNCTION_PROPERTIES</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_COLUMN_REFERENCE</name></expr></argument>)</argument_list></call><operator>,</operator>
             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column %s does not have an accessor function"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// keeps compiler silent</comment>
    <return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * For the given entity and column name, construct an expression that will
 * access the column or get the access function if the entity is a variable.
 */</comment>
<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>make_qual</name><parameter_list>(<parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl></parameter>,
                       <parameter><decl><type><name>transform_entity</name> <modifier>*</modifier></type><name>entity</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>col_name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>qualified_name</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>args</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>entity</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>function_name</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>function_name</name> <operator>=</operator> <call><name>get_accessor_function_name</name><argument_list>(<argument><expr><name><name>entity</name><operator>-&gt;</operator><name>type</name></name></expr></argument>, <argument><expr><name>col_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>qualified_name</name> <operator>=</operator> <call><name>list_make2</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><literal type="string">"ag_catalog"</literal></expr></argument>)</argument_list></call></expr></argument>,
                                    <argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name>function_name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>


        <expr_stmt><expr><name>args</name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name><name>entity</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>node</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><call><name>makeFuncCall</name><argument_list>(<argument><expr><name>qualified_name</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>entity_name</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ColumnRef</name> <modifier>*</modifier></type><name>cr</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>ColumnRef</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// cast graphid to agtype</comment>
        <expr_stmt><expr><name>qualified_name</name> <operator>=</operator> <call><name>list_make2</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><literal type="string">"ag_catalog"</literal></expr></argument>)</argument_list></call></expr></argument>,
                                    <argument><expr><call><name>makeString</name><argument_list>(<argument><expr><literal type="string">"graphid_to_agtype"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>entity</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>ENT_EDGE</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>entity_name</name> <operator>=</operator> <name><name>entity</name><operator>-&gt;</operator><name>entity</name><operator>.</operator><name>node</name><operator>-&gt;</operator><name>name</name></name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name><name>entity</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>ENT_VERTEX</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>entity_name</name> <operator>=</operator> <name><name>entity</name><operator>-&gt;</operator><name>entity</name><operator>.</operator><name>rel</name><operator>-&gt;</operator><name>name</name></name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                            <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unknown entity type"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <expr_stmt><expr><name><name>cr</name><operator>-&gt;</operator><name>fields</name></name> <operator>=</operator> <call><name>list_make2</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name>entity_name</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name>col_name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>node</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name>cr</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <return>return <expr><name>node</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Expr</name> <modifier>*</modifier></type><name>transform_cypher_edge</name><parameter_list>(<parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl></parameter>,
                                   <parameter><decl><type><name>cypher_relationship</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>,
                                   <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>target_list</name></decl></parameter>,
                                   <parameter><decl><type><name>bool</name></type> <name>valid_label</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name> <init>= <expr><operator>(</operator><name>ParseState</name> <operator>*</operator><operator>)</operator><name>cpstate</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>schema_name</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>rel_name</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>label_range_var</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Alias</name> <modifier>*</modifier></type><name>alias</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>resno</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>te</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>expr</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>rel</name><operator>-&gt;</operator><name>label</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>label</name></name> <operator>=</operator> <name>AG_DEFAULT_LABEL_EDGE</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if<condition>(<expr><operator>!</operator><name>valid_label</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         *  XXX: Need to determine proper rules, for when label does not exist
         *  or is for an edge. Maybe labels and edges should share names, like
         *  in openCypher. But these are stand in errors, to prevent
         *  segmentation faults, and other errors.
         *
         *  Update: Nonexistent and mismatched labels now return a NULL value to
         *  prevent segmentation faults, and other errors. We can also consider 
         *  if an all-purpose label would be useful.
         */</comment>
        <expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>label</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>name</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>te</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>expr</name></decl>;</decl_stmt>

        <comment type="block">/*
         * If we are in a WHERE clause transform, we don't want to create new
         * variables, we want to use the existing ones. So, error if otherwise.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>pstate</name><operator>-&gt;</operator><name>p_expr_kind</name></name> <operator>==</operator> <name>EXPR_KIND_WHERE</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>parent_cpstate</name> <init>=
               <expr><operator>(</operator><name>cypher_parsestate</name> <operator>*</operator><operator>)</operator><name><name>pstate</name><operator>-&gt;</operator><name>parentParseState</name><operator>-&gt;</operator><name>parentParseState</name></name></expr></init></decl>;</decl_stmt>
            <comment type="block">/*
             *  If expr_kind is WHERE, the expressions are in the parent's
             *  parent's parsestate, due to the way we transform sublinks.
             */</comment>
            <decl_stmt><decl><type><name>transform_entity</name> <modifier>*</modifier></type><name>entity</name> <init>= <expr><call><name>find_variable</name><argument_list>(<argument><expr><name>parent_cpstate</name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name>entity</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
            <block>{<block_content>
                <return>return <expr><name><name>entity</name><operator>-&gt;</operator><name>expr</name></name></expr>;</return>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"variable `%s` does not exist"</literal></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>te</name> <operator>=</operator> <call><name>findTarget</name><argument_list>(<argument><expr><operator>*</operator><name>target_list</name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* also search for a variable from a previous transform */</comment>
        <expr_stmt><expr><name>expr</name> <operator>=</operator> <call><name>colNameToVar</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>expr</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <return>return <expr><operator>(</operator><name>Expr</name><operator>*</operator><operator>)</operator><name>expr</name></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>te</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>transform_entity</name> <modifier>*</modifier></type><name>entity</name> <init>= <expr><call><name>find_variable</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <comment type="block">/*
             * TODO: openCypher allows a variable to be used before it
             * is properly declared. This logic is not satifactory
             * for that and must be better developed.
             */</comment>
            <if_stmt><if>if <condition>(<expr><name>entity</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
                <operator>(</operator><name><name>entity</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>ENT_EDGE</name> <operator>||</operator>
                 <operator>!</operator><call><name>IS_DEFAULT_LABEL_EDGE</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>label</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
                 <name><name>rel</name><operator>-&gt;</operator><name>props</name></name><operator>)</operator></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"variable %s already exists"</literal></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
            <return>return <expr><name><name>te</name><operator>-&gt;</operator><name>expr</name></name></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>rel</name><operator>-&gt;</operator><name>name</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <call><name>get_next_default_alias</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>schema_name</name> <operator>=</operator> <call><name>get_graph_namespace_name</name><argument_list>(<argument><expr><name><name>cpstate</name><operator>-&gt;</operator><name>graph_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>valid_label</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>rel_name</name> <operator>=</operator> <call><name>get_label_relation_name</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>label</name></name></expr></argument>, <argument><expr><name><name>cpstate</name><operator>-&gt;</operator><name>graph_oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name>rel_name</name> <operator>=</operator> <name>AG_DEFAULT_LABEL_EDGE</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><name>label_range_var</name> <operator>=</operator> <call><name>makeRangeVar</name><argument_list>(<argument><expr><name>schema_name</name></expr></argument>, <argument><expr><name>rel_name</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>alias</name> <operator>=</operator> <call><name>makeAlias</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>addRangeTableEntry</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>label_range_var</name></expr></argument>, <argument><expr><name>alias</name></expr></argument>,
                             <argument><expr><name><name>label_range_var</name><operator>-&gt;</operator><name>inh</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/*
     * relation is visible (r.a in expression works) but attributes in the
     * relation are not visible (a in expression doesn't work)
     */</comment>
    <expr_stmt><expr><call><name>addRTEtoQuery</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>resno</name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_next_resno</name></name><operator>++</operator></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>valid_label</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>expr</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator><call><name>make_edge_expr</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>label</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name>expr</name> <operator>=</operator> <operator>(</operator><name>Expr</name><operator>*</operator><operator>)</operator><call><name>makeNullConst</name><argument_list>(<argument><expr><name>AGTYPEOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>name</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>te</name> <operator>=</operator> <call><name>makeTargetEntry</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>resno</name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>target_list</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><operator>*</operator><name>target_list</name></expr></argument>, <argument><expr><name>te</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>expr</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Expr</name> <modifier>*</modifier></type><name>transform_cypher_node</name><parameter_list>(<parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl></parameter>,
                                   <parameter><decl><type><name>cypher_node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>target_list</name></decl></parameter>,
                                   <parameter><decl><type><name>bool</name></type> <name>output_node</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>valid_label</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name> <init>= <expr><operator>(</operator><name>ParseState</name> <operator>*</operator><operator>)</operator><name>cpstate</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>schema_name</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>rel_name</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>label_range_var</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Alias</name> <modifier>*</modifier></type><name>alias</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>resno</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>te</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>expr</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>node</name><operator>-&gt;</operator><name>label</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>label</name></name> <operator>=</operator> <name>AG_DEFAULT_LABEL_VERTEX</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><operator>!</operator><name>valid_label</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         *  XXX: Need to determine proper rules, for when label does not exist
         *  or is for an edge. Maybe labels and edges should share names, like
         *  in openCypher. But these are stand in errors, to prevent
         *  segmentation faults, and other errors.
         *
         *  Update: Nonexistent and mismatched labels now return a NULL value to
         *  prevent segmentation faults, and other errors. We can also consider 
         *  if an all-purpose label would be useful.
         */</comment>
        <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>label</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>output_node</name></expr>)</condition>
    <block>{<block_content>
        <return>return <expr><name>NULL</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>name</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>te</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>expr</name></decl>;</decl_stmt>

        <comment type="block">/*
         * If we are in a WHERE clause transform, we don't want to create new
         * variables, we want to use the existing ones. So, error if otherwise.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>pstate</name><operator>-&gt;</operator><name>p_expr_kind</name></name> <operator>==</operator> <name>EXPR_KIND_WHERE</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>parent_cpstate</name> <init>=
               <expr><operator>(</operator><name>cypher_parsestate</name> <operator>*</operator><operator>)</operator><name><name>pstate</name><operator>-&gt;</operator><name>parentParseState</name><operator>-&gt;</operator><name>parentParseState</name></name></expr></init></decl>;</decl_stmt>
            <comment type="block">/*
             *  If expr_kind is WHERE, the expressions are in the parent's
             *  parent's parsestate, due to the way we transform sublinks.
             */</comment>
            <decl_stmt><decl><type><name>transform_entity</name> <modifier>*</modifier></type><name>entity</name> <init>= <expr><call><name>find_variable</name><argument_list>(<argument><expr><name>parent_cpstate</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>


            <if_stmt><if>if <condition>(<expr><name>entity</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
            <block>{<block_content>
                <return>return <expr><name><name>entity</name><operator>-&gt;</operator><name>expr</name></name></expr>;</return>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                       <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                        <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"variable `%s` does not exist"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call><operator>,</operator>
                        <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>te</name> <operator>=</operator> <call><name>findTarget</name><argument_list>(<argument><expr><operator>*</operator><name>target_list</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* also search for the variable from a previous transforms */</comment>
        <expr_stmt><expr><name>expr</name> <operator>=</operator> <call><name>colNameToVar</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>expr</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <return>return <expr><operator>(</operator><name>Expr</name><operator>*</operator><operator>)</operator><name>expr</name></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><name>te</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>transform_entity</name> <modifier>*</modifier></type><name>entity</name> <init>= <expr><call><name>find_variable</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <comment type="block">/*
             * TODO: openCypher allows a variable to be used before it
             * is properly declared. This logic is not satifactory
             * for that and must be better developed.
             */</comment>
            <if_stmt><if>if <condition>(<expr><name>entity</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
                <operator>(</operator><name><name>entity</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>ENT_VERTEX</name> <operator>||</operator>
                 <operator>!</operator><call><name>IS_DEFAULT_LABEL_VERTEX</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>label</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
                 <name><name>node</name><operator>-&gt;</operator><name>props</name></name><operator>)</operator></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"variable %s already exists"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <return>return <expr><name><name>te</name><operator>-&gt;</operator><name>expr</name></name></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <call><name>get_next_default_alias</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><name>schema_name</name> <operator>=</operator> <call><name>get_graph_namespace_name</name><argument_list>(<argument><expr><name><name>cpstate</name><operator>-&gt;</operator><name>graph_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>valid_label</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>rel_name</name> <operator>=</operator> <call><name>get_label_relation_name</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>label</name></name></expr></argument>, <argument><expr><name><name>cpstate</name><operator>-&gt;</operator><name>graph_oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name>rel_name</name> <operator>=</operator> <name>AG_DEFAULT_LABEL_VERTEX</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><name>label_range_var</name> <operator>=</operator> <call><name>makeRangeVar</name><argument_list>(<argument><expr><name>schema_name</name></expr></argument>, <argument><expr><name>rel_name</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>alias</name> <operator>=</operator> <call><name>makeAlias</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>addRangeTableEntry</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>label_range_var</name></expr></argument>, <argument><expr><name>alias</name></expr></argument>,
                             <argument><expr><name><name>label_range_var</name><operator>-&gt;</operator><name>inh</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/*
     * relation is visible (r.a in expression works) but attributes in the
     * relation are not visible (a in expression doesn't work)
     */</comment>
    <expr_stmt><expr><call><name>addRTEtoQuery</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>resno</name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_next_resno</name></name><operator>++</operator></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>valid_label</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>expr</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator><call><name>make_vertex_expr</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>label</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name>expr</name> <operator>=</operator> <operator>(</operator><name>Expr</name><operator>*</operator><operator>)</operator><call><name>makeNullConst</name><argument_list>(<argument><expr><name>AGTYPEOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* make target entry and add it */</comment>
    <expr_stmt><expr><name>te</name> <operator>=</operator> <call><name>makeTargetEntry</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>resno</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>target_list</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><operator>*</operator><name>target_list</name></expr></argument>, <argument><expr><name>te</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>expr</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>make_edge_expr</name><parameter_list>(<parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl></parameter>, <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>,
                            <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>label</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name> <init>= <expr><operator>(</operator><name>ParseState</name> <operator>*</operator><operator>)</operator><name>cpstate</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type> <name>label_name_func_oid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type> <name>func_oid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>id</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>start_id</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>end_id</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Const</name> <modifier>*</modifier></type><name>graph_oid_const</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>props</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>args</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>label_name_args</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>FuncExpr</name> <modifier>*</modifier></type><name>func_expr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>FuncExpr</name> <modifier>*</modifier></type><name>label_name_func_expr</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>func_oid</name> <operator>=</operator> <call><name>get_ag_func_oid</name><argument_list>(<argument><expr><literal type="string">"_agtype_build_edge"</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><name>GRAPHIDOID</name></expr></argument>, <argument><expr><name>GRAPHIDOID</name></expr></argument>,
                               <argument><expr><name>GRAPHIDOID</name></expr></argument>, <argument><expr><name>CSTRINGOID</name></expr></argument>, <argument><expr><name>AGTYPEOID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>id</name> <operator>=</operator> <call><name>scanRTEForColumn</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>, <argument><expr><name>AG_EDGE_COLNAME_ID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>start_id</name> <operator>=</operator> <call><name>scanRTEForColumn</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>, <argument><expr><name>AG_EDGE_COLNAME_START_ID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
                                <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>end_id</name> <operator>=</operator> <call><name>scanRTEForColumn</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>, <argument><expr><name>AG_EDGE_COLNAME_END_ID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
                              <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>label_name_func_oid</name> <operator>=</operator> <call><name>get_ag_func_oid</name><argument_list>(<argument><expr><literal type="string">"_label_name"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>OIDOID</name></expr></argument>,
                                          <argument><expr><name>GRAPHIDOID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>graph_oid_const</name> <operator>=</operator> <call><name>makeConst</name><argument_list>(<argument><expr><name>OIDOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>,
                                <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>cpstate</name><operator>-&gt;</operator><name>graph_oid</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>,
                                <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>label_name_args</name> <operator>=</operator> <call><name>list_make2</name><argument_list>(<argument><expr><name>graph_oid_const</name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>label_name_func_expr</name> <operator>=</operator> <call><name>makeFuncExpr</name><argument_list>(<argument><expr><name>label_name_func_oid</name></expr></argument>, <argument><expr><name>CSTRINGOID</name></expr></argument>,
                                        <argument><expr><name>label_name_args</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>,
                                        <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>COERCE_EXPLICIT_CALL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>label_name_func_expr</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

    <expr_stmt><expr><name>props</name> <operator>=</operator> <call><name>scanRTEForColumn</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>, <argument><expr><name>AG_EDGE_COLNAME_PROPERTIES</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
                             <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>args</name> <operator>=</operator> <call><name>list_make5</name><argument_list>(<argument><expr><name>id</name></expr></argument>, <argument><expr><name>start_id</name></expr></argument>, <argument><expr><name>end_id</name></expr></argument>, <argument><expr><name>label_name_func_expr</name></expr></argument>, <argument><expr><name>props</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>func_expr</name> <operator>=</operator> <call><name>makeFuncExpr</name><argument_list>(<argument><expr><name>func_oid</name></expr></argument>, <argument><expr><name>AGTYPEOID</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>,
                             <argument><expr><name>COERCE_EXPLICIT_CALL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>func_expr</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

    <return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name>func_expr</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>make_vertex_expr</name><parameter_list>(<parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl></parameter>, <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>,
                              <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>label</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name> <init>= <expr><operator>(</operator><name>ParseState</name> <operator>*</operator><operator>)</operator><name>cpstate</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type> <name>label_name_func_oid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type> <name>func_oid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>id</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Const</name> <modifier>*</modifier></type><name>graph_oid_const</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>props</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>args</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>label_name_args</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>FuncExpr</name> <modifier>*</modifier></type><name>func_expr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>FuncExpr</name> <modifier>*</modifier></type><name>label_name_func_expr</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>func_oid</name> <operator>=</operator> <call><name>get_ag_func_oid</name><argument_list>(<argument><expr><literal type="string">"_agtype_build_vertex"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>GRAPHIDOID</name></expr></argument>,
                               <argument><expr><name>CSTRINGOID</name></expr></argument>, <argument><expr><name>AGTYPEOID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>id</name> <operator>=</operator> <call><name>scanRTEForColumn</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>, <argument><expr><name>AG_VERTEX_COLNAME_ID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>label_name_func_oid</name> <operator>=</operator> <call><name>get_ag_func_oid</name><argument_list>(<argument><expr><literal type="string">"_label_name"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>OIDOID</name></expr></argument>,
                                          <argument><expr><name>GRAPHIDOID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>graph_oid_const</name> <operator>=</operator> <call><name>makeConst</name><argument_list>(<argument><expr><name>OIDOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>,
                                <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>cpstate</name><operator>-&gt;</operator><name>graph_oid</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>,
                                <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>label_name_args</name> <operator>=</operator> <call><name>list_make2</name><argument_list>(<argument><expr><name>graph_oid_const</name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>label_name_func_expr</name> <operator>=</operator> <call><name>makeFuncExpr</name><argument_list>(<argument><expr><name>label_name_func_oid</name></expr></argument>, <argument><expr><name>CSTRINGOID</name></expr></argument>,
                                        <argument><expr><name>label_name_args</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>,
                                        <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>COERCE_EXPLICIT_CALL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>label_name_func_expr</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

    <expr_stmt><expr><name>props</name> <operator>=</operator> <call><name>scanRTEForColumn</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>, <argument><expr><name>AG_VERTEX_COLNAME_PROPERTIES</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
                             <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>args</name> <operator>=</operator> <call><name>list_make3</name><argument_list>(<argument><expr><name>id</name></expr></argument>, <argument><expr><name>label_name_func_expr</name></expr></argument>, <argument><expr><name>props</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>func_expr</name> <operator>=</operator> <call><name>makeFuncExpr</name><argument_list>(<argument><expr><name>func_oid</name></expr></argument>, <argument><expr><name>AGTYPEOID</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>,
                             <argument><expr><name>COERCE_EXPLICIT_CALL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>func_expr</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

    <return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name>func_expr</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Query</name> <modifier>*</modifier></type><name>transform_cypher_create</name><parameter_list>(<parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl></parameter>,
                                      <parameter><decl><type><name>cypher_clause</name> <modifier>*</modifier></type><name>clause</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name> <init>= <expr><operator>(</operator><name>ParseState</name> <operator>*</operator><operator>)</operator><name>cpstate</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>cypher_create</name> <modifier>*</modifier></type><name>self</name> <init>= <expr><operator>(</operator><name>cypher_create</name> <operator>*</operator><operator>)</operator><name><name>clause</name><operator>-&gt;</operator><name>self</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>cypher_create_target_nodes</name> <modifier>*</modifier></type><name>target_nodes</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Const</name> <modifier>*</modifier></type><name>null_const</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>transformed_pattern</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>FuncExpr</name> <modifier>*</modifier></type><name>func_expr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>target_nodes</name> <operator>=</operator> <call><name>make_ag_node</name><argument_list>(<argument><expr><name>cypher_create_target_nodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>target_nodes</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>CYPHER_CLAUSE_FLAG_NONE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>target_nodes</name><operator>-&gt;</operator><name>graph_oid</name></name> <operator>=</operator> <name><name>cpstate</name><operator>-&gt;</operator><name>graph_oid</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>commandType</name></name> <operator>=</operator> <name>CMD_SELECT</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>clause</name><operator>-&gt;</operator><name>prev</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>handle_prev_clause</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>, <argument><expr><name>query</name></expr></argument>, <argument><expr><name><name>clause</name><operator>-&gt;</operator><name>prev</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>target_nodes</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>CYPHER_CLAUSE_FLAG_PREVIOUS_CLAUSE</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>null_const</name> <operator>=</operator> <call><name>makeNullConst</name><argument_list>(<argument><expr><name>AGTYPEOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>tle</name> <operator>=</operator> <call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator><name>null_const</name></expr></argument>, <argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_next_resno</name></name><operator>++</operator></expr></argument>,
                          <argument><expr><name>AGE_VARNAME_CREATE_NULL_VALUE</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>, <argument><expr><name>tle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Create the Const Node to hold the pattern. skip the parse node,
     * because we would not be able to control how our pointer to the
     * internal type is copied.
     */</comment>
    <expr_stmt><expr><name>transformed_pattern</name> <operator>=</operator> <call><name>transform_cypher_create_pattern</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>, <argument><expr><name>query</name></expr></argument>,
                                                          <argument><expr><name><name>self</name><operator>-&gt;</operator><name>pattern</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>target_nodes</name><operator>-&gt;</operator><name>paths</name></name> <operator>=</operator> <name>transformed_pattern</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>clause</name><operator>-&gt;</operator><name>next</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>target_nodes</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>CYPHER_CLAUSE_FLAG_TERMINAL</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>


    <expr_stmt><expr><name>func_expr</name> <operator>=</operator> <call><name>make_clause_func_expr</name><argument_list>(<argument><expr><name>CREATE_CLAUSE_FUNCTION_NAME</name></expr></argument>,
                                      <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name>target_nodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Create the target entry</comment>
    <expr_stmt><expr><name>tle</name> <operator>=</operator> <call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator><name>func_expr</name></expr></argument>, <argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_next_resno</name></name><operator>++</operator></expr></argument>,
                          <argument><expr><name>AGE_VARNAME_CREATE_CLAUSE</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>, <argument><expr><name>tle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>rtable</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_rtable</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>jointree</name></name> <operator>=</operator> <call><name>makeFromExpr</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_joinlist</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>query</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>transform_cypher_create_pattern</name><parameter_list>(<parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl></parameter>,
                                             <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>pattern</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>transformed_pattern</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

    <macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>pattern</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>cypher_create_path</name> <modifier>*</modifier></type><name>transformed_path</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>transformed_path</name> <operator>=</operator> <call><name>transform_cypher_create_path</name><argument_list>(
            <argument><expr><name>cpstate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>query</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>, <argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>transformed_pattern</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>transformed_pattern</name></expr></argument>, <argument><expr><name>transformed_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>

    <return>return <expr><name>transformed_pattern</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>cypher_create_path</name> <modifier>*</modifier></type>
<name>transform_cypher_create_path</name><parameter_list>(<parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>target_list</name></decl></parameter>,
                             <parameter><decl><type><name>cypher_path</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name> <init>= <expr><operator>(</operator><name>ParseState</name> <operator>*</operator><operator>)</operator><name>cpstate</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>transformed_path</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>cypher_create_path</name> <modifier>*</modifier></type><name>ccp</name> <init>= <expr><call><name>make_ag_node</name><argument_list>(<argument><expr><name>cypher_create_path</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>in_path</name> <init>= <expr><name><name>path</name><operator>-&gt;</operator><name>var_name</name></name> <operator>!=</operator> <name>NULL</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>ccp</name><operator>-&gt;</operator><name>path_attr_num</name></name> <operator>=</operator> <name>InvalidAttrNumber</name></expr>;</expr_stmt>

    <macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>path-&gt;path</argument>)</argument_list></macro>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>is_ag_node</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>cypher_node</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>cypher_node</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>transform_entity</name> <modifier>*</modifier></type><name>entity</name></decl>;</decl_stmt>

            <decl_stmt><decl><type><name>cypher_target_node</name> <modifier>*</modifier></type><name>rel</name> <init>=
                <expr><call><name>transform_create_cypher_node</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>, <argument><expr><name>target_list</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name>in_path</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>CYPHER_TARGET_NODE_IN_PATH_VAR</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <expr_stmt><expr><name>transformed_path</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>transformed_path</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name>entity</name> <operator>=</operator> <call><name>make_transform_entity</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>, <argument><expr><name>ENT_VERTEX</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name>node</name></expr></argument>,
                                           <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name><name>cpstate</name><operator>-&gt;</operator><name>entities</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>cpstate</name><operator>-&gt;</operator><name>entities</name></name></expr></argument>, <argument><expr><name>entity</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><call><name>is_ag_node</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>cypher_relationship</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>cypher_relationship</name> <modifier>*</modifier></type><name>edge</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>transform_entity</name> <modifier>*</modifier></type><name>entity</name></decl>;</decl_stmt>

            <decl_stmt><decl><type><name>cypher_target_node</name> <modifier>*</modifier></type><name>rel</name> <init>=
                <expr><call><name>transform_create_cypher_edge</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>, <argument><expr><name>target_list</name></expr></argument>, <argument><expr><name>edge</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name>in_path</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>CYPHER_TARGET_NODE_IN_PATH_VAR</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <expr_stmt><expr><name>transformed_path</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>transformed_path</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name>entity</name> <operator>=</operator> <call><name>make_transform_entity</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>, <argument><expr><name>ENT_EDGE</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name>edge</name></expr></argument>,
                                           <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name><name>cpstate</name><operator>-&gt;</operator><name>entities</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>cpstate</name><operator>-&gt;</operator><name>entities</name></name></expr></argument>, <argument><expr><name>entity</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"unreconized node in create pattern"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block>

    <expr_stmt><expr><name><name>ccp</name><operator>-&gt;</operator><name>target_nodes</name></name> <operator>=</operator> <name>transformed_path</name></expr>;</expr_stmt>

    <comment type="block">/*
     * If this path a variable, create a placeholder entry that we can fill
     * in with during the execution phase.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>path</name><operator>-&gt;</operator><name>var_name</name></name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>te</name></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>transformed_path</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"paths require at least 1 vertex"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>path</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>te</name> <operator>=</operator> <call><name>placeholder_target_entry</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>, <argument><expr><name><name>path</name><operator>-&gt;</operator><name>var_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>ccp</name><operator>-&gt;</operator><name>path_attr_num</name></name> <operator>=</operator> <name><name>te</name><operator>-&gt;</operator><name>resno</name></name></expr>;</expr_stmt>

        <expr_stmt><expr><operator>*</operator><name>target_list</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><operator>*</operator><name>target_list</name></expr></argument>, <argument><expr><name>te</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>ccp</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>cypher_target_node</name> <modifier>*</modifier></type>
<name>transform_create_cypher_edge</name><parameter_list>(<parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>target_list</name></decl></parameter>,
                             <parameter><decl><type><name>cypher_relationship</name> <modifier>*</modifier></type><name>edge</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name> <init>= <expr><operator>(</operator><name>ParseState</name> <operator>*</operator><operator>)</operator><name>cpstate</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>cypher_target_node</name> <modifier>*</modifier></type><name>rel</name> <init>= <expr><call><name>make_ag_node</name><argument_list>(<argument><expr><name>cypher_target_node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>props</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name></type> <name>label_relation</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>rv</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>te</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>alias</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>AttrNumber</name></type> <name>resno</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>edge</name><operator>-&gt;</operator><name>label</name></name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>label_cache_data</name> <modifier>*</modifier></type><name>lcd</name> <init>=
            <expr><call><name>search_label_name_graph_cache</name><argument_list>(<argument><expr><name><name>edge</name><operator>-&gt;</operator><name>label</name></name></expr></argument>, <argument><expr><name><name>cpstate</name><operator>-&gt;</operator><name>graph_oid</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>lcd</name> <operator>&amp;&amp;</operator> <name><name>lcd</name><operator>-&gt;</operator><name>kind</name></name> <operator>!=</operator> <name>LABEL_KIND_EDGE</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"label %s is for vertices, not edges"</literal></expr></argument>, <argument><expr><name><name>edge</name><operator>-&gt;</operator><name>label</name></name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>edge</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>LABEL_KIND_EDGE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>CYPHER_TARGET_NODE_FLAG_INSERT</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>label_name</name></name> <operator>=</operator> <name><name>edge</name><operator>-&gt;</operator><name>label</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>resultRelInfo</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>edge</name><operator>-&gt;</operator><name>name</name></name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * Variables can be declared in a CREATE clause, but not used if
         * it already exists.
         */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>variable_exists</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>, <argument><expr><name><name>edge</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"variable %s already exists"</literal></expr></argument>, <argument><expr><name><name>edge</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>variable_name</name></name> <operator>=</operator> <name><name>edge</name><operator>-&gt;</operator><name>name</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>te</name> <operator>=</operator> <call><name>placeholder_target_entry</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>, <argument><expr><name><name>edge</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>tuple_position</name></name> <operator>=</operator> <name><name>te</name><operator>-&gt;</operator><name>resno</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>target_list</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><operator>*</operator><name>target_list</name></expr></argument>, <argument><expr><name>te</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>CYPHER_TARGET_NODE_IS_VAR</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>variable_name</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>tuple_position</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>edge</name><operator>-&gt;</operator><name>dir</name></name> <operator>==</operator> <name>CYPHER_REL_DIR_NONE</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"only directed relationships are allowed in CREATE"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>parser_errposition</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cpstate</name><operator>-&gt;</operator><name>pstate</name></name></expr></argument>, <argument><expr><name><name>edge</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>dir</name></name> <operator>=</operator> <name><name>edge</name><operator>-&gt;</operator><name>dir</name></name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>edge</name><operator>-&gt;</operator><name>label</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"relationships must be specify a label in CREATE."</literal></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>parser_errposition</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cpstate</name><operator>-&gt;</operator><name>pstate</name></name></expr></argument>, <argument><expr><name><name>edge</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="line">// create the label entry if it does not exist</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>label_exists</name><argument_list>(<argument><expr><name><name>edge</name><operator>-&gt;</operator><name>label</name></name></expr></argument>, <argument><expr><name><name>cpstate</name><operator>-&gt;</operator><name>graph_oid</name></name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>parent</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>rv</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>get_label_range_var</name><argument_list>(<argument><expr><name><name>cpstate</name><operator>-&gt;</operator><name>graph_name</name></name></expr></argument>, <argument><expr><name><name>cpstate</name><operator>-&gt;</operator><name>graph_oid</name></name></expr></argument>,
                                 <argument><expr><name>AG_DEFAULT_LABEL_EDGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>parent</name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>create_label</name><argument_list>(<argument><expr><name><name>cpstate</name><operator>-&gt;</operator><name>graph_name</name></name></expr></argument>, <argument><expr><name><name>edge</name><operator>-&gt;</operator><name>label</name></name></expr></argument>, <argument><expr><name>LABEL_TYPE_EDGE</name></expr></argument>,
                     <argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="line">// lock the relation of the label</comment>
    <expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>makeRangeVar</name><argument_list>(<argument><expr><name><name>cpstate</name><operator>-&gt;</operator><name>graph_name</name></name></expr></argument>, <argument><expr><name><name>edge</name><operator>-&gt;</operator><name>label</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>label_relation</name> <operator>=</operator> <call><name>parserOpenTable</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cpstate</name><operator>-&gt;</operator><name>pstate</name></name></expr></argument>, <argument><expr><name>rv</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Store the relid</comment>
    <expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>relid</name></name> <operator>=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>label_relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>addRangeTableEntryForRelation</name><argument_list>(<argument><expr><operator>(</operator><name>ParseState</name> <operator>*</operator><operator>)</operator><name>cpstate</name></expr></argument>, <argument><expr><name>label_relation</name></expr></argument>,
                                        <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>requiredPerms</name></name> <operator>=</operator> <name>ACL_INSERT</name></expr>;</expr_stmt>

    <comment type="line">// Build Id expression, always use the default logic</comment>
    <expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>id_expr</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator><call><name>build_column_default</name><argument_list>(<argument><expr><name>label_relation</name></expr></argument>,
                                      <argument><expr><name>Anum_ag_label_edge_table_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Build properties expression, if no map is given, use the default logic</comment>
    <expr_stmt><expr><name>alias</name> <operator>=</operator> <call><name>get_next_default_alias</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>resno</name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_next_resno</name></name><operator>++</operator></expr>;</expr_stmt>

    <expr_stmt><expr><name>props</name> <operator>=</operator> <call><name>cypher_create_properties</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>label_relation</name></expr></argument>, <argument><expr><name><name>edge</name><operator>-&gt;</operator><name>props</name></name></expr></argument>,
                                     <argument><expr><name>ENT_EDGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>prop_attr_num</name></name> <operator>=</operator> <name>resno</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>te</name> <operator>=</operator> <call><name>makeTargetEntry</name><argument_list>(<argument><expr><name>props</name></expr></argument>, <argument><expr><name>resno</name></expr></argument>, <argument><expr><name>alias</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><operator>*</operator><name>target_list</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><operator>*</operator><name>target_list</name></expr></argument>, <argument><expr><name>te</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Keep the lock</comment>
    <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>label_relation</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>rel</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>variable_exists</name><parameter_list>(<parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name> <init>= <expr><operator>(</operator><name>ParseState</name> <operator>*</operator><operator>)</operator><name>cpstate</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>id</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>name</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <return>return <expr><name>false</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>find_rte</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>, <argument><expr><name>PREV_CYPHER_CLAUSE_ALIAS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>rte</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>id</name> <operator>=</operator> <call><name>scanRTEForColumn</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <return>return <expr><name>id</name> <operator>!=</operator> <name>NULL</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="line">// transform nodes, check to see if the variable name already exists.</comment>
<function><type><specifier>static</specifier> <name>cypher_target_node</name> <modifier>*</modifier></type>
<name>transform_create_cypher_node</name><parameter_list>(<parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>target_list</name></decl></parameter>,
                             <parameter><decl><type><name>cypher_node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name> <init>= <expr><operator>(</operator><name>ParseState</name> <operator>*</operator><operator>)</operator><name>cpstate</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>label</name></name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>label_cache_data</name> <modifier>*</modifier></type><name>lcd</name> <init>=
            <expr><call><name>search_label_name_graph_cache</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>label</name></name></expr></argument>, <argument><expr><name><name>cpstate</name><operator>-&gt;</operator><name>graph_oid</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>lcd</name> <operator>&amp;&amp;</operator> <name><name>lcd</name><operator>-&gt;</operator><name>kind</name></name> <operator>!=</operator> <name>LABEL_KIND_VERTEX</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                            <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"label %s is for edges, not vertices"</literal></expr></argument>,
                                   <argument><expr><name><name>node</name><operator>-&gt;</operator><name>label</name></name></expr></argument>)</argument_list></call><operator>,</operator>
                            <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     *  Check if the variable already exists, if so find the entity and
     *  setup the target node
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>name</name></name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>transform_entity</name> <modifier>*</modifier></type><name>entity</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>entity</name> <operator>=</operator> <call><name>find_variable</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>entity</name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>entity</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>ENT_VERTEX</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"variable %s already exists"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <return>return <expr><call><name>transform_create_cypher_existing_node</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>, <argument><expr><name>target_list</name></expr></argument>,
                                                         <argument><expr><name><name>entity</name><operator>-&gt;</operator><name>declared_in_current_clause</name></name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="line">// otherwise transform the target node as a new node</comment>
    <return>return <expr><call><name>transform_create_cypher_new_node</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>, <argument><expr><name>target_list</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Returns the resno for the TargetEntry with the resname equal to the name
 * passed. Returns -1 otherwise.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>get_target_entry_resno</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>target_list</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

    <macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>target_list</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>te</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>resname</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>te</name><operator>-&gt;</operator><name>expr</name></name> <operator>=</operator> <call><name>add_volatile_wrapper</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name><name>te</name><operator>-&gt;</operator><name>resno</name></name></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block>

    <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Transform logic for a previously declared variable in a CREATE clause.
 * All we need from the variable node is its id, and whether we can skip
 * some tests in the execution phase..
 */</comment>
<function><type><specifier>static</specifier> <name>cypher_target_node</name> <modifier>*</modifier></type><name>transform_create_cypher_existing_node</name><parameter_list>(
    <parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>target_list</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>declared_in_current_clause</name></decl></parameter>,
    <parameter><decl><type><name>cypher_node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>cypher_target_node</name> <modifier>*</modifier></type><name>rel</name> <init>= <expr><call><name>make_ag_node</name><argument_list>(<argument><expr><name>cypher_target_node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>LABEL_KIND_VERTEX</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>CYPHER_TARGET_NODE_FLAG_NONE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>resultRelInfo</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>variable_name</name></name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>name</name></name></expr>;</expr_stmt>


    <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>props</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"previously declared nodes in a create clause cannot have properties"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>label</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"previously declared variables cannot have a label"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <comment type="block">/*
     * When the variable is declared in the same clause this vertex is a part of
     * we can skip some expensive checks in the execution phase.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>declared_in_current_clause</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>EXISTING_VARAIBLE_DECLARED_SAME_CLAUSE</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Get the AttrNumber the variable is stored in, so we can extract the id
     * later.
     */</comment>
    <expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>tuple_position</name></name> <operator>=</operator> <call><name>get_target_entry_resno</name><argument_list>(<argument><expr><operator>*</operator><name>target_list</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>rel</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Transform logic for a node in a create clause that was not previously
 * declared.
 */</comment>
<function><type><specifier>static</specifier> <name>cypher_target_node</name> <modifier>*</modifier></type>
<name>transform_create_cypher_new_node</name><parameter_list>(<parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl></parameter>,
                                 <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>target_list</name></decl></parameter>, <parameter><decl><type><name>cypher_node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name> <init>= <expr><operator>(</operator><name>ParseState</name> <operator>*</operator><operator>)</operator><name>cpstate</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>cypher_target_node</name> <modifier>*</modifier></type><name>rel</name> <init>= <expr><call><name>make_ag_node</name><argument_list>(<argument><expr><name>cypher_target_node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name></type> <name>label_relation</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>rv</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>te</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>props</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>alias</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>resno</name></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>LABEL_KIND_VERTEX</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>tuple_position</name></name> <operator>=</operator> <name>InvalidAttrNumber</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>variable_name</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>resultRelInfo</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>node</name><operator>-&gt;</operator><name>label</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>label_name</name></name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt>
        <comment type="block">/*
         *  If no label is specified, assign the generic label name that
         *  all labels are descendents of.
         */</comment>
        <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>label</name></name> <operator>=</operator> <name>AG_DEFAULT_LABEL_VERTEX</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>label_name</name></name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>label</name></name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="line">// create the label entry if it does not exist</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>label_exists</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>label</name></name></expr></argument>, <argument><expr><name><name>cpstate</name><operator>-&gt;</operator><name>graph_oid</name></name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>parent</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>rv</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>get_label_range_var</name><argument_list>(<argument><expr><name><name>cpstate</name><operator>-&gt;</operator><name>graph_name</name></name></expr></argument>, <argument><expr><name><name>cpstate</name><operator>-&gt;</operator><name>graph_oid</name></name></expr></argument>,
                                 <argument><expr><name>AG_DEFAULT_LABEL_VERTEX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>parent</name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>create_label</name><argument_list>(<argument><expr><name><name>cpstate</name><operator>-&gt;</operator><name>graph_name</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>label</name></name></expr></argument>, <argument><expr><name>LABEL_TYPE_VERTEX</name></expr></argument>,
                     <argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>CYPHER_TARGET_NODE_FLAG_INSERT</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>makeRangeVar</name><argument_list>(<argument><expr><name><name>cpstate</name><operator>-&gt;</operator><name>graph_name</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>label</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>label_relation</name> <operator>=</operator> <call><name>parserOpenTable</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cpstate</name><operator>-&gt;</operator><name>pstate</name></name></expr></argument>, <argument><expr><name>rv</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Store the relid</comment>
    <expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>relid</name></name> <operator>=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>label_relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>addRangeTableEntryForRelation</name><argument_list>(<argument><expr><operator>(</operator><name>ParseState</name> <operator>*</operator><operator>)</operator><name>cpstate</name></expr></argument>, <argument><expr><name>label_relation</name></expr></argument>,
                                        <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>requiredPerms</name></name> <operator>=</operator> <name>ACL_INSERT</name></expr>;</expr_stmt>

    <comment type="line">// id</comment>
    <expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>id_expr</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator><call><name>build_column_default</name><argument_list>(<argument><expr><name>label_relation</name></expr></argument>,
                                                <argument><expr><name>Anum_ag_label_vertex_table_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// properties</comment>
    <expr_stmt><expr><name>alias</name> <operator>=</operator> <call><name>get_next_default_alias</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>resno</name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_next_resno</name></name><operator>++</operator></expr>;</expr_stmt>

    <expr_stmt><expr><name>props</name> <operator>=</operator> <call><name>cypher_create_properties</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>label_relation</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>props</name></name></expr></argument>,
                                     <argument><expr><name>ENT_VERTEX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>prop_attr_num</name></name> <operator>=</operator> <name>resno</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>te</name> <operator>=</operator> <call><name>makeTargetEntry</name><argument_list>(<argument><expr><name>props</name></expr></argument>, <argument><expr><name>resno</name></expr></argument>, <argument><expr><name>alias</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>target_list</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><operator>*</operator><name>target_list</name></expr></argument>, <argument><expr><name>te</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>label_relation</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>name</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>variable_name</name></name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>name</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>te</name> <operator>=</operator> <call><name>placeholder_target_entry</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>tuple_position</name></name> <operator>=</operator> <name><name>te</name><operator>-&gt;</operator><name>resno</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name>target_list</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><operator>*</operator><name>target_list</name></expr></argument>, <argument><expr><name>te</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>CYPHER_TARGET_NODE_IS_VAR</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <call><name>get_next_default_alias</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <return>return <expr><name>rel</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Variable Edges cannot be created until the executor phase, because we
 * don't know what their start and end node ids will be. Therefore, path
 * variables cannot be created either. Create a placeholder entry that we
 * will replace in the execution phase. Do this for nodes too, to be
 * consistent.
 */</comment>
<function><type><specifier>static</specifier> <name>TargetEntry</name> <modifier>*</modifier></type><name>placeholder_target_entry</name><parameter_list>(<parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl></parameter>,
                                             <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name> <init>= <expr><operator>(</operator><name>ParseState</name> <operator>*</operator><operator>)</operator><name>cpstate</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>n</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>resno</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>n</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator><call><name>makeNullConst</name><argument_list>(<argument><expr><name>AGTYPEOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>add_volatile_wrapper</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>resno</name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_next_resno</name></name><operator>++</operator></expr>;</expr_stmt>

    <return>return <expr><call><name>makeTargetEntry</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>resno</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Build the target list for an entity that is not a previously declared
 * variable.
 */</comment>
<function><type><specifier>static</specifier> <name>Expr</name> <modifier>*</modifier></type><name>cypher_create_properties</name><parameter_list>(<parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl></parameter>,
                                      <parameter><decl><type><name>cypher_target_node</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>,
                                      <parameter><decl><type><name>Relation</name></type> <name>label_relation</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>props</name></decl></parameter>,
                                      <parameter><decl><type><name><name>enum</name> <name>transform_entity_type</name></name></type> <name>type</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>properties</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>props</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>is_ag_node</name><argument_list>(<argument><expr><name>props</name></expr></argument>, <argument><expr><name>cypher_param</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name> <init>= <expr><operator>(</operator><name>ParseState</name> <operator>*</operator><operator>)</operator> <name>cpstate</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>cypher_param</name> <modifier>*</modifier></type><name>param</name> <init>= <expr><operator>(</operator><name>cypher_param</name> <operator>*</operator><operator>)</operator><name>props</name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"properties in a CREATE clause as a parameter is not supported"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>param</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>props</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>properties</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator><call><name>transform_cypher_expr</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>, <argument><expr><name>props</name></expr></argument>,
                                                   <argument><expr><name>EXPR_KIND_INSERT_TARGET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>type</name> <operator>==</operator> <name>ENT_VERTEX</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>properties</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator><call><name>build_column_default</name><argument_list>(
            <argument><expr><name>label_relation</name></expr></argument>, <argument><expr><name>Anum_ag_label_vertex_table_properties</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>type</name> <operator>==</operator> <name>ENT_EDGE</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>properties</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator><call><name>build_column_default</name><argument_list>(
            <argument><expr><name>label_relation</name></expr></argument>, <argument><expr><name>Anum_ag_label_edge_table_properties</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"unreconized entity type"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="line">// add a volatile wrapper call to prevent the optimizer from removing it</comment>
    <return>return <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator><call><name>add_volatile_wrapper</name><argument_list>(<argument><expr><name>properties</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * This function is similar to transformFromClause() that is called with a
 * single RangeSubselect.
 */</comment>
<function><type><specifier>static</specifier> <name>RangeTblEntry</name> <modifier>*</modifier></type>
<name>transform_cypher_clause_as_subquery</name><parameter_list>(<parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl></parameter>,
                                    <parameter><decl><type><name>transform_method</name></type> <name>transform</name></decl></parameter>,
                                    <parameter><decl><type><name>cypher_clause</name> <modifier>*</modifier></type><name>clause</name></decl></parameter>,
                                    <parameter><decl><type><name>Alias</name> <modifier>*</modifier></type><name>alias</name></decl></parameter>,
                                    <parameter><decl><type><name>bool</name></type> <name>add_rte_to_query</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name> <init>= <expr><operator>(</operator><name>ParseState</name> <operator>*</operator><operator>)</operator><name>cpstate</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ParseExprKind</name></type> <name>old_expr_kind</name> <init>= <expr><name><name>pstate</name><operator>-&gt;</operator><name>p_expr_kind</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>lateral</name> <init>= <expr><name><name>pstate</name><operator>-&gt;</operator><name>p_lateral_active</name></name></expr></init></decl>;</decl_stmt>

    <comment type="block">/*
     * We allow expression kinds of none, where, and subselect. Others MAY need
     * to be added depending. However, at this time, only these are needed.
     */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_expr_kind</name></name> <operator>==</operator> <name>EXPR_KIND_NONE</name> <operator>||</operator>
           <name><name>pstate</name><operator>-&gt;</operator><name>p_expr_kind</name></name> <operator>==</operator> <name>EXPR_KIND_OTHER</name> <operator>||</operator>
           <name><name>pstate</name><operator>-&gt;</operator><name>p_expr_kind</name></name> <operator>==</operator> <name>EXPR_KIND_WHERE</name> <operator>||</operator>
           <name><name>pstate</name><operator>-&gt;</operator><name>p_expr_kind</name></name> <operator>==</operator> <name>EXPR_KIND_FROM_SUBSELECT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * As these are all sub queries, if this is just of type NONE, note it as a
     * SUBSELECT. Other types will be dealt with as needed.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>pstate</name><operator>-&gt;</operator><name>p_expr_kind</name></name> <operator>==</operator> <name>EXPR_KIND_NONE</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_expr_kind</name></name> <operator>=</operator> <name>EXPR_KIND_FROM_SUBSELECT</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name><name>pstate</name><operator>-&gt;</operator><name>p_expr_kind</name></name> <operator>==</operator> <name>EXPR_KIND_OTHER</name></expr>)</condition>
    <block>{<block_content>
        <comment type="line">// this is a lateral subselect for the MERGE</comment>
        <expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_expr_kind</name></name> <operator>=</operator> <name>EXPR_KIND_FROM_SUBSELECT</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>lateral</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <comment type="block">/*
     * If this is a WHERE, pass it through and set lateral to true because it
     * needs to see what comes before it.
     */</comment>

    <expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>analyze_cypher_clause</name><argument_list>(<argument><expr><name>transform</name></expr></argument>, <argument><expr><name>clause</name></expr></argument>, <argument><expr><name>cpstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* set pstate kind back */</comment>
    <expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_expr_kind</name></name> <operator>=</operator> <name>old_expr_kind</name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>alias</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>alias</name> <operator>=</operator> <call><name>makeAlias</name><argument_list>(<argument><expr><name>PREV_CYPHER_CLAUSE_ALIAS</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>addRangeTableEntryForSubquery</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>query</name></expr></argument>, <argument><expr><name>alias</name></expr></argument>, <argument><expr><name>lateral</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * NOTE: skip namespace conflicts check if the rte will be the only
     *       RangeTblEntry in pstate
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_rtable</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>namespace</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>rtindex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

        <comment type="block">/* get the index of the last entry */</comment>
        <expr_stmt><expr><name>rtindex</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_rtable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* the rte at the end should be the rte just added */</comment>
        <if_stmt><if>if <condition>(<expr><name>rte</name> <operator>!=</operator> <call><name>rt_fetch</name><argument_list>(<argument><expr><name>rtindex</name></expr></argument>, <argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_rtable</name></name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                     <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"rte must be last entry in p_rtable"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>namespace</name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><call><name>create_namespace_item</name><argument_list>(<argument><expr><name>rte</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>checkNameSpaceConflicts</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_namespace</name></name></expr></argument>, <argument><expr><name>namespace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>add_rte_to_query</name></expr>)</condition>
    <block>{<block_content>
        <comment type="line">// all variables(attributes) from the previous clause(subquery) are visible</comment>
        <expr_stmt><expr><call><name>addRTEtoQuery</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>rte</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * When we are done transforming a clause, before transforming the next clause
 * iterate through the transform entities and mark them as not belonging to
 * the clause that is currently being transformed.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>advance_transform_entities_to_next_clause</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>entities</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

    <macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>entities</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>transform_entity</name> <modifier>*</modifier></type><name>entity</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name><name>entity</name><operator>-&gt;</operator><name>declared_in_current_clause</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    </block_content>}</block>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Query</name> <modifier>*</modifier></type><name>analyze_cypher_clause</name><parameter_list>(<parameter><decl><type><name>transform_method</name></type> <name>transform</name></decl></parameter>,
                                    <parameter><decl><type><name>cypher_clause</name> <modifier>*</modifier></type><name>clause</name></decl></parameter>,
                                    <parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>parent_cpstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>parent_pstate</name> <init>= <expr><operator>(</operator><name>ParseState</name><operator>*</operator><operator>)</operator><name>parent_cpstate</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>cpstate</name> <operator>=</operator> <call><name>make_cypher_parsestate</name><argument_list>(<argument><expr><name>parent_cpstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pstate</name> <operator>=</operator> <operator>(</operator><name>ParseState</name><operator>*</operator><operator>)</operator><name>cpstate</name></expr>;</expr_stmt>

    <comment type="block">/* copy the expr_kind down to the child */</comment>
    <expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_expr_kind</name></name> <operator>=</operator> <name><name>parent_pstate</name><operator>-&gt;</operator><name>p_expr_kind</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>transform</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>, <argument><expr><name>clause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>advance_transform_entities_to_next_clause</name><argument_list>(<argument><expr><name><name>cpstate</name><operator>-&gt;</operator><name>entities</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>parent_cpstate</name><operator>-&gt;</operator><name>entities</name></name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name><name>parent_cpstate</name><operator>-&gt;</operator><name>entities</name></name></expr></argument>,
                                           <argument><expr><name><name>cpstate</name><operator>-&gt;</operator><name>entities</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>free_cypher_parsestate</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>query</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>TargetEntry</name> <modifier>*</modifier></type><name>findTarget</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>targetList</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>resname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lt</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>te</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>resname</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <return>return <expr><name>NULL</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <macro><name>foreach</name> <argument_list>(<argument>lt</argument>, <argument>targetList</argument>)</argument_list></macro>
    <block>{<block_content>
        <expr_stmt><expr><name>te</name> <operator>=</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>te</name><operator>-&gt;</operator><name>resjunk</name></name></expr>)</condition>
        <block>{<block_content>
            <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>resname</name></name></expr></argument>, <argument><expr><name>resname</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <return>return <expr><name>te</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block>

    <return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Wrap the expression with a volatile function, to prevent the optimer from
 * elimating the expression.
 */</comment>
<function><type><specifier>static</specifier> <name>Expr</name> <modifier>*</modifier></type><name>add_volatile_wrapper</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Oid</name></type> <name>oid</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>oid</name> <operator>=</operator> <call><name>get_ag_func_oid</name><argument_list>(<argument><expr><literal type="string">"agtype_volatile_wrapper"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>AGTYPEOID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator><call><name>makeFuncExpr</name><argument_list>(<argument><expr><name>oid</name></expr></argument>, <argument><expr><name>AGTYPEOID</name></expr></argument>, <argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>,
                                <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>COERCE_EXPLICIT_CALL</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * from postgresql parse_sub_analyze
 * Modified entry point for recursively analyzing a sub-statement in union.
 */</comment>
<function><type><name>Query</name> <modifier>*</modifier></type><name>cypher_parse_sub_analyze_union</name><parameter_list>(<parameter><decl><type><name>cypher_clause</name> <modifier>*</modifier></type><name>clause</name></decl></parameter>,
                                <parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl></parameter>,
                                <parameter><decl><type><name>CommonTableExpr</name> <modifier>*</modifier></type><name>parentCTE</name></decl></parameter>,
                                <parameter><decl><type><name>bool</name></type> <name>locked_from_parent</name></decl></parameter>,
                                <parameter><decl><type><name>bool</name></type> <name>resolve_unknowns</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>state</name> <init>= <expr><call><name>make_cypher_parsestate</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>pstate</name><operator>.</operator><name>p_parent_cte</name></name> <operator>=</operator> <name>parentCTE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>pstate</name><operator>.</operator><name>p_locked_from_parent</name></name> <operator>=</operator> <name>locked_from_parent</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>pstate</name><operator>.</operator><name>p_resolve_unknowns</name></name> <operator>=</operator> <name>resolve_unknowns</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>transform_cypher_clause</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>clause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>free_cypher_parsestate</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>query</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * from postgresql parse_sub_analyze
 * Entry point for recursively analyzing a sub-statement.
 */</comment>
<function><type><name>Query</name> <modifier>*</modifier></type><name>cypher_parse_sub_analyze</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>parseTree</name></decl></parameter>,
                                <parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl></parameter>,
                                <parameter><decl><type><name>CommonTableExpr</name> <modifier>*</modifier></type><name>parentCTE</name></decl></parameter>,
                                <parameter><decl><type><name>bool</name></type> <name>locked_from_parent</name></decl></parameter>,
                                <parameter><decl><type><name>bool</name></type> <name>resolve_unknowns</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name> <init>= <expr><call><name>make_parsestate</name><argument_list>(<argument><expr><operator>(</operator><name>ParseState</name><operator>*</operator><operator>)</operator><name>cpstate</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>cypher_clause</name> <modifier>*</modifier></type><name>clause</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_parent_cte</name></name> <operator>=</operator> <name>parentCTE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_locked_from_parent</name></name> <operator>=</operator> <name>locked_from_parent</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_resolve_unknowns</name></name> <operator>=</operator> <name>resolve_unknowns</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>clause</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>cypher_clause</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>clause</name><operator>-&gt;</operator><name>self</name></name> <operator>=</operator> <name>parseTree</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>transform_cypher_clause</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>, <argument><expr><name>clause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>free_parsestate</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>query</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Function for transforming MERGE.
 *
 * There are two cases for the form Query that is returned from here will
 * take:
 *
 * 1. If there is no previous clause, the query will have a subquery that
 * represents the path as a select staement, similar to match with a targetList
 * that is all declared variables and the FuncExpr that represents the MERGE
 * clause with its needed metadata information, that will be caught in the
 * planner phase and converted into a path.
 *
 * 2. If there is a previous clause then the query will have two subqueries.
 * The first query will be for the previous clause that we recursively handle.
 * The second query will be for the path that this MERGE clause defines. The
 * two subqueries will be joined together using a LATERAL LEFT JOIN with the
 * previous query on the left and the MERGE path subquery on the right. Like
 * case 1 the targetList will have all the decalred variables and a FuncExpr
 * that represents the MERGE clause with its needed metadata information, that
 * will be caught in the planner phase and converted into a path.
 *
 * This will allow us to be capable of handling the 2 cases that exist with a
 * MERGE clause correctly.
 *
 * Case 1: the path already exists. In this case we do not need to create
 * the path and MERGE will simply pass the tuple information up the execution
 * tree.
 *
 * Case 2: the path does not exist. In this case the LEFT part of the join
 * will not prevent the tuples from the previous clause from being emitted. We
 * can catch when this happens in the execution phase and create the missing
 * data, before passing up the execution tree.
 *
 * It should be noted that both cases can happen in the same query. If the
 * MERGE clause references a variable from a previous clause, it could be that
 * for one tuple the path exists (or there is multiple paths that exist and all
 * paths must be emitted) and for another the path does not exist. This is
 * similar to OPTIONAL MATCH, however with the added feature of creating the
 * path if not there, rather than just emiting NULL.
 */</comment>
<function><type><specifier>static</specifier> <name>Query</name> <modifier>*</modifier></type><name>transform_cypher_merge</name><parameter_list>(<parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl></parameter>,
                                     <parameter><decl><type><name>cypher_clause</name> <modifier>*</modifier></type><name>clause</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name> <init>= <expr><operator>(</operator><name>ParseState</name> <operator>*</operator><operator>)</operator> <name>cpstate</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>cypher_clause</name> <modifier>*</modifier></type><name>merge_clause_as_match</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>cypher_create_path</name> <modifier>*</modifier></type><name>merge_path</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>cypher_merge</name> <modifier>*</modifier></type><name>self</name> <init>= <expr><operator>(</operator><name>cypher_merge</name> <operator>*</operator><operator>)</operator><name><name>clause</name><operator>-&gt;</operator><name>self</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>cypher_merge_information</name> <modifier>*</modifier></type><name>merge_information</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>FuncExpr</name> <modifier>*</modifier></type><name>func_expr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>is_ag_node</name><argument_list>(<argument><expr><name><name>self</name><operator>-&gt;</operator><name>path</name></name></expr></argument>, <argument><expr><name>cypher_path</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>merge_information</name> <operator>=</operator> <call><name>make_ag_node</name><argument_list>(<argument><expr><name>cypher_merge_information</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>commandType</name></name> <operator>=</operator> <name>CMD_SELECT</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>merge_information</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>CYPHER_CLAUSE_FLAG_NONE</name></expr>;</expr_stmt>

    <comment type="line">// make the merge node into a match node</comment>
    <expr_stmt><expr><name>merge_clause_as_match</name> <operator>=</operator> <call><name>convert_merge_to_match</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * If there is a previous clause we need to turn this query into a lateral
     * join. See the function transform_merge_make_lateral_join for details.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>clause</name><operator>-&gt;</operator><name>prev</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>merge_path</name> <operator>=</operator> <call><name>transform_merge_make_lateral_join</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>, <argument><expr><name>query</name></expr></argument>, <argument><expr><name>clause</name></expr></argument>,
                                                       <argument><expr><name>merge_clause_as_match</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>merge_information</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>CYPHER_CLAUSE_FLAG_PREVIOUS_CLAUSE</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="line">// make the merge node into a match node</comment>
        <decl_stmt><decl><type><name>cypher_clause</name> <modifier>*</modifier></type><name>merge_clause_as_match</name> <init>= <expr><call><name>convert_merge_to_match</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="block">/*
         * Create the metadata needed for creating missing paths.
         */</comment>
        <expr_stmt><expr><name>merge_path</name> <operator>=</operator> <call><name>transform_cypher_merge_path</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>query</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>,
                                                 <argument><expr><operator>(</operator><name>cypher_path</name> <operator>*</operator><operator>)</operator><name><name>self</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * If there is not a previous clause, then treat the MERGE's path
         * itself as the previous clause. We need to do this because if the
         * pattern exists, then we need to path all paths that match the
         * query patterns in the execution phase. WE way to do that by
         * converting the merge to a match and have the match logic create the
         * query. the merge execution phase will just pass the results up the
         * execution tree if the path exists.
         */</comment>
        <expr_stmt><expr><call><name>handle_prev_clause</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>, <argument><expr><name>query</name></expr></argument>, <argument><expr><name>merge_clause_as_match</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * For the metadata need to create paths, find the tuple position that
         * will represent the entity in the execution phase.
         */</comment>
        <expr_stmt><expr><call><name>transform_cypher_merge_mark_tuple_position</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>,
                                                   <argument><expr><name>merge_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><name><name>merge_information</name><operator>-&gt;</operator><name>graph_oid</name></name> <operator>=</operator> <name><name>cpstate</name><operator>-&gt;</operator><name>graph_oid</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>merge_information</name><operator>-&gt;</operator><name>path</name></name> <operator>=</operator> <name>merge_path</name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>clause</name><operator>-&gt;</operator><name>next</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>merge_information</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>CYPHER_CLAUSE_FLAG_TERMINAL</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Creates the function expression that the planner will find and
     * convert to a MERGE path.
     */</comment>
    <expr_stmt><expr><name>func_expr</name> <operator>=</operator> <call><name>make_clause_func_expr</name><argument_list>(<argument><expr><name>MERGE_CLAUSE_FUNCTION_NAME</name></expr></argument>,
                                      <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name>merge_information</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Create the target entry</comment>
    <expr_stmt><expr><name>tle</name> <operator>=</operator> <call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator><name>func_expr</name></expr></argument>, <argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_next_resno</name></name><operator>++</operator></expr></argument>,
                          <argument><expr><name>AGE_VARNAME_MERGE_CLAUSE</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>merge_information</name><operator>-&gt;</operator><name>merge_function_attr</name></name> <operator>=</operator> <name><name>tle</name><operator>-&gt;</operator><name>resno</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>, <argument><expr><name>tle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>markTargetListOrigins</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>rtable</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_rtable</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>jointree</name></name> <operator>=</operator> <call><name>makeFromExpr</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_joinlist</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>hasSubLinks</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_hasSubLinks</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>assign_query_collations</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>query</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * This function does the heavy lifting of transforming a MERGE clause that has
 * a clause before it in the query of turning that into a lateral left join.
 * The previous clause will still be able to emit tuples if the path defined in
 * MERGE clause is not found. In that case variable assinged in the MERGE
 * clause will be emitted as NULL (same as OPTIONAL MATCH).
 */</comment>
<function><type><specifier>static</specifier> <name>cypher_create_path</name> <modifier>*</modifier></type>
<name>transform_merge_make_lateral_join</name><parameter_list>(<parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>,
                                  <parameter><decl><type><name>cypher_clause</name> <modifier>*</modifier></type><name>clause</name></decl></parameter>,
                                  <parameter><decl><type><name>cypher_clause</name> <modifier>*</modifier></type><name>isolated_merge_clause</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>cypher_create_path</name> <modifier>*</modifier></type><name>merge_path</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name> <init>= <expr><operator>(</operator><name>ParseState</name> <operator>*</operator><operator>)</operator> <name>cpstate</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Alias</name> <modifier>*</modifier></type><name>l_alias</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Alias</name> <modifier>*</modifier></type><name>r_alias</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>l_rte</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>r_rte</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ParseNamespaceItem</name> <modifier>*</modifier></type><name>l_nsitem</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>r_nsitem</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>JoinExpr</name> <modifier>*</modifier></type><name>j</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>JoinExpr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>res_colnames</name> <init>= <expr><name>NIL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>res_colvars</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ParseNamespaceItem</name> <modifier>*</modifier></type><name>nsitem</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ParseExprKind</name></type> <name>tmp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>cypher_merge</name> <modifier>*</modifier></type><name>self</name> <init>= <expr><operator>(</operator><name>cypher_merge</name> <operator>*</operator><operator>)</operator><name><name>clause</name><operator>-&gt;</operator><name>self</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>cypher_path</name> <modifier>*</modifier></type><name>path</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>is_ag_node</name><argument_list>(<argument><expr><name><name>self</name><operator>-&gt;</operator><name>path</name></name></expr></argument>, <argument><expr><name>cypher_path</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>path</name> <operator>=</operator> <operator>(</operator><name>cypher_path</name> <operator>*</operator><operator>)</operator><name><name>self</name><operator>-&gt;</operator><name>path</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><name>r_alias</name> <operator>=</operator> <call><name>makeAlias</name><argument_list>(<argument><expr><name>CYPHER_OPT_RIGHT_ALIAS</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>l_alias</name> <operator>=</operator> <call><name>makeAlias</name><argument_list>(<argument><expr><name>PREV_CYPHER_CLAUSE_ALIAS</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>j</name><operator>-&gt;</operator><name>jointype</name></name> <operator>=</operator> <name>JOIN_LEFT</name></expr>;</expr_stmt>

    <comment type="block">/*
     * transform the previous clause
     */</comment>
    <expr_stmt><expr><name><name>j</name><operator>-&gt;</operator><name>larg</name></name> <operator>=</operator> <call><name>transform_clause_for_join</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>, <argument><expr><name><name>clause</name><operator>-&gt;</operator><name>prev</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>l_rte</name></expr></argument>,
                                            <argument><expr><operator>&amp;</operator><name>l_nsitem</name></expr></argument>, <argument><expr><name>l_alias</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_namespace</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_namespace</name></name></expr></argument>, <argument><expr><name>l_nsitem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Get the merge path now. This is the only moment where it is simple
     * to know if a variable was declared in the MERGE clause or a previous
     * clause. Unlike create, we do not add these missing variables to the
     * targetList, we just create all the metadata necessary to make the
     * potentially missing parts of the path.
     */</comment>
    <expr_stmt><expr><name>merge_path</name> <operator>=</operator> <call><name>transform_cypher_merge_path</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>query</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>,
                                             <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Transform this MERGE clause as a match clause, mark the parsestate
     * with the flag that a lateral join is active
     */</comment>
    <expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_lateral_active</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>tmp</name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_expr_kind</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_expr_kind</name></name> <operator>=</operator> <name>EXPR_KIND_OTHER</name></expr>;</expr_stmt>

    <comment type="line">// transform MERGE</comment>
    <expr_stmt><expr><name><name>j</name><operator>-&gt;</operator><name>rarg</name></name> <operator>=</operator> <call><name>transform_clause_for_join</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>, <argument><expr><name>isolated_merge_clause</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>r_rte</name></expr></argument>,
                                            <argument><expr><operator>&amp;</operator><name>r_nsitem</name></expr></argument>, <argument><expr><name>r_alias</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// deactivate the lateral flag</comment>
    <expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_lateral_active</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_namespace</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

    <comment type="block">/*
     * Resolve the column names and variables between the two subqueries,
     * in most cases, we can expect there to be overlap
     */</comment>
    <expr_stmt><expr><call><name>get_res_cols</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>l_rte</name></expr></argument>, <argument><expr><name>r_rte</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>res_colnames</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>res_colvars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// make the RTE for the join</comment>
    <expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>addRangeTableEntryForJoin</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>res_colnames</name></expr></argument>, <argument><expr><name><name>j</name><operator>-&gt;</operator><name>jointype</name></name></expr></argument>,
                                        <argument><expr><name>res_colvars</name></expr></argument>, <argument><expr><name><name>j</name><operator>-&gt;</operator><name>alias</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>j</name><operator>-&gt;</operator><name>rtindex</name></name> <operator>=</operator> <call><name>RTERangeTablePosn</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * The index of a node in the p_joinexpr list is expected to match the
     * rtindex the join expression is for. Add NULLs for all the previous
     * rtindexes and add the JoinExpr.
     */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_joinexprs</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>j</name><operator>-&gt;</operator><name>rtindex</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_joinexprs</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_joinexprs</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_joinexprs</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_joinexprs</name></name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_joinexprs</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name><name>j</name><operator>-&gt;</operator><name>rtindex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_joinlist</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_joinlist</name></name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_expr_kind</name></name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>

    <comment type="block">/*
     * Create the namespace item for the joined subqueries, and append
     * to the ParseState's list of namespaces.
     */</comment>
    <expr_stmt><expr><name>nsitem</name> <operator>=</operator> <call><name>create_namespace_item</name><argument_list>(<argument><expr><name>rte</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_namespace</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_namespace</name></name></expr></argument>, <argument><expr><name>nsitem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Create the targetList from the joined subqueries, add everything.
     */</comment>
    <expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>,
                                    <argument><expr><call><name>make_target_list_from_join</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * For the metadata need to create paths, find the tuple position that
     * will represent the entity in the execution phase.
     */</comment>
    <expr_stmt><expr><call><name>transform_cypher_merge_mark_tuple_position</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>,
                                               <argument><expr><name>merge_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>merge_path</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Iterate through the path and find the TargetEntry in the target_list
 * that each cypher_target_node is referencing. Add the volatile wrapper
 * function to keep the optimizer from removing the TargetEntry.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>transform_cypher_merge_mark_tuple_position</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>target_list</name></decl></parameter>,
                                           <parameter><decl><type><name>cypher_create_path</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>path</name><operator>-&gt;</operator><name>var_name</name></name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>te</name> <init>= <expr><call><name>findTarget</name><argument_list>(<argument><expr><name>target_list</name></expr></argument>, <argument><expr><name><name>path</name><operator>-&gt;</operator><name>var_name</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="block">/*
         * Add the volatile wrapper function around the expression, this
         * ensures the optimizer will not remove the expression, if nothing
         * other than a private data structure needs it.
         */</comment>
        <expr_stmt><expr><name><name>te</name><operator>-&gt;</operator><name>expr</name></name> <operator>=</operator> <call><name>add_volatile_wrapper</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Mark the tuple position the target_node is for.</comment>
        <expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>path_attr_num</name></name> <operator>=</operator> <name><name>te</name><operator>-&gt;</operator><name>resno</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>path-&gt;target_nodes</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>cypher_target_node</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>te</name> <init>= <expr><call><name>findTarget</name><argument_list>(<argument><expr><name>target_list</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>variable_name</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="block">/*
         * Add the volatile wrapper function around the expression, this
         * ensures the optimizer will not remove the expression, if nothing
         * other than a private data structure needs it.
         */</comment>
        <expr_stmt><expr><name><name>te</name><operator>-&gt;</operator><name>expr</name></name> <operator>=</operator> <call><name>add_volatile_wrapper</name><argument_list>(<argument><expr><name><name>te</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Mark the tuple position the target_node is for.</comment>
        <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>tuple_position</name></name> <operator>=</operator> <name><name>te</name><operator>-&gt;</operator><name>resno</name></name></expr>;</expr_stmt>
    </block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 * Creates the target nodes for a merge path. If MERGE has a path that doesn't
 * exist then in the MERGE clause we act like a CREATE clause. This function
 * sets up the metadata needed for that process.
 */</comment>
<function><type><specifier>static</specifier> <name>cypher_create_path</name> <modifier>*</modifier></type>
<name>transform_cypher_merge_path</name><parameter_list>(<parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>target_list</name></decl></parameter>,
                            <parameter><decl><type><name>cypher_path</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>transformed_path</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>cypher_create_path</name> <modifier>*</modifier></type><name>ccp</name> <init>= <expr><call><name>make_ag_node</name><argument_list>(<argument><expr><name>cypher_create_path</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>in_path</name> <init>= <expr><name><name>path</name><operator>-&gt;</operator><name>var_name</name></name> <operator>!=</operator> <name>NULL</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>ccp</name><operator>-&gt;</operator><name>path_attr_num</name></name> <operator>=</operator> <name>InvalidAttrNumber</name></expr>;</expr_stmt>

    <macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>path-&gt;path</argument>)</argument_list></macro>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>is_ag_node</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>cypher_node</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>cypher_node</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <decl_stmt><decl><type><name>cypher_target_node</name> <modifier>*</modifier></type><name>rel</name> <init>=
                <expr><call><name>transform_merge_cypher_node</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>, <argument><expr><name>target_list</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name>in_path</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>CYPHER_TARGET_NODE_IN_PATH_VAR</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <expr_stmt><expr><name>transformed_path</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>transformed_path</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><call><name>is_ag_node</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>cypher_relationship</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>cypher_relationship</name> <modifier>*</modifier></type><name>edge</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <decl_stmt><decl><type><name>cypher_target_node</name> <modifier>*</modifier></type><name>rel</name> <init>=
                <expr><call><name>transform_merge_cypher_edge</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>, <argument><expr><name>target_list</name></expr></argument>, <argument><expr><name>edge</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><name>in_path</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>CYPHER_TARGET_NODE_IN_PATH_VAR</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <expr_stmt><expr><name>transformed_path</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>transformed_path</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"unreconized node in create pattern"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block>

    <comment type="line">// store the path's variable name</comment>
    <if_stmt><if>if <condition>(<expr><name><name>path</name><operator>-&gt;</operator><name>var_name</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>ccp</name><operator>-&gt;</operator><name>var_name</name></name> <operator>=</operator> <name><name>path</name><operator>-&gt;</operator><name>var_name</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name><name>ccp</name><operator>-&gt;</operator><name>target_nodes</name></name> <operator>=</operator> <name>transformed_path</name></expr>;</expr_stmt>

    <return>return <expr><name>ccp</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Transforms the parse cypher_relationship to a target_entry for merge.
 * All edges that have variables assigned in a merge must be declared in
 * the merge. Throw an error otherwise.
 */</comment>
<function><type><specifier>static</specifier> <name>cypher_target_node</name> <modifier>*</modifier></type>
<name>transform_merge_cypher_edge</name><parameter_list>(<parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>target_list</name></decl></parameter>,
                             <parameter><decl><type><name>cypher_relationship</name> <modifier>*</modifier></type><name>edge</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name> <init>= <expr><operator>(</operator><name>ParseState</name> <operator>*</operator><operator>)</operator><name>cpstate</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>cypher_target_node</name> <modifier>*</modifier></type><name>rel</name> <init>= <expr><call><name>make_ag_node</name><argument_list>(<argument><expr><name>cypher_target_node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name></type> <name>label_relation</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>rv</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>edge</name><operator>-&gt;</operator><name>name</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>transform_entity</name> <modifier>*</modifier></type><name>entity</name> <init>= <expr><call><name>find_transform_entity</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>, <argument><expr><name><name>edge</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,
                                                         <argument><expr><name>ENT_EDGE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// We found a variable with this variable name, throw an error.</comment>
        <if_stmt><if>if <condition>(<expr><name>entity</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"variable %s already exists"</literal></expr></argument>, <argument><expr><name><name>edge</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>edge</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>CYPHER_TARGET_NODE_IS_VAR</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="line">// assign a default variable name.</comment>
        <expr_stmt><expr><name><name>edge</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <call><name>get_next_default_alias</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>LABEL_KIND_EDGE</name></expr>;</expr_stmt>

    <comment type="line">// all edges are marked with insert</comment>
    <expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>CYPHER_TARGET_NODE_FLAG_INSERT</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>label_name</name></name> <operator>=</operator> <name><name>edge</name><operator>-&gt;</operator><name>label</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>variable_name</name></name> <operator>=</operator> <name><name>edge</name><operator>-&gt;</operator><name>name</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>resultRelInfo</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>dir</name></name> <operator>=</operator> <name><name>edge</name><operator>-&gt;</operator><name>dir</name></name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>edge</name><operator>-&gt;</operator><name>label</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"edges declared in a MERGE clause must have a label"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>parser_errposition</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cpstate</name><operator>-&gt;</operator><name>pstate</name></name></expr></argument>, <argument><expr><name><name>edge</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>


    <comment type="line">// check to see if the label exists, create the label entry if it does not.</comment>
    <if_stmt><if>if <condition>(<expr><name><name>edge</name><operator>-&gt;</operator><name>label</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>label_exists</name><argument_list>(<argument><expr><name><name>edge</name><operator>-&gt;</operator><name>label</name></name></expr></argument>, <argument><expr><name><name>cpstate</name><operator>-&gt;</operator><name>graph_oid</name></name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>parent</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>rv</name></decl>;</decl_stmt>

        <comment type="block">/*
         * setup the default edge table as the parent table, that we
         * will inherit from.
         */</comment>
        <expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>get_label_range_var</name><argument_list>(<argument><expr><name><name>cpstate</name><operator>-&gt;</operator><name>graph_name</name></name></expr></argument>, <argument><expr><name><name>cpstate</name><operator>-&gt;</operator><name>graph_oid</name></name></expr></argument>,
                                 <argument><expr><name>AG_DEFAULT_LABEL_EDGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>parent</name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// create the label</comment>
        <expr_stmt><expr><call><name>create_label</name><argument_list>(<argument><expr><name><name>cpstate</name><operator>-&gt;</operator><name>graph_name</name></name></expr></argument>, <argument><expr><name><name>edge</name><operator>-&gt;</operator><name>label</name></name></expr></argument>, <argument><expr><name>LABEL_TYPE_EDGE</name></expr></argument>,
                     <argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="line">// lock the relation of the label</comment>
    <expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>makeRangeVar</name><argument_list>(<argument><expr><name><name>cpstate</name><operator>-&gt;</operator><name>graph_name</name></name></expr></argument>, <argument><expr><name><name>edge</name><operator>-&gt;</operator><name>label</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>label_relation</name> <operator>=</operator> <call><name>parserOpenTable</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cpstate</name><operator>-&gt;</operator><name>pstate</name></name></expr></argument>, <argument><expr><name>rv</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Store the relid</comment>
    <expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>relid</name></name> <operator>=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>label_relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>addRangeTableEntryForRelation</name><argument_list>(<argument><expr><operator>(</operator><name>ParseState</name> <operator>*</operator><operator>)</operator><name>cpstate</name></expr></argument>, <argument><expr><name>label_relation</name></expr></argument>,
                                        <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>requiredPerms</name></name> <operator>=</operator> <name>ACL_INSERT</name></expr>;</expr_stmt>

    <comment type="line">// Build Id expression, always use the default logic</comment>
    <expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>id_expr</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator><call><name>build_column_default</name><argument_list>(<argument><expr><name>label_relation</name></expr></argument>,
                                      <argument><expr><name>Anum_ag_label_edge_table_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>prop_expr</name></name> <operator>=</operator> <call><name>cypher_create_properties</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>label_relation</name></expr></argument>,
                                              <argument><expr><name><name>edge</name><operator>-&gt;</operator><name>props</name></name></expr></argument>, <argument><expr><name>ENT_EDGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Keep the lock</comment>
    <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>label_relation</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>rel</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Function for creating the metadata MERGE will need if MERGE does not find
 * a path to exist
 */</comment>
<function><type><specifier>static</specifier> <name>cypher_target_node</name> <modifier>*</modifier></type>
<name>transform_merge_cypher_node</name><parameter_list>(<parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>target_list</name></decl></parameter>,
                            <parameter><decl><type><name>cypher_node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>cypher_target_node</name> <modifier>*</modifier></type><name>rel</name> <init>= <expr><call><name>make_ag_node</name><argument_list>(<argument><expr><name>cypher_target_node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Relation</name></type> <name>label_relation</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>rv</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>name</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>

        <decl_stmt><decl><type><name>transform_entity</name> <modifier>*</modifier></type><name>entity</name> <init>= <expr><call><name>find_transform_entity</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,
                                                         <argument><expr><name>ENT_VERTEX</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="block">/*
         *  the vertex was previously declared, we do not need to do any setup
         *  to create the node.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name>entity</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
                <expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>LABEL_KIND_VERTEX</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>tuple_position</name></name> <operator>=</operator> <name>InvalidAttrNumber</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>variable_name</name></name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>name</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>resultRelInfo</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

                <expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>CYPHER_TARGET_NODE_MERGE_EXISTS</name></expr>;</expr_stmt>
                <return>return <expr><name>rel</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>CYPHER_TARGET_NODE_IS_VAR</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="line">// assign a default variable name.</comment>
        <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <call><name>get_next_default_alias</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>LABEL_KIND_VERTEX</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>tuple_position</name></name> <operator>=</operator> <name>InvalidAttrNumber</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>variable_name</name></name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>name</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>resultRelInfo</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>node</name><operator>-&gt;</operator><name>label</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>label_name</name></name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt>
        <comment type="block">/*
         *  If no label is specified, assign the generic label name that
         *  all labels are descendents of.
         */</comment>
        <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>label</name></name> <operator>=</operator> <name>AG_DEFAULT_LABEL_VERTEX</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>label_name</name></name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>label</name></name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="line">// check to see if the label exists, create the label entry if it does not.</comment>
    <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>label</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>label_exists</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>label</name></name></expr></argument>, <argument><expr><name><name>cpstate</name><operator>-&gt;</operator><name>graph_oid</name></name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>parent</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>rv</name></decl>;</decl_stmt>

        <comment type="block">/*
         * setup the default vertex table as the parent table, that we
         * will inherit from.
         */</comment>
        <expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>get_label_range_var</name><argument_list>(<argument><expr><name><name>cpstate</name><operator>-&gt;</operator><name>graph_name</name></name></expr></argument>, <argument><expr><name><name>cpstate</name><operator>-&gt;</operator><name>graph_oid</name></name></expr></argument>,
                                 <argument><expr><name>AG_DEFAULT_LABEL_VERTEX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>parent</name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// create the label</comment>
        <expr_stmt><expr><call><name>create_label</name><argument_list>(<argument><expr><name><name>cpstate</name><operator>-&gt;</operator><name>graph_name</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>label</name></name></expr></argument>, <argument><expr><name>LABEL_TYPE_VERTEX</name></expr></argument>,
                     <argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>CYPHER_TARGET_NODE_FLAG_INSERT</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>makeRangeVar</name><argument_list>(<argument><expr><name><name>cpstate</name><operator>-&gt;</operator><name>graph_name</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>label</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>label_relation</name> <operator>=</operator> <call><name>parserOpenTable</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cpstate</name><operator>-&gt;</operator><name>pstate</name></name></expr></argument>, <argument><expr><name>rv</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Store the relid</comment>
    <expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>relid</name></name> <operator>=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>label_relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>addRangeTableEntryForRelation</name><argument_list>(<argument><expr><operator>(</operator><name>ParseState</name> <operator>*</operator><operator>)</operator><name>cpstate</name></expr></argument>, <argument><expr><name>label_relation</name></expr></argument>,
                                        <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>requiredPerms</name></name> <operator>=</operator> <name>ACL_INSERT</name></expr>;</expr_stmt>

    <comment type="line">// id</comment>
    <expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>id_expr</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator><call><name>build_column_default</name><argument_list>(<argument><expr><name>label_relation</name></expr></argument>,
                                                <argument><expr><name>Anum_ag_label_vertex_table_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>prop_expr</name></name> <operator>=</operator> <call><name>cypher_create_properties</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>label_relation</name></expr></argument>,
                                              <argument><expr><name><name>node</name><operator>-&gt;</operator><name>props</name></name></expr></argument>, <argument><expr><name>ENT_VERTEX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>label_relation</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>rel</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Takes a MERGE parse node and converts it to a MATCH parse node
 */</comment>
<function><type><specifier>static</specifier> <name>cypher_clause</name> <modifier>*</modifier></type><name>convert_merge_to_match</name><parameter_list>(<parameter><decl><type><name>cypher_merge</name> <modifier>*</modifier></type><name>merge</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>cypher_match</name> <modifier>*</modifier></type><name>match</name> <init>= <expr><call><name>make_ag_node</name><argument_list>(<argument><expr><name>cypher_match</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>cypher_clause</name> <modifier>*</modifier></type><name>clause</name> <init>= <expr><call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>cypher_clause</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="line">// match supports multiple paths, whereas merge only supports one.</comment>
    <expr_stmt><expr><name><name>match</name><operator>-&gt;</operator><name>pattern</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name><name>merge</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="line">// MERGE does not support where</comment>
    <expr_stmt><expr><name><name>match</name><operator>-&gt;</operator><name>where</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

    <comment type="block">/*
     *  We do not want the transform logic to transform the previous clauses
     *  with this, just handle this one clause.
     */</comment>
    <expr_stmt><expr><name><name>clause</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>clause</name><operator>-&gt;</operator><name>self</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name>match</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>clause</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

    <return>return <expr><name>clause</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Creates a namespace item for the given rte. boolean arguements will
 * let the rest of the ParseState know if the relation and/or columns are
 * visible, whether the rte is only usable in lateral joins, and if the rte
 * is accessible in lateral joins.
 */</comment>
<function><type><specifier>static</specifier> <name>ParseNamespaceItem</name> <modifier>*</modifier></type><name>create_namespace_item</name><parameter_list>(<parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>,
                                                 <parameter><decl><type><name>bool</name></type> <name>p_rel_visible</name></decl></parameter>,
                                                 <parameter><decl><type><name>bool</name></type> <name>p_cols_visible</name></decl></parameter>,
                                                 <parameter><decl><type><name>bool</name></type> <name>p_lateral_only</name></decl></parameter>,
                                                 <parameter><decl><type><name>bool</name></type> <name>p_lateral_ok</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ParseNamespaceItem</name> <modifier>*</modifier></type><name>nsitem</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>nsitem</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>nsitem</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>nsitem</name><operator>-&gt;</operator><name>p_rte</name></name> <operator>=</operator> <name>rte</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>nsitem</name><operator>-&gt;</operator><name>p_rel_visible</name></name> <operator>=</operator> <name>p_rel_visible</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>nsitem</name><operator>-&gt;</operator><name>p_cols_visible</name></name> <operator>=</operator> <name>p_cols_visible</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>nsitem</name><operator>-&gt;</operator><name>p_lateral_only</name></name> <operator>=</operator> <name>p_lateral_only</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>nsitem</name><operator>-&gt;</operator><name>p_lateral_ok</name></name> <operator>=</operator> <name>p_lateral_ok</name></expr>;</expr_stmt>

    <return>return <expr><name>nsitem</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Creates the function expression that represents the clause. Adds the
 * extensible node that represents the metadata that the clause needs to
 * handle the clause in the execution phase.
 */</comment>
<function><type><specifier>static</specifier> <name>FuncExpr</name> <modifier>*</modifier></type><name>make_clause_func_expr</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>function_name</name></decl></parameter>,
                                       <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>clause_information</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Const</name> <modifier>*</modifier></type><name>clause_information_const</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type> <name>func_oid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>FuncExpr</name> <modifier>*</modifier></type><name>func_expr</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>StringInfo</name></type> <name>str</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <comment type="block">/*
     * Serialize the clause_information data structure. In certain
     * cases (Prepared Statements and PL/pgsql), the MemoryContext that
     * it is stored in will be destroyed. We need to get it into a format
     * that Postgres' can copy between MemoryContexts. Just making it into
     * an ExtensibleNode does not work, because there are certain parts of
     * Postgres that cannot handle an ExtensibleNode in a function call.
     * So we serialize the data structure and place it into a Const node
     * that can handle these situations AND be copied correctly.
     */</comment>
    <expr_stmt><expr><call><name>outNode</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>clause_information</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>clause_information_const</name> <operator>=</operator> <call><name>makeConst</name><argument_list>(<argument><expr><name>INTERNALOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name><name>str</name><operator>-&gt;</operator><name>len</name></name></expr></argument>,
                             <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name><name>str</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>func_oid</name> <operator>=</operator> <call><name>get_ag_func_oid</name><argument_list>(<argument><expr><name>function_name</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>INTERNALOID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>func_expr</name> <operator>=</operator> <call><name>makeFuncExpr</name><argument_list>(<argument><expr><name>func_oid</name></expr></argument>, <argument><expr><name>AGTYPEOID</name></expr></argument>,
                             <argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name>clause_information_const</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>,
                             <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>COERCE_EXPLICIT_CALL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>func_expr</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Utility function that helps a clause add the information needed to
 * the query from the previous clause.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>handle_prev_clause</name><parameter_list>(<parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>,
                               <parameter><decl><type><name>cypher_clause</name> <modifier>*</modifier></type><name>clause</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>first_rte</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name> <init>= <expr><operator>(</operator><name>ParseState</name> <operator>*</operator><operator>)</operator> <name>cpstate</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>rtindex</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>transform_prev_cypher_clause</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>, <argument><expr><name>clause</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rtindex</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_rtable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// rte is the first RangeTblEntry in pstate</comment>
    <if_stmt><if>if <condition>(<expr><name>first_rte</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>rtindex</name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="line">// add all the rte's attributes to the current queries targetlist</comment>
    <expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <call><name>expandRelAttrs</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>, <argument><expr><name>rtindex</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
