<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/builded_projects/age/src/backend/parser/cypher_expr.c"><comment type="block">/*
 * For PostgreSQL Database Management System:
 * (formerly known as Postgres, then as Postgres95)
 *
 * Portions Copyright (c) 1996-2010, The PostgreSQL Global Development Group
 *
 * Portions Copyright (c) 1994, The Regents of the University of California
 *
 * Permission to use, copy, modify, and distribute this software and its documentation for any purpose,
 * without fee, and without a written agreement is hereby granted, provided that the above copyright notice
 * and this paragraph and the following two paragraphs appear in all copies.
 *
 * IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR DIRECT,
 * INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS,
 * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF THE UNIVERSITY
 * OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
 * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 *
 * THE SOFTWARE PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND THE UNIVERSITY OF CALIFORNIA
 * HAS NO OBLIGATIONS TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodeFuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/parsenodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/value.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/tlist.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_coerce.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_collate.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_expr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_func.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/cypher_clause.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_node.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_oper.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_relation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/int8.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/label_commands.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/cypher_nodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/cypher_expr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/cypher_parse_node.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/cypher_transform_entity.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/ag_func.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/agtype.h"</cpp:file></cpp:include>

<comment type="block">/* names of typecast functions */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FUNC_AGTYPE_TYPECAST_EDGE</name></cpp:macro> <cpp:value>"agtype_typecast_edge"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FUNC_AGTYPE_TYPECAST_PATH</name></cpp:macro> <cpp:value>"agtype_typecast_path"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FUNC_AGTYPE_TYPECAST_VERTEX</name></cpp:macro> <cpp:value>"agtype_typecast_vertex"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FUNC_AGTYPE_TYPECAST_NUMERIC</name></cpp:macro> <cpp:value>"agtype_typecast_numeric"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FUNC_AGTYPE_TYPECAST_FLOAT</name></cpp:macro> <cpp:value>"agtype_typecast_float"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FUNC_AGTYPE_TYPECAST_INT</name></cpp:macro> <cpp:value>"agtype_typecast_int"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FUNC_AGTYPE_TYPECAST_PG_FLOAT8</name></cpp:macro> <cpp:value>"agtype_to_float8"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FUNC_AGTYPE_TYPECAST_PG_BIGINT</name></cpp:macro> <cpp:value>"agtype_to_int8"</cpp:value></cpp:define>

<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>transform_cypher_expr_recurse</name><parameter_list>(<parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl></parameter>,
                                           <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>transform_A_Const</name><parameter_list>(<parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl></parameter>, <parameter><decl><type><name>A_Const</name> <modifier>*</modifier></type><name>ac</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>transform_ColumnRef</name><parameter_list>(<parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl></parameter>, <parameter><decl><type><name>ColumnRef</name> <modifier>*</modifier></type><name>cref</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>transform_A_Indirection</name><parameter_list>(<parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl></parameter>,
                                     <parameter><decl><type><name>A_Indirection</name> <modifier>*</modifier></type><name>a_ind</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>transform_AEXPR_OP</name><parameter_list>(<parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl></parameter>, <parameter><decl><type><name>A_Expr</name> <modifier>*</modifier></type><name>a</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>transform_BoolExpr</name><parameter_list>(<parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl></parameter>, <parameter><decl><type><name>BoolExpr</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>transform_cypher_bool_const</name><parameter_list>(<parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl></parameter>,
                                         <parameter><decl><type><name>cypher_bool_const</name> <modifier>*</modifier></type><name>bc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>transform_cypher_integer_const</name><parameter_list>(<parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl></parameter>,
                                            <parameter><decl><type><name>cypher_integer_const</name> <modifier>*</modifier></type><name>ic</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>transform_AEXPR_IN</name><parameter_list>(<parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl></parameter>, <parameter><decl><type><name>A_Expr</name> <modifier>*</modifier></type><name>a</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>transform_cypher_param</name><parameter_list>(<parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl></parameter>,
                                    <parameter><decl><type><name>cypher_param</name> <modifier>*</modifier></type><name>cp</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>transform_cypher_map</name><parameter_list>(<parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl></parameter>, <parameter><decl><type><name>cypher_map</name> <modifier>*</modifier></type><name>cm</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>transform_cypher_list</name><parameter_list>(<parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl></parameter>,
                                   <parameter><decl><type><name>cypher_list</name> <modifier>*</modifier></type><name>cl</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>transform_cypher_string_match</name><parameter_list>(<parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl></parameter>,
                                           <parameter><decl><type><name>cypher_string_match</name> <modifier>*</modifier></type><name>csm_node</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>transform_cypher_typecast</name><parameter_list>(<parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl></parameter>,
                                       <parameter><decl><type><name>cypher_typecast</name> <modifier>*</modifier></type><name>ctypecast</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>transform_CaseExpr</name><parameter_list>(<parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl></parameter>,
                                    <parameter><decl><type><name>CaseExpr</name> <modifier>*</modifier></type><name>cexpr</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>transform_CoalesceExpr</name><parameter_list>(<parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl></parameter>,
                                    <parameter><decl><type><name>CoalesceExpr</name> <modifier>*</modifier></type><name>cexpr</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>transform_SubLink</name><parameter_list>(<parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl></parameter>, <parameter><decl><type><name>SubLink</name> <modifier>*</modifier></type><name>sublink</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>transform_FuncCall</name><parameter_list>(<parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl></parameter>, <parameter><decl><type><name>FuncCall</name> <modifier>*</modifier></type><name>fn</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>transform_WholeRowRef</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>,
                                   <parameter><decl><type><name>int</name></type> <name>location</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ArrayExpr</name> <modifier>*</modifier></type><name>make_agtype_array_expr</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>args</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* transform a cypher expression */</comment>
<function><type><name>Node</name> <modifier>*</modifier></type><name>transform_cypher_expr</name><parameter_list>(<parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>,
                            <parameter><decl><type><name>ParseExprKind</name></type> <name>expr_kind</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name> <init>= <expr><operator>(</operator><name>ParseState</name> <operator>*</operator><operator>)</operator><name>cpstate</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ParseExprKind</name></type> <name>old_expr_kind</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

    <comment type="line">// save and restore identity of expression type we're parsing</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>expr_kind</name> <operator>!=</operator> <name>EXPR_KIND_NONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>old_expr_kind</name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_expr_kind</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_expr_kind</name></name> <operator>=</operator> <name>expr_kind</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>transform_cypher_expr_recurse</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_expr_kind</name></name> <operator>=</operator> <name>old_expr_kind</name></expr>;</expr_stmt>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>transform_cypher_expr_recurse</name><parameter_list>(<parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl></parameter>,
                                           <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>expr</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="line">// guard against stack overflow due to overly complex expressions</comment>
    <expr_stmt><expr><call><name>check_stack_depth</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
    <case>case <expr><name>T_A_Const</name></expr>:</case>
        <return>return <expr><call><name>transform_A_Const</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>, <argument><expr><operator>(</operator><name>A_Const</name> <operator>*</operator><operator>)</operator><name>expr</name></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>T_ColumnRef</name></expr>:</case>
        <return>return <expr><call><name>transform_ColumnRef</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>, <argument><expr><operator>(</operator><name>ColumnRef</name> <operator>*</operator><operator>)</operator><name>expr</name></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>T_A_Indirection</name></expr>:</case>
        <return>return <expr><call><name>transform_A_Indirection</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>, <argument><expr><operator>(</operator><name>A_Indirection</name> <operator>*</operator><operator>)</operator><name>expr</name></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>T_A_Expr</name></expr>:</case>
    <block>{<block_content>
        <decl_stmt><decl><type><name>A_Expr</name> <modifier>*</modifier></type><name>a</name> <init>= <expr><operator>(</operator><name>A_Expr</name> <operator>*</operator><operator>)</operator><name>expr</name></expr></init></decl>;</decl_stmt>

        <switch>switch <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>kind</name></name></expr>)</condition>
        <block>{<block_content>
        <case>case <expr><name>AEXPR_OP</name></expr>:</case>
            <return>return <expr><call><name>transform_AEXPR_OP</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</return>
        <case>case <expr><name>AEXPR_IN</name></expr>:</case>
            <return>return <expr><call><name>transform_AEXPR_IN</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</return>
        <default>default:</default>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"unrecognized A_Expr kind: %d"</literal></expr></argument>,
                                            <argument><expr><name><name>a</name><operator>-&gt;</operator><name>kind</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></switch>
    </block_content>}</block>
    <case>case <expr><name>T_BoolExpr</name></expr>:</case>
        <return>return <expr><call><name>transform_BoolExpr</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>, <argument><expr><operator>(</operator><name>BoolExpr</name> <operator>*</operator><operator>)</operator><name>expr</name></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>T_NullTest</name></expr>:</case>
    <block>{<block_content>
        <decl_stmt><decl><type><name>NullTest</name> <modifier>*</modifier></type><name>n</name> <init>= <expr><operator>(</operator><name>NullTest</name> <operator>*</operator><operator>)</operator><name>expr</name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>arg</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator><call><name>transform_cypher_expr_recurse</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>,
                                                       <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name><name>n</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>argisrow</name></name> <operator>=</operator> <call><name>type_is_rowtype</name><argument_list>(<argument><expr><call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name><name>n</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <return>return <expr><name>expr</name></expr>;</return>
    </block_content>}</block>
    <case>case <expr><name>T_CaseExpr</name></expr>:</case>
        <return>return <expr><call><name>transform_CaseExpr</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>, <argument><expr><operator>(</operator><name>CaseExpr</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>T_CaseTestExpr</name></expr>:</case>
        <return>return <expr><name>expr</name></expr>;</return>
    <case>case <expr><name>T_CoalesceExpr</name></expr>:</case>
        <return>return <expr><call><name>transform_CoalesceExpr</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>, <argument><expr><operator>(</operator><name>CoalesceExpr</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>T_ExtensibleNode</name></expr>:</case>
        <if_stmt><if>if <condition>(<expr><call><name>is_ag_node</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>cypher_bool_const</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><call><name>transform_cypher_bool_const</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>,
                                               <argument><expr><operator>(</operator><name>cypher_bool_const</name> <operator>*</operator><operator>)</operator><name>expr</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>is_ag_node</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>cypher_integer_const</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><call><name>transform_cypher_integer_const</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>,
                                                  <argument><expr><operator>(</operator><name>cypher_integer_const</name> <operator>*</operator><operator>)</operator><name>expr</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>is_ag_node</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>cypher_param</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><call><name>transform_cypher_param</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>, <argument><expr><operator>(</operator><name>cypher_param</name> <operator>*</operator><operator>)</operator><name>expr</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>is_ag_node</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>cypher_map</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><call><name>transform_cypher_map</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>, <argument><expr><operator>(</operator><name>cypher_map</name> <operator>*</operator><operator>)</operator><name>expr</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>is_ag_node</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>cypher_list</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><call><name>transform_cypher_list</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>, <argument><expr><operator>(</operator><name>cypher_list</name> <operator>*</operator><operator>)</operator><name>expr</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>is_ag_node</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>cypher_string_match</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><call><name>transform_cypher_string_match</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>,
                                                 <argument><expr><operator>(</operator><name>cypher_string_match</name> <operator>*</operator><operator>)</operator><name>expr</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>is_ag_node</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>cypher_typecast</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><call><name>transform_cypher_typecast</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>,
                                             <argument><expr><operator>(</operator><name>cypher_typecast</name> <operator>*</operator><operator>)</operator><name>expr</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"unrecognized ExtensibleNode: %s"</literal></expr></argument>,
                                 <argument><expr><operator>(</operator><operator>(</operator><name>ExtensibleNode</name> <operator>*</operator><operator>)</operator><name>expr</name><operator>)</operator><operator>-&gt;</operator><name>extnodename</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    <case>case <expr><name>T_FuncCall</name></expr>:</case>
        <return>return <expr><call><name>transform_FuncCall</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>, <argument><expr><operator>(</operator><name>FuncCall</name> <operator>*</operator><operator>)</operator><name>expr</name></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>T_SubLink</name></expr>:</case>
        <return>return <expr><call><name>transform_SubLink</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>, <argument><expr><operator>(</operator><name>SubLink</name> <operator>*</operator><operator>)</operator><name>expr</name></expr></argument>)</argument_list></call></expr>;</return>
        <break>break;</break>
    <default>default:</default>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"unrecognized node type: %d"</literal></expr></argument>,
                                        <argument><expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></switch>
    <return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>transform_A_Const</name><parameter_list>(<parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl></parameter>, <parameter><decl><type><name>A_Const</name> <modifier>*</modifier></type><name>ac</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name> <init>= <expr><operator>(</operator><name>ParseState</name> <operator>*</operator><operator>)</operator><name>cpstate</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ParseCallbackState</name></type> <name>pcbstate</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Value</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><operator>&amp;</operator><name><name>ac</name><operator>-&gt;</operator><name>val</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type> <name>d</name> <init>= <expr><operator>(</operator><name>Datum</name><operator>)</operator><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>is_null</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Const</name> <modifier>*</modifier></type><name>c</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>setup_parser_errposition_callback</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pcbstate</name></expr></argument>, <argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>ac</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
    <case>case <expr><name>T_Integer</name></expr>:</case>
        <expr_stmt><expr><name>d</name> <operator>=</operator> <call><name>integer_to_agtype</name><argument_list>(<argument><expr><operator>(</operator><name>int64</name><operator>)</operator><call><name>intVal</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
    <case>case <expr><name>T_Float</name></expr>:</case>
        <block>{<block_content>
            <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>n</name> <init>= <expr><call><name>strVal</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int64</name></type> <name>i</name></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><call><name>scanint8</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>i</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name>d</name> <operator>=</operator> <call><name>integer_to_agtype</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <decl_stmt><decl><type><name>float8</name></type> <name>f</name> <init>= <expr><call><name>float8in_internal</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"double precision"</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <expr_stmt><expr><name>d</name> <operator>=</operator> <call><name>float_to_agtype</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block>
        <break>break;</break>
    <case>case <expr><name>T_String</name></expr>:</case>
        <expr_stmt><expr><name>d</name> <operator>=</operator> <call><name>string_to_agtype</name><argument_list>(<argument><expr><call><name>strVal</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
    <case>case <expr><name>T_Null</name></expr>:</case>
        <expr_stmt><expr><name>is_null</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
        <break>break;</break>
    <default>default:</default>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"unrecognized node type: %d"</literal></expr></argument>, <argument><expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    </block_content>}</block></switch>
    <expr_stmt><expr><call><name>cancel_parser_errposition_callback</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pcbstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// typtypmod, typcollation, typlen, and typbyval of agtype are hard-coded.</comment>
    <expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>makeConst</name><argument_list>(<argument><expr><name>AGTYPEOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>is_null</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <name><name>ac</name><operator>-&gt;</operator><name>location</name></name></expr>;</expr_stmt>
    <return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name>c</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Private function borrowed from PG's transformWholeRowRef.
 * Construct a whole-row reference to represent the notation "relation.*".
 */</comment>
<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>transform_WholeRowRef</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>,
                                   <parameter><decl><type><name>int</name></type> <name>location</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>vnum</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>sublevels_up</name></decl>;</decl_stmt>

    <comment type="block">/* Find the RTE's rangetable location */</comment>
    <expr_stmt><expr><name>vnum</name> <operator>=</operator> <call><name>RTERangeTablePosn</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sublevels_up</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Build the appropriate referencing node.  Note that if the RTE is a
     * function returning scalar, we create just a plain reference to the
     * function value, not a composite containing a single column.  This is
     * pretty inconsistent at first sight, but it's what we've done
     * historically.  One argument for it is that "rel" and "rel.*" mean the
     * same thing for composite relations, so why not for scalar functions...
     */</comment>
     <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>makeWholeRowVar</name><argument_list>(<argument><expr><name>rte</name></expr></argument>, <argument><expr><name>vnum</name></expr></argument>, <argument><expr><name>sublevels_up</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

     <comment type="block">/* location is not filled in by makeWholeRowVar */</comment>
     <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <name>location</name></expr>;</expr_stmt>

     <comment type="block">/* mark relation as requiring whole-row SELECT access */</comment>
     <expr_stmt><expr><call><name>markVarForSelectPriv</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

     <return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Function to transform a ColumnRef node from the grammar into a Var node
 * Code borrowed from PG's transformColumnRef.
 */</comment>
<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>transform_ColumnRef</name><parameter_list>(<parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl></parameter>, <parameter><decl><type><name>ColumnRef</name> <modifier>*</modifier></type><name>cref</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name> <init>= <expr><operator>(</operator><name>ParseState</name> <operator>*</operator><operator>)</operator><name>cpstate</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>field1</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>field2</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>colname</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>nspname</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>relname</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>levels_up</name></decl>;</decl_stmt>

    <switch>switch <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>cref</name><operator>-&gt;</operator><name>fields</name></name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><literal type="number">1</literal></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>transform_entity</name> <modifier>*</modifier></type><name>te</name></decl>;</decl_stmt>
                <expr_stmt><expr><name>field1</name> <operator>=</operator> <operator>(</operator><name>Node</name><operator>*</operator><operator>)</operator><call><name>linitial</name><argument_list>(<argument><expr><name><name>cref</name><operator>-&gt;</operator><name>fields</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>field1</name></expr></argument>, <argument><expr><name>String</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>colname</name> <operator>=</operator> <call><name>strVal</name><argument_list>(<argument><expr><name>field1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/* Try to identify as an unqualified column */</comment>
                <expr_stmt><expr><name>node</name> <operator>=</operator> <call><name>colNameToVar</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>colname</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name><name>cref</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>node</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
                <block>{<block_content>
                        <break>break;</break>
                </block_content>}</block></if></if_stmt>

                <comment type="block">/*
                 * Try to find the columnRef as a transform_entity and extract
                 * the expr.
                 */</comment>
                <expr_stmt><expr><name>te</name> <operator>=</operator> <call><name>find_variable</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>, <argument><expr><name>colname</name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>te</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>te</name><operator>-&gt;</operator><name>expr</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>node</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name><name>te</name><operator>-&gt;</operator><name>expr</name></name></expr>;</expr_stmt>
                    <break>break;</break>
                </block_content>}</block></if></if_stmt>

                <comment type="block">/*
                 * Not known as a column of any range-table entry.
                 * Try to find the name as a relation.  Note that only
                 * relations already entered into the rangetable will be
                 * recognized.
                 *
                 * This is a hack for backwards compatibility with
                 * PostQUEL-inspired syntax.  The preferred form now is
                 * "rel.*".
                 */</comment>
                <expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>refnameRangeTblEntry</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>colname</name></expr></argument>,
                                           <argument><expr><name><name>cref</name><operator>-&gt;</operator><name>location</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>levels_up</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>rte</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>node</name> <operator>=</operator> <call><name>transform_WholeRowRef</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>, <argument><expr><name><name>cref</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else
                <block>{<block_content>
                    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
                                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not find rte for %s"</literal></expr></argument>, <argument><expr><name>colname</name></expr></argument>)</argument_list></call><operator>,</operator>
                                 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>cref</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></else></if_stmt>

                <if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATA_EXCEPTION</name></expr></argument>)</argument_list></call><operator>,</operator>
                            <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unable to transform whole row for %s"</literal></expr></argument>, <argument><expr><name>colname</name></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>cref</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>

                <break>break;</break>
            </block_content>}</block>
        <case>case <expr><literal type="number">2</literal></expr>:</case>
            <block>{<block_content>
                <decl_stmt><decl><type><name>Oid</name></type> <name>inputTypeId</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>Oid</name></type> <name>targetTypeId</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>

                <expr_stmt><expr><name>field1</name> <operator>=</operator> <operator>(</operator><name>Node</name><operator>*</operator><operator>)</operator><call><name>linitial</name><argument_list>(<argument><expr><name><name>cref</name><operator>-&gt;</operator><name>fields</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>field2</name> <operator>=</operator> <operator>(</operator><name>Node</name><operator>*</operator><operator>)</operator><call><name>lsecond</name><argument_list>(<argument><expr><name><name>cref</name><operator>-&gt;</operator><name>fields</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>field1</name></expr></argument>, <argument><expr><name>String</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>relname</name> <operator>=</operator> <call><name>strVal</name><argument_list>(<argument><expr><name>field1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>field2</name></expr></argument>, <argument><expr><name>String</name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>colname</name> <operator>=</operator> <call><name>strVal</name><argument_list>(<argument><expr><name>field2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>

                <comment type="block">/* locate the referenced RTE */</comment>
                <expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>refnameRangeTblEntry</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>nspname</name></expr></argument>, <argument><expr><name>relname</name></expr></argument>,
                                           <argument><expr><name><name>cref</name><operator>-&gt;</operator><name>location</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>levels_up</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>rte</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not find rte for %s.%s"</literal></expr></argument>, <argument><expr><name>relname</name></expr></argument>,
                                    <argument><expr><name>colname</name></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>cref</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>
                </block_content>}</block></if></if_stmt>

                <comment type="block">/*
                 * TODO: Left in for potential future use.
                 * Is it a whole-row reference?
                 */</comment>
                <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>field2</name></expr></argument>, <argument><expr><name>A_Star</name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>node</name> <operator>=</operator> <call><name>transform_WholeRowRef</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>, <argument><expr><name><name>cref</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>
                </block_content>}</block></if></if_stmt>

                <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>field2</name></expr></argument>, <argument><expr><name>String</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/* try to identify as a column of the RTE */</comment>
                <expr_stmt><expr><name>node</name> <operator>=</operator> <call><name>scanRTEForColumn</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>, <argument><expr><name>colname</name></expr></argument>, <argument><expr><name><name>cref</name><operator>-&gt;</operator><name>location</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
                                        <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not find column %s in rel %s of rte"</literal></expr></argument>,
                                    <argument><expr><name>colname</name></expr></argument>, <argument><expr><name>relname</name></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>cref</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>

                <comment type="block">/* coerce it to AGTYPE if possible */</comment>
                <expr_stmt><expr><name>inputTypeId</name> <operator>=</operator> <call><name>exprType</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>targetTypeId</name> <operator>=</operator> <name>AGTYPEOID</name></expr>;</expr_stmt>

                <if_stmt><if>if <condition>(<expr><call><name>can_coerce_type</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>inputTypeId</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>targetTypeId</name></expr></argument>,
                                    <argument><expr><name>COERCION_EXPLICIT</name></expr></argument>)</argument_list></call></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><name>node</name> <operator>=</operator> <call><name>coerce_type</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>inputTypeId</name></expr></argument>, <argument><expr><name>targetTypeId</name></expr></argument>,
                                       <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>COERCION_EXPLICIT</name></expr></argument>,
                                       <argument><expr><name>COERCE_EXPLICIT_CAST</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>
                <break>break;</break>
            </block_content>}</block>
        <default>default:</default>
            <block>{<block_content>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                        <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"improper qualified name (too many dotted names): %s"</literal></expr></argument>,
                                <argument><expr><call><name>NameListToString</name><argument_list>(<argument><expr><name><name>cref</name><operator>-&gt;</operator><name>fields</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
                         <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>cref</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            </block_content>}</block>
    </block_content>}</block></switch>

    <if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"variable `%s` does not exist"</literal></expr></argument>, <argument><expr><name>colname</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>cref</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>node</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>transform_AEXPR_OP</name><parameter_list>(<parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl></parameter>, <parameter><decl><type><name>A_Expr</name> <modifier>*</modifier></type><name>a</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name> <init>= <expr><operator>(</operator><name>ParseState</name> <operator>*</operator><operator>)</operator><name>cpstate</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>last_srf</name> <init>= <expr><name><name>pstate</name><operator>-&gt;</operator><name>p_last_srf</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>lexpr</name> <init>= <expr><call><name>transform_cypher_expr_recurse</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>lexpr</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>rexpr</name> <init>= <expr><call><name>transform_cypher_expr_recurse</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>rexpr</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><call><name>make_op</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>lexpr</name></expr></argument>, <argument><expr><name>rexpr</name></expr></argument>, <argument><expr><name>last_srf</name></expr></argument>,
                           <argument><expr><name><name>a</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>transform_AEXPR_IN</name><parameter_list>(<parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl></parameter>, <parameter><decl><type><name>A_Expr</name> <modifier>*</modifier></type><name>a</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Oid</name></type> <name>func_in_oid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>FuncExpr</name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>args</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>args</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><call><name>transform_cypher_expr_recurse</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>rexpr</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>args</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><call><name>transform_cypher_expr_recurse</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>lexpr</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* get the agtype_access_slice function */</comment>
    <expr_stmt><expr><name>func_in_oid</name> <operator>=</operator> <call><name>get_ag_func_oid</name><argument_list>(<argument><expr><literal type="string">"agtype_in_operator"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>AGTYPEOID</name></expr></argument>,
                                  <argument><expr><name>AGTYPEOID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>makeFuncExpr</name><argument_list>(<argument><expr><name>func_in_oid</name></expr></argument>, <argument><expr><name>AGTYPEOID</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>,
                          <argument><expr><name>COERCE_EXPLICIT_CALL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <call><name>exprLocation</name><argument_list>(<argument><expr><name><name>a</name><operator>-&gt;</operator><name>lexpr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>transform_BoolExpr</name><parameter_list>(<parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl></parameter>, <parameter><decl><type><name>BoolExpr</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name> <init>= <expr><operator>(</operator><name>ParseState</name> <operator>*</operator><operator>)</operator><name>cpstate</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>args</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>opname</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>la</name></decl>;</decl_stmt>

    <switch>switch <condition>(<expr><name><name>expr</name><operator>-&gt;</operator><name>boolop</name></name></expr>)</condition>
    <block>{<block_content>
    <case>case <expr><name>AND_EXPR</name></expr>:</case>
        <expr_stmt><expr><name>opname</name> <operator>=</operator> <literal type="string">"AND"</literal></expr>;</expr_stmt>
        <break>break;</break>
    <case>case <expr><name>OR_EXPR</name></expr>:</case>
        <expr_stmt><expr><name>opname</name> <operator>=</operator> <literal type="string">"OR"</literal></expr>;</expr_stmt>
        <break>break;</break>
    <case>case <expr><name>NOT_EXPR</name></expr>:</case>
        <expr_stmt><expr><name>opname</name> <operator>=</operator> <literal type="string">"NOT"</literal></expr>;</expr_stmt>
        <break>break;</break>
    <default>default:</default>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"unrecognized boolop: %d"</literal></expr></argument>,
                                        <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>expr</name><operator>-&gt;</operator><name>boolop</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    </block_content>}</block></switch>

    <macro><name>foreach</name> <argument_list>(<argument>la</argument>, <argument>expr-&gt;args</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>arg</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>la</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name>arg</name> <operator>=</operator> <call><name>transform_cypher_expr_recurse</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>arg</name> <operator>=</operator> <call><name>coerce_to_boolean</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>opname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>args</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>

    <return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><call><name>makeBoolExpr</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>boolop</name></name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name><name>expr</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>transform_cypher_bool_const</name><parameter_list>(<parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl></parameter>,
                                         <parameter><decl><type><name>cypher_bool_const</name> <modifier>*</modifier></type><name>bc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name> <init>= <expr><operator>(</operator><name>ParseState</name> <operator>*</operator><operator>)</operator><name>cpstate</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ParseCallbackState</name></type> <name>pcbstate</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type> <name>agt</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Const</name> <modifier>*</modifier></type><name>c</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>setup_parser_errposition_callback</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pcbstate</name></expr></argument>, <argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>bc</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>agt</name> <operator>=</operator> <call><name>boolean_to_agtype</name><argument_list>(<argument><expr><name><name>bc</name><operator>-&gt;</operator><name>boolean</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>cancel_parser_errposition_callback</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pcbstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// typtypmod, typcollation, typlen, and typbyval of agtype are hard-coded.</comment>
    <expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>makeConst</name><argument_list>(<argument><expr><name>AGTYPEOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>agt</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <name><name>bc</name><operator>-&gt;</operator><name>location</name></name></expr>;</expr_stmt>

    <return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name>c</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>transform_cypher_integer_const</name><parameter_list>(<parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl></parameter>,
                                            <parameter><decl><type><name>cypher_integer_const</name> <modifier>*</modifier></type><name>ic</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name> <init>= <expr><operator>(</operator><name>ParseState</name> <operator>*</operator><operator>)</operator><name>cpstate</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ParseCallbackState</name></type> <name>pcbstate</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Datum</name></type> <name>agt</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Const</name> <modifier>*</modifier></type><name>c</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>setup_parser_errposition_callback</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pcbstate</name></expr></argument>, <argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>ic</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>agt</name> <operator>=</operator> <call><name>integer_to_agtype</name><argument_list>(<argument><expr><name><name>ic</name><operator>-&gt;</operator><name>integer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>cancel_parser_errposition_callback</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pcbstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// typtypmod, typcollation, typlen, and typbyval of agtype are hard-coded.</comment>
    <expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>makeConst</name><argument_list>(<argument><expr><name>AGTYPEOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>agt</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <name><name>ic</name><operator>-&gt;</operator><name>location</name></name></expr>;</expr_stmt>

    <return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name>c</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>transform_cypher_param</name><parameter_list>(<parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl></parameter>,
                                    <parameter><decl><type><name>cypher_param</name> <modifier>*</modifier></type><name>cp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name> <init>= <expr><operator>(</operator><name>ParseState</name> <operator>*</operator><operator>)</operator><name>cpstate</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Const</name> <modifier>*</modifier></type><name>const_str</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>FuncExpr</name> <modifier>*</modifier></type><name>func_expr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type> <name>func_access_oid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>args</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>cpstate</name><operator>-&gt;</operator><name>params</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(
            <argument><expr><name>ERROR</name></expr></argument>,
            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_PARAMETER</name></expr></argument>)</argument_list></call><operator>,</operator>
             <call><name>errmsg</name><argument_list>(
                 <argument><expr><literal type="string">"parameters argument is missing from cypher() function call"</literal></expr></argument>)</argument_list></call><operator>,</operator>
             <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>cp</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* get the agtype_access_operator function */</comment>
    <expr_stmt><expr><name>func_access_oid</name> <operator>=</operator> <call><name>get_ag_func_oid</name><argument_list>(<argument><expr><literal type="string">"agtype_access_operator"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>,
                                      <argument><expr><name>AGTYPEARRAYOID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>args</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><call><name>copyObject</name><argument_list>(<argument><expr><name><name>cpstate</name><operator>-&gt;</operator><name>params</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>const_str</name> <operator>=</operator> <call><name>makeConst</name><argument_list>(<argument><expr><name>AGTYPEOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
                          <argument><expr><call><name>string_to_agtype</name><argument_list>(<argument><expr><name><name>cp</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>args</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>const_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>func_expr</name> <operator>=</operator> <call><name>makeFuncExpr</name><argument_list>(<argument><expr><name>func_access_oid</name></expr></argument>, <argument><expr><name>AGTYPEOID</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>,
                             <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>COERCE_EXPLICIT_CALL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>func_expr</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <name><name>cp</name><operator>-&gt;</operator><name>location</name></name></expr>;</expr_stmt>

    <return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name>func_expr</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>transform_cypher_map</name><parameter_list>(<parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl></parameter>, <parameter><decl><type><name>cypher_map</name> <modifier>*</modifier></type><name>cm</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name> <init>= <expr><operator>(</operator><name>ParseState</name> <operator>*</operator><operator>)</operator><name>cpstate</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>newkeyvals</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>le</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>FuncExpr</name> <modifier>*</modifier></type><name>fexpr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type> <name>func_oid</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>cm</name><operator>-&gt;</operator><name>keyvals</name></name></expr></argument>)</argument_list></call> <operator>%</operator> <literal type="number">2</literal> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>le</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name><name>cm</name><operator>-&gt;</operator><name>keyvals</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while <condition>(<expr><name>le</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>key</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>val</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>newval</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ParseCallbackState</name></type> <name>pcbstate</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Const</name> <modifier>*</modifier></type><name>newkey</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>key</name> <operator>=</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>le</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>le</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>le</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>le</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>le</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>le</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>newval</name> <operator>=</operator> <call><name>transform_cypher_expr_recurse</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>setup_parser_errposition_callback</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pcbstate</name></expr></argument>, <argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>cm</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="line">// typtypmod, typcollation, typlen, and typbyval of agtype are</comment>
        <comment type="line">// hard-coded.</comment>
        <expr_stmt><expr><name>newkey</name> <operator>=</operator> <call><name>makeConst</name><argument_list>(<argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
                           <argument><expr><call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><call><name>strVal</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>cancel_parser_errposition_callback</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pcbstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>newkeyvals</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><call><name>lappend</name><argument_list>(<argument><expr><name>newkeyvals</name></expr></argument>, <argument><expr><name>newkey</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>newval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>

    <if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>newkeyvals</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>func_oid</name> <operator>=</operator> <call><name>get_ag_func_oid</name><argument_list>(<argument><expr><literal type="string">"agtype_build_map"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name>func_oid</name> <operator>=</operator> <call><name>get_ag_func_oid</name><argument_list>(<argument><expr><literal type="string">"agtype_build_map"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>ANYOID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><name>fexpr</name> <operator>=</operator> <call><name>makeFuncExpr</name><argument_list>(<argument><expr><name>func_oid</name></expr></argument>, <argument><expr><name>AGTYPEOID</name></expr></argument>, <argument><expr><name>newkeyvals</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>,
                         <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>COERCE_EXPLICIT_CALL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>fexpr</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <name><name>cm</name><operator>-&gt;</operator><name>location</name></name></expr>;</expr_stmt>

    <return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name>fexpr</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>transform_cypher_list</name><parameter_list>(<parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl></parameter>, <parameter><decl><type><name>cypher_list</name> <modifier>*</modifier></type><name>cl</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>newelems</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>le</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>FuncExpr</name> <modifier>*</modifier></type><name>fexpr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type> <name>func_oid</name></decl>;</decl_stmt>

    <macro><name>foreach</name> <argument_list>(<argument>le</argument>, <argument>cl-&gt;elems</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>newv</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>newv</name> <operator>=</operator> <call><name>transform_cypher_expr_recurse</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>, <argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>le</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>newelems</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>newelems</name></expr></argument>, <argument><expr><name>newv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>

    <if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>newelems</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>func_oid</name> <operator>=</operator> <call><name>get_ag_func_oid</name><argument_list>(<argument><expr><literal type="string">"agtype_build_list"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name>func_oid</name> <operator>=</operator> <call><name>get_ag_func_oid</name><argument_list>(<argument><expr><literal type="string">"agtype_build_list"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>ANYOID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><name>fexpr</name> <operator>=</operator> <call><name>makeFuncExpr</name><argument_list>(<argument><expr><name>func_oid</name></expr></argument>, <argument><expr><name>AGTYPEOID</name></expr></argument>, <argument><expr><name>newelems</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>,
                         <argument><expr><name>COERCE_EXPLICIT_CALL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>fexpr</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <name><name>cl</name><operator>-&gt;</operator><name>location</name></name></expr>;</expr_stmt>

    <return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name>fexpr</name></expr>;</return>
</block_content>}</block></function>

<comment type="line">// makes a VARIADIC agtype array</comment>
<function><type><specifier>static</specifier> <name>ArrayExpr</name> <modifier>*</modifier></type><name>make_agtype_array_expr</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>args</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ArrayExpr</name>  <modifier>*</modifier></type><name>newa</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>ArrayExpr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>newa</name><operator>-&gt;</operator><name>elements</name></name> <operator>=</operator> <name>args</name></expr>;</expr_stmt>

    <comment type="block">/* assume all the variadic arguments were coerced to the same type */</comment>
    <expr_stmt><expr><name><name>newa</name><operator>-&gt;</operator><name>element_typeid</name></name> <operator>=</operator> <name>AGTYPEOID</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>newa</name><operator>-&gt;</operator><name>array_typeid</name></name> <operator>=</operator> <name>AGTYPEARRAYOID</name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>newa</name><operator>-&gt;</operator><name>array_typeid</name></name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not find array type for data type %s"</literal></expr></argument>,
                        <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name><name>newa</name><operator>-&gt;</operator><name>element_typeid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* array_collid will be set by parse_collate.c */</comment>
    <expr_stmt><expr><name><name>newa</name><operator>-&gt;</operator><name>multidims</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

    <return>return <expr><name>newa</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>transform_A_Indirection</name><parameter_list>(<parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl></parameter>,
                                     <parameter><decl><type><name>A_Indirection</name> <modifier>*</modifier></type><name>a_ind</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>location</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>ind_arg_expr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>FuncExpr</name> <modifier>*</modifier></type><name>func_expr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type> <name>func_access_oid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type> <name>func_slice_oid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>args</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type> <name>is_access</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* validate that we have an indirection with at least 1 entry */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>a_ind</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>a_ind</name><operator>-&gt;</operator><name>indirection</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* get the agtype_access_operator function */</comment>
    <expr_stmt><expr><name>func_access_oid</name> <operator>=</operator> <call><name>get_ag_func_oid</name><argument_list>(<argument><expr><literal type="string">"agtype_access_operator"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>,
                                      <argument><expr><name>AGTYPEARRAYOID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* get the agtype_access_slice function */</comment>
    <expr_stmt><expr><name>func_slice_oid</name> <operator>=</operator> <call><name>get_ag_func_oid</name><argument_list>(<argument><expr><literal type="string">"agtype_access_slice"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>AGTYPEOID</name></expr></argument>,
                                     <argument><expr><name>AGTYPEOID</name></expr></argument>, <argument><expr><name>AGTYPEOID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* transform indirection argument expression */</comment>
    <expr_stmt><expr><name>ind_arg_expr</name> <operator>=</operator> <call><name>transform_cypher_expr_recurse</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>, <argument><expr><name><name>a_ind</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* get the location of the expression */</comment>
    <expr_stmt><expr><name>location</name> <operator>=</operator> <call><name>exprLocation</name><argument_list>(<argument><expr><name>ind_arg_expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* add the expression as the first entry */</comment>
    <expr_stmt><expr><name>args</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>ind_arg_expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* iterate through the indirections */</comment>
    <macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>a_ind-&gt;indirection</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="block">/* is this a slice? */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>A_Indices</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name>A_Indices</name> <operator>*</operator><operator>)</operator><name>node</name><operator>)</operator><operator>-&gt;</operator><name>is_slice</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>A_Indices</name> <modifier>*</modifier></type><name>indices</name> <init>= <expr><operator>(</operator><name>A_Indices</name> <operator>*</operator><operator>)</operator><name>node</name></expr></init></decl>;</decl_stmt>

            <comment type="block">/* were we working on an access? if so, wrap and close it */</comment>
            <if_stmt><if>if <condition>(<expr><name>is_access</name></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>ArrayExpr</name> <modifier>*</modifier></type><name>newa</name> <init>= <expr><call><name>make_agtype_array_expr</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <expr_stmt><expr><name>func_expr</name> <operator>=</operator> <call><name>makeFuncExpr</name><argument_list>(<argument><expr><name>func_access_oid</name></expr></argument>, <argument><expr><name>AGTYPEOID</name></expr></argument>,
                                         <argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name>newa</name></expr></argument>)</argument_list></call></expr></argument>,
                                         <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>,
                                         <argument><expr><name>COERCE_EXPLICIT_CALL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><name><name>func_expr</name><operator>-&gt;</operator><name>funcvariadic</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>func_expr</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <name>location</name></expr>;</expr_stmt>

                <comment type="block">/*
                 * The result of this function is the input to the next access
                 * or slice operator. So we need to start out with a new arg
                 * list with this function expression.
                 */</comment>
                <expr_stmt><expr><name>args</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>NIL</name></expr></argument>, <argument><expr><name>func_expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/* we are no longer working on an access */</comment>
                <expr_stmt><expr><name>is_access</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

            </block_content>}</block></if></if_stmt>

            <comment type="block">/* add slice bounds to args */</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>indices</name><operator>-&gt;</operator><name>lidx</name></name></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>A_Const</name> <modifier>*</modifier></type><name>n</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>A_Const</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>T_Null</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name>node</name> <operator>=</operator> <call><name>transform_cypher_expr_recurse</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><name>node</name> <operator>=</operator> <call><name>transform_cypher_expr_recurse</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>, <argument><expr><name><name>indices</name><operator>-&gt;</operator><name>lidx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>

            <expr_stmt><expr><name>args</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>indices</name><operator>-&gt;</operator><name>uidx</name></name></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>A_Const</name> <modifier>*</modifier></type><name>n</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>A_Const</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>T_Null</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
                <expr_stmt><expr><name>node</name> <operator>=</operator> <call><name>transform_cypher_expr_recurse</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><name>node</name> <operator>=</operator> <call><name>transform_cypher_expr_recurse</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>, <argument><expr><name><name>indices</name><operator>-&gt;</operator><name>uidx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
            <expr_stmt><expr><name>args</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* wrap and close it */</comment>
            <expr_stmt><expr><name>func_expr</name> <operator>=</operator> <call><name>makeFuncExpr</name><argument_list>(<argument><expr><name>func_slice_oid</name></expr></argument>, <argument><expr><name>AGTYPEOID</name></expr></argument>, <argument><expr><name>args</name></expr></argument>,
                                     <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>,
                                     <argument><expr><name>COERCE_EXPLICIT_CALL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>func_expr</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <name>location</name></expr>;</expr_stmt>

            <comment type="block">/*
             * The result of this function is the input to the next access
             * or slice operator. So we need to start out with a new arg
             * list with this function expression.
             */</comment>
            <expr_stmt><expr><name>args</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>NIL</name></expr></argument>, <argument><expr><name>func_expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <comment type="block">/* is this a string or index?*/</comment>
        <if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>String</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>A_Indices</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* we are working on an access */</comment>
            <expr_stmt><expr><name>is_access</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

            <comment type="block">/* is this an index? */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>A_Indices</name></expr></argument>)</argument_list></call></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>A_Indices</name> <modifier>*</modifier></type><name>indices</name> <init>= <expr><operator>(</operator><name>A_Indices</name> <operator>*</operator><operator>)</operator><name>node</name></expr></init></decl>;</decl_stmt>

                <expr_stmt><expr><name>node</name> <operator>=</operator> <call><name>transform_cypher_expr_recurse</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>, <argument><expr><name><name>indices</name><operator>-&gt;</operator><name>uidx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>args</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if>
            <comment type="block">/* it must be a string */</comment>
            <else>else
            <block>{<block_content>
                <decl_stmt><decl><type><name>Const</name> <modifier>*</modifier></type><name>const_str</name> <init>= <expr><call><name>makeConst</name><argument_list>(<argument><expr><name>AGTYPEOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
                                             <argument><expr><call><name>string_to_agtype</name><argument_list>(<argument><expr><call><name>strVal</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                                             <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><name>args</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>const_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if>
        <comment type="block">/* not an indirection we understand */</comment>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                    <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid indirection node %d"</literal></expr></argument>, <argument><expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block>

    <comment type="block">/* if we were doing an access, we need wrap the args with access func. */</comment>
    <if_stmt><if>if <condition>(<expr><name>is_access</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>ArrayExpr</name> <modifier>*</modifier></type><name>newa</name> <init>= <expr><call><name>make_agtype_array_expr</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name>func_expr</name> <operator>=</operator> <call><name>makeFuncExpr</name><argument_list>(<argument><expr><name>func_access_oid</name></expr></argument>, <argument><expr><name>AGTYPEOID</name></expr></argument>, <argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name>newa</name></expr></argument>)</argument_list></call></expr></argument>,
                                 <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>,
                                 <argument><expr><name>COERCE_EXPLICIT_CALL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>func_expr</name><operator>-&gt;</operator><name>funcvariadic</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>func_expr</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>func_expr</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <name>location</name></expr>;</expr_stmt>

    <return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name>func_expr</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>transform_cypher_string_match</name><parameter_list>(<parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl></parameter>,
                                           <parameter><decl><type><name>cypher_string_match</name> <modifier>*</modifier></type><name>csm_node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>expr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>FuncExpr</name> <modifier>*</modifier></type><name>func_expr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type> <name>func_access_oid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>args</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>func_name</name></decl>;</decl_stmt>

    <switch>switch <condition>(<expr><name><name>csm_node</name><operator>-&gt;</operator><name>operation</name></name></expr>)</condition>
    <block>{<block_content>
    <case>case <expr><name>CSMO_STARTS_WITH</name></expr>:</case>
        <expr_stmt><expr><name>func_name</name> <operator>=</operator> <literal type="string">"agtype_string_match_starts_with"</literal></expr>;</expr_stmt>
        <break>break;</break>
    <case>case <expr><name>CSMO_ENDS_WITH</name></expr>:</case>
        <expr_stmt><expr><name>func_name</name> <operator>=</operator> <literal type="string">"agtype_string_match_ends_with"</literal></expr>;</expr_stmt>
        <break>break;</break>
    <case>case <expr><name>CSMO_CONTAINS</name></expr>:</case>
        <expr_stmt><expr><name>func_name</name> <operator>=</operator> <literal type="string">"agtype_string_match_contains"</literal></expr>;</expr_stmt>
        <break>break;</break>

    <default>default:</default>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"unknown Cypher string match operation"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></switch>

    <expr_stmt><expr><name>func_access_oid</name> <operator>=</operator> <call><name>get_ag_func_oid</name><argument_list>(<argument><expr><name>func_name</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>AGTYPEOID</name></expr></argument>, <argument><expr><name>AGTYPEOID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>expr</name> <operator>=</operator> <call><name>transform_cypher_expr_recurse</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>, <argument><expr><name><name>csm_node</name><operator>-&gt;</operator><name>lhs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>args</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>expr</name> <operator>=</operator> <call><name>transform_cypher_expr_recurse</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>, <argument><expr><name><name>csm_node</name><operator>-&gt;</operator><name>rhs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>args</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>func_expr</name> <operator>=</operator> <call><name>makeFuncExpr</name><argument_list>(<argument><expr><name>func_access_oid</name></expr></argument>, <argument><expr><name>AGTYPEOID</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>,
                             <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>COERCE_EXPLICIT_CALL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>func_expr</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <name><name>csm_node</name><operator>-&gt;</operator><name>location</name></name></expr>;</expr_stmt>

    <return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name>func_expr</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Function to create a typecasting node
 */</comment>
<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>transform_cypher_typecast</name><parameter_list>(<parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl></parameter>,
                                       <parameter><decl><type><name>cypher_typecast</name> <modifier>*</modifier></type><name>ctypecast</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>fname</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>FuncCall</name> <modifier>*</modifier></type><name>fnode</name></decl>;</decl_stmt>

    <comment type="block">/* verify input parameter */</comment>
    <expr_stmt><expr><call><name>Assert</name> <argument_list>(<argument><expr><name>cpstate</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name> <argument_list>(<argument><expr><name>ctypecast</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* create the qualified function name, schema first */</comment>
    <expr_stmt><expr><name>fname</name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><literal type="string">"ag_catalog"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* append the name of the requested typecast function */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name><name>ctypecast</name><operator>-&gt;</operator><name>typecast</name></name></expr></argument>, <argument><expr><literal type="string">"edge"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>fname</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name>FUNC_AGTYPE_TYPECAST_EDGE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name><name>ctypecast</name><operator>-&gt;</operator><name>typecast</name></name></expr></argument>, <argument><expr><literal type="string">"path"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>fname</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name>FUNC_AGTYPE_TYPECAST_PATH</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name><name>ctypecast</name><operator>-&gt;</operator><name>typecast</name></name></expr></argument>, <argument><expr><literal type="string">"vertex"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>fname</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name>FUNC_AGTYPE_TYPECAST_VERTEX</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name><name>ctypecast</name><operator>-&gt;</operator><name>typecast</name></name></expr></argument>, <argument><expr><literal type="string">"numeric"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>fname</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name>FUNC_AGTYPE_TYPECAST_NUMERIC</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name><name>ctypecast</name><operator>-&gt;</operator><name>typecast</name></name></expr></argument>, <argument><expr><literal type="string">"float"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>fname</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name>FUNC_AGTYPE_TYPECAST_FLOAT</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name><name>ctypecast</name><operator>-&gt;</operator><name>typecast</name></name></expr></argument>, <argument><expr><literal type="string">"int"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
             <call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name><name>ctypecast</name><operator>-&gt;</operator><name>typecast</name></name></expr></argument>, <argument><expr><literal type="string">"integer"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>fname</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name>FUNC_AGTYPE_TYPECAST_INT</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name><name>ctypecast</name><operator>-&gt;</operator><name>typecast</name></name></expr></argument>, <argument><expr><literal type="string">"pg_float8"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>fname</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name>FUNC_AGTYPE_TYPECAST_PG_FLOAT8</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name><name>ctypecast</name><operator>-&gt;</operator><name>typecast</name></name></expr></argument>, <argument><expr><literal type="string">"pg_bigint"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>fname</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name>FUNC_AGTYPE_TYPECAST_PG_BIGINT</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <comment type="block">/* if none was found, error out */</comment>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"typecast \'%s\' not supported"</literal></expr></argument>,
                                 <argument><expr><name><name>ctypecast</name><operator>-&gt;</operator><name>typecast</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* make a function call node */</comment>
    <expr_stmt><expr><name>fnode</name> <operator>=</operator> <call><name>makeFuncCall</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name><name>ctypecast</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr></argument>,
                         <argument><expr><name><name>ctypecast</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* return the transformed function */</comment>
    <return>return <expr><call><name>transform_FuncCall</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>, <argument><expr><name>fnode</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Code borrowed from PG's transformFuncCall and updated for AGE
 */</comment>
<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>transform_FuncCall</name><parameter_list>(<parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl></parameter>, <parameter><decl><type><name>FuncCall</name> <modifier>*</modifier></type><name>fn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name> <init>= <expr><operator>&amp;</operator><name><name>cpstate</name><operator>-&gt;</operator><name>pstate</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>last_srf</name> <init>= <expr><name><name>pstate</name><operator>-&gt;</operator><name>p_last_srf</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>targs</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>fname</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>arg</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>retval</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Transform the list of arguments ... */</comment>
    <macro><name>foreach</name><argument_list>(<argument>arg</argument>, <argument>fn-&gt;args</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>farg</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name>farg</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><call><name>lfirst</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>targs</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>targs</name></expr></argument>, <argument><expr><call><name>transform_cypher_expr_recurse</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>, <argument><expr><name>farg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>

    <comment type="block">/* within group should not happen */</comment>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>fn</name><operator>-&gt;</operator><name>agg_within_group</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * If the function name is not qualified, then it is one of ours. We need to
     * construct its name, and qualify it, so that PG can find it.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>fn</name><operator>-&gt;</operator><name>funcname</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* get the name, size, and the ag name allocated */</comment>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><operator>(</operator><operator>(</operator><name>Value</name><operator>*</operator><operator>)</operator><call><name>linitial</name><argument_list>(<argument><expr><name><name>fn</name><operator>-&gt;</operator><name>funcname</name></name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name><name>val</name><operator>.</operator><name>str</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>pnlen</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ag_name</name> <init>= <expr><call><name>palloc</name><argument_list>(<argument><expr><name>pnlen</name> <operator>+</operator> <literal type="number">5</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

        <comment type="block">/* copy in the prefix - all AGE functions are prefixed with age_ */</comment>
        <expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name>ag_name</name></expr></argument>, <argument><expr><literal type="string">"age_"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * All AGE function names are in lower case. So, copy in the name
         * in lower case.
         */</comment>
        <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>pnlen</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>ag_name</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <call><name>tolower</name><argument_list>(<argument><expr><name><name>name</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

        <comment type="block">/* terminate it with 0 */</comment>
        <expr_stmt><expr><name><name>ag_name</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

        <comment type="block">/* qualify the name with our schema name */</comment>
        <expr_stmt><expr><name>fname</name> <operator>=</operator> <call><name>list_make2</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><literal type="string">"ag_catalog"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name>ag_name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Currently 3 functions need the graph name passed in as the first
         * argument - in addition to the other arguments: startNode, endNode,
         * and vle. So, check for those 3 functions here and that the arg list
         * is not empty. Then prepend the graph name if necessary.
         */</comment>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>list_length</name><argument_list>(<argument><expr><name>targs</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator> <operator>&amp;&amp;</operator>
            <operator>(</operator><call><name>strcmp</name><argument_list>(<argument><expr><literal type="string">"startNode"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
              <call><name>strcmp</name><argument_list>(<argument><expr><literal type="string">"endNode"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
              <call><name>strcmp</name><argument_list>(<argument><expr><literal type="string">"vle"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
              <call><name>strcmp</name><argument_list>(<argument><expr><literal type="string">"vertex_stats"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>graph_name</name> <init>= <expr><name><name>cpstate</name><operator>-&gt;</operator><name>graph_name</name></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Datum</name></type> <name>d</name> <init>= <expr><call><name>string_to_agtype</name><argument_list>(<argument><expr><name>graph_name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Const</name> <modifier>*</modifier></type><name>c</name> <init>= <expr><call><name>makeConst</name><argument_list>(<argument><expr><name>AGTYPEOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
                                 <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><name>targs</name> <operator>=</operator> <call><name>lcons</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>targs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

    </block_content>}</block></if>
    <comment type="block">/* If it is not one of our functions, pass the name list through */</comment>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name>fname</name> <operator>=</operator> <name><name>fn</name><operator>-&gt;</operator><name>funcname</name></name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* ... and hand off to ParseFuncOrColumn */</comment>
    <expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>ParseFuncOrColumn</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>fname</name></expr></argument>, <argument><expr><name>targs</name></expr></argument>, <argument><expr><name>last_srf</name></expr></argument>, <argument><expr><name>fn</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
                               <argument><expr><name><name>fn</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* flag that an aggregate was found during a transform */</comment>
    <if_stmt><if>if <condition>(<expr><name>retval</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>retval</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>T_Aggref</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>cpstate</name><operator>-&gt;</operator><name>exprHasAgg</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>retval</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Code borrowed from PG's transformCoalesceExpr and updated for AGE
 */</comment>
<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>transform_CoalesceExpr</name><parameter_list>(<parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl></parameter>, <parameter><decl><type><name>CoalesceExpr</name>
                                    <modifier>*</modifier></type><name>cexpr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name> <init>= <expr><operator>&amp;</operator><name><name>cpstate</name><operator>-&gt;</operator><name>pstate</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CoalesceExpr</name> <modifier>*</modifier></type><name>newcexpr</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>CoalesceExpr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>last_srf</name> <init>= <expr><name><name>pstate</name><operator>-&gt;</operator><name>p_last_srf</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>newargs</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>newcoercedargs</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>args</name></decl>;</decl_stmt>

    <macro><name>foreach</name><argument_list>(<argument>args</argument>, <argument>cexpr-&gt;args</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>e</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><call><name>lfirst</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>newe</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>newe</name> <operator>=</operator> <call><name>transform_cypher_expr_recurse</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>newargs</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>newargs</name></expr></argument>, <argument><expr><name>newe</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>

    <expr_stmt><expr><name><name>newcexpr</name><operator>-&gt;</operator><name>coalescetype</name></name> <operator>=</operator> <call><name>select_common_type</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>newargs</name></expr></argument>, <argument><expr><literal type="string">"COALESCE"</literal></expr></argument>,
                                                <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* coalescecollid will be set by parse_collate.c */</comment>

    <comment type="block">/* Convert arguments if necessary */</comment>
    <macro><name>foreach</name><argument_list>(<argument>args</argument>, <argument>newargs</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>e</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><call><name>lfirst</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>newe</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>newe</name> <operator>=</operator> <call><name>coerce_to_common_type</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name><name>newcexpr</name><operator>-&gt;</operator><name>coalescetype</name></name></expr></argument>,
                                     <argument><expr><literal type="string">"COALESCE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>newcoercedargs</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>newcoercedargs</name></expr></argument>, <argument><expr><name>newe</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>

    <comment type="block">/* if any subexpression contained a SRF, complain */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>pstate</name><operator>-&gt;</operator><name>p_last_srf</name></name> <operator>!=</operator> <name>last_srf</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <comment type="block">/* translator: %s is name of a SQL construct, eg GROUP BY */</comment>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"set-returning functions are not allowed in %s"</literal></expr></argument>,
                        <argument><expr><literal type="string">"COALESCE"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><call><name>exprLocation</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_last_srf</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name><name>newcexpr</name><operator>-&gt;</operator><name>args</name></name> <operator>=</operator> <name>newcoercedargs</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>newcexpr</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <name><name>cexpr</name><operator>-&gt;</operator><name>location</name></name></expr>;</expr_stmt>
    <return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newcexpr</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Code borrowed from PG's transformCaseExpr and updated for AGE
 */</comment>
<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>transform_CaseExpr</name><parameter_list>(<parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl></parameter>,<parameter><decl><type><name>CaseExpr</name>
                                <modifier>*</modifier></type><name>cexpr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name> <init>= <expr><operator>&amp;</operator><name><name>cpstate</name><operator>-&gt;</operator><name>pstate</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CaseExpr</name>   <modifier>*</modifier></type><name>newcexpr</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>CaseExpr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Node</name>       <modifier>*</modifier></type><name>last_srf</name> <init>= <expr><name><name>pstate</name><operator>-&gt;</operator><name>p_last_srf</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Node</name>       <modifier>*</modifier></type><name>arg</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>CaseTestExpr</name> <modifier>*</modifier></type><name>placeholder</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>newargs</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>resultexprs</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Node</name>       <modifier>*</modifier></type><name>defresult</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Oid</name></type>         <name>ptype</name></decl>;</decl_stmt>

    <comment type="block">/* transform the test expression, if any */</comment>
    <expr_stmt><expr><name>arg</name> <operator>=</operator> <call><name>transform_cypher_expr_recurse</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>cexpr</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* generate placeholder for test expression */</comment>
    <if_stmt><if>if <condition>(<expr><name>arg</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>exprType</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>UNKNOWNOID</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>arg</name> <operator>=</operator> <call><name>coerce_to_common_type</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><literal type="string">"CASE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><call><name>assign_expr_collations</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>placeholder</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>CaseTestExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>placeholder</name><operator>-&gt;</operator><name>typeId</name></name> <operator>=</operator> <call><name>exprType</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>placeholder</name><operator>-&gt;</operator><name>typeMod</name></name> <operator>=</operator> <call><name>exprTypmod</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>placeholder</name><operator>-&gt;</operator><name>collation</name></name> <operator>=</operator> <call><name>exprCollation</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <expr_stmt><expr><name>placeholder</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><name><name>newcexpr</name><operator>-&gt;</operator><name>arg</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>arg</name></expr>;</expr_stmt>

    <comment type="block">/* transform the list of arguments */</comment>
    <expr_stmt><expr><name>newargs</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>resultexprs</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
    <macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>cexpr-&gt;args</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>CaseWhen</name>   <modifier>*</modifier></type><name>w</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>CaseWhen</name></expr></argument>, <argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>CaseWhen</name>   <modifier>*</modifier></type><name>neww</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>CaseWhen</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Node</name>       <modifier>*</modifier></type><name>warg</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>warg</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>w</name><operator>-&gt;</operator><name>expr</name></name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>placeholder</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* shorthand form was specified, so expand... */</comment>
            <expr_stmt><expr><name>warg</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeSimpleA_Expr</name><argument_list>(<argument><expr><name>AEXPR_OP</name></expr></argument>, <argument><expr><literal type="string">"="</literal></expr></argument>,
                                             <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>placeholder</name></expr></argument>,
                                             <argument><expr><name>warg</name></expr></argument>,
                                             <argument><expr><name><name>w</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>neww</name><operator>-&gt;</operator><name>expr</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>transform_cypher_expr_recurse</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>, <argument><expr><name>warg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>neww</name><operator>-&gt;</operator><name>expr</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>coerce_to_boolean</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
                                                <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>neww</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>,
                                                <argument><expr><literal type="string">"CASE/WHEN"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>warg</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>w</name><operator>-&gt;</operator><name>result</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>neww</name><operator>-&gt;</operator><name>result</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>transform_cypher_expr_recurse</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>, <argument><expr><name>warg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>neww</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <name><name>w</name><operator>-&gt;</operator><name>location</name></name></expr>;</expr_stmt>

        <expr_stmt><expr><name>newargs</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>newargs</name></expr></argument>, <argument><expr><name>neww</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>resultexprs</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>resultexprs</name></expr></argument>, <argument><expr><name><name>neww</name><operator>-&gt;</operator><name>result</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>

    <expr_stmt><expr><name><name>newcexpr</name><operator>-&gt;</operator><name>args</name></name> <operator>=</operator> <name>newargs</name></expr>;</expr_stmt>

    <comment type="block">/* transform the default clause */</comment>
    <expr_stmt><expr><name>defresult</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>cexpr</name><operator>-&gt;</operator><name>defresult</name></name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>defresult</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>A_Const</name>    <modifier>*</modifier></type><name>n</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>A_Const</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>T_Null</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>defresult</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>n</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>newcexpr</name><operator>-&gt;</operator><name>defresult</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>transform_cypher_expr_recurse</name><argument_list>(<argument><expr><name>cpstate</name></expr></argument>, <argument><expr><name>defresult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>resultexprs</name> <operator>=</operator> <call><name>lcons</name><argument_list>(<argument><expr><name><name>newcexpr</name><operator>-&gt;</operator><name>defresult</name></name></expr></argument>, <argument><expr><name>resultexprs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>ptype</name> <operator>=</operator> <call><name>select_common_type</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>resultexprs</name></expr></argument>, <argument><expr><literal type="string">"CASE"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>ptype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>newcexpr</name><operator>-&gt;</operator><name>casetype</name></name> <operator>=</operator> <name>ptype</name></expr>;</expr_stmt>
    <comment type="block">/* casecollid will be set by parse_collate.c */</comment>

    <comment type="block">/* Convert default result clause, if necessary */</comment>
    <expr_stmt><expr><name><name>newcexpr</name><operator>-&gt;</operator><name>defresult</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator>
        <call><name>coerce_to_common_type</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
                              <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>newcexpr</name><operator>-&gt;</operator><name>defresult</name></name></expr></argument>,
                              <argument><expr><name>ptype</name></expr></argument>,
                              <argument><expr><literal type="string">"CASE/ELSE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Convert when-clause results, if necessary */</comment>
    <macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>newcexpr-&gt;args</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>CaseWhen</name>   <modifier>*</modifier></type><name>w</name> <init>= <expr><operator>(</operator><name>CaseWhen</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name><name>w</name><operator>-&gt;</operator><name>result</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator>
            <call><name>coerce_to_common_type</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
                                  <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>w</name><operator>-&gt;</operator><name>result</name></name></expr></argument>,
                                  <argument><expr><name>ptype</name></expr></argument>,
                                  <argument><expr><literal type="string">"CASE/WHEN"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>

    <comment type="block">/* if any subexpression contained a SRF, complain */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>pstate</name><operator>-&gt;</operator><name>p_last_srf</name></name> <operator>!=</operator> <name>last_srf</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
        <comment type="block">/* translator: %s is name of a SQL construct, eg GROUP BY */</comment>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"set-returning functions are not allowed in %s"</literal></expr></argument>,
                        <argument><expr><literal type="string">"CASE"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"You might be able to move the set-returning function into a LATERAL FROM item."</literal></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
                                    <argument><expr><call><name>exprLocation</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_last_srf</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name><name>newcexpr</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <name><name>cexpr</name><operator>-&gt;</operator><name>location</name></name></expr>;</expr_stmt>

    <return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newcexpr</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* from PG's transformSubLink but reduced and hooked into our parser */</comment>
<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>transform_SubLink</name><parameter_list>(<parameter><decl><type><name>cypher_parsestate</name> <modifier>*</modifier></type><name>cpstate</name></decl></parameter>, <parameter><decl><type><name>SubLink</name> <modifier>*</modifier></type><name>sublink</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><operator>(</operator><name>Node</name><operator>*</operator><operator>)</operator><name>sublink</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Query</name> <modifier>*</modifier></type><name>qtree</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name> <init>= <expr><operator>(</operator><name>ParseState</name><operator>*</operator><operator>)</operator><name>cpstate</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>err</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <comment type="block">/*
     * Check to see if the sublink is in an invalid place within the query. We
     * allow sublinks everywhere in SELECT/INSERT/UPDATE/DELETE, but generally
     * not in utility statements.
     */</comment>
    <switch>switch <condition>(<expr><name><name>pstate</name><operator>-&gt;</operator><name>p_expr_kind</name></name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><name>EXPR_KIND_NONE</name></expr>:</case>
            <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>          <comment type="block">/* can't happen */</comment>
            <break>break;</break>
        <case>case <expr><name>EXPR_KIND_OTHER</name></expr>:</case>
            <comment type="block">/* Accept sublink here; caller must throw error if wanted */</comment>

            <break>break;</break>
        <case>case <expr><name>EXPR_KIND_SELECT_TARGET</name></expr>:</case>
        <case>case <expr><name>EXPR_KIND_FROM_SUBSELECT</name></expr>:</case>
        <case>case <expr><name>EXPR_KIND_WHERE</name></expr>:</case>
            <comment type="block">/* okay */</comment>
            <break>break;</break>
        <default>default:</default>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                            <call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"unsupported SubLink"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                            <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>sublink</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></switch>
    <if_stmt><if>if <condition>(<expr><name>err</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>sublink</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_hasSubLinks</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    <comment type="block">/*
     * OK, let's transform the sub-SELECT.
     */</comment>
    <expr_stmt><expr><name>qtree</name> <operator>=</operator> <call><name>cypher_parse_sub_analyze</name><argument_list>(<argument><expr><name><name>sublink</name><operator>-&gt;</operator><name>subselect</name></name></expr></argument>, <argument><expr><name>cpstate</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
                                     <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Check that we got a SELECT.  Anything else should be impossible given
     * restrictions of the grammar, but check anyway.
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>qtree</name></expr></argument>, <argument><expr><name>Query</name></expr></argument>)</argument_list></call> <operator>||</operator> <name><name>qtree</name><operator>-&gt;</operator><name>commandType</name></name> <operator>!=</operator> <name>CMD_SELECT</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected non-SELECT command in SubLink"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name><name>sublink</name><operator>-&gt;</operator><name>subselect</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name>qtree</name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>sublink</name><operator>-&gt;</operator><name>subLinkType</name></name> <operator>==</operator> <name>EXISTS_SUBLINK</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * EXISTS needs no test expression or combining operator. These fields
         * should be null already, but make sure.
         */</comment>
        <expr_stmt><expr><name><name>sublink</name><operator>-&gt;</operator><name>testexpr</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>sublink</name><operator>-&gt;</operator><name>operName</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unsupported SubLink type"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>
</unit>
