<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/builded_projects/age/src/backend/executor/cypher_delete.c"><comment type="block">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/sysattr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/multixact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/bufmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/tuptable.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/execnodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/extensible.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/plannodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parsetree.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_relation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"rewrite/rewriteHandler.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/tqual.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/ag_label.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/label_commands.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/cypher_executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/cypher_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/cypher_parse_node.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/cypher_nodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/agtype.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/graphid.h"</cpp:file></cpp:include>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>begin_cypher_delete</name><parameter_list>(<parameter><decl><type><name>CustomScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
                                <parameter><decl><type><name>int</name></type> <name>eflags</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type><name>exec_cypher_delete</name><parameter_list>(<parameter><decl><type><name>CustomScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>end_cypher_delete</name><parameter_list>(<parameter><decl><type><name>CustomScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>rescan_cypher_delete</name><parameter_list>(<parameter><decl><type><name>CustomScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>process_delete_list</name><parameter_list>(<parameter><decl><type><name>CustomScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>find_connected_edges</name><parameter_list>(<parameter><decl><type><name>CustomScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>graph_name</name></decl></parameter>,
                                 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>labels</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>var_name</name></decl></parameter>, <parameter><decl><type><name>graphid</name></type> <name>id</name></decl></parameter>,
                                 <parameter><decl><type><name>bool</name></type> <name>detach_delete</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>agtype_value</name> <modifier>*</modifier></type><name>extract_entity</name><parameter_list>(<parameter><decl><type><name>CustomScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
                                    <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>scanTupleSlot</name></decl></parameter>,
                                    <parameter><decl><type><name>int</name></type> <name>entity_position</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>delete_entity</name><parameter_list>(<parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>resultRelInfo</name></decl></parameter>,
                          <parameter><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><specifier>const</specifier> <name>CustomExecMethods</name></type> <name>cypher_delete_exec_methods</name> <init>= <expr><block>{<expr><name>DELETE_SCAN_STATE_NAME</name></expr>,
                                                      <expr><name>begin_cypher_delete</name></expr>,
                                                      <expr><name>exec_cypher_delete</name></expr>,
                                                      <expr><name>end_cypher_delete</name></expr>,
                                                      <expr><name>rescan_cypher_delete</name></expr>,
                                                      <expr><name>NULL</name></expr>,
                                                      <expr><name>NULL</name></expr>,
                                                      <expr><name>NULL</name></expr>,
                                                      <expr><name>NULL</name></expr>,
                                                      <expr><name>NULL</name></expr>,
                                                      <expr><name>NULL</name></expr>,
                                                      <expr><name>NULL</name></expr>,
                                                      <expr><name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Initialization at the beginning of execution. Setup the child node,
 * setup its scan tuple slot and projection infp, expression context,
 * collect metadata about visible edges, and alter the commandid for
 * the transaction.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>begin_cypher_delete</name><parameter_list>(<parameter><decl><type><name>CustomScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
                                <parameter><decl><type><name>int</name></type> <name>eflags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>cypher_delete_custom_scan_state</name> <modifier>*</modifier></type><name>css</name> <init>=
        <expr><operator>(</operator><name>cypher_delete_custom_scan_state</name> <operator>*</operator><operator>)</operator><name>node</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Plan</name> <modifier>*</modifier></type><name>subplan</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>css</name><operator>-&gt;</operator><name>cs</name><operator>-&gt;</operator><name>custom_plans</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// setup child</comment>
    <expr_stmt><expr><name>subplan</name> <operator>=</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>css</name><operator>-&gt;</operator><name>cs</name><operator>-&gt;</operator><name>custom_plans</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>lefttree</name></name> <operator>=</operator> <call><name>ExecInitNode</name><argument_list>(<argument><expr><name>subplan</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// setup expr context</comment>
    <expr_stmt><expr><call><name>ExecAssignExprContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// setup scan tuple slot and projection info</comment>
    <expr_stmt><expr><call><name>ExecInitScanTupleSlot</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>ss</name></name></expr></argument>,
                          <argument><expr><call><name>ExecGetResultType</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>lefttree</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CYPHER_CLAUSE_IS_TERMINAL</name><argument_list>(<argument><expr><name><name>css</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>TupleDesc</name></type> <name>tupdesc</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ss_ScanTupleSlot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name></name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>ExecAssignProjectionInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name></name></expr></argument>, <argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Get all the labels that are visible to this delete clause at this point
     * in the transaction. To be used later when the delete clause finds
     * vertices.
     */</comment>
    <expr_stmt><expr><name><name>css</name><operator>-&gt;</operator><name>edge_labels</name></name> <operator>=</operator> <call><name>get_all_edge_labels_per_graph</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name><name>css</name><operator>-&gt;</operator><name>delete_data</name><operator>-&gt;</operator><name>graph_oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Postgres does not assign the es_output_cid in queries that do
     * not write to disk, ie: SELECT commands. We need the command id
     * for our clauses, and we may need to initialize it. We cannot use
     * GetCurrentCommandId because there may be other cypher clauses
     * that have modified the command id.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>estate</name><operator>-&gt;</operator><name>es_output_cid</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_output_cid</name></name> <operator>=</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_snapshot</name><operator>-&gt;</operator><name>curcid</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>Increment_Estate_CommandId</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Called once per tuple. If this is a terminal DELETE clause
 * process everyone of its child tuple, otherwise process the
 * next tuple.
 */</comment>
<function><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type><name>exec_cypher_delete</name><parameter_list>(<parameter><decl><type><name>CustomScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>cypher_delete_custom_scan_state</name> <modifier>*</modifier></type><name>css</name> <init>=
        <expr><operator>(</operator><name>cypher_delete_custom_scan_state</name> <operator>*</operator><operator>)</operator><name>node</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name> <init>= <expr><name><name>css</name><operator>-&gt;</operator><name>css</name><operator>.</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>state</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name> <init>= <expr><name><name>css</name><operator>-&gt;</operator><name>css</name><operator>.</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>ps_ExprContext</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>CYPHER_CLAUSE_IS_TERMINAL</name><argument_list>(<argument><expr><name><name>css</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * If the DELETE clause was the final cypher clause written
         * then we aren't returning anything from this result node.
         * So the exec_cypher_delete function will only be called once.
         * Therefore we will process all tuples from the subtree at once.
         */</comment>
        <while>while<condition>(<expr><name>true</name></expr>)</condition>
        <block>{<block_content>
            <comment type="line">//Process the subtree first</comment>
            <macro><name>Decrement_Estate_CommandId</name><argument_list>(<argument>estate</argument>)</argument_list></macro>
            <expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>ExecProcNode</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>lefttree</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <macro><name>Increment_Estate_CommandId</name><argument_list>(<argument>estate</argument>)</argument_list></macro>

            <if_stmt><if>if <condition>(<expr><call><name>TupIsNull</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <break>break;</break></block_content></block></if></if_stmt>

            <comment type="line">// setup the scantuple that the process_delete_list needs</comment>
            <expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_scantuple</name></name> <operator>=</operator>
                <name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>lefttree</name><operator>-&gt;</operator><name>ps_ProjInfo</name><operator>-&gt;</operator><name>pi_exprContext</name><operator>-&gt;</operator><name>ecxt_scantuple</name></name></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>process_delete_list</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></while>

        <return>return <expr><name>NULL</name></expr>;</return>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="line">//Process the subtree first</comment>
        <macro><name>Decrement_Estate_CommandId</name><argument_list>(<argument>estate</argument>)</argument_list></macro>
        <expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>ExecProcNode</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>lefttree</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <macro><name>Increment_Estate_CommandId</name><argument_list>(<argument>estate</argument>)</argument_list></macro>

        <if_stmt><if>if <condition>(<expr><call><name>TupIsNull</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

        <comment type="line">// setup the scantuple that the process_delete_list needs</comment>
        <expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_scantuple</name></name> <operator>=</operator>
            <name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>lefttree</name><operator>-&gt;</operator><name>ps_ProjInfo</name><operator>-&gt;</operator><name>pi_exprContext</name><operator>-&gt;</operator><name>ecxt_scantuple</name></name></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>process_delete_list</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_scantuple</name></name> <operator>=</operator>
            <call><name>ExecProject</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>lefttree</name><operator>-&gt;</operator><name>ps_ProjInfo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <return>return <expr><call><name>ExecProject</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>ps_ProjInfo</name></name></expr></argument>)</argument_list></call></expr>;</return>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Called at the end of execution. Tell its child to
 * end its execution.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>end_cypher_delete</name><parameter_list>(<parameter><decl><type><name>CustomScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>ExecEndNode</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>lefttree</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Used for rewinding the scan state and reprocessing the results.
 *
 * XXX: This is not currently supported. We need to find out
 * when this function will be called and determine a process
 * for allowing the Delete clause to run multiple times without
 * redundant edits to the database.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>rescan_cypher_delete</name><parameter_list>(<parameter><decl><type><name>CustomScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
     <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
             <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                      <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cypher DELETE clause cannot be rescaned"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                      <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"its unsafe to use joins in a query with a Cypher DELETE clause"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Create the CustomScanState from the CustomScan and pass
 * necessary metadata.
 */</comment>
<function><type><name>Node</name> <modifier>*</modifier></type><name>create_cypher_delete_plan_state</name><parameter_list>(<parameter><decl><type><name>CustomScan</name> <modifier>*</modifier></type><name>cscan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>cypher_delete_custom_scan_state</name> <modifier>*</modifier></type><name>cypher_css</name> <init>=
        <expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>cypher_delete_custom_scan_state</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>cypher_delete_information</name> <modifier>*</modifier></type><name>delete_data</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>serialized_data</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Const</name> <modifier>*</modifier></type><name>c</name></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>cypher_css</name><operator>-&gt;</operator><name>cs</name></name> <operator>=</operator> <name>cscan</name></expr>;</expr_stmt>

    <comment type="line">// get the serialized data structure from the Const and deserialize it.</comment>
    <expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>cscan</name><operator>-&gt;</operator><name>custom_private</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>serialized_data</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>c</name><operator>-&gt;</operator><name>constvalue</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>delete_data</name> <operator>=</operator> <call><name>stringToNode</name><argument_list>(<argument><expr><name>serialized_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>is_ag_node</name><argument_list>(<argument><expr><name>delete_data</name></expr></argument>, <argument><expr><name>cypher_delete_information</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>cypher_css</name><operator>-&gt;</operator><name>delete_data</name></name> <operator>=</operator> <name>delete_data</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cypher_css</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name><name>delete_data</name><operator>-&gt;</operator><name>flags</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>cypher_css</name><operator>-&gt;</operator><name>css</name><operator>.</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>T_CustomScanState</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cypher_css</name><operator>-&gt;</operator><name>css</name><operator>.</operator><name>methods</name></name> <operator>=</operator> <operator>&amp;</operator><name>cypher_delete_exec_methods</name></expr>;</expr_stmt>

    <return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name>cypher_css</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Extract the vertex or edge to be deleted, perform some type checking to
 * validate datum is an agtype vertex or edge.
 */</comment>
<function><type><specifier>static</specifier> <name>agtype_value</name> <modifier>*</modifier></type><name>extract_entity</name><parameter_list>(<parameter><decl><type><name>CustomScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
                                    <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>scanTupleSlot</name></decl></parameter>,
                                    <parameter><decl><type><name>int</name></type> <name>entity_position</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>original_entity_value</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>agtype</name> <modifier>*</modifier></type><name>original_entity</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TupleDesc</name></type> <name>tupleDescriptor</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>tupleDescriptor</name> <operator>=</operator> <name><name>scanTupleSlot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name></name></expr>;</expr_stmt>

    <comment type="line">// type checking, make sure the entity is an agtype vertex or edge</comment>
    <if_stmt><if>if <condition>(<expr><name><name>tupleDescriptor</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><name>entity_position</name> <operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>atttypid</name> <operator>!=</operator> <name>AGTYPEOID</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"DELETE clause can only delete agtype"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>original_entity</name> <operator>=</operator> <call><name>DATUM_GET_AGTYPE_P</name><argument_list>(<argument><expr><name><name>scanTupleSlot</name><operator>-&gt;</operator><name>tts_values</name><index>[<expr><name>entity_position</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>original_entity_value</name> <operator>=</operator> <call><name>get_ith_agtype_value_from_container</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>original_entity</name><operator>-&gt;</operator><name>root</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>original_entity_value</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>AGTV_VERTEX</name> <operator>&amp;&amp;</operator> <name><name>original_entity_value</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>AGTV_EDGE</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"DELETE clause can only delete vertices and edges"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <return>return <expr><name>original_entity_value</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Try and delete the entity that is describe by the HeapTuple in the table
 * described by the resultRelInfo.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>delete_entity</name><parameter_list>(<parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>resultRelInfo</name></decl></parameter>,
                          <parameter><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>saved_resultRelInfo</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LockTupleMode</name></type> <name>lockmode</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HeapUpdateFailureData</name></type> <name>hufd</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HTSU_Result</name></type> <name>lock_result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HTSU_Result</name></type> <name>delete_result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Buffer</name></type> <name>buffer</name></decl>;</decl_stmt>

    <comment type="line">// Find the physical tuple, this variable is coming from</comment>
    <expr_stmt><expr><name>saved_resultRelInfo</name> <operator>=</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_result_relation_info</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_result_relation_info</name></name> <operator>=</operator> <name>resultRelInfo</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>lockmode</name> <operator>=</operator> <call><name>ExecUpdateLockMode</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>resultRelInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>lock_result</name> <operator>=</operator> <call><name>heap_lock_tuple</name><argument_list>(<argument><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>,
                                  <argument><expr><call><name>GetCurrentCommandId</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>,
                                  <argument><expr><name>LockWaitBlock</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hufd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * It is possible the entity may have already been deleted. If the tuple
     * can be deleted, the lock result will be HeapTupleMayBeUpdated. If the
     * tuple was already deleted by this DELETE clause, the result would be
     * HeapTupleSelfUpdated, if the result was deleted by a previous delete
     * clause, the result will HeapTupleInvisible. Throw an error if any
     * other result was returned.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>lock_result</name> <operator>==</operator> <name>HeapTupleMayBeUpdated</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>delete_result</name> <operator>=</operator> <call><name>heap_delete</name><argument_list>(<argument><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></argument>,
                                    <argument><expr><operator>&amp;</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><call><name>GetCurrentCommandId</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></argument>,
                                    <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_crosscheck_snapshot</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hufd</name></expr></argument>,
                                    <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Unlike locking, the heap_delete either succeeded
         * HeapTupleMayBeUpdate, or it failed and returned any other result.
         */</comment>
        <switch>switch <condition>(<expr><name>delete_result</name></expr>)</condition>
        <block>{<block_content>
                <case>case <expr><name>HeapTupleMayBeUpdated</name></expr>:</case>
                        <break>break;</break>
                <case>case <expr><name>HeapTupleSelfUpdated</name></expr>:</case>
                        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"deleting the same entity more than once cannot happen"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <comment type="block">/* ereport never gets here */</comment>
                        <break>break;</break>
                <case>case <expr><name>HeapTupleUpdated</name></expr>:</case>
                        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_T_R_SERIALIZATION_FAILURE</name></expr></argument>)</argument_list></call><operator>,</operator>
                                         <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not serialize access due to concurrent update"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <comment type="block">/* ereport never gets here */</comment>
                        <break>break;</break>
                <default>default:</default>
                        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Entity failed to be update"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <comment type="block">/* elog never gets here */</comment>
                        <break>break;</break>
        </block_content>}</block></switch>
        <comment type="block">/* increment the command counter */</comment>
        <expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <if type="elseif">else if <condition>(<expr><name>lock_result</name> <operator>!=</operator> <name>HeapTupleInvisible</name> <operator>&amp;&amp;</operator>
             <name>lock_result</name> <operator>!=</operator> <name>HeapTupleSelfUpdated</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Entity could not be locked for updating"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>ReleaseBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_result_relation_info</name></name> <operator>=</operator> <name>saved_resultRelInfo</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * After the delete's subtress has been processed, we then go through the list
 * of variables to be deleted.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>process_delete_list</name><parameter_list>(<parameter><decl><type><name>CustomScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>cypher_delete_custom_scan_state</name> <modifier>*</modifier></type><name>css</name> <init>=
        <expr><operator>(</operator><name>cypher_delete_custom_scan_state</name> <operator>*</operator><operator>)</operator><name>node</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name> <init>= <expr><name><name>css</name><operator>-&gt;</operator><name>css</name><operator>.</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>ps_ExprContext</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>scanTupleSlot</name> <init>= <expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_scantuple</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>state</name></name></expr></init></decl>;</decl_stmt>

    <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>css-&gt;delete_data-&gt;delete_items</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>cypher_delete_item</name> <modifier>*</modifier></type><name>item</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>agtype_value</name> <modifier>*</modifier></type><name>original_entity_value</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>id</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>label</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>scan_keys</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>HeapScanDesc</name></type> <name>scan_desc</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>resultRelInfo</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>HeapTuple</name></type> <name>heap_tuple</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>label_name</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Value</name> <modifier>*</modifier></type><name>pos</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>entity_position</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>item</name> <operator>=</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>pos</name> <operator>=</operator> <name><name>item</name><operator>-&gt;</operator><name>entity_position</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>entity_position</name> <operator>=</operator> <name><name>pos</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>ival</name></name></expr>;</expr_stmt>

        <comment type="block">/* skip if the entity is null */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>scanTupleSlot</name><operator>-&gt;</operator><name>tts_isnull</name><index>[<expr><name>entity_position</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
            <continue>continue;</continue></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>original_entity_value</name> <operator>=</operator> <call><name>extract_entity</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>scanTupleSlot</name></expr></argument>,
                                               <argument><expr><name>entity_position</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>id</name> <operator>=</operator> <call><name>GET_AGTYPE_VALUE_OBJECT_VALUE</name><argument_list>(<argument><expr><name>original_entity_value</name></expr></argument>, <argument><expr><literal type="string">"id"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>label</name> <operator>=</operator> <call><name>GET_AGTYPE_VALUE_OBJECT_VALUE</name><argument_list>(<argument><expr><name>original_entity_value</name></expr></argument>, <argument><expr><literal type="string">"label"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>label_name</name> <operator>=</operator> <call><name>pnstrdup</name><argument_list>(<argument><expr><name><name>label</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>val</name></name></expr></argument>, <argument><expr><name><name>label</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>string</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>resultRelInfo</name> <operator>=</operator> <call><name>create_entity_result_rel_info</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name><name>css</name><operator>-&gt;</operator><name>delete_data</name><operator>-&gt;</operator><name>graph_name</name></name></expr></argument>, <argument><expr><name>label_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Setup the scan key to require the id field on-disc to match the
         * entity's graphid.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>original_entity_value</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AGTV_VERTEX</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scan_keys</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>Anum_ag_label_vertex_table_id</name></expr></argument>,
                        <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_GRAPHIDEQ</name></expr></argument>,
                        <argument><expr><call><name>GRAPHID_GET_DATUM</name><argument_list>(<argument><expr><name><name>id</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>int_value</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <if type="elseif">else if <condition>(<expr><name><name>original_entity_value</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AGTV_EDGE</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scan_keys</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>Anum_ag_label_edge_table_id</name></expr></argument>,
                        <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_GRAPHIDEQ</name></expr></argument>,
                        <argument><expr><call><name>GRAPHID_GET_DATUM</name><argument_list>(<argument><expr><name><name>id</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>int_value</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                    <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"DELETE clause can only delete vertices and edges"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <comment type="block">/*
         * Setup the scan description, with the correct snapshot and scan keys.
         */</comment>
        <expr_stmt><expr><name>scan_desc</name> <operator>=</operator> <call><name>heap_beginscan</name><argument_list>(<argument><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></argument>,
                                   <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_snapshot</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>scan_keys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Retrieve the tuple. */</comment>
        <expr_stmt><expr><name>heap_tuple</name> <operator>=</operator> <call><name>heap_getnext</name><argument_list>(<argument><expr><name>scan_desc</name></expr></argument>, <argument><expr><name>ForwardScanDirection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * If the heap tuple still exists (It wasn't deleted after this variable
         * was created) we can delete it. Otherwise, its safe to skip this
         * delete.
         */</comment>
        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>heap_tuple</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>heap_endscan</name><argument_list>(<argument><expr><name>scan_desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>destroy_entity_result_rel_info</name><argument_list>(<argument><expr><name>resultRelInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <continue>continue;</continue>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/*
         * For vertices, we need to check if the vertex is connected to any
         * edges, * if there are, we need to delete them or throw an error,
         * depending on if the query specified the DETACH option.
         */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>original_entity_value</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>AGTV_VERTEX</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>find_connected_edges</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name><name>css</name><operator>-&gt;</operator><name>delete_data</name><operator>-&gt;</operator><name>graph_name</name></name></expr></argument>,
                                 <argument><expr><name><name>css</name><operator>-&gt;</operator><name>edge_labels</name></name></expr></argument>, <argument><expr><name><name>item</name><operator>-&gt;</operator><name>var_name</name></name></expr></argument>,
                                 <argument><expr><name><name>id</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>int_value</name></name></expr></argument>, <argument><expr><name><name>css</name><operator>-&gt;</operator><name>delete_data</name><operator>-&gt;</operator><name>detach</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* At this point, we are ready to delete the node/vertex. */</comment>
        <expr_stmt><expr><call><name>delete_entity</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>resultRelInfo</name></expr></argument>, <argument><expr><name>heap_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Close the scan and the relation. */</comment>
        <expr_stmt><expr><call><name>heap_endscan</name><argument_list>(<argument><expr><name>scan_desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>destroy_entity_result_rel_info</name><argument_list>(<argument><expr><name>resultRelInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 * Find the edges connected to the given node. If there is any edges either
 * delete them or throw an error, depending on the detach delete option.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>find_connected_edges</name><parameter_list>(<parameter><decl><type><name>CustomScanState</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>graph_name</name></decl></parameter>,
                                 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>labels</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>var_name</name></decl></parameter>, <parameter><decl><type><name>graphid</name></type> <name>id</name></decl></parameter>,
                                 <parameter><decl><type><name>bool</name></type> <name>detach_delete</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>cypher_delete_custom_scan_state</name> <modifier>*</modifier></type><name>css</name> <init>=
        <expr><operator>(</operator><name>cypher_delete_custom_scan_state</name> <operator>*</operator><operator>)</operator><name>node</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name> <init>= <expr><name><name>css</name><operator>-&gt;</operator><name>css</name><operator>.</operator><name>ss</name><operator>.</operator><name>ps</name><operator>.</operator><name>state</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>Increment_Estate_CommandId</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * We need to scan through all the edges to see if this vertex has
     * any edges attached to it.
     *
     * XXX: If we implement an on-disc graph storage system. Such as
     * an adjacency matrix, the performace of this check can be massively
     * improved. However, right now we have to scan every edge to see if
     * one has this vertex as a start or end vertex.
     */</comment>
    <macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>labels</argument>)</argument_list></macro>
    <block>{<block_content>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>label_name</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ResultRelInfo</name> <modifier>*</modifier></type><name>resultRelInfo</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>HeapScanDesc</name></type> <name>scan_desc</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>resultRelInfo</name> <operator>=</operator> <call><name>create_entity_result_rel_info</name><argument_list>(<argument><expr><name>estate</name></expr></argument>,
                                                      <argument><expr><name>graph_name</name></expr></argument>, <argument><expr><name>label_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>scan_desc</name> <operator>=</operator> <call><name>heap_beginscan</name><argument_list>(<argument><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></argument>,
                                   <argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_snapshot</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>ExecInitExtraTupleSlot</name><argument_list>(<argument><expr><name>estate</name></expr></argument>,
                    <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name><name>resultRelInfo</name><operator>-&gt;</operator><name>ri_RelationDesc</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// scan the table</comment>
        <while>while<condition>(<expr><name>true</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>graphid</name></type> <name>startid</name></decl>, <decl><type ref="prev"/><name>endid</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>bool</name></type> <name>isNull</name></decl>;</decl_stmt>

            <expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>heap_getnext</name><argument_list>(<argument><expr><name>scan_desc</name></expr></argument>, <argument><expr><name>ForwardScanDirection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="line">// no more tuples to process, break and scan the next label.</comment>
            <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                <break>break;</break></block_content></block></if></if_stmt>

            <expr_stmt><expr><call><name>ExecStoreTuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>InvalidBuffer</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name>startid</name> <operator>=</operator> <call><name>GRAPHID_GET_DATUM</name><argument_list>(<argument><expr><call><name>slot_getattr</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><name>Anum_ag_label_edge_table_start_id</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>endid</name> <operator>=</operator> <call><name>GRAPHID_GET_DATUM</name><argument_list>(<argument><expr><call><name>slot_getattr</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><name>Anum_ag_label_edge_table_end_id</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name>id</name> <operator>==</operator> <name>startid</name> <operator>||</operator> <name>id</name> <operator>==</operator> <name>endid</name></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/*
                 * We have found an edge that uses the vertex. Either delete the
                 * edge or throw an error. Depending on whether the DETACH
                 * option was specified in the query.
                 */</comment>
                <if_stmt><if>if <condition>(<expr><name>detach_delete</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>delete_entity</name><argument_list>(<argument><expr><name>estate</name></expr></argument>, <argument><expr><name>resultRelInfo</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
                <else>else<block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                            <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
                             <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Cannot delete vertex %s, because it still has edges attached. "</literal>
                                    <literal type="string">"To delete this vertex, you must first delete the attached edges."</literal></expr></argument>,
                                    <argument><expr><name>var_name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></while>

        <expr_stmt><expr><call><name>heap_endscan</name><argument_list>(<argument><expr><name>scan_desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>destroy_entity_result_rel_info</name><argument_list>(<argument><expr><name>resultRelInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block>

    <expr_stmt><expr><call><name>Decrement_Estate_CommandId</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
