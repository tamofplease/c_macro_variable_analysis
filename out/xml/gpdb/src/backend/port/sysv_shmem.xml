<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/backend/port/sysv_shmem.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * sysv_shmem.c
 *	  Implement shared memory using SysV facilities
 *
 * These routines used to be a fairly thin layer on top of SysV shared
 * memory functionality.  With the addition of anonymous-shmem logic,
 * they're a bit fatter now.  We still require a SysV shmem block to
 * exist, though, because mmap'd shmem provides no way to find out how
 * many processes are attached, which we need for interlocking purposes.
 *
 * Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 * IDENTIFICATION
 *	  src/backend/port/sysv_shmem.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;signal.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/file.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/mman.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/stat.h&gt;</cpp:file></cpp:include>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_SYS_IPC_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/ipc.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_SYS_SHM_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/shm.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"portability/mem.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/dsm.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/fd.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/ipc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/pg_shmem.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/guc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/pidfile.h"</cpp:file></cpp:include>


<comment type="block">/*
 * As of PostgreSQL 9.3, we normally allocate only a very small amount of
 * System V shared memory, and only for the purposes of providing an
 * interlock to protect the data directory.  The real shared memory block
 * is allocated using mmap().  This works around the problem that many
 * systems have very low limits on the amount of System V shared memory
 * that can be allocated.  Even a limit of a few megabytes will be enough
 * to run many copies of PostgreSQL without needing to adjust system settings.
 *
 * We assume that no one will attempt to run PostgreSQL 9.3 or later on
 * systems that are ancient enough that anonymous shared memory is not
 * supported, such as pre-2.4 versions of Linux.  If that turns out to be
 * false, we might need to add compile and/or run-time tests here and do this
 * only if the running kernel supports it.
 *
 * However, we must always disable this logic in the EXEC_BACKEND case, and
 * fall back to the old method of allocating the entire segment using System V
 * shared memory, because there's no way to attach an anonymous mmap'd segment
 * to a process after exec().  Since EXEC_BACKEND is intended only for
 * developer use, this shouldn't be a big problem.  Because of this, we do
 * not worry about supporting anonymous shmem in the EXEC_BACKEND cases below.
 *
 * As of PostgreSQL 12, we regained the ability to use a large System V shared
 * memory region even in non-EXEC_BACKEND builds, if shared_memory_type is set
 * to sysv (though this is not the default).
 */</comment>


<typedef>typedef <type><name>key_t</name></type> <name>IpcMemoryKey</name>;</typedef>		<comment type="block">/* shared memory key passed to shmget(2) */</comment>
<typedef>typedef <type><name>int</name></type> <name>IpcMemoryId</name>;</typedef>		<comment type="block">/* shared memory ID returned by shmget(2) */</comment>

<comment type="block">/*
 * How does a given IpcMemoryId relate to this PostgreSQL process?
 *
 * One could recycle unattached segments of different data directories if we
 * distinguished that case from other SHMSTATE_FOREIGN cases.  Doing so would
 * cause us to visit less of the key space, making us less likely to detect a
 * SHMSTATE_ATTACHED key.  It would also complicate the concurrency analysis,
 * in that postmasters of different data directories could simultaneously
 * attempt to recycle a given key.  We'll waste keys longer in some cases, but
 * avoiding the problems of the alternative justifies that loss.
 */</comment>
<typedef>typedef <type><enum>enum
<block>{
	<decl><name>SHMSTATE_ANALYSIS_FAILURE</name></decl>,	<comment type="block">/* unexpected failure to analyze the ID */</comment>
	<decl><name>SHMSTATE_ATTACHED</name></decl>,			<comment type="block">/* pertinent to DataDir, has attached PIDs */</comment>
	<decl><name>SHMSTATE_ENOENT</name></decl>,			<comment type="block">/* no segment of that ID */</comment>
	<decl><name>SHMSTATE_FOREIGN</name></decl>,			<comment type="block">/* exists, but not pertinent to DataDir */</comment>
	<decl><name>SHMSTATE_UNATTACHED</name></decl>			<comment type="block">/* pertinent to DataDir, no attached PIDs */</comment>
}</block></enum></type> <name>IpcMemoryState</name>;</typedef>


<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>UsedShmemSegID</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name>	   <modifier>*</modifier></type><name>UsedShmemSegAddr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>Size</name></type> <name>AnonymousShmemSize</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type><name>AnonymousShmem</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<function_decl><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type><name>InternalIpcMemoryCreate</name><parameter_list>(<parameter><decl><type><name>IpcMemoryKey</name></type> <name>memKey</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>size</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>IpcMemoryDetach</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>status</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>shmaddr</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>IpcMemoryDelete</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>status</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>shmId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>IpcMemoryState</name></type> <name>PGSharedMemoryAttach</name><parameter_list>(<parameter><decl><type><name>IpcMemoryId</name></type> <name>shmId</name></decl></parameter>,
										   <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>attachAt</name></decl></parameter>,
										   <parameter><decl><type><name>PGShmemHeader</name> <modifier>*</modifier><modifier>*</modifier></type><name>addr</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 *	InternalIpcMemoryCreate(memKey, size)
 *
 * Attempt to create a new shared memory segment with the specified key.
 * Will fail (return NULL) if such a segment already exists.  If successful,
 * attach the segment to the current process and return its attached address.
 * On success, callbacks are registered with on_shmem_exit to detach and
 * delete the segment when on_shmem_exit is called.
 *
 * If we fail with a failure code other than collision-with-existing-segment,
 * print out an error and abort.  Other types of errors are not recoverable.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type>
<name>InternalIpcMemoryCreate</name><parameter_list>(<parameter><decl><type><name>IpcMemoryKey</name></type> <name>memKey</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>IpcMemoryId</name></type> <name>shmid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>void</name>	   <modifier>*</modifier></type><name>requestedAddress</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>void</name>	   <modifier>*</modifier></type><name>memAddress</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Normally we just pass requestedAddress = NULL to shmat(), allowing the
	 * system to choose where the segment gets mapped.  But in an EXEC_BACKEND
	 * build, it's possible for whatever is chosen in the postmaster to not
	 * work for backends, due to variations in address space layout.  As a
	 * rather klugy workaround, allow the user to specify the address to use
	 * via setting the environment variable PG_SHMEM_ADDR.  (If this were of
	 * interest for anything except debugging, we'd probably create a cleaner
	 * and better-documented way to set it, such as a GUC.)
	 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>EXEC_BACKEND</name></cpp:ifdef>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>pg_shmem_addr</name> <init>= <expr><call><name>getenv</name><argument_list>(<argument><expr><literal type="string">"PG_SHMEM_ADDR"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>pg_shmem_addr</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>requestedAddress</name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <call><name>strtoul</name><argument_list>(<argument><expr><name>pg_shmem_addr</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><name>shmid</name> <operator>=</operator> <call><name>shmget</name><argument_list>(<argument><expr><name>memKey</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>IPC_CREAT</name> <operator>|</operator> <name>IPC_EXCL</name> <operator>|</operator> <name>IPCProtection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>shmid</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>shmget_errno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * Fail quietly if error indicates a collision with existing segment.
		 * One would expect EEXIST, given that we said IPC_EXCL, but perhaps
		 * we could get a permission violation instead?  Also, EIDRM might
		 * occur if an old seg is slated for destruction but not gone yet.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>shmget_errno</name> <operator>==</operator> <name>EEXIST</name> <operator>||</operator> <name>shmget_errno</name> <operator>==</operator> <name>EACCES</name>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>EIDRM</name></cpp:ifdef>
			<operator>||</operator> <name>shmget_errno</name> <operator>==</operator> <name>EIDRM</name></expr>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Some BSD-derived kernels are known to return EINVAL, not EEXIST, if
		 * there is an existing segment but it's smaller than "size" (this is
		 * a result of poorly-thought-out ordering of error tests). To
		 * distinguish between collision and invalid size in such cases, we
		 * make a second try with size = 0.  These kernels do not test size
		 * against SHMMIN in the preexisting-segment case, so we will not get
		 * EINVAL a second time if there is such a segment.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>shmget_errno</name> <operator>==</operator> <name>EINVAL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>shmid</name> <operator>=</operator> <call><name>shmget</name><argument_list>(<argument><expr><name>memKey</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>IPC_CREAT</name> <operator>|</operator> <name>IPC_EXCL</name> <operator>|</operator> <name>IPCProtection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>shmid</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* As above, fail quietly if we verify a collision */</comment>
				<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>EEXIST</name> <operator>||</operator> <name>errno</name> <operator>==</operator> <name>EACCES</name>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>EIDRM</name></cpp:ifdef>
					<operator>||</operator> <name>errno</name> <operator>==</operator> <name>EIDRM</name></expr>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
					)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
				<comment type="block">/* Otherwise, fall through to report the original error */</comment>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/*
				 * On most platforms we cannot get here because SHMMIN is
				 * greater than zero.  However, if we do succeed in creating a
				 * zero-size segment, free it and then fall through to report
				 * the original error.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>shmctl</name><argument_list>(<argument><expr><name>shmid</name></expr></argument>, <argument><expr><name>IPC_RMID</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"shmctl(%d, %d, 0) failed: %m"</literal></expr></argument>,
						 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>shmid</name></expr></argument>, <argument><expr><name>IPC_RMID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Else complain and abort.
		 *
		 * Note: at this point EINVAL should mean that either SHMMIN or SHMMAX
		 * is violated.  SHMALL violation might be reported as either ENOMEM
		 * (BSDen) or ENOSPC (Linux); the Single Unix Spec fails to say which
		 * it should be.  SHMMNI violation is ENOSPC, per spec.  Just plain
		 * not-enough-RAM is ENOMEM.
		 */</comment>
		<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>shmget_errno</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not create shared memory segment: %m"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Failed system call was shmget(key=%lu, size=%zu, 0%o)."</literal></expr></argument>,
						   <argument><expr><operator>(</operator><name>unsigned</name> <name>long</name><operator>)</operator> <name>memKey</name></expr></argument>, <argument><expr><name>size</name></expr></argument>,
						   <argument><expr><name>IPC_CREAT</name> <operator>|</operator> <name>IPC_EXCL</name> <operator>|</operator> <name>IPCProtection</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <ternary><condition><expr><operator>(</operator><name>shmget_errno</name> <operator>==</operator> <name>EINVAL</name><operator>)</operator></expr> ?</condition><then>
				 <expr><call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"This error usually means that PostgreSQL's request for a shared memory "</literal>
						 <literal type="string">"segment exceeded your kernel's SHMMAX parameter, or possibly that "</literal>
						 <literal type="string">"it is less than "</literal>
						 <literal type="string">"your kernel's SHMMIN parameter.\n"</literal>
						 <literal type="string">"The PostgreSQL documentation contains more information about shared "</literal>
						 <literal type="string">"memory configuration."</literal></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>,</operator>
				 <ternary><condition><expr><operator>(</operator><name>shmget_errno</name> <operator>==</operator> <name>ENOMEM</name><operator>)</operator></expr> ?</condition><then>
				 <expr><call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"This error usually means that PostgreSQL's request for a shared "</literal>
						 <literal type="string">"memory segment exceeded your kernel's SHMALL parameter.  You might need "</literal>
						 <literal type="string">"to reconfigure the kernel with larger SHMALL.\n"</literal>
						 <literal type="string">"The PostgreSQL documentation contains more information about shared "</literal>
						 <literal type="string">"memory configuration."</literal></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>,</operator>
				 <ternary><condition><expr><operator>(</operator><name>shmget_errno</name> <operator>==</operator> <name>ENOSPC</name><operator>)</operator></expr> ?</condition><then>
				 <expr><call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"This error does *not* mean that you have run out of disk space.  "</literal>
						 <literal type="string">"It occurs either if all available shared memory IDs have been taken, "</literal>
						 <literal type="string">"in which case you need to raise the SHMMNI parameter in your kernel, "</literal>
						 <literal type="string">"or because the system's overall limit for shared memory has been "</literal>
						 <literal type="string">"reached.\n"</literal>
						 <literal type="string">"The PostgreSQL documentation contains more information about shared "</literal>
						 <literal type="string">"memory configuration."</literal></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Register on-exit routine to delete the new segment */</comment>
	<expr_stmt><expr><call><name>on_shmem_exit</name><argument_list>(<argument><expr><name>IpcMemoryDelete</name></expr></argument>, <argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>shmid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* OK, should be able to attach to the segment */</comment>
	<expr_stmt><expr><name>memAddress</name> <operator>=</operator> <call><name>shmat</name><argument_list>(<argument><expr><name>shmid</name></expr></argument>, <argument><expr><name>requestedAddress</name></expr></argument>, <argument><expr><name>PG_SHMAT_FLAGS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>memAddress</name> <operator>==</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"shmat(id=%d, addr=%p, flags=0x%x) failed: %m"</literal></expr></argument>,
			 <argument><expr><name>shmid</name></expr></argument>, <argument><expr><name>requestedAddress</name></expr></argument>, <argument><expr><name>PG_SHMAT_FLAGS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Register on-exit routine to detach new segment before deleting */</comment>
	<expr_stmt><expr><call><name>on_shmem_exit</name><argument_list>(<argument><expr><name>IpcMemoryDetach</name></expr></argument>, <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>memAddress</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Store shmem key and ID in data directory lockfile.  Format to try to
	 * keep it the same length always (trailing junk in the lockfile won't
	 * hurt, but might confuse humans).
	 */</comment>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>line</name><index>[<expr><literal type="number">64</literal></expr>]</index></name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>line</name></expr></argument>, <argument><expr><literal type="string">"%9lu %9lu"</literal></expr></argument>,
				<argument><expr><operator>(</operator><name>unsigned</name> <name>long</name><operator>)</operator> <name>memKey</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>long</name><operator>)</operator> <name>shmid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>AddToDataDirLockFile</name><argument_list>(<argument><expr><name>LOCK_FILE_LINE_SHMEM_KEY</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>memAddress</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/****************************************************************************/</comment>
<comment type="block">/*	IpcMemoryDetach(status, shmaddr)	removes a shared memory segment		*/</comment>
<comment type="block">/*										from process' address space			*/</comment>
<comment type="block">/*	(called as an on_shmem_exit callback, hence funny argument list)		*/</comment>
<comment type="block" format="doxygen">/****************************************************************************/</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>IpcMemoryDetach</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>status</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>shmaddr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Detach System V shared memory block. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>shmdt</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>shmaddr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"shmdt(%p) failed: %m"</literal></expr></argument>, <argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>shmaddr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/****************************************************************************/</comment>
<comment type="block">/*	IpcMemoryDelete(status, shmId)		deletes a shared memory segment		*/</comment>
<comment type="block">/*	(called as an on_shmem_exit callback, hence funny argument list)		*/</comment>
<comment type="block" format="doxygen">/****************************************************************************/</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>IpcMemoryDelete</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>status</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>shmId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>shmctl</name><argument_list>(<argument><expr><call><name>DatumGetInt32</name><argument_list>(<argument><expr><name>shmId</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>IPC_RMID</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"shmctl(%d, %d, 0) failed: %m"</literal></expr></argument>,
			 <argument><expr><call><name>DatumGetInt32</name><argument_list>(<argument><expr><name>shmId</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>IPC_RMID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * PGSharedMemoryIsInUse
 *
 * Is a previously-existing shmem segment still existing and in use?
 *
 * The point of this exercise is to detect the case where a prior postmaster
 * crashed, but it left child backends that are still running.  Therefore
 * we only care about shmem segments that are associated with the intended
 * DataDir.  This is an important consideration since accidental matches of
 * shmem segment IDs are reasonably common.
 */</comment>
<function><type><name>bool</name></type>
<name>PGSharedMemoryIsInUse</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>long</name></type> <name>id1</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>long</name></type> <name>id2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGShmemHeader</name> <modifier>*</modifier></type><name>memAddress</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>IpcMemoryState</name></type> <name>state</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>state</name> <operator>=</operator> <call><name>PGSharedMemoryAttach</name><argument_list>(<argument><expr><operator>(</operator><name>IpcMemoryId</name><operator>)</operator> <name>id2</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>memAddress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>memAddress</name> <operator>&amp;&amp;</operator> <call><name>shmdt</name><argument_list>(<argument><expr><name>memAddress</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"shmdt(%p) failed: %m"</literal></expr></argument>, <argument><expr><name>memAddress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<switch>switch <condition>(<expr><name>state</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>SHMSTATE_ENOENT</name></expr>:</case>
		<case>case <expr><name>SHMSTATE_FOREIGN</name></expr>:</case>
		<case>case <expr><name>SHMSTATE_UNATTACHED</name></expr>:</case>
			<return>return <expr><name>false</name></expr>;</return>
		<case>case <expr><name>SHMSTATE_ANALYSIS_FAILURE</name></expr>:</case>
		<case>case <expr><name>SHMSTATE_ATTACHED</name></expr>:</case>
			<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></switch>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Test for a segment with id shmId; see comment at IpcMemoryState.
 *
 * If the segment exists, we'll attempt to attach to it, using attachAt
 * if that's not NULL (but it's best to pass NULL if possible).
 *
 * *addr is set to the segment memory address if we attached to it, else NULL.
 */</comment>
<function><type><specifier>static</specifier> <name>IpcMemoryState</name></type>
<name>PGSharedMemoryAttach</name><parameter_list>(<parameter><decl><type><name>IpcMemoryId</name></type> <name>shmId</name></decl></parameter>,
					 <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>attachAt</name></decl></parameter>,
					 <parameter><decl><type><name>PGShmemHeader</name> <modifier>*</modifier><modifier>*</modifier></type><name>addr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>shmid_ds</name></name></type> <name>shmStat</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>statbuf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGShmemHeader</name> <modifier>*</modifier></type><name>hdr</name></decl>;</decl_stmt>

	<expr_stmt><expr><operator>*</operator><name>addr</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * First, try to stat the shm segment ID, to see if it exists at all.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>shmctl</name><argument_list>(<argument><expr><name>shmId</name></expr></argument>, <argument><expr><name>IPC_STAT</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>shmStat</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * EINVAL actually has multiple possible causes documented in the
		 * shmctl man page, but we assume it must mean the segment no longer
		 * exists.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>EINVAL</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>SHMSTATE_ENOENT</name></expr>;</return></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * EACCES implies we have no read permission, which means it is not a
		 * Postgres shmem segment (or at least, not one that is relevant to
		 * our data directory).
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>EACCES</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>SHMSTATE_FOREIGN</name></expr>;</return></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Some Linux kernel versions (in fact, all of them as of July 2007)
		 * sometimes return EIDRM when EINVAL is correct.  The Linux kernel
		 * actually does not have any internal state that would justify
		 * returning EIDRM, so we can get away with assuming that EIDRM is
		 * equivalent to EINVAL on that platform.
		 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_LINUX_EIDRM_BUG</name></cpp:ifdef>
		<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>EIDRM</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>SHMSTATE_ENOENT</name></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

		<comment type="block">/*
		 * Otherwise, we had better assume that the segment is in use.  The
		 * only likely case is (non-Linux, assumed spec-compliant) EIDRM,
		 * which implies that the segment has been IPC_RMID'd but there are
		 * still processes attached to it.
		 */</comment>
		<return>return <expr><name>SHMSTATE_ANALYSIS_FAILURE</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Try to attach to the segment and see if it matches our data directory.
	 * This avoids key-conflict problems on machines that are running several
	 * postmasters under the same userid and port number.  (That would not
	 * ordinarily happen in production, but it can happen during parallel
	 * testing.  Since our test setups don't open any TCP ports on Unix, such
	 * cases don't conflict otherwise.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>stat</name><argument_list>(<argument><expr><name>DataDir</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>statbuf</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>SHMSTATE_ANALYSIS_FAILURE</name></expr>;</return></block_content></block></if></if_stmt>	<comment type="block">/* can't stat; be conservative */</comment>

	<expr_stmt><expr><name>hdr</name> <operator>=</operator> <operator>(</operator><name>PGShmemHeader</name> <operator>*</operator><operator>)</operator> <call><name>shmat</name><argument_list>(<argument><expr><name>shmId</name></expr></argument>, <argument><expr><name>attachAt</name></expr></argument>, <argument><expr><name>PG_SHMAT_FLAGS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>hdr</name> <operator>==</operator> <operator>(</operator><name>PGShmemHeader</name> <operator>*</operator><operator>)</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Attachment failed.  The cases we're interested in are the same as
		 * for the shmctl() call above.  In particular, note that the owning
		 * postmaster could have terminated and removed the segment between
		 * shmctl() and shmat().
		 *
		 * If attachAt isn't NULL, it's possible that EINVAL reflects a
		 * problem with that address not a vanished segment, so it's best to
		 * pass NULL when probing for conflicting segments.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>EINVAL</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>SHMSTATE_ENOENT</name></expr>;</return></block_content></block></if></if_stmt> <comment type="block">/* segment disappeared */</comment>
		<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>EACCES</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>SHMSTATE_FOREIGN</name></expr>;</return></block_content></block></if></if_stmt>	<comment type="block">/* must be non-Postgres */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_LINUX_EIDRM_BUG</name></cpp:ifdef>
		<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>EIDRM</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>SHMSTATE_ENOENT</name></expr>;</return></block_content></block></if></if_stmt> <comment type="block">/* segment disappeared */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<comment type="block">/* Otherwise, be conservative. */</comment>
		<return>return <expr><name>SHMSTATE_ANALYSIS_FAILURE</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><operator>*</operator><name>addr</name> <operator>=</operator> <name>hdr</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>hdr</name><operator>-&gt;</operator><name>magic</name></name> <operator>!=</operator> <name>PGShmemMagic</name> <operator>||</operator>
		<name><name>hdr</name><operator>-&gt;</operator><name>device</name></name> <operator>!=</operator> <name><name>statbuf</name><operator>.</operator><name>st_dev</name></name> <operator>||</operator>
		<name><name>hdr</name><operator>-&gt;</operator><name>inode</name></name> <operator>!=</operator> <name><name>statbuf</name><operator>.</operator><name>st_ino</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * It's either not a Postgres segment, or not one for my data
		 * directory.
		 */</comment>
		<return>return <expr><name>SHMSTATE_FOREIGN</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * It does match our data directory, so now test whether any processes are
	 * still attached to it.  (We are, now, but the shm_nattch result is from
	 * before we attached to it.)
	 */</comment>
	<return>return <expr><ternary><condition><expr><name><name>shmStat</name><operator>.</operator><name>shm_nattch</name></name> <operator>==</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name>SHMSTATE_UNATTACHED</name></expr> </then><else>: <expr><name>SHMSTATE_ATTACHED</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MAP_HUGETLB</name></cpp:ifdef>

<comment type="block">/*
 * Identify the huge page size to use.
 *
 * Some Linux kernel versions have a bug causing mmap() to fail on requests
 * that are not a multiple of the hugepage size.  Versions without that bug
 * instead silently round the request up to the next hugepage multiple ---
 * and then munmap() fails when we give it a size different from that.
 * So we have to round our request up to a multiple of the actual hugepage
 * size to avoid trouble.
 *
 * Doing the round-up ourselves also lets us make use of the extra memory,
 * rather than just wasting it.  Currently, we just increase the available
 * space recorded in the shmem header, which will make the extra usable for
 * purposes such as additional locktable entries.  Someday, for very large
 * hugepage sizes, we might want to think about more invasive strategies,
 * such as increasing shared_buffers to absorb the extra space.
 *
 * Returns the (real or assumed) page size into *hugepagesize,
 * and the hugepage-related mmap flags to use into *mmap_flags.
 *
 * Currently *mmap_flags is always just MAP_HUGETLB.  Someday, on systems
 * that support it, we might OR in additional bits to specify a particular
 * non-default huge page size.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>GetHugePageSize</name><parameter_list>(<parameter><decl><type><name>Size</name> <modifier>*</modifier></type><name>hugepagesize</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>mmap_flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * If we fail to find out the system's default huge page size, assume it
	 * is 2MB.  This will work fine when the actual size is less.  If it's
	 * more, we might get mmap() or munmap() failures due to unaligned
	 * requests; but at this writing, there are no reports of any non-Linux
	 * systems being picky about that.
	 */</comment>
	<expr_stmt><expr><operator>*</operator><name>hugepagesize</name> <operator>=</operator> <literal type="number">2</literal> <operator>*</operator> <literal type="number">1024</literal> <operator>*</operator> <literal type="number">1024</literal></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>mmap_flags</name> <operator>=</operator> <name>MAP_HUGETLB</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * System-dependent code to find out the default huge page size.
	 *
	 * On Linux, read /proc/meminfo looking for a line like "Hugepagesize:
	 * nnnn kB".  Ignore any failures, falling back to the preset default.
	 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__linux__</name></cpp:ifdef>
	<block>{<block_content>
		<decl_stmt><decl><type><name>FILE</name>	   <modifier>*</modifier></type><name>fp</name> <init>= <expr><call><name>AllocateFile</name><argument_list>(<argument><expr><literal type="string">"/proc/meminfo"</literal></expr></argument>, <argument><expr><literal type="string">"r"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>buf</name><index>[<expr><literal type="number">128</literal></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>sz</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name></type>		<name>ch</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>fp</name></expr>)</condition>
		<block>{<block_content>
			<while>while <condition>(<expr><call><name>fgets</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><call><name>sscanf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"Hugepagesize: %u %c"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>sz</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ch</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">2</literal></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name>ch</name> <operator>==</operator> <literal type="char">'k'</literal></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><operator>*</operator><name>hugepagesize</name> <operator>=</operator> <name>sz</name> <operator>*</operator> <operator>(</operator><name>Size</name><operator>)</operator> <literal type="number">1024</literal></expr>;</expr_stmt>
						<break>break;</break>
					</block_content>}</block></if></if_stmt>
					<comment type="block">/* We could accept other units besides kB, if needed */</comment>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></while>
			<expr_stmt><expr><call><name>FreeFile</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* __linux__ */</comment>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* MAP_HUGETLB */</comment>

<comment type="block">/*
 * Creates an anonymous mmap()ed shared memory segment.
 *
 * Pass the requested size in *size.  This function will modify *size to the
 * actual size of the allocation, if it ends up allocating a segment that is
 * larger than requested.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type>
<name>CreateAnonymousSegment</name><parameter_list>(<parameter><decl><type><name>Size</name> <modifier>*</modifier></type><name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Size</name></type>		<name>allocsize</name> <init>= <expr><operator>*</operator><name>size</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>void</name>	   <modifier>*</modifier></type><name>ptr</name> <init>= <expr><name>MAP_FAILED</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>mmap_errno</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>MAP_HUGETLB</name></cpp:ifndef>
	<comment type="block">/* PGSharedMemoryCreate should have dealt with this case */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>huge_pages</name> <operator>!=</operator> <name>HUGE_PAGES_ON</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<if_stmt><if>if <condition>(<expr><name>huge_pages</name> <operator>==</operator> <name>HUGE_PAGES_ON</name> <operator>||</operator> <name>huge_pages</name> <operator>==</operator> <name>HUGE_PAGES_TRY</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Round up the request size to a suitable large value.
		 */</comment>
		<decl_stmt><decl><type><name>Size</name></type>		<name>hugepagesize</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>mmap_flags</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>GetHugePageSize</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hugepagesize</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>mmap_flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>allocsize</name> <operator>%</operator> <name>hugepagesize</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>allocsize</name> <operator>+=</operator> <name>hugepagesize</name> <operator>-</operator> <operator>(</operator><name>allocsize</name> <operator>%</operator> <name>hugepagesize</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name>mmap</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>allocsize</name></expr></argument>, <argument><expr><name>PROT_READ</name> <operator>|</operator> <name>PROT_WRITE</name></expr></argument>,
				   <argument><expr><name>PG_MMAP_FLAGS</name> <operator>|</operator> <name>mmap_flags</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>mmap_errno</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>huge_pages</name> <operator>==</operator> <name>HUGE_PAGES_TRY</name> <operator>&amp;&amp;</operator> <name>ptr</name> <operator>==</operator> <name>MAP_FAILED</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"mmap(%zu) with MAP_HUGETLB failed, huge pages disabled: %m"</literal></expr></argument>,
				 <argument><expr><name>allocsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>==</operator> <name>MAP_FAILED</name> <operator>&amp;&amp;</operator> <name>huge_pages</name> <operator>!=</operator> <name>HUGE_PAGES_ON</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Use the original size, not the rounded-up value, when falling back
		 * to non-huge pages.
		 */</comment>
		<expr_stmt><expr><name>allocsize</name> <operator>=</operator> <operator>*</operator><name>size</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name>mmap</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>allocsize</name></expr></argument>, <argument><expr><name>PROT_READ</name> <operator>|</operator> <name>PROT_WRITE</name></expr></argument>,
				   <argument><expr><name>PG_MMAP_FLAGS</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>mmap_errno</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>==</operator> <name>MAP_FAILED</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>mmap_errno</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not map anonymous shared memory: %m"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <ternary><condition><expr><operator>(</operator><name>mmap_errno</name> <operator>==</operator> <name>ENOMEM</name><operator>)</operator></expr> ?</condition><then>
				 <expr><call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"This error usually means that PostgreSQL's request "</literal>
						 <literal type="string">"for a shared memory segment exceeded available memory, "</literal>
						 <literal type="string">"swap space, or huge pages. To reduce the request size "</literal>
						 <literal type="string">"(currently %zu bytes), reduce PostgreSQL's shared "</literal>
						 <literal type="string">"memory usage, perhaps by reducing shared_buffers or "</literal>
						 <literal type="string">"max_connections."</literal></expr></argument>,
						 <argument><expr><operator>*</operator><name>size</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><operator>*</operator><name>size</name> <operator>=</operator> <name>allocsize</name></expr>;</expr_stmt>
	<return>return <expr><name>ptr</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * AnonymousShmemDetach --- detach from an anonymous mmap'd block
 * (called as an on_shmem_exit callback, hence funny argument list)
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>AnonymousShmemDetach</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>status</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Release anonymous shared memory block, if any. */</comment>
	<if_stmt><if>if <condition>(<expr><name>AnonymousShmem</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>munmap</name><argument_list>(<argument><expr><name>AnonymousShmem</name></expr></argument>, <argument><expr><name>AnonymousShmemSize</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"munmap(%p, %zu) failed: %m"</literal></expr></argument>,
				 <argument><expr><name>AnonymousShmem</name></expr></argument>, <argument><expr><name>AnonymousShmemSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>AnonymousShmem</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * PGSharedMemoryCreate
 *
 * Create a shared memory segment of the given size and initialize its
 * standard header.  Also, register an on_shmem_exit callback to release
 * the storage.
 *
 * Dead Postgres segments pertinent to this DataDir are recycled if found, but
 * we do not fail upon collision with foreign shmem segments.  The idea here
 * is to detect and re-use keys that may have been assigned by a crashed
 * postmaster or backend.
 *
 * The port number is passed for possible use as a key (for SysV, we use
 * it to generate the starting shmem key).
 */</comment>
<function><type><name>PGShmemHeader</name> <modifier>*</modifier></type>
<name>PGSharedMemoryCreate</name><parameter_list>(<parameter><decl><type><name>Size</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>port</name></decl></parameter>,
					 <parameter><decl><type><name>PGShmemHeader</name> <modifier>*</modifier><modifier>*</modifier></type><name>shim</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>IpcMemoryKey</name></type> <name>NextShmemSegID</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>void</name>	   <modifier>*</modifier></type><name>memAddress</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGShmemHeader</name> <modifier>*</modifier></type><name>hdr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>statbuf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>sysvsize</name></decl>;</decl_stmt>

	<comment type="block">/* Complain if hugepages demanded but we can't possibly support them */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>MAP_HUGETLB</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<if_stmt><if>if <condition>(<expr><name>huge_pages</name> <operator>==</operator> <name>HUGE_PAGES_ON</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"huge pages not supported on this platform"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/* Room for a header? */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>size</name> <operator>&gt;</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PGShmemHeader</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>shared_memory_type</name> <operator>==</operator> <name>SHMEM_TYPE_MMAP</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>AnonymousShmem</name> <operator>=</operator> <call><name>CreateAnonymousSegment</name><argument_list>(<argument><expr><operator>&amp;</operator><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>AnonymousShmemSize</name> <operator>=</operator> <name>size</name></expr>;</expr_stmt>

		<comment type="block">/* Register on-exit routine to unmap the anonymous segment */</comment>
		<expr_stmt><expr><call><name>on_shmem_exit</name><argument_list>(<argument><expr><name>AnonymousShmemDetach</name></expr></argument>, <argument><expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Now we need only allocate a minimal-sized SysV shmem block. */</comment>
		<expr_stmt><expr><name>sysvsize</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PGShmemHeader</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>sysvsize</name> <operator>=</operator> <name>size</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * Loop till we find a free IPC key.  Trust CreateDataDirLockFile() to
	 * ensure no more than one postmaster per data directory can enter this
	 * loop simultaneously.  (CreateDataDirLockFile() does not ensure that,
	 * but prefer fixing it over coping here.)
	 */</comment>
	<expr_stmt><expr><name>NextShmemSegID</name> <operator>=</operator> <literal type="number">1</literal> <operator>+</operator> <name>port</name> <operator>*</operator> <literal type="number">1000</literal></expr>;</expr_stmt>

	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>IpcMemoryId</name></type> <name>shmid</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PGShmemHeader</name> <modifier>*</modifier></type><name>oldhdr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>IpcMemoryState</name></type> <name>state</name></decl>;</decl_stmt>

		<comment type="block">/* Try to create new segment */</comment>
		<expr_stmt><expr><name>memAddress</name> <operator>=</operator> <call><name>InternalIpcMemoryCreate</name><argument_list>(<argument><expr><name>NextShmemSegID</name></expr></argument>, <argument><expr><name>sysvsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>memAddress</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>				<comment type="block">/* successful create and attach */</comment>

		<comment type="block">/* Check shared memory and possibly remove and recreate */</comment>

		<comment type="block">/*
		 * shmget() failure is typically EACCES, hence SHMSTATE_FOREIGN.
		 * ENOENT, a narrow possibility, implies SHMSTATE_ENOENT, but one can
		 * safely treat SHMSTATE_ENOENT like SHMSTATE_FOREIGN.
		 */</comment>
		<expr_stmt><expr><name>shmid</name> <operator>=</operator> <call><name>shmget</name><argument_list>(<argument><expr><name>NextShmemSegID</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PGShmemHeader</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>shmid</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>oldhdr</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>state</name> <operator>=</operator> <name>SHMSTATE_FOREIGN</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>state</name> <operator>=</operator> <call><name>PGSharedMemoryAttach</name><argument_list>(<argument><expr><name>shmid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>oldhdr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<switch>switch <condition>(<expr><name>state</name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>SHMSTATE_ANALYSIS_FAILURE</name></expr>:</case>
			<case>case <expr><name>SHMSTATE_ATTACHED</name></expr>:</case>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_LOCK_FILE_EXISTS</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"pre-existing shared memory block (key %lu, ID %lu) is still in use"</literal></expr></argument>,
								<argument><expr><operator>(</operator><name>unsigned</name> <name>long</name><operator>)</operator> <name>NextShmemSegID</name></expr></argument>,
								<argument><expr><operator>(</operator><name>unsigned</name> <name>long</name><operator>)</operator> <name>shmid</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Terminate any old server processes associated with data directory \"%s\"."</literal></expr></argument>,
								 <argument><expr><name>DataDir</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>SHMSTATE_ENOENT</name></expr>:</case>

				<comment type="block">/*
				 * To our surprise, some other process deleted since our last
				 * InternalIpcMemoryCreate().  Moments earlier, we would have
				 * seen SHMSTATE_FOREIGN.  Try that same ID again.
				 */</comment>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
					 <argument><expr><literal type="string">"shared memory block (key %lu, ID %lu) deleted during startup"</literal></expr></argument>,
					 <argument><expr><operator>(</operator><name>unsigned</name> <name>long</name><operator>)</operator> <name>NextShmemSegID</name></expr></argument>,
					 <argument><expr><operator>(</operator><name>unsigned</name> <name>long</name><operator>)</operator> <name>shmid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>SHMSTATE_FOREIGN</name></expr>:</case>
				<expr_stmt><expr><name>NextShmemSegID</name><operator>++</operator></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>SHMSTATE_UNATTACHED</name></expr>:</case>

				<comment type="block">/*
				 * The segment pertains to DataDir, and every process that had
				 * used it has died or detached.  Zap it, if possible, and any
				 * associated dynamic shared memory segments, as well.  This
				 * shouldn't fail, but if it does, assume the segment belongs
				 * to someone else after all, and try the next candidate.
				 * Otherwise, try again to create the segment.  That may fail
				 * if some other process creates the same shmem key before we
				 * do, in which case we'll try the next key.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>oldhdr</name><operator>-&gt;</operator><name>dsm_control</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>dsm_cleanup_using_control_segment</name><argument_list>(<argument><expr><name><name>oldhdr</name><operator>-&gt;</operator><name>dsm_control</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>shmctl</name><argument_list>(<argument><expr><name>shmid</name></expr></argument>, <argument><expr><name>IPC_RMID</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>NextShmemSegID</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<break>break;</break>
		</block_content>}</block></switch>

		<if_stmt><if>if <condition>(<expr><name>oldhdr</name> <operator>&amp;&amp;</operator> <call><name>shmdt</name><argument_list>(<argument><expr><name>oldhdr</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"shmdt(%p) failed: %m"</literal></expr></argument>, <argument><expr><name>oldhdr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Initialize new segment. */</comment>
	<expr_stmt><expr><name>hdr</name> <operator>=</operator> <operator>(</operator><name>PGShmemHeader</name> <operator>*</operator><operator>)</operator> <name>memAddress</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hdr</name><operator>-&gt;</operator><name>creatorPID</name></name> <operator>=</operator> <call><name>getpid</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hdr</name><operator>-&gt;</operator><name>magic</name></name> <operator>=</operator> <name>PGShmemMagic</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hdr</name><operator>-&gt;</operator><name>dsm_control</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/* Fill in the data directory ID info, too */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>stat</name><argument_list>(<argument><expr><name>DataDir</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>statbuf</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not stat data directory \"%s\": %m"</literal></expr></argument>,
						<argument><expr><name>DataDir</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>hdr</name><operator>-&gt;</operator><name>device</name></name> <operator>=</operator> <name><name>statbuf</name><operator>.</operator><name>st_dev</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hdr</name><operator>-&gt;</operator><name>inode</name></name> <operator>=</operator> <name><name>statbuf</name><operator>.</operator><name>st_ino</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Initialize space allocation status for segment.
	 */</comment>
	<expr_stmt><expr><name><name>hdr</name><operator>-&gt;</operator><name>totalsize</name></name> <operator>=</operator> <name>size</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hdr</name><operator>-&gt;</operator><name>freeoffset</name></name> <operator>=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PGShmemHeader</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>shim</name> <operator>=</operator> <name>hdr</name></expr>;</expr_stmt>

	<comment type="block">/* Save info for possible future use */</comment>
	<expr_stmt><expr><name>UsedShmemSegAddr</name> <operator>=</operator> <name>memAddress</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>UsedShmemSegID</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>long</name><operator>)</operator> <name>NextShmemSegID</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * If AnonymousShmem is NULL here, then we're not using anonymous shared
	 * memory, and should return a pointer to the System V shared memory
	 * block. Otherwise, the System V shared memory block is only a shim, and
	 * we must return a pointer to the real block.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>AnonymousShmem</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>hdr</name></expr>;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>AnonymousShmem</name></expr></argument>, <argument><expr><name>hdr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PGShmemHeader</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><operator>(</operator><name>PGShmemHeader</name> <operator>*</operator><operator>)</operator> <name>AnonymousShmem</name></expr>;</return>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>EXEC_BACKEND</name></cpp:ifdef>

<comment type="block">/*
 * PGSharedMemoryReAttach
 *
 * This is called during startup of a postmaster child process to re-attach to
 * an already existing shared memory segment.  This is needed only in the
 * EXEC_BACKEND case; otherwise postmaster children inherit the shared memory
 * segment attachment via fork().
 *
 * UsedShmemSegID and UsedShmemSegAddr are implicit parameters to this
 * routine.  The caller must have already restored them to the postmaster's
 * values.
 */</comment>
<function><type><name>void</name></type>
<name>PGSharedMemoryReAttach</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>IpcMemoryId</name></type> <name>shmid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGShmemHeader</name> <modifier>*</modifier></type><name>hdr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>IpcMemoryState</name></type> <name>state</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>void</name>	   <modifier>*</modifier></type><name>origUsedShmemSegAddr</name> <init>= <expr><name>UsedShmemSegAddr</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>UsedShmemSegAddr</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>IsUnderPostmaster</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__CYGWIN__</name></cpp:ifdef>
	<comment type="block">/* cygipc (currently) appears to not detach on exec. */</comment>
	<expr_stmt><expr><call><name>PGSharedMemoryDetach</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>UsedShmemSegAddr</name> <operator>=</operator> <name>origUsedShmemSegAddr</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG3</name></expr></argument>, <argument><expr><literal type="string">"attaching to %p"</literal></expr></argument>, <argument><expr><name>UsedShmemSegAddr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>shmid</name> <operator>=</operator> <call><name>shmget</name><argument_list>(<argument><expr><name>UsedShmemSegID</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PGShmemHeader</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>shmid</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>state</name> <operator>=</operator> <name>SHMSTATE_FOREIGN</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>state</name> <operator>=</operator> <call><name>PGSharedMemoryAttach</name><argument_list>(<argument><expr><name>shmid</name></expr></argument>, <argument><expr><name>UsedShmemSegAddr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hdr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>state</name> <operator>!=</operator> <name>SHMSTATE_ATTACHED</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"could not reattach to shared memory (key=%d, addr=%p): %m"</literal></expr></argument>,
			 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>UsedShmemSegID</name></expr></argument>, <argument><expr><name>UsedShmemSegAddr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>hdr</name> <operator>!=</operator> <name>origUsedShmemSegAddr</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"reattaching to shared memory returned unexpected address (got %p, expected %p)"</literal></expr></argument>,
			 <argument><expr><name>hdr</name></expr></argument>, <argument><expr><name>origUsedShmemSegAddr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>dsm_set_control_handle</name><argument_list>(<argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>dsm_control</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>UsedShmemSegAddr</name> <operator>=</operator> <name>hdr</name></expr>;</expr_stmt>		<comment type="block">/* probably redundant */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * PGSharedMemoryNoReAttach
 *
 * This is called during startup of a postmaster child process when we choose
 * *not* to re-attach to the existing shared memory segment.  We must clean up
 * to leave things in the appropriate state.  This is not used in the non
 * EXEC_BACKEND case, either.
 *
 * The child process startup logic might or might not call PGSharedMemoryDetach
 * after this; make sure that it will be a no-op if called.
 *
 * UsedShmemSegID and UsedShmemSegAddr are implicit parameters to this
 * routine.  The caller must have already restored them to the postmaster's
 * values.
 */</comment>
<function><type><name>void</name></type>
<name>PGSharedMemoryNoReAttach</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>UsedShmemSegAddr</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>IsUnderPostmaster</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__CYGWIN__</name></cpp:ifdef>
	<comment type="block">/* cygipc (currently) appears to not detach on exec. */</comment>
	<expr_stmt><expr><call><name>PGSharedMemoryDetach</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/* For cleanliness, reset UsedShmemSegAddr to show we're not attached. */</comment>
	<expr_stmt><expr><name>UsedShmemSegAddr</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<comment type="block">/* And the same for UsedShmemSegID. */</comment>
	<expr_stmt><expr><name>UsedShmemSegID</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* EXEC_BACKEND */</comment>

<comment type="block">/*
 * PGSharedMemoryDetach
 *
 * Detach from the shared memory segment, if still attached.  This is not
 * intended to be called explicitly by the process that originally created the
 * segment (it will have on_shmem_exit callback(s) registered to do that).
 * Rather, this is for subprocesses that have inherited an attachment and want
 * to get rid of it.
 *
 * UsedShmemSegID and UsedShmemSegAddr are implicit parameters to this
 * routine, also AnonymousShmem and AnonymousShmemSize.
 */</comment>
<function><type><name>void</name></type>
<name>PGSharedMemoryDetach</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>UsedShmemSegAddr</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>shmdt</name><argument_list>(<argument><expr><name>UsedShmemSegAddr</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>EXEC_BACKEND</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__CYGWIN__</name></expr></argument>)</argument_list></call></expr></cpp:if>
		<comment type="block">/* Work-around for cygipc exec bug */</comment>
			<operator>&amp;&amp;</operator> <call><name>shmdt</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"shmdt(%p) failed: %m"</literal></expr></argument>, <argument><expr><name>UsedShmemSegAddr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>UsedShmemSegAddr</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>AnonymousShmem</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>munmap</name><argument_list>(<argument><expr><name>AnonymousShmem</name></expr></argument>, <argument><expr><name>AnonymousShmemSize</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"munmap(%p, %zu) failed: %m"</literal></expr></argument>,
				 <argument><expr><name>AnonymousShmem</name></expr></argument>, <argument><expr><name>AnonymousShmemSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>AnonymousShmem</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>
</unit>
