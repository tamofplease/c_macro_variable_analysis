<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/backend/port/sysv_sema.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * sysv_sema.c
 *	  Implement PGSemaphores using SysV semaphore facilities
 *
 *
 * Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 * IDENTIFICATION
 *	  src/backend/port/sysv_sema.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;signal.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/file.h&gt;</cpp:file></cpp:include>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_SYS_IPC_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/ipc.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_SYS_SEM_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/sem.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/ipc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/pg_sema.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/shmem.h"</cpp:file></cpp:include>


<typedef>typedef <type><struct>struct <name>PGSemaphoreData</name>
<block>{
	<decl_stmt><decl><type><name>int</name></type>			<name>semId</name></decl>;</decl_stmt>			<comment type="block">/* semaphore set identifier */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>semNum</name></decl>;</decl_stmt>			<comment type="block">/* semaphore number within set */</comment>
}</block></struct></type> <name>PGSemaphoreData</name>;</typedef>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>HAVE_UNION_SEMUN</name></cpp:ifndef>
<union>union <name>semun</name>
<block>{
	<decl_stmt><decl><type><name>int</name></type>			<name>val</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>semid_ds</name></name> <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>short</name> <modifier>*</modifier></type><name>array</name></decl>;</decl_stmt>
}</block>;</union>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<typedef>typedef <type><name>key_t</name></type> <name>IpcSemaphoreKey</name>;</typedef>	<comment type="block">/* semaphore key passed to semget(2) */</comment>
<typedef>typedef <type><name>int</name></type> <name>IpcSemaphoreId</name>;</typedef>		<comment type="block">/* semaphore ID returned by semget(2) */</comment>

<comment type="block">/*
 * SEMAS_PER_SET is the number of useful semaphores in each semaphore set
 * we allocate.  It must be *less than* your kernel's SEMMSL (max semaphores
 * per set) parameter, which is often around 25.  (Less than, because we
 * allocate one extra sema in each set for identification purposes.)
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SEMAS_PER_SET</name></cpp:macro>	<cpp:value>16</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IPCProtection</name></cpp:macro>	<cpp:value>(0600)</cpp:value></cpp:define>	<comment type="block">/* access/modify by user only */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PGSemaMagic</name></cpp:macro>		<cpp:value>537</cpp:value></cpp:define>		<comment type="block">/* must be less than SEMVMX */</comment>


<decl_stmt><decl><type><specifier>static</specifier> <name>PGSemaphore</name></type> <name>sharedSemas</name></decl>;</decl_stmt> <comment type="block">/* array of PGSemaphoreData in shared memory */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>numSharedSemas</name></decl>;</decl_stmt>		<comment type="block">/* number of PGSemaphoreDatas used so far */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>maxSharedSemas</name></decl>;</decl_stmt>		<comment type="block">/* allocated size of PGSemaphoreData array */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>IpcSemaphoreId</name> <modifier>*</modifier></type><name>mySemaSets</name></decl>;</decl_stmt>	<comment type="block">/* IDs of sema sets acquired so far */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>numSemaSets</name></decl>;</decl_stmt>		<comment type="block">/* number of sema sets acquired so far */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>maxSemaSets</name></decl>;</decl_stmt>		<comment type="block">/* allocated size of mySemaSets array */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>IpcSemaphoreKey</name></type> <name>nextSemaKey</name></decl>;</decl_stmt> <comment type="block">/* next key to try using */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>nextSemaNumber</name></decl>;</decl_stmt>		<comment type="block">/* next free sem num in last sema set */</comment>


<function_decl><type><specifier>static</specifier> <name>IpcSemaphoreId</name></type> <name>InternalIpcSemaphoreCreate</name><parameter_list>(<parameter><decl><type><name>IpcSemaphoreKey</name></type> <name>semKey</name></decl></parameter>,
												 <parameter><decl><type><name>int</name></type> <name>numSems</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>IpcSemaphoreInitialize</name><parameter_list>(<parameter><decl><type><name>IpcSemaphoreId</name></type> <name>semId</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>semNum</name></decl></parameter>,
								   <parameter><decl><type><name>int</name></type> <name>value</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>IpcSemaphoreKill</name><parameter_list>(<parameter><decl><type><name>IpcSemaphoreId</name></type> <name>semId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>IpcSemaphoreGetValue</name><parameter_list>(<parameter><decl><type><name>IpcSemaphoreId</name></type> <name>semId</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>semNum</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>pid_t</name></type> <name>IpcSemaphoreGetLastPID</name><parameter_list>(<parameter><decl><type><name>IpcSemaphoreId</name></type> <name>semId</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>semNum</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>IpcSemaphoreId</name></type> <name>IpcSemaphoreCreate</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>numSems</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ReleaseSemaphores</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>status</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * InternalIpcSemaphoreCreate
 *
 * Attempt to create a new semaphore set with the specified key.
 * Will fail (return -1) if such a set already exists.
 *
 * If we fail with a failure code other than collision-with-existing-set,
 * print out an error and abort.  Other types of errors suggest nonrecoverable
 * problems.
 */</comment>
<function><type><specifier>static</specifier> <name>IpcSemaphoreId</name></type>
<name>InternalIpcSemaphoreCreate</name><parameter_list>(<parameter><decl><type><name>IpcSemaphoreKey</name></type> <name>semKey</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>numSems</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>semId</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>semId</name> <operator>=</operator> <call><name>semget</name><argument_list>(<argument><expr><name>semKey</name></expr></argument>, <argument><expr><name>numSems</name></expr></argument>, <argument><expr><name>IPC_CREAT</name> <operator>|</operator> <name>IPC_EXCL</name> <operator>|</operator> <name>IPCProtection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>semId</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>saved_errno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * Fail quietly if error indicates a collision with existing set. One
		 * would expect EEXIST, given that we said IPC_EXCL, but perhaps we
		 * could get a permission violation instead?  Also, EIDRM might occur
		 * if an old set is slated for destruction but not gone yet.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>saved_errno</name> <operator>==</operator> <name>EEXIST</name> <operator>||</operator> <name>saved_errno</name> <operator>==</operator> <name>EACCES</name>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>EIDRM</name></cpp:ifdef>
			<operator>||</operator> <name>saved_errno</name> <operator>==</operator> <name>EIDRM</name></expr>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			)</condition><block type="pseudo"><block_content>
			<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Else complain and abort
		 */</comment>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not create semaphores: %m"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Failed system call was semget(%lu, %d, 0%o)."</literal></expr></argument>,
						   <argument><expr><operator>(</operator><name>unsigned</name> <name>long</name><operator>)</operator> <name>semKey</name></expr></argument>, <argument><expr><name>numSems</name></expr></argument>,
						   <argument><expr><name>IPC_CREAT</name> <operator>|</operator> <name>IPC_EXCL</name> <operator>|</operator> <name>IPCProtection</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <ternary><condition><expr><operator>(</operator><name>saved_errno</name> <operator>==</operator> <name>ENOSPC</name><operator>)</operator></expr> ?</condition><then>
				 <expr><call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"This error does *not* mean that you have run out of disk space.  "</literal>
						 <literal type="string">"It occurs when either the system limit for the maximum number of "</literal>
						 <literal type="string">"semaphore sets (SEMMNI), or the system wide maximum number of "</literal>
						 <literal type="string">"semaphores (SEMMNS), would be exceeded.  You need to raise the "</literal>
						 <literal type="string">"respective kernel parameter.  Alternatively, reduce PostgreSQL's "</literal>
						 <literal type="string">"consumption of semaphores by reducing its max_connections parameter.\n"</literal>
						 <literal type="string">"The PostgreSQL documentation contains more information about "</literal>
						 <literal type="string">"configuring your system for PostgreSQL."</literal></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>semId</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Initialize a semaphore to the specified value.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>IpcSemaphoreInitialize</name><parameter_list>(<parameter><decl><type><name>IpcSemaphoreId</name></type> <name>semId</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>semNum</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>union</name> <name>semun</name></name></type> <name>semun</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>semun</name><operator>.</operator><name>val</name></name> <operator>=</operator> <name>value</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>semctl</name><argument_list>(<argument><expr><name>semId</name></expr></argument>, <argument><expr><name>semNum</name></expr></argument>, <argument><expr><name>SETVAL</name></expr></argument>, <argument><expr><name>semun</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>saved_errno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"semctl(%d, %d, SETVAL, %d) failed: %m"</literal></expr></argument>,
								 <argument><expr><name>semId</name></expr></argument>, <argument><expr><name>semNum</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <ternary><condition><expr><operator>(</operator><name>saved_errno</name> <operator>==</operator> <name>ERANGE</name><operator>)</operator></expr> ?</condition><then>
				 <expr><call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"You possibly need to raise your kernel's SEMVMX value to be at least "</literal>
						 <literal type="string">"%d.  Look into the PostgreSQL documentation for details."</literal></expr></argument>,
						 <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * IpcSemaphoreKill(semId)	- removes a semaphore set
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>IpcSemaphoreKill</name><parameter_list>(<parameter><decl><type><name>IpcSemaphoreId</name></type> <name>semId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>union</name> <name>semun</name></name></type> <name>semun</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>semun</name><operator>.</operator><name>val</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>				<comment type="block">/* unused, but keep compiler quiet */</comment>

	<if_stmt><if>if <condition>(<expr><call><name>semctl</name><argument_list>(<argument><expr><name>semId</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>IPC_RMID</name></expr></argument>, <argument><expr><name>semun</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"semctl(%d, 0, IPC_RMID, ...) failed: %m"</literal></expr></argument>, <argument><expr><name>semId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Get the current value (semval) of the semaphore */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>IpcSemaphoreGetValue</name><parameter_list>(<parameter><decl><type><name>IpcSemaphoreId</name></type> <name>semId</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>semNum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>union</name> <name>semun</name></name></type> <name>dummy</name></decl>;</decl_stmt>			<comment type="block">/* for Solaris */</comment>

	<expr_stmt><expr><name><name>dummy</name><operator>.</operator><name>val</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>				<comment type="block">/* unused */</comment>

	<return>return <expr><call><name>semctl</name><argument_list>(<argument><expr><name>semId</name></expr></argument>, <argument><expr><name>semNum</name></expr></argument>, <argument><expr><name>GETVAL</name></expr></argument>, <argument><expr><name>dummy</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Get the PID of the last process to do semop() on the semaphore */</comment>
<function><type><specifier>static</specifier> <name>pid_t</name></type>
<name>IpcSemaphoreGetLastPID</name><parameter_list>(<parameter><decl><type><name>IpcSemaphoreId</name></type> <name>semId</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>semNum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>union</name> <name>semun</name></name></type> <name>dummy</name></decl>;</decl_stmt>			<comment type="block">/* for Solaris */</comment>

	<expr_stmt><expr><name><name>dummy</name><operator>.</operator><name>val</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>				<comment type="block">/* unused */</comment>

	<return>return <expr><call><name>semctl</name><argument_list>(<argument><expr><name>semId</name></expr></argument>, <argument><expr><name>semNum</name></expr></argument>, <argument><expr><name>GETPID</name></expr></argument>, <argument><expr><name>dummy</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Create a semaphore set with the given number of useful semaphores
 * (an additional sema is actually allocated to serve as identifier).
 * Dead Postgres sema sets are recycled if found, but we do not fail
 * upon collision with non-Postgres sema sets.
 *
 * The idea here is to detect and re-use keys that may have been assigned
 * by a crashed postmaster or backend.
 */</comment>
<function><type><specifier>static</specifier> <name>IpcSemaphoreId</name></type>
<name>IpcSemaphoreCreate</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>numSems</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>IpcSemaphoreId</name></type> <name>semId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>union</name> <name>semun</name></name></type> <name>semun</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGSemaphoreData</name></type> <name>mysema</name></decl>;</decl_stmt>

	<comment type="block">/* Loop till we find a free IPC key */</comment>
	<for>for <control>(<init><expr><name>nextSemaKey</name><operator>++</operator></expr>;</init><condition>;</condition> <incr><expr><name>nextSemaKey</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>pid_t</name></type>		<name>creatorPID</name></decl>;</decl_stmt>

		<comment type="block">/* Try to create new semaphore set */</comment>
		<expr_stmt><expr><name>semId</name> <operator>=</operator> <call><name>InternalIpcSemaphoreCreate</name><argument_list>(<argument><expr><name>nextSemaKey</name></expr></argument>, <argument><expr><name>numSems</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>semId</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>				<comment type="block">/* successful create */</comment>

		<comment type="block">/* See if it looks to be leftover from a dead Postgres process */</comment>
		<expr_stmt><expr><name>semId</name> <operator>=</operator> <call><name>semget</name><argument_list>(<argument><expr><name>nextSemaKey</name></expr></argument>, <argument><expr><name>numSems</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>semId</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>			<comment type="block">/* failed: must be some other app's */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>IpcSemaphoreGetValue</name><argument_list>(<argument><expr><name>semId</name></expr></argument>, <argument><expr><name>numSems</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>PGSemaMagic</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>			<comment type="block">/* sema belongs to a non-Postgres app */</comment>

		<comment type="block">/*
		 * If the creator PID is my own PID or does not belong to any extant
		 * process, it's safe to zap it.
		 */</comment>
		<expr_stmt><expr><name>creatorPID</name> <operator>=</operator> <call><name>IpcSemaphoreGetLastPID</name><argument_list>(<argument><expr><name>semId</name></expr></argument>, <argument><expr><name>numSems</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>creatorPID</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>			<comment type="block">/* oops, GETPID failed */</comment>
		<if_stmt><if>if <condition>(<expr><name>creatorPID</name> <operator>!=</operator> <call><name>getpid</name><argument_list>()</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>kill</name><argument_list>(<argument><expr><name>creatorPID</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>errno</name> <operator>!=</operator> <name>ESRCH</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>		<comment type="block">/* sema belongs to a live process */</comment>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * The sema set appears to be from a dead Postgres process, or from a
		 * previous cycle of life in this same process.  Zap it, if possible.
		 * This probably shouldn't fail, but if it does, assume the sema set
		 * belongs to someone else after all, and continue quietly.
		 */</comment>
		<expr_stmt><expr><name><name>semun</name><operator>.</operator><name>val</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>			<comment type="block">/* unused, but keep compiler quiet */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>semctl</name><argument_list>(<argument><expr><name>semId</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>IPC_RMID</name></expr></argument>, <argument><expr><name>semun</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Now try again to create the sema set.
		 */</comment>
		<expr_stmt><expr><name>semId</name> <operator>=</operator> <call><name>InternalIpcSemaphoreCreate</name><argument_list>(<argument><expr><name>nextSemaKey</name></expr></argument>, <argument><expr><name>numSems</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>semId</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>				<comment type="block">/* successful create */</comment>

		<comment type="block">/*
		 * Can only get here if some other process managed to create the same
		 * sema key before we did.  Let him have that one, loop around to try
		 * next key.
		 */</comment>
	</block_content>}</block></for>

	<comment type="block">/*
	 * OK, we created a new sema set.  Mark it as created by this process. We
	 * do this by setting the spare semaphore to PGSemaMagic-1 and then
	 * incrementing it with semop().  That leaves it with value PGSemaMagic
	 * and sempid referencing this process.
	 */</comment>
	<expr_stmt><expr><call><name>IpcSemaphoreInitialize</name><argument_list>(<argument><expr><name>semId</name></expr></argument>, <argument><expr><name>numSems</name></expr></argument>, <argument><expr><name>PGSemaMagic</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>mysema</name><operator>.</operator><name>semId</name></name> <operator>=</operator> <name>semId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>mysema</name><operator>.</operator><name>semNum</name></name> <operator>=</operator> <name>numSems</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PGSemaphoreUnlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mysema</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>semId</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Report amount of shared memory needed for semaphores
 */</comment>
<function><type><name>Size</name></type>
<name>PGSemaphoreShmemSize</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>maxSemas</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>mul_size</name><argument_list>(<argument><expr><name>maxSemas</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PGSemaphoreData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * PGReserveSemaphores --- initialize semaphore support
 *
 * This is called during postmaster start or shared memory reinitialization.
 * It should do whatever is needed to be able to support up to maxSemas
 * subsequent PGSemaphoreCreate calls.  Also, if any system resources
 * are acquired here or in PGSemaphoreCreate, register an on_shmem_exit
 * callback to release them.
 *
 * The port number is passed for possible use as a key (for SysV, we use
 * it to generate the starting semaphore key).  In a standalone backend,
 * zero will be passed.
 *
 * In the SysV implementation, we acquire semaphore sets on-demand; the
 * maxSemas parameter is just used to size the arrays.  There is an array
 * of PGSemaphoreData structs in shared memory, and a postmaster-local array
 * with one entry per SysV semaphore set, which we use for releasing the
 * semaphore sets when done.  (This design ensures that postmaster shutdown
 * doesn't rely on the contents of shared memory, which a failed backend might
 * have clobbered.)
 */</comment>
<function><type><name>void</name></type>
<name>PGReserveSemaphores</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>maxSemas</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>port</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * We must use ShmemAllocUnlocked(), since the spinlock protecting
	 * ShmemAlloc() won't be ready yet.  (This ordering is necessary when we
	 * are emulating spinlocks with semaphores.)
	 */</comment>
	<expr_stmt><expr><name>sharedSemas</name> <operator>=</operator> <operator>(</operator><name>PGSemaphore</name><operator>)</operator>
		<call><name>ShmemAllocUnlocked</name><argument_list>(<argument><expr><call><name>PGSemaphoreShmemSize</name><argument_list>(<argument><expr><name>maxSemas</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>numSharedSemas</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>maxSharedSemas</name> <operator>=</operator> <name>maxSemas</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>maxSemaSets</name> <operator>=</operator> <operator>(</operator><name>maxSemas</name> <operator>+</operator> <name>SEMAS_PER_SET</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator> <name>SEMAS_PER_SET</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>mySemaSets</name> <operator>=</operator> <operator>(</operator><name>IpcSemaphoreId</name> <operator>*</operator><operator>)</operator>
		<call><name>malloc</name><argument_list>(<argument><expr><name>maxSemaSets</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>IpcSemaphoreId</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>mySemaSets</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>numSemaSets</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>nextSemaKey</name> <operator>=</operator> <name>port</name> <operator>*</operator> <literal type="number">1000</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>nextSemaNumber</name> <operator>=</operator> <name>SEMAS_PER_SET</name></expr>;</expr_stmt> <comment type="block">/* force sema set alloc on 1st call */</comment>

	<expr_stmt><expr><call><name>on_shmem_exit</name><argument_list>(<argument><expr><name>ReleaseSemaphores</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Release semaphores at shutdown or shmem reinitialization
 *
 * (called as an on_shmem_exit callback, hence funny argument list)
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ReleaseSemaphores</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>status</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numSemaSets</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>IpcSemaphoreKill</name><argument_list>(<argument><expr><name><name>mySemaSets</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>mySemaSets</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * PGSemaphoreCreate
 *
 * Allocate a PGSemaphore structure with initial count 1
 */</comment>
<function><type><name>PGSemaphore</name></type>
<name>PGSemaphoreCreate</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGSemaphore</name></type> <name>sema</name></decl>;</decl_stmt>

	<comment type="block">/* Can't do this in a backend, because static state is postmaster's */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>IsUnderPostmaster</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>nextSemaNumber</name> <operator>&gt;=</operator> <name>SEMAS_PER_SET</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Time to allocate another semaphore set */</comment>
		<if_stmt><if>if <condition>(<expr><name>numSemaSets</name> <operator>&gt;=</operator> <name>maxSemaSets</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"too many semaphores created"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>mySemaSets</name><index>[<expr><name>numSemaSets</name></expr>]</index></name> <operator>=</operator> <call><name>IpcSemaphoreCreate</name><argument_list>(<argument><expr><name>SEMAS_PER_SET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>numSemaSets</name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>nextSemaNumber</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Use the next shared PGSemaphoreData */</comment>
	<if_stmt><if>if <condition>(<expr><name>numSharedSemas</name> <operator>&gt;=</operator> <name>maxSharedSemas</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"too many semaphores created"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>sema</name> <operator>=</operator> <operator>&amp;</operator><name><name>sharedSemas</name><index>[<expr><name>numSharedSemas</name><operator>++</operator></expr>]</index></name></expr>;</expr_stmt>
	<comment type="block">/* Assign the next free semaphore in the current set */</comment>
	<expr_stmt><expr><name><name>sema</name><operator>-&gt;</operator><name>semId</name></name> <operator>=</operator> <name><name>mySemaSets</name><index>[<expr><name>numSemaSets</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sema</name><operator>-&gt;</operator><name>semNum</name></name> <operator>=</operator> <name>nextSemaNumber</name><operator>++</operator></expr>;</expr_stmt>
	<comment type="block">/* Initialize it to count 1 */</comment>
	<expr_stmt><expr><call><name>IpcSemaphoreInitialize</name><argument_list>(<argument><expr><name><name>sema</name><operator>-&gt;</operator><name>semId</name></name></expr></argument>, <argument><expr><name><name>sema</name><operator>-&gt;</operator><name>semNum</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>sema</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * PGSemaphoreReset
 *
 * Reset a previously-initialized PGSemaphore to have count 0
 */</comment>
<function><type><name>void</name></type>
<name>PGSemaphoreReset</name><parameter_list>(<parameter><decl><type><name>PGSemaphore</name></type> <name>sema</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>IpcSemaphoreInitialize</name><argument_list>(<argument><expr><name><name>sema</name><operator>-&gt;</operator><name>semId</name></name></expr></argument>, <argument><expr><name><name>sema</name><operator>-&gt;</operator><name>semNum</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * PGSemaphoreLock
 *
 * Lock a semaphore (decrement count), blocking if count would be &lt; 0
 */</comment>
<function><type><name>void</name></type>
<name>PGSemaphoreLock</name><parameter_list>(<parameter><decl><type><name>PGSemaphore</name></type> <name>sema</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>errStatus</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>sembuf</name></name></type> <name>sops</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>sops</name><operator>.</operator><name>sem_op</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>			<comment type="block">/* decrement */</comment>
	<expr_stmt><expr><name><name>sops</name><operator>.</operator><name>sem_flg</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sops</name><operator>.</operator><name>sem_num</name></name> <operator>=</operator> <name><name>sema</name><operator>-&gt;</operator><name>semNum</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Note: if errStatus is -1 and errno == EINTR then it means we returned
	 * from the operation prematurely because we were sent a signal.  So we
	 * try and lock the semaphore again.
	 *
	 * We used to check interrupts here, but that required servicing
	 * interrupts directly from signal handlers. Which is hard to do safely
	 * and portably.
	 */</comment>
	<do>do
	<block>{<block_content>
		<expr_stmt><expr><name>errStatus</name> <operator>=</operator> <call><name>semop</name><argument_list>(<argument><expr><name><name>sema</name><operator>-&gt;</operator><name>semId</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sops</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block> while <condition>(<expr><name>errStatus</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>errno</name> <operator>==</operator> <name>EINTR</name></expr>)</condition>;</do>

	<if_stmt><if>if <condition>(<expr><name>errStatus</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"semop(id=%d,num=%d) failed: %m"</literal></expr></argument>, <argument><expr><name><name>sema</name><operator>-&gt;</operator><name>semId</name></name></expr></argument>, <argument><expr><name><name>sema</name><operator>-&gt;</operator><name>semNum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * PGSemaphoreLockInterruptable
 *
 * Lock a semaphore (decrement count), blocking if count would be &lt; 0.
 * Return true if the lock obtained or false if an interrupt occurred.
 */</comment>
<function><type><name>bool</name></type>
<name>PGSemaphoreLockInterruptable</name><parameter_list>(<parameter><decl><type><name>PGSemaphore</name></type> <name>sema</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>errStatus</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>sembuf</name></name></type> <name>sops</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>sops</name><operator>.</operator><name>sem_op</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>			<comment type="block">/* decrement */</comment>
	<expr_stmt><expr><name><name>sops</name><operator>.</operator><name>sem_flg</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sops</name><operator>.</operator><name>sem_num</name></name> <operator>=</operator> <name><name>sema</name><operator>-&gt;</operator><name>semNum</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name>errStatus</name> <operator>=</operator> <call><name>semop</name><argument_list>(<argument><expr><name><name>sema</name><operator>-&gt;</operator><name>semId</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sops</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>errStatus</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>EINTR</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"semop(id=%d,num=%d) failed: %m"</literal></expr></argument>, <argument><expr><name><name>sema</name><operator>-&gt;</operator><name>semId</name></name></expr></argument>, <argument><expr><name><name>sema</name><operator>-&gt;</operator><name>semNum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * PGSemaphoreUnlock
 *
 * Unlock a semaphore (increment count)
 */</comment>
<function><type><name>void</name></type>
<name>PGSemaphoreUnlock</name><parameter_list>(<parameter><decl><type><name>PGSemaphore</name></type> <name>sema</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>errStatus</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>sembuf</name></name></type> <name>sops</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>sops</name><operator>.</operator><name>sem_op</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>			<comment type="block">/* increment */</comment>
	<expr_stmt><expr><name><name>sops</name><operator>.</operator><name>sem_flg</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sops</name><operator>.</operator><name>sem_num</name></name> <operator>=</operator> <name><name>sema</name><operator>-&gt;</operator><name>semNum</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Note: if errStatus is -1 and errno == EINTR then it means we returned
	 * from the operation prematurely because we were sent a signal.  So we
	 * try and unlock the semaphore again. Not clear this can really happen,
	 * but might as well cope.
	 */</comment>
	<do>do
	<block>{<block_content>
		<expr_stmt><expr><name>errStatus</name> <operator>=</operator> <call><name>semop</name><argument_list>(<argument><expr><name><name>sema</name><operator>-&gt;</operator><name>semId</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sops</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block> while <condition>(<expr><name>errStatus</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>errno</name> <operator>==</operator> <name>EINTR</name></expr>)</condition>;</do>

	<if_stmt><if>if <condition>(<expr><name>errStatus</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"semop(id=%d,num=%d) failed: %m"</literal></expr></argument>, <argument><expr><name><name>sema</name><operator>-&gt;</operator><name>semId</name></name></expr></argument>, <argument><expr><name><name>sema</name><operator>-&gt;</operator><name>semNum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * PGSemaphoreTryLock
 *
 * Lock a semaphore only if able to do so without blocking
 */</comment>
<function><type><name>bool</name></type>
<name>PGSemaphoreTryLock</name><parameter_list>(<parameter><decl><type><name>PGSemaphore</name></type> <name>sema</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>errStatus</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>sembuf</name></name></type> <name>sops</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>sops</name><operator>.</operator><name>sem_op</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>			<comment type="block">/* decrement */</comment>
	<expr_stmt><expr><name><name>sops</name><operator>.</operator><name>sem_flg</name></name> <operator>=</operator> <name>IPC_NOWAIT</name></expr>;</expr_stmt>	<comment type="block">/* but don't block */</comment>
	<expr_stmt><expr><name><name>sops</name><operator>.</operator><name>sem_num</name></name> <operator>=</operator> <name><name>sema</name><operator>-&gt;</operator><name>semNum</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Note: if errStatus is -1 and errno == EINTR then it means we returned
	 * from the operation prematurely because we were sent a signal.  So we
	 * try and lock the semaphore again.
	 */</comment>
	<do>do
	<block>{<block_content>
		<expr_stmt><expr><name>errStatus</name> <operator>=</operator> <call><name>semop</name><argument_list>(<argument><expr><name><name>sema</name><operator>-&gt;</operator><name>semId</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sops</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block> while <condition>(<expr><name>errStatus</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>errno</name> <operator>==</operator> <name>EINTR</name></expr>)</condition>;</do>

	<if_stmt><if>if <condition>(<expr><name>errStatus</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Expect EAGAIN or EWOULDBLOCK (platform-dependent) */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>EAGAIN</name></cpp:ifdef>
		<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>EAGAIN</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>		<comment type="block">/* failed to lock it */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>EWOULDBLOCK</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>EAGAIN</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>(</operator><name>EWOULDBLOCK</name> <operator>!=</operator> <name>EAGAIN</name><operator>)</operator><operator>)</operator></expr></cpp:if>
		<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>EWOULDBLOCK</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>		<comment type="block">/* failed to lock it */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<comment type="block">/* Otherwise we got trouble */</comment>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"semop(id=%d,num=%d) failed: %m"</literal></expr></argument>, <argument><expr><name><name>sema</name><operator>-&gt;</operator><name>semId</name></name></expr></argument>, <argument><expr><name><name>sema</name><operator>-&gt;</operator><name>semNum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>
</unit>
