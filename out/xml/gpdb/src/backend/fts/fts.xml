<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/backend/fts/fts.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * fts.c
 *	  Process under QD postmaster polls the segments on a periodic basis
 *    or at the behest of QEs.
 *
 * Maintains an array in shared memory containing the state of each segment.
 *
 * Portions Copyright (c) 2005-2010, Greenplum Inc.
 * Portions Copyright (c) 2011, EMC Corp.
 * Portions Copyright (c) 2012-Present VMware, Inc. or its affiliates.
 *
 *
 * IDENTIFICATION
 *	    src/backend/fts/fts.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>

<comment type="block">/* These are always necessary for a bgworker */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/bgworker.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/ipc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/latch.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/lwlock.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/proc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/shmem.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/genam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/table.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/indexing.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq/pqsignal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbvars.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq-int.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbfts.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgstat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/fts.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/ftsprobe.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/postmaster.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/faultinjector.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/fmgroids.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/gp_configuration_history.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/gp_segment_configuration.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tcop/tcopprot.h"</cpp:file></cpp:include> <comment type="block">/* quickdie() */</comment>

<decl_stmt><decl><type><name>bool</name></type> <name>am_ftsprobe</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>am_ftshandler</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * STATIC VARIABLES
 */</comment>
<decl_stmt><decl><type><specifier>volatile</specifier> <name>pid_t</name> <modifier>*</modifier></type><name>shmFtsProbePID</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>skip_fts_probe</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>volatile</specifier> <name>bool</name></type> <name>probe_requested</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>volatile</specifier> <name>sig_atomic_t</name></type> <name>got_SIGHUP</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * FUNCTION PROTOTYPES
 */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>FtsLoop</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>CdbComponentDatabases</name> <modifier>*</modifier></type><name>readCdbComponentInfoAndUpdateStatus</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*=========================================================================
 * HELPER FUNCTIONS
 */</comment>
<comment type="block">/* SIGHUP: set flag to reload config file */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>sigHupHandler</name><parameter_list>(<parameter><decl><type><name>SIGNAL_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name>got_SIGHUP</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>MyProc</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>SetLatch</name><argument_list>(<argument><expr><name>MyLatch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* SIGINT: set flag to indicate a FTS scan is requested */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>sigIntHandler</name><parameter_list>(<parameter><decl><type><name>SIGNAL_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name>probe_requested</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>MyProc</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>SetLatch</name><argument_list>(<argument><expr><name>MyLatch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>pid_t</name></type>
<name>FtsProbePID</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><operator>*</operator><name>shmFtsProbePID</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>FtsProbeStartRule</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>main_arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><operator>(</operator><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * FtsProbeMain
 */</comment>
<function><type><name>void</name></type>
<name>FtsProbeMain</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>main_arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><operator>*</operator><name>shmFtsProbePID</name> <operator>=</operator> <name>MyProcPid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>am_ftsprobe</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * reread postgresql.conf if requested
	 */</comment>
	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGHUP</name></expr></argument>, <argument><expr><name>sigHupHandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGINT</name></expr></argument>, <argument><expr><name>sigIntHandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* We're now ready to receive signals */</comment>
	<expr_stmt><expr><call><name>BackgroundWorkerUnblockSignals</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Connect to our database */</comment>
	<expr_stmt><expr><call><name>BackgroundWorkerInitializeConnection</name><argument_list>(<argument><expr><name>DB_FOR_COMMON_ACCESS</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* main loop */</comment>
	<expr_stmt><expr><call><name>FtsLoop</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* One iteration done, go away */</comment>
	<expr_stmt><expr><call><name>proc_exit</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Populate cdb_component_dbs object by reading from catalog.
 * Internally, the object is allocated in CdbComponentsContext.
 */</comment>
<function><type><specifier>static</specifier>
<name>CdbComponentDatabases</name> <modifier>*</modifier></type><name>readCdbComponentInfoAndUpdateStatus</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CdbComponentDatabases</name> <modifier>*</modifier></type><name>cdbs</name> <init>= <expr><call><name>cdbcomponent_getCdbComponents</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>cdbs</name><operator>-&gt;</operator><name>total_segment_dbs</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>CdbComponentDatabaseInfo</name> <modifier>*</modifier></type><name>segInfo</name> <init>= <expr><operator>&amp;</operator><name><name>cdbs</name><operator>-&gt;</operator><name>segment_db_info</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint8</name></type>	<name>segStatus</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SEGMENT_IS_ALIVE</name><argument_list>(<argument><expr><name>segInfo</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>FTS_STATUS_SET_DOWN</name><argument_list>(<argument><expr><name>segStatus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>ftsProbeInfo</name><operator>-&gt;</operator><name>status</name><index>[<expr><name><name>segInfo</name><operator>-&gt;</operator><name>config</name><operator>-&gt;</operator><name>dbid</name></name></expr>]</index></name> <operator>=</operator> <name>segStatus</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Initialize fts_stausVersion after populating the config details in
	 * shared memory for the first time after FTS startup.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>ftsProbeInfo</name><operator>-&gt;</operator><name>status_version</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>ftsProbeInfo</name><operator>-&gt;</operator><name>status_version</name></name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>writeGpSegConfigToFTSFiles</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>cdbs</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>probeWalRepUpdateConfig</name><parameter_list>(<parameter><decl><type><name>int16</name></type> <name>dbid</name></decl></parameter>, <parameter><decl><type><name>int16</name></type> <name>segindex</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>role</name></decl></parameter>,
						<parameter><decl><type><name>bool</name></type> <name>IsSegmentAlive</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>IsInSync</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>AssertImply</name><argument_list>(<argument><expr><name>IsInSync</name></expr></argument>, <argument><expr><name>IsSegmentAlive</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Insert new tuple into gp_configuration_history catalog.
	 */</comment>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Relation</name></type> <name>histrel</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTuple</name></type> <name>histtuple</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type> <name><name>histvals</name><index>[<expr><name>Natts_gp_configuration_history</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name><name>histnulls</name><index>[<expr><name>Natts_gp_configuration_history</name></expr>]</index></name> <init>= <expr><block>{ <expr><name>false</name></expr> }</block></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name></type> <name><name>desc</name><index>[<expr><name>SQL_CMD_BUF_SIZE</name></expr>]</index></name></decl>;</decl_stmt>

		<expr_stmt><expr><name>histrel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>GpConfigHistoryRelationId</name></expr></argument>,
							 <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>histvals</name><index>[<expr><name>Anum_gp_configuration_history_time</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator>
				<call><name>TimestampTzGetDatum</name><argument_list>(<argument><expr><call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>histvals</name><index>[<expr><name>Anum_gp_configuration_history_dbid</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator>
				<call><name>Int16GetDatum</name><argument_list>(<argument><expr><name>dbid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>desc</name></expr></argument>)</argument_list></sizeof></expr></argument>,
				 <argument><expr><literal type="string">"FTS: update role, status, and mode for dbid %d with contentid %d to %c, %c, and %c"</literal></expr></argument>,
				 <argument><expr><name>dbid</name></expr></argument>, <argument><expr><name>segindex</name></expr></argument>, <argument><expr><name>role</name></expr></argument>,
				 <argument><expr><ternary><condition><expr><name>IsSegmentAlive</name></expr> ?</condition><then> <expr><name>GP_SEGMENT_CONFIGURATION_STATUS_UP</name></expr> </then><else>:
				 <expr><name>GP_SEGMENT_CONFIGURATION_STATUS_DOWN</name></expr></else></ternary></expr></argument>,
				 <argument><expr><ternary><condition><expr><name>IsInSync</name></expr> ?</condition><then> <expr><name>GP_SEGMENT_CONFIGURATION_MODE_INSYNC</name></expr> </then><else>:
				 <expr><name>GP_SEGMENT_CONFIGURATION_MODE_NOTINSYNC</name></expr></else></ternary></expr></argument>
			)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>histvals</name><index>[<expr><name>Anum_gp_configuration_history_desc</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator>
				<call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name>desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>histtuple</name> <operator>=</operator> <call><name>heap_form_tuple</name><argument_list>(<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>histrel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>histvals</name></expr></argument>, <argument><expr><name>histnulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CatalogTupleInsert</name><argument_list>(<argument><expr><name>histrel</name></expr></argument>, <argument><expr><name>histtuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>SIMPLE_FAULT_INJECTOR</name><argument_list>(<argument><expr><literal type="string">"fts_update_config"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>histrel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * Find and update gp_segment_configuration tuple.
	 */</comment>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Relation</name></type> <name>configrel</name></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>HeapTuple</name></type> <name>configtuple</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTuple</name></type> <name>newtuple</name></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>Datum</name></type> <name><name>configvals</name><index>[<expr><name>Natts_gp_segment_configuration</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name><name>confignulls</name><index>[<expr><name>Natts_gp_segment_configuration</name></expr>]</index></name> <init>= <expr><block>{ <expr><name>false</name></expr> }</block></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name><name>repls</name><index>[<expr><name>Natts_gp_segment_configuration</name></expr>]</index></name> <init>= <expr><block>{ <expr><name>false</name></expr> }</block></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>ScanKeyData</name></type> <name>scankey</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>sscan</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>configrel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>GpSegmentConfigRelationId</name></expr></argument>,
							   <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>scankey</name></expr></argument>,
					<argument><expr><name>Anum_gp_segment_configuration_dbid</name></expr></argument>,
					<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_INT2EQ</name></expr></argument>,
					<argument><expr><call><name>Int16GetDatum</name><argument_list>(<argument><expr><name>dbid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>sscan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>configrel</name></expr></argument>, <argument><expr><name>GpSegmentConfigDbidIndexId</name></expr></argument>,
								   <argument><expr><name>true</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>scankey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>configtuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>sscan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>configtuple</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"FTS cannot find dbid=%d in %s"</literal></expr></argument>, <argument><expr><name>dbid</name></expr></argument>,
				 <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>configrel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name><name>configvals</name><index>[<expr><name>Anum_gp_segment_configuration_role</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>CharGetDatum</name><argument_list>(<argument><expr><name>role</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>repls</name><index>[<expr><name>Anum_gp_segment_configuration_role</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>configvals</name><index>[<expr><name>Anum_gp_segment_configuration_status</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator>
			<call><name>CharGetDatum</name><argument_list>(<argument><expr><ternary><condition><expr><name>IsSegmentAlive</name></expr> ?</condition><then> <expr><name>GP_SEGMENT_CONFIGURATION_STATUS_UP</name></expr> </then><else>:
										<expr><name>GP_SEGMENT_CONFIGURATION_STATUS_DOWN</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>repls</name><index>[<expr><name>Anum_gp_segment_configuration_status</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>configvals</name><index>[<expr><name>Anum_gp_segment_configuration_mode</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator>
			<call><name>CharGetDatum</name><argument_list>(<argument><expr><ternary><condition><expr><name>IsInSync</name></expr> ?</condition><then> <expr><name>GP_SEGMENT_CONFIGURATION_MODE_INSYNC</name></expr> </then><else>:
						 <expr><name>GP_SEGMENT_CONFIGURATION_MODE_NOTINSYNC</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>repls</name><index>[<expr><name>Anum_gp_segment_configuration_mode</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>newtuple</name> <operator>=</operator> <call><name>heap_modify_tuple</name><argument_list>(<argument><expr><name>configtuple</name></expr></argument>, <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>configrel</name></expr></argument>)</argument_list></call></expr></argument>,
									 <argument><expr><name>configvals</name></expr></argument>, <argument><expr><name>confignulls</name></expr></argument>, <argument><expr><name>repls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>configrel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>configtuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>newtuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>sscan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>newtuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>configrel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<function><type><specifier>static</specifier>
<name>void</name></type> <name>FtsLoop</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>	<name>updated_probe_state</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>probeContext</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"/><name>oldContext</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>time_t</name></type> <name>elapsed</name></decl>,	<decl><type ref="prev"/><name>probe_start_time</name></decl>, <decl><type ref="prev"/><name>timeout</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CdbComponentDatabases</name> <modifier>*</modifier></type><name>cdbs</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>probeContext</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>,
										 <argument><expr><literal type="string">"FtsProbeMemCtxt"</literal></expr></argument>,
										 <argument><expr><name>ALLOCSET_DEFAULT_INITSIZE</name></expr></argument>,	<comment type="block">/* always have some memory */</comment>
										 <argument><expr><name>ALLOCSET_DEFAULT_INITSIZE</name></expr></argument>,
										 <argument><expr><name>ALLOCSET_DEFAULT_MAXSIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><name>true</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type>		<name>has_mirrors</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>rc</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>got_SIGHUP</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>got_SIGHUP</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ProcessConfigFile</name><argument_list>(<argument><expr><name>PGC_SIGHUP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>SIMPLE_FAULT_INJECTOR</name><argument_list>(<argument><expr><literal type="string">"ftsLoop_before_probe"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>probe_start_time</name> <operator>=</operator> <call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ftsProbeInfo</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ftsProbeInfo</name><operator>-&gt;</operator><name>start_count</name></name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ftsProbeInfo</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Need a transaction to access the catalogs */</comment>
		<expr_stmt><expr><call><name>StartTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>cdbs</name> <operator>=</operator> <call><name>readCdbComponentInfoAndUpdateStatus</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Check here gp_segment_configuration if has mirror's */</comment>
		<expr_stmt><expr><name>has_mirrors</name> <operator>=</operator> <call><name>gp_segment_config_has_mirrors</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* close the transaction we started above */</comment>
		<expr_stmt><expr><call><name>CommitTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Reset this as we are performing the probe */</comment>
		<expr_stmt><expr><name>probe_requested</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>skip_fts_probe</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FAULT_INJECTOR</name></cpp:ifdef>
		<if_stmt><if>if <condition>(<expr><call><name>SIMPLE_FAULT_INJECTOR</name><argument_list>(<argument><expr><literal type="string">"fts_probe"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>FaultInjectorTypeSkip</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>skip_fts_probe</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

		<if_stmt><if>if <condition>(<expr><name>skip_fts_probe</name> <operator>||</operator> <operator>!</operator><name>has_mirrors</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>elogif</name><argument_list>(<argument><expr><name>gp_log_fts</name> <operator>&gt;=</operator> <name>GPVARS_VERBOSITY_VERBOSE</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>,
				   <argument><expr><literal type="string">"skipping FTS probes due to %s"</literal></expr></argument>,
				   <argument><expr><ternary><condition><expr><operator>!</operator><name>has_mirrors</name></expr> ?</condition><then> <expr><literal type="string">"no mirrors"</literal></expr> </then><else>: <expr><literal type="string">"fts_probe fault"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>elogif</name><argument_list>(<argument><expr><name>gp_log_fts</name> <operator>==</operator> <name>GPVARS_VERBOSITY_DEBUG</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>,
				   <argument><expr><literal type="string">"FTS: starting scan with %d segments and %d contents"</literal></expr></argument>,
				   <argument><expr><name><name>cdbs</name><operator>-&gt;</operator><name>total_segment_dbs</name></name></expr></argument>,
				   <argument><expr><name><name>cdbs</name><operator>-&gt;</operator><name>total_segments</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/*
			 * We probe in a special context, some of the heap access
			 * stuff palloc()s internally
			 */</comment>
			<expr_stmt><expr><name>oldContext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>probeContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>updated_probe_state</name> <operator>=</operator> <call><name>FtsWalRepMessageSegments</name><argument_list>(<argument><expr><name>cdbs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* free any pallocs we made inside probeSegments() */</comment>
			<expr_stmt><expr><call><name>MemoryContextReset</name><argument_list>(<argument><expr><name>probeContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Bump the version if configuration was updated. */</comment>
			<if_stmt><if>if <condition>(<expr><name>updated_probe_state</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * File GPSEGCONFIGDUMPFILE under $PGDATA is used by other
				 * components to fetch latest gp_segment_configuration outside
				 * of a transaction. FTS updates this file in the first probe
				 * and every probe which updated gp_segment_configuration.
				 */</comment>
				<expr_stmt><expr><call><name>StartTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>writeGpSegConfigToFTSFiles</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>CommitTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name><name>ftsProbeInfo</name><operator>-&gt;</operator><name>status_version</name></name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/* free current components info and free ip addr caches */</comment>	
		<expr_stmt><expr><call><name>cdbcomponent_destroyCdbComponents</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>SIMPLE_FAULT_INJECTOR</name><argument_list>(<argument><expr><literal type="string">"ftsLoop_after_probe"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Notify any waiting backends about probe cycle completion. */</comment>
		<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ftsProbeInfo</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ftsProbeInfo</name><operator>-&gt;</operator><name>done_count</name></name> <operator>=</operator> <name><name>ftsProbeInfo</name><operator>-&gt;</operator><name>start_count</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ftsProbeInfo</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


		<comment type="block">/* check if we need to sleep before starting next iteration */</comment>
		<expr_stmt><expr><name>elapsed</name> <operator>=</operator> <call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>probe_start_time</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>timeout</name> <operator>=</operator> <ternary><condition><expr><name>elapsed</name> <operator>&gt;=</operator> <name>gp_fts_probe_interval</name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: 
							<expr><name>gp_fts_probe_interval</name> <operator>-</operator> <name>elapsed</name></expr></else></ternary></expr>;</expr_stmt>

		<comment type="block">/*
		 * In above code we might update gp_segment_configuration and then wal
		 * is generated. While synchronizing wal to standby, we need to wait on
		 * MyLatch also in SyncRepWaitForLSN(). The set latch introduced by
		 * outside fts probe trigger (e.g. gp_request_fts_probe_scan() or
		 * FtsNotifyProber()) might be consumed by it so we do not WaitLatch()
		 * here with a long timeout here else we may block for that long
		 * timeout, so we recheck probe_requested here before waitLatch().
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>probe_requested</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>elogif</name><argument_list>(<argument><expr><name>gp_log_fts</name> <operator>&gt;=</operator> <name>GPVARS_VERBOSITY_VERBOSE</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>,
				   <argument><expr><literal type="string">"FTS: run the probe due to external request, even if the remaining time for the next probe is %ds"</literal></expr></argument>,
				   <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>timeout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>timeout</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>WaitLatch</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>MyProc</name><operator>-&gt;</operator><name>procLatch</name></name></expr></argument>,
					   <argument><expr><name>WL_LATCH_SET</name> <operator>|</operator> <name>WL_TIMEOUT</name> <operator>|</operator> <name>WL_POSTMASTER_DEATH</name></expr></argument>,
					   <argument><expr><name>timeout</name> <operator>*</operator> <literal type="number">1000L</literal></expr></argument>,
					   <argument><expr><name>WAIT_EVENT_FTS_PROBE_MAIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>SIMPLE_FAULT_INJECTOR</name><argument_list>(<argument><expr><literal type="string">"ftsLoop_after_latch"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ResetLatch</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>MyProc</name><operator>-&gt;</operator><name>procLatch</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* emergency bailout if postmaster has died */</comment>
		<if_stmt><if>if <condition>(<expr><name>rc</name> <operator>&amp;</operator> <name>WL_POSTMASTER_DEATH</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>proc_exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></while> <comment type="block">/* end server loop */</comment>

	<return>return;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Check if FTS is active
 */</comment>
<function><type><name>bool</name></type>
<name>FtsIsActive</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><operator>!</operator><name>skip_fts_probe</name></expr>;</return>
</block_content>}</block></function>
</unit>
