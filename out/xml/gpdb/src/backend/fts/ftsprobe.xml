<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/backend/fts/ftsprobe.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * ftsprobe.c
 *	  Implementation of segment probing interface
 *
 * Portions Copyright (c) 2006-2011, Greenplum inc
 * Portions Copyright (c) 2012-Present VMware, Inc. or its affiliates.
 *
 *
 * IDENTIFICATION
 *	    src/backend/fts/ftsprobe.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_POLL_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;poll.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_SYS_POLL_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/poll.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq-fe.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq-int.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbfts.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbvars.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/fts.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/ftsprobe.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/postmaster.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/snapmgr.h"</cpp:file></cpp:include>


<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>pollfd</name></name> <modifier>*</modifier></type><name>PollFds</name></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>CdbComponentDatabaseInfo</name> <modifier>*</modifier></type>
<name>FtsGetPeerSegment</name><parameter_list>(<parameter><decl><type><name>CdbComponentDatabases</name> <modifier>*</modifier></type><name>cdbs</name></decl></parameter>,
				  <parameter><decl><type><name>int</name></type> <name>content</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>dbid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>cdbs</name><operator>-&gt;</operator><name>total_segment_dbs</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>CdbComponentDatabaseInfo</name> <modifier>*</modifier></type><name>segInfo</name> <init>= <expr><operator>&amp;</operator><name><name>cdbs</name><operator>-&gt;</operator><name>segment_db_info</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>segInfo</name><operator>-&gt;</operator><name>config</name><operator>-&gt;</operator><name>segindex</name></name> <operator>==</operator> <name>content</name> <operator>&amp;&amp;</operator> <name><name>segInfo</name><operator>-&gt;</operator><name>config</name><operator>-&gt;</operator><name>dbid</name></name> <operator>!=</operator> <name>dbid</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* found it */</comment>
			<return>return <expr><name>segInfo</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>FtsMessageState</name></type>
<name>nextSuccessState</name><parameter_list>(<parameter><decl><type><name>FtsMessageState</name></type> <name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FtsMessageState</name></type> <name>result</name> <init>= <expr><name>FTS_PROBE_FAILED</name></expr></init></decl>;</decl_stmt> <comment type="block">/* to shut up compiler */</comment>
	<switch>switch<condition>(<expr><name>state</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>FTS_PROBE_SEGMENT</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <name>FTS_PROBE_SUCCESS</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>FTS_SYNCREP_OFF_SEGMENT</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <name>FTS_SYNCREP_OFF_SUCCESS</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>FTS_PROMOTE_SEGMENT</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <name>FTS_PROMOTE_SUCCESS</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>FTS_PROBE_RETRY_WAIT</name></expr>:</case>
		<case>case <expr><name>FTS_SYNCREP_OFF_RETRY_WAIT</name></expr>:</case>
		<case>case <expr><name>FTS_PROMOTE_RETRY_WAIT</name></expr>:</case>
		<case>case <expr><name>FTS_PROBE_SUCCESS</name></expr>:</case>
		<case>case <expr><name>FTS_SYNCREP_OFF_SUCCESS</name></expr>:</case>
		<case>case <expr><name>FTS_PROMOTE_SUCCESS</name></expr>:</case>
		<case>case <expr><name>FTS_PROBE_FAILED</name></expr>:</case>
		<case>case <expr><name>FTS_SYNCREP_OFF_FAILED</name></expr>:</case>
		<case>case <expr><name>FTS_PROMOTE_FAILED</name></expr>:</case>
		<case>case <expr><name>FTS_RESPONSE_PROCESSED</name></expr>:</case>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cannot determine next success state for %d"</literal></expr></argument>, <argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>FtsMessageState</name></type>
<name>nextFailedState</name><parameter_list>(<parameter><decl><type><name>FtsMessageState</name></type> <name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FtsMessageState</name></type> <name>result</name> <init>= <expr><name>FTS_PROBE_FAILED</name></expr></init></decl>;</decl_stmt> <comment type="block">/* to shut up compiler */</comment>
	<switch>switch<condition>(<expr><name>state</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>FTS_PROBE_SEGMENT</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <name>FTS_PROBE_FAILED</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>FTS_SYNCREP_OFF_SEGMENT</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <name>FTS_SYNCREP_OFF_FAILED</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>FTS_PROMOTE_SEGMENT</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <name>FTS_PROMOTE_FAILED</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>FTS_PROBE_FAILED</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <name>FTS_PROBE_FAILED</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>FTS_SYNCREP_OFF_FAILED</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <name>FTS_SYNCREP_OFF_FAILED</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>FTS_PROMOTE_FAILED</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <name>FTS_PROMOTE_FAILED</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>FTS_PROBE_RETRY_WAIT</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <name>FTS_PROBE_FAILED</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>FTS_SYNCREP_OFF_RETRY_WAIT</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <name>FTS_SYNCREP_OFF_FAILED</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>FTS_PROMOTE_RETRY_WAIT</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <name>FTS_PROMOTE_FAILED</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>FTS_PROBE_SUCCESS</name></expr>:</case>
		<case>case <expr><name>FTS_SYNCREP_OFF_SUCCESS</name></expr>:</case>
		<case>case <expr><name>FTS_PROMOTE_SUCCESS</name></expr>:</case>
		<case>case <expr><name>FTS_RESPONSE_PROCESSED</name></expr>:</case>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cannot determine next failed state for %d"</literal></expr></argument>, <argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>allDone</name><parameter_list>(<parameter><decl><type><name>fts_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>result</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>context</name><operator>-&gt;</operator><name>num_pairs</name></name> <operator>&amp;&amp;</operator> <name>result</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<comment type="block">/*
		 * If any segment is not in a final state, return false.
		 */</comment>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name><name>context</name><operator>-&gt;</operator><name>perSegInfos</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>state</name> <operator>==</operator> <name>FTS_RESPONSE_PROCESSED</name><operator>)</operator></expr>;</expr_stmt>
	</block_content>}</block></for>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Establish async libpq connection to a segment
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ftsConnectStart</name><parameter_list>(<parameter><decl><type><name>fts_segment_info</name> <modifier>*</modifier></type><name>ftsInfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type> <name><name>conninfo</name><index>[<expr><literal type="number">1024</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>hostip</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * No events should be pending on the connection that hasn't started
	 * yet.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>ftsInfo</name><operator>-&gt;</operator><name>poll_revents</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/*
	 * The segment acting as primary should be the one to receive PROBE or
	 * SYNCREP_OFF messages.
	 */</comment>
	<expr_stmt><expr><call><name>AssertImply</name><argument_list>(<argument><expr><name><name>ftsInfo</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>FTS_PROBE_SEGMENT</name> <operator>||</operator>
				<name><name>ftsInfo</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>FTS_SYNCREP_OFF_SEGMENT</name></expr></argument>,
				<argument><expr><call><name>SEGMENT_IS_ACTIVE_PRIMARY</name><argument_list>(<argument><expr><name><name>ftsInfo</name><operator>-&gt;</operator><name>primary_cdbinfo</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>hostip</name> <operator>=</operator> <name><name>ftsInfo</name><operator>-&gt;</operator><name>primary_cdbinfo</name><operator>-&gt;</operator><name>config</name><operator>-&gt;</operator><name>hostip</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>conninfo</name></expr></argument>, <argument><expr><literal type="number">1024</literal></expr></argument>, <argument><expr><literal type="string">"host=%s port=%d gpconntype=%s"</literal></expr></argument>,
			 <argument><expr><ternary><condition><expr><name>hostip</name></expr> ?</condition><then> <expr><name>hostip</name></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>, <argument><expr><name><name>ftsInfo</name><operator>-&gt;</operator><name>primary_cdbinfo</name><operator>-&gt;</operator><name>config</name><operator>-&gt;</operator><name>port</name></name></expr></argument>,
			 <argument><expr><name>GPCONN_TYPE_FTS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ftsInfo</name><operator>-&gt;</operator><name>conn</name></name> <operator>=</operator> <call><name>PQconnectStart</name><argument_list>(<argument><expr><name>conninfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>ftsInfo</name><operator>-&gt;</operator><name>conn</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"FTS: cannot create libpq connection object, possibly out"</literal>
			 <literal type="string">" of memory (content=%d, dbid=%d)"</literal></expr></argument>,
			 <argument><expr><name><name>ftsInfo</name><operator>-&gt;</operator><name>primary_cdbinfo</name><operator>-&gt;</operator><name>config</name><operator>-&gt;</operator><name>segindex</name></name></expr></argument>,
			 <argument><expr><name><name>ftsInfo</name><operator>-&gt;</operator><name>primary_cdbinfo</name><operator>-&gt;</operator><name>config</name><operator>-&gt;</operator><name>dbid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>ftsInfo</name><operator>-&gt;</operator><name>conn</name><operator>-&gt;</operator><name>status</name></name> <operator>==</operator> <name>CONNECTION_BAD</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"FTS: cannot establish libpq connection to "</literal>
			 <literal type="string">"(content=%d, dbid=%d): %s"</literal></expr></argument>,
			 <argument><expr><name><name>ftsInfo</name><operator>-&gt;</operator><name>primary_cdbinfo</name><operator>-&gt;</operator><name>config</name><operator>-&gt;</operator><name>segindex</name></name></expr></argument>, <argument><expr><name><name>ftsInfo</name><operator>-&gt;</operator><name>primary_cdbinfo</name><operator>-&gt;</operator><name>config</name><operator>-&gt;</operator><name>dbid</name></name></expr></argument>,
			 <argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name><name>ftsInfo</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Connection started, we must wait until the socket becomes ready for
	 * writing before anything can be written on this socket.  Therefore, mark
	 * the connection to be considered for subsequent poll step.
	 */</comment>
	<expr_stmt><expr><name><name>ftsInfo</name><operator>-&gt;</operator><name>poll_events</name></name> <operator>|=</operator> <name>POLLOUT</name></expr>;</expr_stmt>
	<comment type="block">/*
	 * Start the timer.
	 */</comment>
	<expr_stmt><expr><name><name>ftsInfo</name><operator>-&gt;</operator><name>startTime</name></name> <operator>=</operator> <operator>(</operator><name>pg_time_t</name><operator>)</operator> <call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Check if the primary segment is restarting normally by examing the PQ error message.
 * It could be that they are in RESET (waiting for the children to exit) or making 
 * progress in RECOVERY. Note there is no good source of RESET progress indications 
 * that we could check, so we simply always allow it. Normally RESET should be fast 
 * and there's a timeout in postmaster to guard against long wait.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>checkIfFailedDueToNormalRestart</name><parameter_list>(<parameter><decl><type><name>fts_segment_info</name> <modifier>*</modifier></type><name>ftsInfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>strstr</name><argument_list>(<argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name><name>ftsInfo</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><name>POSTMASTER_IN_RECOVERY_MSG</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>||</operator>
		<call><name>strstr</name><argument_list>(<argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name><name>ftsInfo</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><name>POSTMASTER_IN_STARTUP_MSG</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>XLogRecPtr</name></type> <name>tmpptr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ptr</name> <init>= <expr><call><name>strstr</name><argument_list>(<argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name><name>ftsInfo</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>POSTMASTER_IN_RECOVERY_DETAIL_MSG</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint32</name></type>		<name>tmp_xlogid</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint32</name></type>		<name>tmp_xrecoff</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ptr</name> <operator>==</operator> <name>NULL</name><operator>)</operator> <operator>||</operator>
		    <call><name>sscanf</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>POSTMASTER_IN_RECOVERY_DETAIL_MSG</name> <literal type="string">" %X/%X\n"</literal></expr></argument>,
		    <argument><expr><operator>&amp;</operator><name>tmp_xlogid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmp_xrecoff</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">2</literal></expr>)</condition>
		<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ASSERT_CHECKING</name></cpp:ifdef>
			<macro><name>elog</name><argument_list>(<argument>ERROR</argument>,
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
			<argument>elog(LOG,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
				<literal type="string">"invalid in-recovery message %s "</literal>
				<literal type="string">"(content=%d, dbid=%d) state=%d"</literal>,
				PQerrorMessage(ftsInfo-&gt;conn),
				ftsInfo-&gt;primary_cdbinfo-&gt;config-&gt;segindex,
				ftsInfo-&gt;primary_cdbinfo-&gt;config-&gt;dbid,
				ftsInfo-&gt;state);
			return;
		}
		tmpptr = ((uint64) tmp_xlogid) &lt;&lt; <literal type="number">32</literal> | (uint64) tmp_xrecoff;

		<comment type="block">/*
		 * If the xlog record returned from the primary is less than or
		 * equal to the xlog record we had saved from the last probe
		 * then we assume that recovery is not making progress. In the
		 * case of rolling panics on the primary the returned xlog
		 * location can be less than the recorded xlog location. In
		 * these cases of rolling panic or recovery hung we want to
		 * mark the primary as down.
		 */</comment>
		if (tmpptr &lt;= ftsInfo-&gt;xlogrecptr)
		{
			ftsInfo-&gt;restart_state = PM_IN_RECOVERY_NOT_MAKING_PROGRESS;
			elog(LOG, <literal type="string">"FTS: detected segment is in recovery mode and not making progress (content=%d) "</literal>
				 <literal type="string">"primary dbid=%d, mirror dbid=%d"</literal>,
				 ftsInfo-&gt;primary_cdbinfo-&gt;config-&gt;segindex,
				 ftsInfo-&gt;primary_cdbinfo-&gt;config-&gt;dbid,
				 ftsInfo-&gt;mirror_cdbinfo-&gt;config-&gt;dbid);
		}
		else
		{
			ftsInfo-&gt;restart_state = PM_IN_RECOVERY_MAKING_PROGRESS;
			ftsInfo-&gt;xlogrecptr = tmpptr;
			elogif(gp_log_fts &gt;= GPVARS_VERBOSITY_VERBOSE, LOG,
				   <literal type="string">"FTS: detected segment is in recovery mode replayed (%X/%X) (content=%d) "</literal>
				   <literal type="string">"primary dbid=%d, mirror dbid=%d"</literal>,
				   (uint32) (tmpptr &gt;&gt; <literal type="number">32</literal>),
				   (uint32) tmpptr,
				   ftsInfo-&gt;primary_cdbinfo-&gt;config-&gt;segindex,
				   ftsInfo-&gt;primary_cdbinfo-&gt;config-&gt;dbid,
				   ftsInfo-&gt;mirror_cdbinfo-&gt;config-&gt;dbid);
		}
	}
	else if (strstr(PQerrorMessage(ftsInfo-&gt;conn), _(POSTMASTER_IN_RESET_MSG)))
	{
		ftsInfo-&gt;restart_state = PM_IN_RESETTING;
		elog(LOG, <literal type="string">"FTS: detected segment is in RESET state (content=%d) "</literal>
				   <literal type="string">"primary dbid=%d, mirror dbid=%d"</literal>,
				   ftsInfo-&gt;primary_cdbinfo-&gt;config-&gt;segindex,
				   ftsInfo-&gt;primary_cdbinfo-&gt;config-&gt;dbid,
				   ftsInfo-&gt;mirror_cdbinfo-&gt;config-&gt;dbid);
	}
}

<comment type="block">/*
 * Start a libpq connection for each "per segment" object in context.  If the
 * connection is already started for an object, advance libpq state machine for
 * that object by calling PQconnectPoll().  An established libpq connection
 * (authentication complete and ready-for-query received) is identified by: (1)
 * state of the "per segment" object is any of FTS_PROBE_SEGMENT,
 * FTS_SYNCREP_OFF_SEGMENT, FTS_PROMOTE_SEGMENT and (2) PQconnectPoll() returns
 * PGRES_POLLING_OK for the connection.
 *
 * Upon failure, transition that object to a failed state.
 */</comment>
static void
ftsConnect(fts_context *context)
{
	int i;
	for (i = <literal type="number">0</literal>; i &lt; context-&gt;num_pairs; i++)
	{
		fts_segment_info *ftsInfo = &amp;context-&gt;perSegInfos[i];
		elogif(gp_log_fts == GPVARS_VERBOSITY_DEBUG, LOG,
			   <literal type="string">"FTS: ftsConnect (content=%d, dbid=%d) state=%d, "</literal>
			   <literal type="string">"retry_count=%d, conn-&gt;status=%d"</literal>,
			   ftsInfo-&gt;primary_cdbinfo-&gt;config-&gt;segindex,
			   ftsInfo-&gt;primary_cdbinfo-&gt;config-&gt;dbid,
			   ftsInfo-&gt;state, ftsInfo-&gt;retry_count,
			   ftsInfo-&gt;conn ? ftsInfo-&gt;conn-&gt;status : -<literal type="number">1</literal>);
		if (ftsInfo-&gt;conn &amp;&amp; PQstatus(ftsInfo-&gt;conn) == CONNECTION_OK)
			continue;
		switch(ftsInfo-&gt;state)
		{
			case FTS_PROBE_SEGMENT:
			case FTS_SYNCREP_OFF_SEGMENT:
			case FTS_PROMOTE_SEGMENT:
				<comment type="block">/*
				 * We always default to PM_NOT_IN_RESTART.  If connect fails, we then check
				 * the primary's restarting state, so we can skip promoting mirror if it's in
				 * PM_IN_RESETTING or PM_IN_RECOVERY_MAKING_PROGRESS.
				 */</comment>
				ftsInfo-&gt;restart_state = PM_NOT_IN_RESTART;
				if (ftsInfo-&gt;conn == NULL)
				{
					AssertImply(ftsInfo-&gt;retry_count &gt; <literal type="number">0</literal>,
								ftsInfo-&gt;retry_count &lt;= gp_fts_probe_retries);
					if (!ftsConnectStart(ftsInfo))
						ftsInfo-&gt;state = nextFailedState(ftsInfo-&gt;state);
				}
				else if (ftsInfo-&gt;poll_revents &amp; (POLLOUT | POLLIN))
				{
					switch(PQconnectPoll(ftsInfo-&gt;conn))
					{
						case PGRES_POLLING_OK:
							<comment type="block">/*
							 * Response-state is already set and now the
							 * connection is also ready with authentication
							 * completed.  Next step should now be able to send
							 * the appropriate FTS message.
							 */</comment>
							elogif(gp_log_fts == GPVARS_VERBOSITY_DEBUG, LOG,
								   <literal type="string">"FTS: established libpq connection "</literal>
								   <literal type="string">"(content=%d, dbid=%d) state=%d, "</literal>
								   <literal type="string">"retry_count=%d, conn-&gt;status=%d"</literal>,
								   ftsInfo-&gt;primary_cdbinfo-&gt;config-&gt;segindex,
								   ftsInfo-&gt;primary_cdbinfo-&gt;config-&gt;dbid,
								   ftsInfo-&gt;state, ftsInfo-&gt;retry_count,
								   ftsInfo-&gt;conn-&gt;status);
							ftsInfo-&gt;poll_events = POLLOUT;
							break;

						case PGRES_POLLING_READING:
							<comment type="block">/*
							 * The connection can now be polled for reading and
							 * if the poll() returns POLLIN in revents, data
							 * has arrived.
							 */</comment>
							ftsInfo-&gt;poll_events |= POLLIN;
							break;

						case PGRES_POLLING_WRITING:
							<comment type="block">/*
							 * The connection can now be polled for writing and
							 * may be written to, if ready.
							 */</comment>
							ftsInfo-&gt;poll_events |= POLLOUT;
							break;

						case PGRES_POLLING_FAILED:
							ftsInfo-&gt;state = nextFailedState(ftsInfo-&gt;state);
							checkIfFailedDueToNormalRestart(ftsInfo);
							elog(LOG, <literal type="string">"FTS: cannot establish libpq connection "</literal>
								 <literal type="string">"(content=%d, dbid=%d): %s, retry_count=%d"</literal>,
								 ftsInfo-&gt;primary_cdbinfo-&gt;config-&gt;segindex,
								 ftsInfo-&gt;primary_cdbinfo-&gt;config-&gt;dbid,
								 PQerrorMessage(ftsInfo-&gt;conn),
								 ftsInfo-&gt;retry_count);
							break;

						default:
							elog(ERROR, <literal type="string">"FTS: invalid response to PQconnectPoll"</literal>
								 <literal type="string">" (content=%d, dbid=%d): %s"</literal>,
								 ftsInfo-&gt;primary_cdbinfo-&gt;config-&gt;segindex,
								 ftsInfo-&gt;primary_cdbinfo-&gt;config-&gt;dbid,
								 PQerrorMessage(ftsInfo-&gt;conn));
							break;
					}
				}
				else
					elogif(gp_log_fts &gt;= GPVARS_VERBOSITY_VERBOSE, LOG,
						   <literal type="string">"FTS: ftsConnect (content=%d, dbid=%d) state=%d, "</literal>
						   <literal type="string">"retry_count=%d, conn-&gt;status=%d pollfd.revents unset"</literal>,
						   ftsInfo-&gt;primary_cdbinfo-&gt;config-&gt;segindex,
						   ftsInfo-&gt;primary_cdbinfo-&gt;config-&gt;dbid,
						   ftsInfo-&gt;state, ftsInfo-&gt;retry_count,
						   ftsInfo-&gt;conn ? ftsInfo-&gt;conn-&gt;status : -<literal type="number">1</literal>);
				break;
			case FTS_PROBE_SUCCESS:
			case FTS_SYNCREP_OFF_SUCCESS:
			case FTS_PROMOTE_SUCCESS:
			case FTS_PROBE_FAILED:
			case FTS_SYNCREP_OFF_FAILED:
			case FTS_PROMOTE_FAILED:
			case FTS_PROBE_RETRY_WAIT:
			case FTS_SYNCREP_OFF_RETRY_WAIT:
			case FTS_PROMOTE_RETRY_WAIT:
			case FTS_RESPONSE_PROCESSED:
				break;
		}
	}
}

<comment type="block">/*
 * Timeout is said to have occurred if greater than gp_fts_probe_timeout
 * seconds have elapsed since connection start and a response is not received.
 * Segments for which a response is received already are exempted from timeout
 * evaluation.
 */</comment>
static void
ftsCheckTimeout(fts_segment_info *ftsInfo, pg_time_t now)
{
	if (!IsFtsMessageStateSuccess(ftsInfo-&gt;state) &amp;&amp;
		(int) (now - ftsInfo-&gt;startTime) &gt; gp_fts_probe_timeout)
	{
		elog(LOG,
			 <literal type="string">"FTS timeout detected for (content=%d, dbid=%d) "</literal>
			 <literal type="string">"state=%d, retry_count=%d,"</literal>,
			 ftsInfo-&gt;primary_cdbinfo-&gt;config-&gt;segindex,
			 ftsInfo-&gt;primary_cdbinfo-&gt;config-&gt;dbid, ftsInfo-&gt;state,
			 ftsInfo-&gt;retry_count);
		ftsInfo-&gt;state = nextFailedState(ftsInfo-&gt;state);
	}
}

static void
ftsPoll(fts_context *context)
{
	int i;
	int nfds=<literal type="number">0</literal>;
	int nready;
	for (i = <literal type="number">0</literal>; i &lt; context-&gt;num_pairs; i++)
	{
		fts_segment_info *ftsInfo = &amp;context-&gt;perSegInfos[i];
		if (ftsInfo-&gt;poll_events &amp; (POLLIN|POLLOUT))
		{
			PollFds[nfds].fd = PQsocket(ftsInfo-&gt;conn);
			PollFds[nfds].events = ftsInfo-&gt;poll_events;
			PollFds[nfds].revents = <literal type="number">0</literal>;
			ftsInfo-&gt;fd_index = nfds;
			nfds++;
		}
		else
			ftsInfo-&gt;fd_index = -<literal type="number">1</literal>; <comment type="block">/*
									 * This socket is not considered for
									 * polling.
									 */</comment>
	}
	if (nfds == <literal type="number">0</literal>)
		return;

	nready = poll(PollFds, nfds, <literal type="number">50</literal>);
	if (nready &lt; <literal type="number">0</literal>)
	{
		if (errno == EINTR)
		{
			elogif(gp_log_fts == GPVARS_VERBOSITY_DEBUG, LOG,
				   <literal type="string">"FTS: ftsPoll() interrupted, nfds %d"</literal>, nfds);
		}
		else
			elog(ERROR, <literal type="string">"FTS: ftsPoll() failed: nfds %d, %m"</literal>, nfds);
	}
	else if (nready == <literal type="number">0</literal>)
	{
		elogif(gp_log_fts == GPVARS_VERBOSITY_DEBUG, LOG,
			   <literal type="string">"FTS: ftsPoll() timed out, nfds %d"</literal>, nfds);
	}

	elogif(gp_log_fts == GPVARS_VERBOSITY_DEBUG, LOG,
		   <literal type="string">"FTS: ftsPoll() found %d out of %d sockets ready"</literal>,
		   nready, nfds);

	pg_time_t now = (pg_time_t) time(NULL);

	<comment type="block">/* Record poll() response poll_revents for each "per_segment" object. */</comment>
	for (i = <literal type="number">0</literal>; i &lt; context-&gt;num_pairs; i++)
	{
		fts_segment_info *ftsInfo = &amp;context-&gt;perSegInfos[i];

		if (ftsInfo-&gt;poll_events &amp; (POLLIN|POLLOUT))
		{
			Assert(PollFds[ftsInfo-&gt;fd_index].fd == PQsocket(ftsInfo-&gt;conn));
			ftsInfo-&gt;poll_revents = PollFds[ftsInfo-&gt;fd_index].revents;
			<comment type="block">/*
			 * Reset poll_events for fds that were found ready.  Assume
			 * that at the most one bit is set in poll_events (POLLIN
			 * or POLLOUT).
			 */</comment>
			if (ftsInfo-&gt;poll_revents &amp; ftsInfo-&gt;poll_events)
			{
				ftsInfo-&gt;poll_events = <literal type="number">0</literal>;
			}
			else if (ftsInfo-&gt;poll_revents &amp; (POLLHUP | POLLERR))
			{
				ftsInfo-&gt;state = nextFailedState(ftsInfo-&gt;state);
				elog(LOG,
					 <literal type="string">"FTS poll failed (revents=%d, events=%d) for "</literal>
					 <literal type="string">"(content=%d, dbid=%d) state=%d, retry_count=%d, "</literal>
					 <literal type="string">"libpq status=%d, asyncStatus=%d"</literal>,
					 ftsInfo-&gt;poll_revents, ftsInfo-&gt;poll_events,
					 ftsInfo-&gt;primary_cdbinfo-&gt;config-&gt;segindex,
					 ftsInfo-&gt;primary_cdbinfo-&gt;config-&gt;dbid, ftsInfo-&gt;state,
					 ftsInfo-&gt;retry_count, ftsInfo-&gt;conn-&gt;status,
					 ftsInfo-&gt;conn-&gt;asyncStatus);
			}
			else if (ftsInfo-&gt;poll_revents)
			{
				ftsInfo-&gt;state = nextFailedState(ftsInfo-&gt;state);
				elog(LOG,
					 <literal type="string">"FTS unexpected events (revents=%d, events=%d) for "</literal>
					 <literal type="string">"(content=%d, dbid=%d) state=%d, retry_count=%d, "</literal>
					 <literal type="string">"libpq status=%d, asyncStatus=%d"</literal>,
					 ftsInfo-&gt;poll_revents, ftsInfo-&gt;poll_events,
					 ftsInfo-&gt;primary_cdbinfo-&gt;config-&gt;segindex,
					 ftsInfo-&gt;primary_cdbinfo-&gt;config-&gt;dbid, ftsInfo-&gt;state,
					 ftsInfo-&gt;retry_count, ftsInfo-&gt;conn-&gt;status,
					 ftsInfo-&gt;conn-&gt;asyncStatus);
			}
			<comment type="block">/* If poll timed-out above, check timeout */</comment>
			ftsCheckTimeout(ftsInfo, now);
		}
	}
}

<comment type="block">/*
 * Send FTS query
 */</comment>
static void
ftsSend(fts_context *context)
{
	fts_segment_info *ftsInfo;
	const char *message_type;
	char message[FTS_MSG_MAX_LEN];
	int i;

	for (i = <literal type="number">0</literal>; i &lt; context-&gt;num_pairs; i++)
	{
		ftsInfo = &amp;context-&gt;perSegInfos[i];
		elogif(gp_log_fts == GPVARS_VERBOSITY_DEBUG, LOG,
			   <literal type="string">"FTS: ftsSend (content=%d, dbid=%d) state=%d, "</literal>
			   <literal type="string">"retry_count=%d, conn-&gt;asyncStatus=%d"</literal>,
			   ftsInfo-&gt;primary_cdbinfo-&gt;config-&gt;segindex,
			   ftsInfo-&gt;primary_cdbinfo-&gt;config-&gt;dbid,
			   ftsInfo-&gt;state, ftsInfo-&gt;retry_count,
			   ftsInfo-&gt;conn ? ftsInfo-&gt;conn-&gt;asyncStatus : -<literal type="number">1</literal>);
		switch(ftsInfo-&gt;state)
		{
			case FTS_PROBE_SEGMENT:
			case FTS_SYNCREP_OFF_SEGMENT:
			case FTS_PROMOTE_SEGMENT:
				<comment type="block">/*
				 * The libpq connection must be ready for accepting query and
				 * the socket must be writable.
				 */</comment>
				if (PQstatus(ftsInfo-&gt;conn) != CONNECTION_OK ||
					ftsInfo-&gt;conn-&gt;asyncStatus != PGASYNC_IDLE ||
				    !(ftsInfo-&gt;poll_revents &amp; POLLOUT))
					break;
				if (ftsInfo-&gt;state == FTS_PROBE_SEGMENT)
					message_type = FTS_MSG_PROBE;
				else if (ftsInfo-&gt;state == FTS_SYNCREP_OFF_SEGMENT)
					message_type = FTS_MSG_SYNCREP_OFF;
				else
					message_type = FTS_MSG_PROMOTE;

				snprintf(message, FTS_MSG_MAX_LEN, FTS_MSG_FORMAT,
						 message_type,
						 ftsInfo-&gt;primary_cdbinfo-&gt;config-&gt;dbid,
						 ftsInfo-&gt;primary_cdbinfo-&gt;config-&gt;segindex);

				if (PQsendQuery(ftsInfo-&gt;conn, message))
				{
					<comment type="block">/*
					 * Message sent successfully, mark the socket to be polled
					 * for reading so we will be ready to read response when it
					 * arrives.
					 */</comment>
					ftsInfo-&gt;poll_events = POLLIN;
					elogif(gp_log_fts &gt;= GPVARS_VERBOSITY_VERBOSE, LOG,
						   <literal type="string">"FTS sent %s to (content=%d, dbid=%d), retry_count=%d"</literal>,
						   message, ftsInfo-&gt;primary_cdbinfo-&gt;config-&gt;segindex,
						   ftsInfo-&gt;primary_cdbinfo-&gt;config-&gt;dbid, ftsInfo-&gt;retry_count);
				}
				else
				{
					elog(LOG,
						 <literal type="string">"FTS: failed to send %s to segment (content=%d, "</literal>
						 <literal type="string">"dbid=%d) state=%d, retry_count=%d, "</literal>
						 <literal type="string">"conn-&gt;asyncStatus=%d %s"</literal>, message,
						 ftsInfo-&gt;primary_cdbinfo-&gt;config-&gt;segindex,
						 ftsInfo-&gt;primary_cdbinfo-&gt;config-&gt;dbid,
						 ftsInfo-&gt;state, ftsInfo-&gt;retry_count,
						 ftsInfo-&gt;conn-&gt;asyncStatus,
						 PQerrorMessage(ftsInfo-&gt;conn));
					ftsInfo-&gt;state = nextFailedState(ftsInfo-&gt;state);
				}
				break;
			default:
				<comment type="block">/* Cannot send messages in any other state. */</comment>
				break;
		}
	}
}

<comment type="block">/*
 * Record FTS handler's response from libpq result into fts_result
 */</comment>
static void
probeRecordResponse(fts_segment_info *ftsInfo, PGresult *result)
{
	ftsInfo-&gt;result.isPrimaryAlive = true;

	ftsInfo-&gt;result.isMirrorAlive = *PQgetvalue(result, <literal type="number">0</literal>,
			Anum_fts_message_response_is_mirror_up);

	ftsInfo-&gt;result.isInSync = *PQgetvalue(result, <literal type="number">0</literal>,
			Anum_fts_message_response_is_in_sync);

	ftsInfo-&gt;result.isSyncRepEnabled = *PQgetvalue(result, <literal type="number">0</literal>,
			Anum_fts_message_response_is_syncrep_enabled);

	ftsInfo-&gt;result.isRoleMirror = *PQgetvalue(result, <literal type="number">0</literal>,
			Anum_fts_message_response_is_role_mirror);

	ftsInfo-&gt;result.retryRequested = *PQgetvalue(result, <literal type="number">0</literal>,
			Anum_fts_message_response_request_retry);

	elogif(gp_log_fts &gt;= GPVARS_VERBOSITY_DEBUG, LOG,
		   <literal type="string">"FTS: segment (content=%d, dbid=%d, role=%c) reported "</literal>
		   <literal type="string">"isMirrorUp %d, isInSync %d, isSyncRepEnabled %d, "</literal>
		   <literal type="string">"isRoleMirror %d, and retryRequested %d to the prober."</literal>,
		   ftsInfo-&gt;primary_cdbinfo-&gt;config-&gt;segindex,
		   ftsInfo-&gt;primary_cdbinfo-&gt;config-&gt;dbid,
		   ftsInfo-&gt;primary_cdbinfo-&gt;config-&gt;role,
		   ftsInfo-&gt;result.isMirrorAlive,
		   ftsInfo-&gt;result.isInSync,
		   ftsInfo-&gt;result.isSyncRepEnabled,
		   ftsInfo-&gt;result.isRoleMirror,
		   ftsInfo-&gt;result.retryRequested);
}

<comment type="block">/*
 * Receive segment response
 */</comment>
static void
ftsReceive(fts_context *context)
{
	fts_segment_info *ftsInfo;
	PGresult *result = NULL;
	int ntuples;
	int nfields;
	int i;

	for (i = <literal type="number">0</literal>; i &lt; context-&gt;num_pairs; i++)
	{
		ftsInfo = &amp;context-&gt;perSegInfos[i];
		elogif(gp_log_fts == GPVARS_VERBOSITY_DEBUG, LOG,
			   <literal type="string">"FTS: ftsReceive (content=%d, dbid=%d) state=%d, "</literal>
			   <literal type="string">"retry_count=%d, conn-&gt;asyncStatus=%d"</literal>,
			   ftsInfo-&gt;primary_cdbinfo-&gt;config-&gt;segindex,
			   ftsInfo-&gt;primary_cdbinfo-&gt;config-&gt;dbid,
			   ftsInfo-&gt;state, ftsInfo-&gt;retry_count,
			   ftsInfo-&gt;conn ? ftsInfo-&gt;conn-&gt;asyncStatus : -<literal type="number">1</literal>);
		switch(ftsInfo-&gt;state)
		{
			case FTS_PROBE_SEGMENT:
			case FTS_SYNCREP_OFF_SEGMENT:
			case FTS_PROMOTE_SEGMENT:
				<comment type="block">/*
				 * The libpq connection must be established and a message must
				 * have arrived on the socket.
				 */</comment>
				if (PQstatus(ftsInfo-&gt;conn) != CONNECTION_OK ||
					!(ftsInfo-&gt;poll_revents &amp; POLLIN))
					break;
				<comment type="block">/* Read the response that has arrived. */</comment>
				if (!PQconsumeInput(ftsInfo-&gt;conn))
				{
					elog(LOG, <literal type="string">"FTS: failed to read from (content=%d, dbid=%d)"</literal>
						 <literal type="string">" state=%d, retry_count=%d, conn-&gt;asyncStatus=%d %s"</literal>,
						 ftsInfo-&gt;primary_cdbinfo-&gt;config-&gt;segindex,
						 ftsInfo-&gt;primary_cdbinfo-&gt;config-&gt;dbid,
						 ftsInfo-&gt;state, ftsInfo-&gt;retry_count,
						 ftsInfo-&gt;conn-&gt;asyncStatus,
						 PQerrorMessage(ftsInfo-&gt;conn));
					ftsInfo-&gt;state = nextFailedState(ftsInfo-&gt;state);
					break;
				}
				<comment type="block">/* Parse the response. */</comment>
				if (PQisBusy(ftsInfo-&gt;conn))
				{
					<comment type="block">/*
					 * There is not enough data in the buffer.
					 */</comment>
					break;
				}

				<comment type="block">/*
				 * Response parsed, PQgetResult() should not block for I/O now.
				 */</comment>
				result = PQgetResult(ftsInfo-&gt;conn);

				if (!result || PQstatus(ftsInfo-&gt;conn) == CONNECTION_BAD)
				{
					elog(LOG, <literal type="string">"FTS: error getting results from (content=%d, "</literal>
						 <literal type="string">"dbid=%d) state=%d, retry_count=%d, "</literal>
						 <literal type="string">"conn-&gt;asyncStatus=%d conn-&gt;status=%d %s"</literal>,
						 ftsInfo-&gt;primary_cdbinfo-&gt;config-&gt;segindex,
						 ftsInfo-&gt;primary_cdbinfo-&gt;config-&gt;dbid,
						 ftsInfo-&gt;state, ftsInfo-&gt;retry_count,
						 ftsInfo-&gt;conn-&gt;asyncStatus,
						 ftsInfo-&gt;conn-&gt;status,
						 PQerrorMessage(ftsInfo-&gt;conn));
					ftsInfo-&gt;state = nextFailedState(ftsInfo-&gt;state);
					break;
				}

				if (PQresultStatus(result) != PGRES_TUPLES_OK)
				{
					elog(LOG, <literal type="string">"FTS: error response from (content=%d, dbid=%d)"</literal>
						 <literal type="string">" state=%d, retry_count=%d, conn-&gt;asyncStatus=%d %s"</literal>,
						 ftsInfo-&gt;primary_cdbinfo-&gt;config-&gt;segindex,
						 ftsInfo-&gt;primary_cdbinfo-&gt;config-&gt;dbid,
						 ftsInfo-&gt;state, ftsInfo-&gt;retry_count,
						 ftsInfo-&gt;conn-&gt;asyncStatus,
						 PQresultErrorMessage(result));
					ftsInfo-&gt;state = nextFailedState(ftsInfo-&gt;state);
					break;
				}
				ntuples = PQntuples(result);
				nfields = PQnfields(result);
				if (nfields != Natts_fts_message_response ||
					ntuples != FTS_MESSAGE_RESPONSE_NTUPLES)
				{
					<comment type="block">/*
					 * XXX: Investigate: including conn-&gt;asyncStatus generated
					 * a format string warning at compile time.
					 */</comment>
					elog(LOG, <literal type="string">"FTS: invalid response from (content=%d, dbid=%d)"</literal>
						 <literal type="string">" state=%d, retry_count=%d, expected %d tuple with "</literal>
						 <literal type="string">"%d fields, got %d tuples with %d fields"</literal>,
						 ftsInfo-&gt;primary_cdbinfo-&gt;config-&gt;segindex,
						 ftsInfo-&gt;primary_cdbinfo-&gt;config-&gt;dbid,
						 ftsInfo-&gt;state, ftsInfo-&gt;retry_count,
						 FTS_MESSAGE_RESPONSE_NTUPLES,
						 Natts_fts_message_response, ntuples, nfields);
					ftsInfo-&gt;state = nextFailedState(ftsInfo-&gt;state);
					break;
				}
				<comment type="block">/*
				 * Result received and parsed successfully.  Record it so that
				 * subsequent step processes it and transitions to next state.
				 */</comment>
				probeRecordResponse(ftsInfo, result);
				ftsInfo-&gt;state = nextSuccessState(ftsInfo-&gt;state);
				break;
			default:
				<comment type="block">/* Cannot receive response in any other state. */</comment>
				break;
		}

		<comment type="block">/*
		 * Reference to the result should already be stored in
		 * connection object. If it is not then free explicitly.
		 */</comment>
		if (result &amp;&amp; result != ftsInfo-&gt;conn-&gt;result)
		{
			PQclear(result);
			result = NULL;
		}
	}
}

static void
retryForFtsFailed(fts_segment_info *ftsInfo, pg_time_t now)
{
	if (ftsInfo-&gt;retry_count == gp_fts_probe_retries)
	{
		elog(LOG, <literal type="string">"FTS max (%d) retries exhausted "</literal>
			<literal type="string">"(content=%d, dbid=%d) state=%d"</literal>,
			ftsInfo-&gt;retry_count,
			ftsInfo-&gt;primary_cdbinfo-&gt;config-&gt;segindex,
			ftsInfo-&gt;primary_cdbinfo-&gt;config-&gt;dbid, ftsInfo-&gt;state);
		return;
	}

	ftsInfo-&gt;retry_count++;
	if (ftsInfo-&gt;state == FTS_PROBE_SUCCESS ||
		ftsInfo-&gt;state == FTS_PROBE_FAILED)
		ftsInfo-&gt;state = FTS_PROBE_RETRY_WAIT;
	else if (ftsInfo-&gt;state == FTS_SYNCREP_OFF_FAILED)
		ftsInfo-&gt;state = FTS_SYNCREP_OFF_RETRY_WAIT;
	else
		ftsInfo-&gt;state = FTS_PROMOTE_RETRY_WAIT;
	ftsInfo-&gt;retryStartTime = now;
	elogif(gp_log_fts == GPVARS_VERBOSITY_DEBUG, LOG,
		<literal type="string">"FTS initialized retry start time to now "</literal>
		<literal type="string">"(content=%d, dbid=%d) state=%d"</literal>,
		ftsInfo-&gt;primary_cdbinfo-&gt;config-&gt;segindex,
		ftsInfo-&gt;primary_cdbinfo-&gt;config-&gt;dbid, ftsInfo-&gt;state);

	PQfinish(ftsInfo-&gt;conn);
	ftsInfo-&gt;conn = NULL;
	ftsInfo-&gt;poll_events = ftsInfo-&gt;poll_revents = <literal type="number">0</literal>;
	<comment type="block">/* Reset result before next attempt. */</comment>
	memset(&amp;ftsInfo-&gt;result, <literal type="number">0</literal>, sizeof(fts_result));
}

<comment type="block">/*
 * If retry attempts are available, transition the segments to the start state
 * corresponding to their failure state.  If retries have exhausted, leave the
 * segment in the failure state.
 */</comment>
static void
processRetry(fts_context *context)
{
	fts_segment_info *ftsInfo;
	int i;
	pg_time_t now = (pg_time_t) time(NULL);

	for (i = <literal type="number">0</literal>; i &lt; context-&gt;num_pairs; i++)
	{
		ftsInfo = &amp;context-&gt;perSegInfos[i];
		switch(ftsInfo-&gt;state)
		{
			case FTS_PROBE_SUCCESS:
				<comment type="block">/*
				 * Purpose of retryRequested flag is to avoid considering
				 * mirror as down prematurely.  If mirror is already marked
				 * down in configuration, there is no need to retry.
				 */</comment>
				if (!(ftsInfo-&gt;result.retryRequested &amp;&amp;
					  SEGMENT_IS_ALIVE(ftsInfo-&gt;mirror_cdbinfo)))
					break;
				<comment type="block">/* else, fallthrough */</comment>
			case FTS_PROBE_FAILED:
			case FTS_SYNCREP_OFF_FAILED:
			case FTS_PROMOTE_FAILED:
				retryForFtsFailed(ftsInfo, now);
				break;
			case FTS_PROBE_RETRY_WAIT:
			case FTS_SYNCREP_OFF_RETRY_WAIT:
			case FTS_PROMOTE_RETRY_WAIT:
				<comment type="block">/* Wait for 1 second before making another attempt. */</comment>
				if ((int) (now - ftsInfo-&gt;retryStartTime) &lt; <literal type="number">1</literal>)
					break;
				<comment type="block">/*
				 * We have remained in retry state for over a second, it's time
				 * to make another attempt.
				 */</comment>
				elogif(gp_log_fts &gt;= GPVARS_VERBOSITY_VERBOSE, LOG,
					   <literal type="string">"FTS retrying attempt %d (content=%d, dbid=%d) "</literal>
					   <literal type="string">"state=%d"</literal>, ftsInfo-&gt;retry_count,
					   ftsInfo-&gt;primary_cdbinfo-&gt;config-&gt;segindex,
					   ftsInfo-&gt;primary_cdbinfo-&gt;config-&gt;dbid, ftsInfo-&gt;state);
				if (ftsInfo-&gt;state == FTS_PROBE_RETRY_WAIT)
					ftsInfo-&gt;state = FTS_PROBE_SEGMENT;
				else if (ftsInfo-&gt;state == FTS_SYNCREP_OFF_RETRY_WAIT)
					ftsInfo-&gt;state = FTS_SYNCREP_OFF_SEGMENT;
				else
					ftsInfo-&gt;state = FTS_PROMOTE_SEGMENT;
				break;
			default:
				break;
		}
	}
}

<comment type="block">/*
 * Return true for segments whose response is ready to be processed.  Segments
 * whose response is already processed should have response-&gt;conn set to NULL.
 */</comment>
static bool
ftsResponseReady(fts_segment_info *ftsInfo)
{
	return (IsFtsMessageStateSuccess(ftsInfo-&gt;state) ||
			IsFtsMessageStateFailed(ftsInfo-&gt;state));
}

static bool
updateConfiguration(CdbComponentDatabaseInfo *primary,
					CdbComponentDatabaseInfo *mirror,
					char newPrimaryRole, char newMirrorRole,
					bool IsInSync, bool IsPrimaryAlive, bool IsMirrorAlive)
{
	bool UpdatePrimary = (IsPrimaryAlive != SEGMENT_IS_ALIVE(primary));
	bool UpdateMirror = (IsMirrorAlive != SEGMENT_IS_ALIVE(mirror));

	<comment type="block">/*
	 * If probe response state is different from current state in
	 * configuration, update both primary and mirror.
	 */</comment>
	if (IsInSync != SEGMENT_IS_IN_SYNC(primary))
		UpdatePrimary = UpdateMirror = true;

	<comment type="block">/*
	 * A mirror being promoted must be already in-sync in configuration.
	 * Update to the configuration must include mode as not-in-sync and primary
	 * status as down.
	 */</comment>
	AssertImply(newPrimaryRole == GP_SEGMENT_CONFIGURATION_ROLE_MIRROR,
				SEGMENT_IS_IN_SYNC(mirror) &amp;&amp; !IsInSync &amp;&amp; !IsPrimaryAlive);

	<comment type="block">/*
	 * Primary and mirror should always have the same mode in configuration,
	 * either both reflecting in-sync or not in-sync.
	 */</comment>
	Assert(primary-&gt;config-&gt;mode == mirror-&gt;config-&gt;mode);

	bool UpdateNeeded = UpdatePrimary || UpdateMirror;
	<comment type="block">/*
	 * Commit/abort transaction below will destroy
	 * CurrentResourceOwner.  We need it for catalog reads.
	 */</comment>
	ResourceOwner save = CurrentResourceOwner;
	if (UpdateNeeded)
	{
		StartTransactionCommand();
		GetTransactionSnapshot();

		if (UpdatePrimary)
			probeWalRepUpdateConfig(primary-&gt;config-&gt;dbid, primary-&gt;config-&gt;segindex,
									newPrimaryRole, IsPrimaryAlive,
									IsInSync);

		if (UpdateMirror)
			probeWalRepUpdateConfig(mirror-&gt;config-&gt;dbid, mirror-&gt;config-&gt;segindex,
									newMirrorRole, IsMirrorAlive,
									IsInSync);

		CommitTransactionCommand();
		CurrentResourceOwner = save;

		<comment type="block">/*
		 * Update the status to in-memory variable as well used by
		 * dispatcher, now that changes has been persisted to catalog.
		 */</comment>
		Assert(ftsProbeInfo);
		if (IsPrimaryAlive)
			FTS_STATUS_SET_UP(ftsProbeInfo-&gt;status[primary-&gt;config-&gt;dbid]);
		else
			FTS_STATUS_SET_DOWN(ftsProbeInfo-&gt;status[primary-&gt;config-&gt;dbid]);

		if (IsMirrorAlive)
			FTS_STATUS_SET_UP(ftsProbeInfo-&gt;status[mirror-&gt;config-&gt;dbid]);
		else
			FTS_STATUS_SET_DOWN(ftsProbeInfo-&gt;status[mirror-&gt;config-&gt;dbid]);
	}

	return UpdateNeeded;
}

<comment type="block">/*
 * Process responses from primary segments:
 * (a) Transition internal state so that segments can be messaged subsequently
 * (e.g. promotion and turning off syncrep).
 * (b) Update gp_segment_configuration catalog table, if needed.
 */</comment>
static bool
processResponse(fts_context *context)
{
	bool is_updated = false;

	for (int response_index = <literal type="number">0</literal>;
		 response_index &lt; context-&gt;num_pairs &amp;&amp; FtsIsActive();
		 response_index ++)
	{
		fts_segment_info *ftsInfo = &amp;(context-&gt;perSegInfos[response_index]);

		<comment type="block">/*
		 * Consider segments that are in final state (success / failure) and
		 * that are not already processed.
		 */</comment>
		if (!ftsResponseReady(ftsInfo))
			continue;

		<comment type="block">/* All retries must have exhausted before a failure is processed. */</comment>
		AssertImply(IsFtsMessageStateFailed(ftsInfo-&gt;state),
					ftsInfo-&gt;retry_count == gp_fts_probe_retries);

		CdbComponentDatabaseInfo *primary = ftsInfo-&gt;primary_cdbinfo;

		CdbComponentDatabaseInfo *mirror = ftsInfo-&gt;mirror_cdbinfo;

		bool IsPrimaryAlive = ftsInfo-&gt;result.isPrimaryAlive;
		<comment type="block">/* Trust a response from primary only if it's alive. */</comment>
		bool IsMirrorAlive =  IsPrimaryAlive ?
			ftsInfo-&gt;result.isMirrorAlive : SEGMENT_IS_ALIVE(mirror);
		bool IsInSync = IsPrimaryAlive ?
			ftsInfo-&gt;result.isInSync : false;

		<comment type="block">/* If primary and mirror are in sync, then both have to be ALIVE. */</comment>
		AssertImply(IsInSync, IsPrimaryAlive &amp;&amp; IsMirrorAlive);

		switch(ftsInfo-&gt;state)
		{
			case FTS_PROBE_SUCCESS:
				Assert(IsPrimaryAlive);
				if (ftsInfo-&gt;result.isSyncRepEnabled &amp;&amp; !IsMirrorAlive)
				{
					if (!ftsInfo-&gt;result.retryRequested)
					{
						<comment type="block">/*
						 * Primaries that have syncrep enabled continue to block
						 * commits until FTS update the mirror status as down.
						 */</comment>
						is_updated |= updateConfiguration(
							primary, mirror,
							GP_SEGMENT_CONFIGURATION_ROLE_PRIMARY,
							GP_SEGMENT_CONFIGURATION_ROLE_MIRROR,
							IsInSync, IsPrimaryAlive, IsMirrorAlive);
						<comment type="block">/*
						 * If mirror was marked up in configuration, it must have
						 * been marked down by updateConfiguration().
						 */</comment>
						AssertImply(SEGMENT_IS_ALIVE(mirror), is_updated);
						<comment type="block">/*
						 * Now that the configuration is updated, FTS must notify
						 * the primaries to unblock commits by sending syncrep off
						 * message.
						 */</comment>
						ftsInfo-&gt;state = FTS_SYNCREP_OFF_SEGMENT;
						elogif(gp_log_fts &gt;= GPVARS_VERBOSITY_VERBOSE, LOG,
							   <literal type="string">"FTS turning syncrep off on (content=%d, dbid=%d)"</literal>,
							   primary-&gt;config-&gt;segindex, primary-&gt;config-&gt;dbid);
					}
					else
					{
						elogif(gp_log_fts &gt;= GPVARS_VERBOSITY_VERBOSE, LOG,
							   <literal type="string">"FTS skipping mirror down update for (content=%d) as retryRequested"</literal>,
							   primary-&gt;config-&gt;segindex);
						ftsInfo-&gt;state = FTS_RESPONSE_PROCESSED;
					}
				}
				else if (ftsInfo-&gt;result.isRoleMirror)
				{
					<comment type="block">/*
					 * A promote message sent previously didn't make it to the
					 * mirror.  Catalog must have been updated before sending
					 * the previous promote message.
					 */</comment>
					Assert(!IsMirrorAlive);
					Assert(!SEGMENT_IS_ALIVE(mirror));
					Assert(SEGMENT_IS_NOT_INSYNC(mirror));
					Assert(SEGMENT_IS_NOT_INSYNC(primary));
					Assert(!ftsInfo-&gt;result.isSyncRepEnabled);
					elogif(gp_log_fts &gt;= GPVARS_VERBOSITY_VERBOSE, LOG,
						   <literal type="string">"FTS resending promote request to (content=%d,"</literal>
						   <literal type="string">" dbid=%d)"</literal>, primary-&gt;config-&gt;segindex, primary-&gt;config-&gt;dbid);
					ftsInfo-&gt;state = FTS_PROMOTE_SEGMENT;
				}
				else
				{
					<comment type="block">/*
					 * No subsequent state transition needed, update catalog if
					 * necessary.  The cases are mirror status found to change
					 * from down to up, mode found to change from not in-sync
					 * to in-sync or syncrep found to change from off to on.
					 */</comment>
					is_updated |= updateConfiguration(
						primary, mirror,
						GP_SEGMENT_CONFIGURATION_ROLE_PRIMARY,
						GP_SEGMENT_CONFIGURATION_ROLE_MIRROR,
						IsInSync, IsPrimaryAlive, IsMirrorAlive);
					ftsInfo-&gt;state = FTS_RESPONSE_PROCESSED;
				}
				break;
			case FTS_PROBE_FAILED:
				<comment type="block">/* Primary is down */</comment>

				<comment type="block">/* If primary is in resetting or making progress in recovery, do not mark it down and promote mirror */</comment>
				if (ftsInfo-&gt;restart_state == PM_IN_RESETTING)
				{
					Assert(strstr(PQerrorMessage(ftsInfo-&gt;conn), _(POSTMASTER_IN_RESET_MSG)));
					elogif(gp_log_fts &gt;= GPVARS_VERBOSITY_VERBOSE, LOG,
						 <literal type="string">"FTS: detected segment is in resetting mode "</literal>
						 <literal type="string">"(content=%d) primary dbid=%d, mirror dbid=%d"</literal>,
						 primary-&gt;config-&gt;segindex, primary-&gt;config-&gt;dbid, mirror-&gt;config-&gt;dbid);

					ftsInfo-&gt;state = FTS_RESPONSE_PROCESSED;
					break;
				}
				else if (ftsInfo-&gt;restart_state == PM_IN_RECOVERY_MAKING_PROGRESS)
				{
					Assert(strstr(PQerrorMessage(ftsInfo-&gt;conn), _(POSTMASTER_IN_RECOVERY_MSG)) ||
						   strstr(PQerrorMessage(ftsInfo-&gt;conn), _(POSTMASTER_IN_STARTUP_MSG)));
					elogif(gp_log_fts &gt;= GPVARS_VERBOSITY_VERBOSE, LOG,
						 <literal type="string">"FTS: detected segment is in recovery mode and making "</literal>
						 <literal type="string">"progress (content=%d) primary dbid=%d, mirror dbid=%d"</literal>,
						 primary-&gt;config-&gt;segindex, primary-&gt;config-&gt;dbid, mirror-&gt;config-&gt;dbid);

					ftsInfo-&gt;state = FTS_RESPONSE_PROCESSED;
					break;
				}

				Assert(!IsPrimaryAlive);
				<comment type="block">/* See if mirror can be promoted. */</comment>
				if (SEGMENT_IS_IN_SYNC(mirror))
				{
					<comment type="block">/*
					 * Primary and mirror must have been recorded as in-sync
					 * before the probe.
					 */</comment>
					Assert(SEGMENT_IS_IN_SYNC(primary));

					<comment type="block">/*
					 * Flip the roles and mark the failed primary as down in
					 * FTS configuration before sending promote message.
					 * Dispatcher should no longer consider the failed primary
					 * for gang creation, FTS should no longer probe the failed
					 * primary.
					 */</comment>
					is_updated |= updateConfiguration(
						primary, mirror,
						GP_SEGMENT_CONFIGURATION_ROLE_MIRROR, <comment type="block">/* newPrimaryRole */</comment>
						GP_SEGMENT_CONFIGURATION_ROLE_PRIMARY, <comment type="block">/* newMirrorRole */</comment>
						IsInSync, IsPrimaryAlive, IsMirrorAlive);
					Assert(is_updated);

					<comment type="block">/*
					 * Swap the primary and mirror references so that the
					 * mirror will be promoted in subsequent connect, poll,
					 * send, receive steps.
					 */</comment>
					elogif(gp_log_fts &gt;= GPVARS_VERBOSITY_VERBOSE, LOG,
						   <literal type="string">"FTS promoting mirror (content=%d, dbid=%d) "</literal>
						   <literal type="string">"to be the new primary"</literal>,
						   mirror-&gt;config-&gt;segindex, mirror-&gt;config-&gt;dbid);
					ftsInfo-&gt;state = FTS_PROMOTE_SEGMENT;
					ftsInfo-&gt;primary_cdbinfo = mirror;
					ftsInfo-&gt;mirror_cdbinfo = primary;
				}
				else
				{
					<comment type="block">/*
					 * Only log here, will handle it later, having an "ERROR"
					 * keyword here for customer convenience
					 */</comment>
					elog(WARNING, <literal type="string">"ERROR: FTS double fault detected (content=%d) "</literal>
						 <literal type="string">"primary dbid=%d, mirror dbid=%d"</literal>,
						 primary-&gt;config-&gt;segindex, primary-&gt;config-&gt;dbid, mirror-&gt;config-&gt;dbid);
					ftsInfo-&gt;state = FTS_RESPONSE_PROCESSED;
				}
				break;
			case FTS_SYNCREP_OFF_FAILED:
				<comment type="block">/*
				 * Another attempt to turn off syncrep will be made in the next
				 * probe cycle.  Until then, leave the transactions waiting for
				 * syncrep.  A worse alternative is to PANIC.
				 */</comment>
				elog(WARNING, <literal type="string">"FTS failed to turn off syncrep on (content=%d,"</literal>
					 <literal type="string">" dbid=%d)"</literal>, primary-&gt;config-&gt;segindex, primary-&gt;config-&gt;dbid);
				ftsInfo-&gt;state = FTS_RESPONSE_PROCESSED;
				break;
			case FTS_PROMOTE_FAILED:
				<comment type="block">/*
				 * Only log here, will handle it later, having an "ERROR"
				 * keyword here for customer convenience
				 */</comment>
				elog(WARNING, <literal type="string">"ERROR: FTS double fault detected (content=%d) "</literal>
					 <literal type="string">"primary dbid=%d, mirror dbid=%d"</literal>,
					 primary-&gt;config-&gt;segindex, primary-&gt;config-&gt;dbid, mirror-&gt;config-&gt;dbid);
				ftsInfo-&gt;state = FTS_RESPONSE_PROCESSED;
				break;
			case FTS_PROMOTE_SUCCESS:
				elogif(gp_log_fts &gt;= GPVARS_VERBOSITY_VERBOSE, LOG,
					   <literal type="string">"FTS mirror (content=%d, dbid=%d) promotion "</literal>
					   <literal type="string">"triggered successfully"</literal>,
					   primary-&gt;config-&gt;segindex, primary-&gt;config-&gt;dbid);
				ftsInfo-&gt;state = FTS_RESPONSE_PROCESSED;
				break;
			case FTS_SYNCREP_OFF_SUCCESS:
				elogif(gp_log_fts &gt;= GPVARS_VERBOSITY_VERBOSE, LOG,
					   <literal type="string">"FTS primary (content=%d, dbid=%d) notified to turn "</literal>
					   <literal type="string">"syncrep off"</literal>, primary-&gt;config-&gt;segindex, primary-&gt;config-&gt;dbid);
				ftsInfo-&gt;state = FTS_RESPONSE_PROCESSED;
				break;
			default:
				elog(ERROR, <literal type="string">"FTS invalid internal state %d for (content=%d)"</literal>
					 <literal type="string">"primary dbid=%d, mirror dbid=%d"</literal>, ftsInfo-&gt;state,
					 primary-&gt;config-&gt;segindex, primary-&gt;config-&gt;dbid, mirror-&gt;config-&gt;dbid);
				break;
		}
		<comment type="block">/* Close connection and reset result for next message, if any. */</comment>
		memset(&amp;ftsInfo-&gt;result, <literal type="number">0</literal>, sizeof(fts_result));
		PQfinish(ftsInfo-&gt;conn);
		ftsInfo-&gt;conn = NULL;
		ftsInfo-&gt;poll_events = ftsInfo-&gt;poll_revents = <literal type="number">0</literal>;
		ftsInfo-&gt;retry_count = <literal type="number">0</literal>;
	}

	return is_updated;
}

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ASSERT_CHECKING</name></cpp:ifdef>
static bool
FtsIsSegmentAlive(CdbComponentDatabaseInfo *segInfo)
{
	if (SEGMENT_IS_ACTIVE_MIRROR(segInfo) &amp;&amp; SEGMENT_IS_ALIVE(segInfo))
		return true;

	if (SEGMENT_IS_ACTIVE_PRIMARY(segInfo))
		return true;

	return false;
}
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * Initialize context before a probe cycle based on cluster configuration in
 * cdbs.
 */</comment>
static void
FtsWalRepInitProbeContext(CdbComponentDatabases *cdbs, fts_context *context)
{
	context-&gt;num_pairs = cdbs-&gt;total_segments;
	context-&gt;perSegInfos = (fts_segment_info *) palloc0(
		context-&gt;num_pairs * sizeof(fts_segment_info));

	int fts_index = <literal type="number">0</literal>;
	int cdb_index = <literal type="number">0</literal>;
	for(; cdb_index &lt; cdbs-&gt;total_segment_dbs; cdb_index++)
	{
		CdbComponentDatabaseInfo *primary = &amp;(cdbs-&gt;segment_db_info[cdb_index]);
		if (!SEGMENT_IS_ACTIVE_PRIMARY(primary))
			continue;
		CdbComponentDatabaseInfo *mirror = FtsGetPeerSegment(cdbs,
															 primary-&gt;config-&gt;segindex,
															 primary-&gt;config-&gt;dbid);
		<comment type="block">/*
		 * If there is no mirror under this primary, no need to probe.
		 */</comment>
		if (!mirror)
		{
			context-&gt;num_pairs--;
			continue;
		}

		<comment type="block">/* primary in catalog will NEVER be marked down. */</comment>
		Assert(FtsIsSegmentAlive(primary));

		fts_segment_info *ftsInfo = &amp;(context-&gt;perSegInfos[fts_index]);
		<comment type="block">/*
		 * Initialize the response object.  Response from a segment will be
		 * processed only if ftsInfo-&gt;state is one of SUCCESS states.  If a
		 * failure is encountered in messaging a segment, its response will not
		 * be processed.
		 */</comment>
		ftsInfo-&gt;result.isPrimaryAlive = false;
		ftsInfo-&gt;result.isMirrorAlive = false;
		ftsInfo-&gt;result.isInSync = false;
		ftsInfo-&gt;result.isSyncRepEnabled = false;
		ftsInfo-&gt;result.retryRequested = false;
		ftsInfo-&gt;result.isRoleMirror = false;
		ftsInfo-&gt;result.dbid = primary-&gt;config-&gt;dbid;
		ftsInfo-&gt;state = FTS_PROBE_SEGMENT;
		ftsInfo-&gt;restart_state = PM_NOT_IN_RESTART;
		ftsInfo-&gt;xlogrecptr = InvalidXLogRecPtr;

		ftsInfo-&gt;primary_cdbinfo = primary;
		ftsInfo-&gt;mirror_cdbinfo = mirror;

		Assert(fts_index &lt; context-&gt;num_pairs);
		fts_index ++;
	}
}

static void
InitPollFds(size_t size)
{
	PollFds = (struct pollfd *) palloc0(size * sizeof(struct pollfd));
}

bool
FtsWalRepMessageSegments(CdbComponentDatabases *cdbs)
{
	bool is_updated = false;
	fts_context context;

	FtsWalRepInitProbeContext(cdbs, &amp;context);
	InitPollFds(cdbs-&gt;total_segments);

	while (!allDone(&amp;context) &amp;&amp; FtsIsActive())
	{
		ftsConnect(&amp;context);
		ftsPoll(&amp;context);
		ftsSend(&amp;context);
		ftsReceive(&amp;context);
		processRetry(&amp;context);
		is_updated |= processResponse(&amp;context);
	}
	int i;
	if (!FtsIsActive())
	{
		for (i = <literal type="number">0</literal>; i &lt; context.num_pairs; i++)
		{
			if (context.perSegInfos[i].conn)
			{
				PQfinish(context.perSegInfos[i].conn);
				context.perSegInfos[i].conn = NULL;
			}
		}
	}
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ASSERT_CHECKING</name></cpp:ifdef>
	<comment type="block">/*
	 * At the end of probe cycle, there shouldn't be any active libpq
	 * connections.
	 */</comment>
	for (i = <literal type="number">0</literal>; i &lt; context.num_pairs; i++)
	{
		if (context.perSegInfos[i].conn != NULL)
			elog(ERROR,
				 <literal type="string">"FTS libpq connection left open (content=%d, dbid=%d)"</literal>
				 <literal type="string">" state=%d, retry_count=%d, conn-&gt;status=%d"</literal>,
				 context.perSegInfos[i].primary_cdbinfo-&gt;config-&gt;segindex,
				 context.perSegInfos[i].primary_cdbinfo-&gt;config-&gt;dbid,
				 context.perSegInfos[i].state,
				 context.perSegInfos[i].retry_count,
				 context.perSegInfos[i].conn-&gt;status);
	}
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	pfree(context.perSegInfos);
	pfree(PollFds);
	return is_updated;
}</argument></argument_list></macro></block_content></block></if></if_stmt></block_content></block></if></if_stmt></block_content></block></function>

<comment type="block">/* EOF */</comment>
</unit>
