<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/backend/cdb/cdbtargeteddispatch.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * cdbtargeteddispatch.c
 *
 * Portions Copyright (c) 2009, Greenplum inc
 * Portions Copyright (c) 2012-Present VMware, Inc. or its affiliates.
 *
 *
 * IDENTIFICATION
 *	    src/backend/cdb/cdbtargeteddispatch.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/relation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbtargeteddispatch.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/clauses.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parsetree.h"</cpp:file></cpp:include>	<comment type="block">/* for rt_fetch() */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>	<comment type="block">/* for makeVar() */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/relcache.h"</cpp:file></cpp:include>		<comment type="block">/* RelationGetPartitioningKey() */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/optimizer.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/predtest_valueset.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/gp_distribution_policy.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_proc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbdisp_query.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbhash.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbllize.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbmutate.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbplan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbvars.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbutil.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/executor.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PRINT_DISPATCH_DECISIONS_STRING</name></cpp:macro> <cpp:value>("print_dispatch_decisions")</cpp:value></cpp:define>

<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>gp_test_options</name> <init>= <expr><literal type="string">""</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/* PRINT_DISPATCH_DECISIONS_STRING; */</comment>

<comment type="block" format="doxygen">/**
 * Used when building up all of the composite distribution keys.
 */</comment>
<typedef>typedef <type><struct>struct <name>PartitionKeyInfo</name>
<block>{
	<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	  <modifier>*</modifier><modifier>*</modifier></type><name>values</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>counter</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numValues</name></decl>;</decl_stmt>
}</block></struct></type> <name>PartitionKeyInfo</name>;</typedef>

<comment type="block" format="doxygen">/**
 * Initialize a DirectDispatchCalculationInfo.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>InitDirectDispatchCalculationInfo</name><parameter_list>(<parameter><decl><type><name>DirectDispatchInfo</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>isDirectDispatch</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>contentIds</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>haveProcessedAnyCalculations</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
 * Mark a DirectDispatchCalculationInfo as having targeted dispatch disabled
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>DisableTargetedDispatch</name><parameter_list>(<parameter><decl><type><name>DirectDispatchInfo</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>isDirectDispatch</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>contentIds</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>haveProcessedAnyCalculations</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
 * helper function for AssignContentIdsFromUpdateDeleteQualification
 */</comment>
<function><type><specifier>static</specifier> <name>DirectDispatchInfo</name></type>
<name>GetContentIdsFromPlanForSingleRelation</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>plan</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>rangeTableIndex</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>qualification</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>GpPolicy</name>   <modifier>*</modifier></type><name>policy</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PartitionKeyInfo</name> <modifier>*</modifier></type><name>parts</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>DirectDispatchInfo</name></type> <name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>relation</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>InitDirectDispatchCalculationInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>plan</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>T_BitmapHeapScan</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * do not assert for bitmap heap scan --&gt; it can have a child which is
		 * an index scan
		 */</comment>
		<comment type="block">/*
		 * in fact, checking the quals for the bitmap heap scan are redundant
		 * with checking them on the child scan.  But it won't cause any harm
		 * since we will recurse to the child scan.
		 */</comment>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>plan</name><operator>-&gt;</operator><name>lefttree</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>plan</name><operator>-&gt;</operator><name>righttree</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* open and get relation info */</comment>
	<expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>planner_rt_fetch</name><argument_list>(<argument><expr><name>rangeTableIndex</name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_RELATION</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Get a copy of the rel's GpPolicy from the relcache. */</comment>
		<expr_stmt><expr><name>relation</name> <operator>=</operator> <call><name>relation_open</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>policy</name> <operator>=</operator> <name><name>relation</name><operator>-&gt;</operator><name>rd_cdbpolicy</name></name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>policy</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>parts</name> <operator>=</operator> <operator>(</operator><name>PartitionKeyInfo</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>policy</name><operator>-&gt;</operator><name>nattrs</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PartitionKeyInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>policy</name><operator>-&gt;</operator><name>nattrs</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<expr_stmt><expr><name><name>parts</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>attr</name> <operator>=</operator> <call><name>TupleDescAttr</name><argument_list>(<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_att</name></name></expr></argument>, <argument><expr><name><name>policy</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><name>i</name></expr>]</index></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>parts</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>values</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>parts</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>numValues</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>parts</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>counter</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			</block_content>}</block></for>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* fall through, policy will be NULL so we won't direct dispatch */</comment>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>forceDistRandom</name></name> <operator>||</operator>	<name>policy</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*  we won't direct dispatch  */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_RELATION</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>result</name><operator>.</operator><name>haveProcessedAnyCalculations</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<return>return <expr><name>result</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * We first test if the predict contains a qual like
	 * gp_segment_id = some_const. This is very suitable
	 * for a direct dispatch. If this leads to direct dispatch
	 * then we just return because it does not need to
	 * eval distkey.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>GpPolicyIsPartitioned</name><argument_list>(<argument><expr><name>policy</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Var</name>                <modifier>*</modifier></type><name>seg_id_var</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>                 <name>vartypeid</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int32</name></type>               <name>type_mod</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>                 <name>type_coll</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PossibleValueSet</name></type>    <name>pvs_segids</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Node</name>              <modifier>*</modifier><modifier>*</modifier></type><name>seg_ids</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>                 <name>len</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>                 <name>i</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>               <modifier>*</modifier></type><name>contentIds</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>get_atttypetypmodcoll</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>GpSegmentIdAttributeNumber</name></expr></argument>,
							  <argument><expr><operator>&amp;</operator><name>vartypeid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>type_mod</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>type_coll</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>seg_id_var</name> <operator>=</operator> <call><name>makeVar</name><argument_list>(<argument><expr><name>rangeTableIndex</name></expr></argument>,
							 <argument><expr><name>GpSegmentIdAttributeNumber</name></expr></argument>,
							 <argument><expr><name>vartypeid</name></expr></argument>, <argument><expr><name>type_mod</name></expr></argument>, <argument><expr><name>type_coll</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>pvs_segids</name> <operator>=</operator> <call><name>DeterminePossibleValueSet</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>qualification</name></expr></argument>,
											   <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>seg_id_var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>pvs_segids</name><operator>.</operator><name>isAnyValuePossible</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>seg_ids</name> <operator>=</operator> <call><name>GetPossibleValuesAsArray</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pvs_segids</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>len</name> <operator>&lt;</operator> <name><name>policy</name><operator>-&gt;</operator><name>numsegments</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>result</name><operator>.</operator><name>isDirectDispatch</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>len</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
				<block>{<block_content>
					<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>val</name> <init>= <expr><name><name>seg_ids</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
					<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<decl_stmt><decl><type><name>int32</name></type> <name>segid</name> <init>= <expr><call><name>DatumGetInt32</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>val</name><operator>)</operator><operator>-&gt;</operator><name>constvalue</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
						<expr_stmt><expr><name>contentIds</name> <operator>=</operator> <call><name>list_append_unique_int</name><argument_list>(<argument><expr><name>contentIds</name></expr></argument>, <argument><expr><name>segid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<expr_stmt><expr><name><name>result</name><operator>.</operator><name>isDirectDispatch</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
						<break>break;</break>
					</block_content>}</block></else></if_stmt>
				</block_content>}</block></for>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>DeletePossibleValueSetData</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pvs_segids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>result</name><operator>.</operator><name>isDirectDispatch</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>result</name><operator>.</operator><name>contentIds</name></name> <operator>=</operator> <name>contentIds</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>result</name><operator>.</operator><name>haveProcessedAnyCalculations</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_RELATION</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<return>return <expr><name>result</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>GpPolicyIsHashPartitioned</name><argument_list>(<argument><expr><name>policy</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>long</name></type>		<name>totalCombinations</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>parts</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* calculate possible value set for each partitioning attribute */</comment>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>policy</name><operator>-&gt;</operator><name>nattrs</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>var</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>PossibleValueSet</name></type> <name>pvs</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>var</name> <operator>=</operator> <call><name>makeVar</name><argument_list>(<argument><expr><name>rangeTableIndex</name></expr></argument>,
						  <argument><expr><name><name>policy</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
						  <argument><expr><name><name>parts</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>attr</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>,
						  <argument><expr><name><name>parts</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>attr</name><operator>-&gt;</operator><name>atttypmod</name></name></expr></argument>,
						  <argument><expr><name><name>parts</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>attr</name><operator>-&gt;</operator><name>attcollation</name></name></expr></argument>,
						  <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block" format="doxygen">/**
			 * Note that right now we only examine the given qual.  This is okay because if there are other
			 *   quals on the plan then those would be ANDed with the qual, which can only narrow our choice
			 *   of segment and not expand it.
			 */</comment>
			<expr_stmt><expr><name>pvs</name> <operator>=</operator> <call><name>DeterminePossibleValueSet</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>qualification</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>pvs</name><operator>.</operator><name>isAnyValuePossible</name></name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * can't isolate to single statement -- totalCombinations = -1
				 * will signal this
				 */</comment>
				<expr_stmt><expr><call><name>DeletePossibleValueSetData</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pvs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>totalCombinations</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><name><name>parts</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>values</name> <operator>=</operator> <call><name>GetPossibleValuesAsArray</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pvs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>parts</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>numValues</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>totalCombinations</name> <operator>*=</operator> <name><name>parts</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>numValues</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>DeletePossibleValueSetData</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pvs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></for>

		<comment type="block">/*
		 * calculate possible target content ids from the combinations of
		 * partitioning attributes
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>totalCombinations</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * one of the possible sets was empty and so we don't care where
			 * we run this
			 */</comment>
			<expr_stmt><expr><name><name>result</name><operator>.</operator><name>isDirectDispatch</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>result</name><operator>.</operator><name>contentIds</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>		<comment type="block">/* direct dispatch but no
													 * specific content at
													 * all! */</comment>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>totalCombinations</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
			<comment type="block">/* don't bother for ones which will likely hash to many segments */</comment>
				 <name>totalCombinations</name> <operator>&lt;</operator> <name><name>policy</name><operator>-&gt;</operator><name>numsegments</name></name> <operator>*</operator> <literal type="number">3</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>CdbHash</name>    <modifier>*</modifier></type><name>h</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>long</name></type>		<name>index</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>h</name> <operator>=</operator> <call><name>makeCdbHashForRelation</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>result</name><operator>.</operator><name>isDirectDispatch</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>result</name><operator>.</operator><name>contentIds</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

			<comment type="block">/* for each combination of keys calculate target segment */</comment>
			<for>for <control>(<init><expr><name>index</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>index</name> <operator>&lt;</operator> <name>totalCombinations</name></expr>;</condition> <incr><expr><name>index</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<decl_stmt><decl><type><name>long</name></type>		<name>curIndex</name> <init>= <expr><name>index</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int</name></type>			<name>hashCode</name></decl>;</decl_stmt>

				<comment type="block">/* hash the attribute values */</comment>
				<expr_stmt><expr><call><name>cdbhashinit</name><argument_list>(<argument><expr><name>h</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>policy</name><operator>-&gt;</operator><name>nattrs</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
				<block>{<block_content>
					<decl_stmt><decl><type><name>int</name></type>			<name>numValues</name> <init>= <expr><name><name>parts</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>numValues</name></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>int</name></type>			<name>which</name> <init>= <expr><name>curIndex</name> <operator>%</operator> <name>numValues</name></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>val</name> <init>= <expr><name><name>parts</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>values</name><index>[<expr><name>which</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<decl_stmt><decl><type><name>Const</name>		<modifier>*</modifier></type><name>c</name> <init>= <expr><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>val</name></expr></init></decl>;</decl_stmt>

						<expr_stmt><expr><call><name>cdbhash</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name><name>c</name><operator>-&gt;</operator><name>constvalue</name></name></expr></argument>, <argument><expr><name><name>c</name><operator>-&gt;</operator><name>constisnull</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<expr_stmt><expr><name><name>result</name><operator>.</operator><name>isDirectDispatch</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
						<break>break;</break>
					</block_content>}</block></else></if_stmt>
					<expr_stmt><expr><name>curIndex</name> <operator>/=</operator> <name>numValues</name></expr>;</expr_stmt>
				</block_content>}</block></for>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>result</name><operator>.</operator><name>isDirectDispatch</name></name></expr>)</condition><block type="pseudo"><block_content>
					<break>break;</break></block_content></block></if></if_stmt>

				<expr_stmt><expr><name>hashCode</name> <operator>=</operator> <call><name>cdbhashreduce</name><argument_list>(<argument><expr><name>h</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name><name>result</name><operator>.</operator><name>contentIds</name></name> <operator>=</operator> <call><name>list_append_unique_int</name><argument_list>(<argument><expr><name><name>result</name><operator>.</operator><name>contentIds</name></name></expr></argument>, <argument><expr><name>hashCode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></for>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* know nothing, can't do directed dispatch */</comment>
			<expr_stmt><expr><name><name>result</name><operator>.</operator><name>isDirectDispatch</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_RELATION</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>result</name><operator>.</operator><name>haveProcessedAnyCalculations</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>MergeDirectDispatchCalculationInfo</name><parameter_list>(<parameter><decl><type><name>DirectDispatchInfo</name> <modifier>*</modifier></type><name>to</name></decl></parameter>, <parameter><decl><type><name>DirectDispatchInfo</name> <modifier>*</modifier></type><name>from</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>from</name><operator>-&gt;</operator><name>isDirectDispatch</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* from eliminates all options so take it */</comment>
		<expr_stmt><expr><name><name>to</name><operator>-&gt;</operator><name>isDirectDispatch</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><operator>!</operator><name><name>to</name><operator>-&gt;</operator><name>haveProcessedAnyCalculations</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* to has no data, so just take from */</comment>
		<expr_stmt><expr><operator>*</operator><name>to</name> <operator>=</operator> <operator>*</operator><name>from</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><operator>!</operator><name><name>to</name><operator>-&gt;</operator><name>isDirectDispatch</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* to cannot get better -- leave it alone */</comment>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>from</name><operator>-&gt;</operator><name>contentIds</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* from says that it doesn't need to run anywhere -- so we accept to */</comment>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>to</name><operator>-&gt;</operator><name>contentIds</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* to didn't even think it needed to run so accept from */</comment>
		<expr_stmt><expr><name><name>to</name><operator>-&gt;</operator><name>contentIds</name></name> <operator>=</operator> <name><name>from</name><operator>-&gt;</operator><name>contentIds</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* union to with from */</comment>
		<expr_stmt><expr><name><name>to</name><operator>-&gt;</operator><name>contentIds</name></name> <operator>=</operator> <call><name>list_union_int</name><argument_list>(<argument><expr><name><name>to</name><operator>-&gt;</operator><name>contentIds</name></name></expr></argument>, <argument><expr><name><name>from</name><operator>-&gt;</operator><name>contentIds</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name><name>to</name><operator>-&gt;</operator><name>haveProcessedAnyCalculations</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
 * returns true if we should print test messages.  Note for clients: for multi-slice queries then messages will print in
 *   the order of processing which may not always be deterministic (single joins can be rearranged by the planner,
 *   for example).
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ShouldPrintTestMessages</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<return>return <expr><name>gp_test_options</name> <operator>&amp;&amp;</operator> <call><name>strstr</name><argument_list>(<argument><expr><name>gp_test_options</name></expr></argument>, <argument><expr><name>PRINT_DISPATCH_DECISIONS_STRING</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>FinalizeDirectDispatchDataForSlice</name><parameter_list>(<parameter><decl><type><name>PlanSlice</name> <modifier>*</modifier></type><name>slice</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DirectDispatchInfo</name> <modifier>*</modifier></type><name>dd</name> <init>= <expr><operator>&amp;</operator><name><name>slice</name><operator>-&gt;</operator><name>directDispatch</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>dd</name><operator>-&gt;</operator><name>haveProcessedAnyCalculations</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>dd</name><operator>-&gt;</operator><name>isDirectDispatch</name></name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>dd</name><operator>-&gt;</operator><name>contentIds</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>int</name></type>			<name>random_segno</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>random_segno</name> <operator>=</operator> <call><name>cdbhashrandomseg</name><argument_list>(<argument><expr><call><name>getgpsegmentCount</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>dd</name><operator>-&gt;</operator><name>contentIds</name></name> <operator>=</operator> <call><name>list_make1_int</name><argument_list>(<argument><expr><name>random_segno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>ShouldPrintTestMessages</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>INFO</name></expr></argument>, <argument><expr><literal type="string">"DDCR learned no content dispatch is required"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><call><name>ShouldPrintTestMessages</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>INFO</name></expr></argument>, <argument><expr><literal type="string">"DDCR learned dispatch to content %d"</literal></expr></argument>, <argument><expr><call><name>linitial_int</name><argument_list>(<argument><expr><name><name>dd</name><operator>-&gt;</operator><name>contentIds</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>ShouldPrintTestMessages</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>INFO</name></expr></argument>, <argument><expr><literal type="string">"DDCR learned full dispatch is required"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>ShouldPrintTestMessages</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>INFO</name></expr></argument>, <argument><expr><literal type="string">"DDCR learned no information: default to full dispatch"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>dd</name><operator>-&gt;</operator><name>isDirectDispatch</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>DirectDispatchUpdateContentIdsFromPlan</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>plan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DirectDispatchInfo</name></type> <name>dispatchInfo</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>InitDirectDispatchCalculationInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dispatchInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>plan</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>T_Result</name></expr>:</case>
		<case>case <expr><name>T_Append</name></expr>:</case>
		<case>case <expr><name>T_MergeAppend</name></expr>:</case>
		<case>case <expr><name>T_LockRows</name></expr>:</case>
		<case>case <expr><name>T_ModifyTable</name></expr>:</case>
		<case>case <expr><name>T_BitmapAnd</name></expr>:</case>
		<case>case <expr><name>T_BitmapOr</name></expr>:</case>
		<case>case <expr><name>T_BitmapHeapScan</name></expr>:</case>
			<comment type="block">/* no change to dispatchInfo */</comment>
			<break>break;</break>
		<case>case <expr><name>T_SampleScan</name></expr>:</case>
			<expr_stmt><expr><call><name>DisableTargetedDispatch</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dispatchInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_SeqScan</name></expr>:</case>
			<comment type="block">/*
			 * we can determine the dispatch data to merge by looking at
			 * the relation begin scanned
			 */</comment>
			<expr_stmt><expr><name>dispatchInfo</name> <operator>=</operator> <call><name>GetContentIdsFromPlanForSingleRelation</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
																  <argument><expr><name>plan</name></expr></argument>,
																  <argument><expr><operator>(</operator><operator>(</operator><name>Scan</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name>scanrelid</name></expr></argument>,
																  <argument><expr><name><name>plan</name><operator>-&gt;</operator><name>qual</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_IndexScan</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>IndexScan</name>  <modifier>*</modifier></type><name>indexScan</name> <init>= <expr><operator>(</operator><name>IndexScan</name> <operator>*</operator><operator>)</operator> <name>plan</name></expr></init></decl>;</decl_stmt>

				<comment type="block">/*
				 * we can determine the dispatch data to merge by looking
				 * at the relation begin scanned
				 */</comment>
				<expr_stmt><expr><name>dispatchInfo</name> <operator>=</operator> <call><name>GetContentIdsFromPlanForSingleRelation</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
																	  <argument><expr><name>plan</name></expr></argument>,
																	  <argument><expr><operator>(</operator><operator>(</operator><name>Scan</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name>scanrelid</name></expr></argument>,
																	  <argument><expr><name><name>indexScan</name><operator>-&gt;</operator><name>indexqualorig</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* must use _orig_ qual ! */</comment>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_IndexOnlyScan</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>IndexOnlyScan</name>  <modifier>*</modifier></type><name>indexOnlyScan</name> <init>= <expr><operator>(</operator><name>IndexOnlyScan</name> <operator>*</operator><operator>)</operator> <name>plan</name></expr></init></decl>;</decl_stmt>

				<comment type="block">/*
				 * we can determine the dispatch data to merge by looking
				 * at the relation begin scanned
				 */</comment>
				<expr_stmt><expr><name>dispatchInfo</name> <operator>=</operator> <call><name>GetContentIdsFromPlanForSingleRelation</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
																	  <argument><expr><name>plan</name></expr></argument>,
																	  <argument><expr><operator>(</operator><operator>(</operator><name>Scan</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name>scanrelid</name></expr></argument>,
																	  <argument><expr><name><name>indexOnlyScan</name><operator>-&gt;</operator><name>indexqualorig</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* must use _orig_ qual ! */</comment>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_BitmapIndexScan</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>BitmapIndexScan</name> <modifier>*</modifier></type><name>bitmapScan</name> <init>= <expr><operator>(</operator><name>BitmapIndexScan</name> <operator>*</operator><operator>)</operator> <name>plan</name></expr></init></decl>;</decl_stmt>

				<comment type="block">/*
				 * we can determine the dispatch data to merge by looking
				 * at the relation begin scanned
				 */</comment>
				<expr_stmt><expr><name>dispatchInfo</name> <operator>=</operator> <call><name>GetContentIdsFromPlanForSingleRelation</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
																	  <argument><expr><name>plan</name></expr></argument>,
																	  <argument><expr><operator>(</operator><operator>(</operator><name>Scan</name> <operator>*</operator><operator>)</operator> <name>plan</name><operator>)</operator><operator>-&gt;</operator><name>scanrelid</name></expr></argument>,
																	  <argument><expr><name><name>bitmapScan</name><operator>-&gt;</operator><name>indexqualorig</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* must use original qual ! */</comment>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_SubqueryScan</name></expr>:</case>
		<case>case <expr><name>T_NamedTuplestoreScan</name></expr>:</case>
			<comment type="block">/* no change to dispatchInfo */</comment>
			<break>break;</break>
		<case>case <expr><name>T_TidScan</name></expr>:</case>
		<case>case <expr><name>T_FunctionScan</name></expr>:</case>
		<case>case <expr><name>T_TableFuncScan</name></expr>:</case>
		<case>case <expr><name>T_WorkTableScan</name></expr>:</case>
			<expr_stmt><expr><call><name>DisableTargetedDispatch</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dispatchInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_ValuesScan</name></expr>:</case>
			<comment type="block">/* no change to dispatchInfo */</comment>
			<break>break;</break>
		<case>case <expr><name>T_NestLoop</name></expr>:</case>
		<case>case <expr><name>T_MergeJoin</name></expr>:</case>
		<case>case <expr><name>T_HashJoin</name></expr>:</case>
			<comment type="block">/* join: no change to dispatchInfo */</comment>

			<comment type="block">/*
			 * note that we could want to look at the join qual but
			 * constant checks should have been pushed down to the
			 * underlying scans so we shouldn't learn anything
			 */</comment>
			<break>break;</break>
		<case>case <expr><name>T_Material</name></expr>:</case>
		<case>case <expr><name>T_Sort</name></expr>:</case>
		<case>case <expr><name>T_Agg</name></expr>:</case>
		<case>case <expr><name>T_TupleSplit</name></expr>:</case>
		<case>case <expr><name>T_Unique</name></expr>:</case>
		<case>case <expr><name>T_Gather</name></expr>:</case>
		<case>case <expr><name>T_Hash</name></expr>:</case>
		<case>case <expr><name>T_SetOp</name></expr>:</case>
		<case>case <expr><name>T_Limit</name></expr>:</case>
		<case>case <expr><name>T_PartitionSelector</name></expr>:</case>
			<break>break;</break>
		<case>case <expr><name>T_Motion</name></expr>:</case>
			<comment type="block">/*
			 * It's currently not allowed to direct-dispatch a slice that
			 * has a Motion that sends tuples to it. It would be possible
			 * in principle, but the interconnect initialization code gets
			 * confused.
			 */</comment>
			<expr_stmt><expr><call><name>DisableTargetedDispatch</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dispatchInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_ShareInputScan</name></expr>:</case>

			<comment type="block">/*
			 * note: could try to peek into the building slice to get its
			 * direct dispatch values but we don't
			 */</comment>
			<expr_stmt><expr><call><name>DisableTargetedDispatch</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dispatchInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_WindowAgg</name></expr>:</case>
		<case>case <expr><name>T_TableFunctionScan</name></expr>:</case>
		<case>case <expr><name>T_RecursiveUnion</name></expr>:</case>
			<comment type="block">/* no change to dispatchInfo */</comment>
			<break>break;</break>
		<case>case <expr><name>T_ForeignScan</name></expr>:</case>
			<expr_stmt><expr><call><name>DisableTargetedDispatch</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dispatchInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* not sure about
													 * foreign tables ...
													 * so disable */</comment>
			<break>break;</break>
		<case>case <expr><name>T_SplitUpdate</name></expr>:</case>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unknown plan node %d"</literal></expr></argument>, <argument><expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>plan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<comment type="block">/*
	 * analyzed node type, now do the work (for all except subquery scan,
	 * which do work in the switch above and return
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>dispatchInfo</name><operator>.</operator><name>haveProcessedAnyCalculations</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* learned new info: merge it in */</comment>
		<expr_stmt><expr><call><name>MergeDirectDispatchCalculationInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>root</name><operator>-&gt;</operator><name>curSlice</name><operator>-&gt;</operator><name>directDispatch</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dispatchInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>DirectDispatchUpdateContentIdsForInsert</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>plan</name></decl></parameter>,
										<parameter><decl><type><name>GpPolicy</name> <modifier>*</modifier></type><name>targetPolicy</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>hashfuncs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DirectDispatchInfo</name></type> <name>dispatchInfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isDirectDispatch</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>values</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>nulls</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>InitDirectDispatchCalculationInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dispatchInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>values</name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>targetPolicy</name><operator>-&gt;</operator><name>nattrs</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>nulls</name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>targetPolicy</name><operator>-&gt;</operator><name>nattrs</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * the nested loops here seem scary -- especially since we've already
	 * walked them before -- but I think this is still required since they may
	 * not be in the same order. (also typically we don't distribute by more
	 * than a handful of attributes).
	 */</comment>
	<expr_stmt><expr><name>isDirectDispatch</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>targetPolicy</name><operator>-&gt;</operator><name>nattrs</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>plan-&gt;targetlist</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Const</name>	   <modifier>*</modifier></type><name>c</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>tle</name><operator>-&gt;</operator><name>resno</name></name> <operator>!=</operator> <name><name>targetPolicy</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* the planner could not simplify this */</comment>
				<expr_stmt><expr><name>isDirectDispatch</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><name>c</name> <operator>=</operator> <operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>c</name><operator>-&gt;</operator><name>constvalue</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>nulls</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>c</name><operator>-&gt;</operator><name>constisnull</name></name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isDirectDispatch</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><name>isDirectDispatch</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>uint32</name></type>		<name>hashcode</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>CdbHash</name>    <modifier>*</modifier></type><name>h</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>h</name> <operator>=</operator> <call><name>makeCdbHash</name><argument_list>(<argument><expr><name><name>targetPolicy</name><operator>-&gt;</operator><name>numsegments</name></name></expr></argument>, <argument><expr><name><name>targetPolicy</name><operator>-&gt;</operator><name>nattrs</name></name></expr></argument>, <argument><expr><name>hashfuncs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>cdbhashinit</name><argument_list>(<argument><expr><name>h</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>targetPolicy</name><operator>-&gt;</operator><name>nattrs</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><call><name>cdbhash</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>nulls</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>

		<comment type="block">/* We now have the hash-partition that this row belong to */</comment>
		<expr_stmt><expr><name>hashcode</name> <operator>=</operator> <call><name>cdbhashreduce</name><argument_list>(<argument><expr><name>h</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>dispatchInfo</name><operator>.</operator><name>isDirectDispatch</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>dispatchInfo</name><operator>.</operator><name>contentIds</name></name> <operator>=</operator> <call><name>list_make1_int</name><argument_list>(<argument><expr><name>hashcode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>dispatchInfo</name><operator>.</operator><name>haveProcessedAnyCalculations</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

		<comment type="block">/* learned new info: merge it in */</comment>
		<expr_stmt><expr><call><name>MergeDirectDispatchCalculationInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>root</name><operator>-&gt;</operator><name>curSlice</name><operator>-&gt;</operator><name>directDispatch</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dispatchInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"sending single row constant insert to content %d"</literal></expr></argument>, <argument><expr><name>hashcode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
