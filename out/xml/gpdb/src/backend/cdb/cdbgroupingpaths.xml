<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/backend/cdb/cdbgroupingpaths.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * cdbgroupingpaths.c
 *	  Routines to aid in planning grouping queries for parallel
 *    execution.  This is, essentially, an extension of the file
 *    optimizer/plan/planner.c, although some functions are not
 *    externalized.
 *
 *
 * The general shape of the generated plan is similar to the parallel
 * aggregation plans in upstream:
 *
 * Finalize Aggregate [3]
 *    Motion             [2]
 *       Partial Aggregate  [1]
 *
 * but there are many different variants of this basic shape:
 *
 * [1] The Partial stage can be sorted or hashed. Furthermore,
 *     the sorted Agg can be construct from sorting the cheapest input Path,
 *     or from pre-sorted Paths.
 *
 * [2] The partial results need to be gathered for the second stage.
 *     For plain aggregation, with no GROUP BY, the results need to be
 *     gathered to a single node. With GROUP BY, they can be redistributed
 *     according to the GROUP BY columns.
 *
 * [3] Like the first tage, the second stage can likewise be sorted or hashed.
 *
 *
 * Things get more complicated if any of the aggregates have DISTINCT
 * arguments, also known as DQAs or Distinct-Qualified Aggregates. If there
 * is only one DQA, and the input path happens to be collocated with the
 * DISTINCT argument, then we can proceed with a two-stage path like above.
 * But otherwise, three stages and possibly TupleSplit node is needed. See
 * add_single_dqa_hash_agg_path() and add_multi_dqas_hash_agg_path() for
 * details.
 *
 * Portions Copyright (c) 2019-Present VMware, Inc. or its affiliates.
 *
 *
 * IDENTIFICATION
 *	    src/backend/cdb/cdbgroupingpaths.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbgroup.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbgroupingpaths.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbhash.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbpath.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbpathlocus.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbutil.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbvars.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodeFuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/clauses.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/cost.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/optimizer.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/pathnode.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/paths.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/tlist.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_clause.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_oper.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/selfuncs.h"</cpp:file></cpp:include>

<typedef>typedef <type><enum>enum
<block>{
	<decl><name>INVALID_DQA</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>,
	<decl><name>SINGLE_DQA</name></decl>, <comment type="block">/* only one unique DQA expr */</comment>
	<decl><name>MULTI_DQAS</name></decl>, <comment type="block">/* multiple DQA exprs */</comment>
	<decl><name>SINGLE_DQA_WITHAGG</name></decl>, <comment type="block">/* only one unique DQA expr with agg */</comment>
	<decl><name>MULTI_DQAS_WITHAGG</name></decl><comment type="block">/* mixed DQA and normal aggregate */</comment>
}</block></enum></type> <name>DQAType</name>;</typedef>

<comment type="block">/*
 * For convenience, we collect various inputs and intermediate planning results
 * in this struct, instead of passing a dozen arguments to all subroutines.
 */</comment>
<typedef>typedef <type><struct>struct
<block>{
	<comment type="block">/* From the Query */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>hasAggs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>groupClause</name></decl>;</decl_stmt>	<comment type="block">/* a list of SortGroupClause's */</comment>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>groupingSets</name></decl>;</decl_stmt>	<comment type="block">/* a list of GroupingSet's if present */</comment>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>group_tles</name></decl>;</decl_stmt>

	<comment type="block">/* Inputs from the caller */</comment>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>havingQual</name></decl>;</decl_stmt>		<comment type="block">/* qualifications applied to groups */</comment>
	<decl_stmt><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>target</name></decl>;</decl_stmt>			<comment type="block">/* targetlist of final aggregated result */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>can_sort</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>can_hash</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>dNumGroupsTotal</name></decl>;</decl_stmt>		<comment type="block">/* total number of groups in the result, across all QEs */</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>AggClauseCosts</name> <modifier>*</modifier></type><name>agg_costs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>AggClauseCosts</name> <modifier>*</modifier></type><name>agg_partial_costs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>AggClauseCosts</name> <modifier>*</modifier></type><name>agg_final_costs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>rollups</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>new_rollups</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AggStrategy</name></type> <name>strat</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>partial_grouping_target</name></decl>;</decl_stmt>	<comment type="block">/* targetlist of partially aggregated result */</comment>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>final_groupClause</name></decl>;</decl_stmt>			<comment type="block">/* SortGroupClause for final grouping */</comment>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>final_group_tles</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Index</name></type>		<name>gsetid_sortref</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Pathkeys representing GROUP BY.
	 *
	 * 'partial_needed_pathkeys' represents a sort order that's needed for
	 * doing a sorted GroupAggregate in the first
	 * stage. 'partial_sort_pathkey' is normally the same, but in case of
	 * DISTINCT ON and ORDER BY it can include extra columns that are presentt
	 * in the ORDER BY but not in DISTINCT ON. The idea is the needed_pathkeys
	 * are sufficient to perform the grouping, but if we have to sort the
	 * input, we sort using sort_pathkeys. By including the extra columns in
	 * the Sort we can avoid sorting the data again later to satisfy the ORDER
	 * BY.
	 *
	 * 'final_needed_pathkeys' is the sort order needed to perform the 2nd
	 * stage by sorted GroupAggregate.  In normal GROUP BY it is the same as
	 * 'partial_needed_pathkeys', but if there are GROUPING SETS,
	 * 'final_needed_pathkeys' includes the internal GROUPINGSET_ID()
	 * expression, used to distinguish the rolled up rows. And
	 * 'final_sort_pathkeys' is the same, but might include extra ORDER BY
	 * columns.
	 *
	 */</comment>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>partial_needed_pathkeys</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>partial_sort_pathkeys</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>final_needed_pathkeys</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>final_sort_pathkeys</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>DQAType</name></type>     <name>type</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * partial_rel holds the partially aggregated results from the first stage.
	 */</comment>
	<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>partial_rel</name></decl>;</decl_stmt>
}</block></struct></type> <name>cdb_agg_planning_context</name>;</typedef>

<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>DQAType</name></type>     <name>type</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>PathTarget</name>  <modifier>*</modifier></type><name>final_target</name></decl>;</decl_stmt>          <comment type="block">/* finalize agg tlist */</comment>
	<decl_stmt><decl><type><name>PathTarget</name>  <modifier>*</modifier></type><name>partial_target</name></decl>;</decl_stmt>        <comment type="block">/* partial agg tlist */</comment>
	<decl_stmt><decl><type><name>PathTarget</name>  <modifier>*</modifier></type><name>tup_split_target</name></decl>;</decl_stmt>      <comment type="block">/* AggExprId + subpath_proj_target */</comment>
	<decl_stmt><decl><type><name>PathTarget</name>  <modifier>*</modifier></type><name>input_proj_target</name></decl>;</decl_stmt>     <comment type="block">/* input tuple tlist + DQA expr */</comment>

	<decl_stmt><decl><type><name>List</name>        <modifier>*</modifier></type><name>dqa_group_clause</name></decl>;</decl_stmt>      <comment type="block">/* DQA exprs + group by clause for remove duplication */</comment>

	<decl_stmt><decl><type><name>List</name>        <modifier>*</modifier></type><name>dqa_expr_lst</name></decl>;</decl_stmt>          <comment type="block">/* DQAExpr list */</comment>
	<decl_stmt><decl><type><name>double</name></type>		 <name>dNumDistinctGroups</name></decl>;</decl_stmt>	<comment type="block">/* # of distinct combinations of GROUP BY and DISTINCT exprs */</comment>

}</block></struct></type> <name>cdb_multi_dqas_info</name>;</typedef>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>create_two_stage_paths</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>cdb_agg_planning_context</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>,
								   <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>input_rel</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>output_rel</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>get_common_group_tles</name><parameter_list>(<parameter><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>target</name></decl></parameter>,
								   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>groupClause</name></decl></parameter>,
								   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>rollups</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>get_all_rollup_groupclauses</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>rollups</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>CdbPathLocus</name></type> <name>choose_grouping_locus</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>path</name></decl></parameter>,
										  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>group_tles</name></decl></parameter>,
										  <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>need_redistribute_p</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>Index</name></type> <name>add_gsetid_tlist</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>SortGroupClause</name> <modifier>*</modifier></type><name>create_gsetid_groupclause</name><parameter_list>(<parameter><decl><type><name>Index</name></type> <name>groupref</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>strip_gsetid_from_pathkeys</name><parameter_list>(<parameter><decl><type><name>Index</name></type> <name>gsetid_sortref</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>pathkeys</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>add_first_stage_group_agg_path</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
										   <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>path</name></decl></parameter>,
										   <parameter><decl><type><name>bool</name></type> <name>is_sorted</name></decl></parameter>,
										   <parameter><decl><type><name>cdb_agg_planning_context</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>add_first_stage_hash_agg_path</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
										  <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>path</name></decl></parameter>,
										  <parameter><decl><type><name>cdb_agg_planning_context</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>add_second_stage_group_agg_path</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
											<parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>path</name></decl></parameter>,
											<parameter><decl><type><name>bool</name></type> <name>is_sorted</name></decl></parameter>,
											<parameter><decl><type><name>cdb_agg_planning_context</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>,
											<parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>output_rel</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>add_second_stage_hash_agg_path</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
										   <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>path</name></decl></parameter>,
										   <parameter><decl><type><name>cdb_agg_planning_context</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>,
										   <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>output_rel</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>add_single_dqa_hash_agg_path</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
										 <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>path</name></decl></parameter>,
										 <parameter><decl><type><name>cdb_agg_planning_context</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>,
										 <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>output_rel</name></decl></parameter>,
										 <parameter><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>input_target</name></decl></parameter>,
										 <parameter><decl><type><name>List</name>       <modifier>*</modifier></type><name>dqa_group_clause</name></decl></parameter>,
										 <parameter><decl><type><name>double</name></type> <name>dNumDistinctGroups</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>add_single_mixed_dqa_hash_agg_path</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
                                               <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>path</name></decl></parameter>,
                                               <parameter><decl><type><name>cdb_agg_planning_context</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>,
                                               <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>output_rel</name></decl></parameter>,
                                               <parameter><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>input_target</name></decl></parameter>,
                                               <parameter><decl><type><name>List</name>       <modifier>*</modifier></type><name>dqa_group_clause</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type>
<name>add_multi_dqas_hash_agg_path</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
							 <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>path</name></decl></parameter>,
							 <parameter><decl><type><name>cdb_agg_planning_context</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>,
							 <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>output_rel</name></decl></parameter>,
							 <parameter><decl><type><name>cdb_multi_dqas_info</name> <modifier>*</modifier></type><name>info</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type>
<name>fetch_single_dqa_info</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
					  <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>path</name></decl></parameter>,
					  <parameter><decl><type><name>cdb_agg_planning_context</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>,
					  <parameter><decl><type><name>cdb_multi_dqas_info</name> <modifier>*</modifier></type><name>info</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type>
<name>fetch_multi_dqas_info</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
					  <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>path</name></decl></parameter>,
					  <parameter><decl><type><name>cdb_agg_planning_context</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>,
					  <parameter><decl><type><name>cdb_multi_dqas_info</name> <modifier>*</modifier></type><name>info</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>DQAType</name></type>
<name>recognize_dqa_type</name><parameter_list>(<parameter><decl><type><name>cdb_agg_planning_context</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>PathTarget</name> <modifier>*</modifier></type>
<name>strip_aggdistinct</name><parameter_list>(<parameter><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>target</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * cdb_create_multistage_grouping_paths
 *
 * This is basically an extension of the function create_grouping_paths() from
 * planner.c.  It creates two- and three-stage Paths to implement aggregates
 * and/or GROUP BY.
 *
 * The caller already constructed Paths for one-stage plans, we are only
 * concerned about more complicated multi-stage plans here.
 */</comment>
<function><type><name>void</name></type>
<name>cdb_create_multistage_grouping_paths</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
								   <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>input_rel</name></decl></parameter>,
								   <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>output_rel</name></decl></parameter>,
								   <parameter><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>target</name></decl></parameter>,
								   <parameter><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>partial_grouping_target</name></decl></parameter>,
								   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>havingQual</name></decl></parameter>,
								   <parameter><decl><type><name>double</name></type> <name>dNumGroupsTotal</name></decl></parameter>,
								   <parameter><decl><type><specifier>const</specifier> <name>AggClauseCosts</name> <modifier>*</modifier></type><name>agg_costs</name></decl></parameter>,
								   <parameter><decl><type><specifier>const</specifier> <name>AggClauseCosts</name> <modifier>*</modifier></type><name>agg_partial_costs</name></decl></parameter>,
								   <parameter><decl><type><specifier>const</specifier> <name>AggClauseCosts</name> <modifier>*</modifier></type><name>agg_final_costs</name></decl></parameter>,
								   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>rollups</name></decl></parameter>,
								   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>new_rollups</name></decl></parameter>,
								   <parameter><decl><type><name>AggStrategy</name></type> <name>strat</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>parse</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>parse</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>cheapest_path</name> <init>= <expr><name><name>input_rel</name><operator>-&gt;</operator><name>cheapest_total_path</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>has_ordered_aggs</name> <init>= <expr><name><name>agg_costs</name><operator>-&gt;</operator><name>numPureOrderedAggs</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>cdb_agg_planning_context</name></type> <name>ctx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>can_sort</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>can_hash</name></decl>;</decl_stmt>

	<comment type="block">/* The caller should've checked these already */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>parse</name><operator>-&gt;</operator><name>hasAggs</name></name> <operator>||</operator> <name><name>parse</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * This prohibition could be relaxed if we tracked missing combine
	 * functions per DQA and were willing to plan some DQAs as single and
	 * some as multiple phases.  Not currently, however.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>agg_costs</name><operator>-&gt;</operator><name>hasNonCombine</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>agg_costs</name><operator>-&gt;</operator><name>hasNonSerial</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>config</name><operator>-&gt;</operator><name>gp_enable_multiphase_agg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Ordered aggregates need to run the transition function on the
	 * values in sorted order, which in turn translates into single phase
	 * aggregation.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>has_ordered_aggs</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * We are currently unwilling to redistribute a gathered intermediate
	 * across the cluster.  This might change one day.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CdbPathLocus_IsPartitioned</name><argument_list>(<argument><expr><name><name>cheapest_path</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Is the input hashable / sortable? This is largely the same logic as in
	 * upstream create_grouping_paths(), but we can do hashing in limited ways
	 * even if there are DISTINCT aggs or grouping setst.
	 *
	 * GPDB_12_MERGE:FIXME: the similar rules in planner.c got more complicated.
	 * Does this need to be more fine-grained too? See GROUPING_CAN_USE_SORT and
	 * GROUPING_CAN_USE_HASH.
	 */</comment>
	<expr_stmt><expr><name>can_sort</name> <operator>=</operator> <call><name>grouping_is_sortable</name><argument_list>(<argument><expr><name><name>parse</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>can_hash</name> <operator>=</operator> <operator>(</operator><name><name>parse</name><operator>-&gt;</operator><name>groupClause</name></name> <operator>!=</operator> <name>NIL</name> <operator>&amp;&amp;</operator>
				<name><name>agg_costs</name><operator>-&gt;</operator><name>numPureOrderedAggs</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
				<call><name>grouping_is_hashable</name><argument_list>(<argument><expr><name><name>parse</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>

	<comment type="block">/*
	 * Prepare a struct to hold the arguments and intermediate results
	 * across subroutines.
	 */</comment>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ctx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>can_sort</name></name> <operator>=</operator> <name>can_sort</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>can_hash</name></name> <operator>=</operator> <name>can_hash</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>target</name></name> <operator>=</operator> <name>target</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>dNumGroupsTotal</name></name> <operator>=</operator> <name>dNumGroupsTotal</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>agg_costs</name></name> <operator>=</operator> <name>agg_costs</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>agg_partial_costs</name></name> <operator>=</operator> <name>agg_partial_costs</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>agg_final_costs</name></name> <operator>=</operator> <name>agg_final_costs</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>rollups</name></name> <operator>=</operator> <name>rollups</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>new_rollups</name></name> <operator>=</operator> <name>new_rollups</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>strat</name></name> <operator>=</operator> <name>strat</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>hasAggs</name></name> <operator>=</operator> <name><name>parse</name><operator>-&gt;</operator><name>hasAggs</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>groupClause</name></name> <operator>=</operator> <name><name>parse</name><operator>-&gt;</operator><name>groupClause</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>groupingSets</name></name> <operator>=</operator> <name><name>parse</name><operator>-&gt;</operator><name>groupingSets</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>havingQual</name></name> <operator>=</operator> <name>havingQual</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>partial_rel</name></name> <operator>=</operator> <call><name>fetch_upper_rel</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>UPPERREL_CDB_FIRST_STAGE_GROUP_AGG</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* create a partial rel similar to make_grouping_rel() */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IS_OTHER_REL</name><argument_list>(<argument><expr><name>input_rel</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>partial_rel</name></name> <operator>=</operator> <call><name>fetch_upper_rel</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>UPPERREL_CDB_FIRST_STAGE_GROUP_AGG</name></expr></argument>,
										  <argument><expr><name><name>input_rel</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>partial_rel</name><operator>-&gt;</operator><name>reloptkind</name></name> <operator>=</operator> <name>RELOPT_OTHER_UPPER_REL</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>partial_rel</name></name> <operator>=</operator> <call><name>fetch_upper_rel</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>UPPERREL_CDB_FIRST_STAGE_GROUP_AGG</name></expr></argument>,
										  <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>partial_needed_pathkeys</name></name> <operator>=</operator> <name><name>root</name><operator>-&gt;</operator><name>group_pathkeys</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>partial_sort_pathkeys</name></name> <operator>=</operator> <name><name>root</name><operator>-&gt;</operator><name>group_pathkeys</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>group_tles</name></name> <operator>=</operator> <call><name>get_common_group_tles</name><argument_list>(<argument><expr><name>target</name></expr></argument>,
										   <argument><expr><name><name>parse</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>,
										   <argument><expr><name><name>ctx</name><operator>.</operator><name>rollups</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * For twostage grouping sets, we perform grouping sets aggregation in
	 * partial stage and normal aggregation in final stage.
	 *
	 * With this method, there is a problem, i.e., in the final stage of
	 * aggregation, we don't have a way to distinguish which tuple comes from
	 * which grouping set, which is needed for merging the partial results.
	 *
	 * For instance, suppose we have a table t(c1, c2, c3) containing one row
	 * (1, NULL, 3), and we are selecting agg(c3) group by grouping sets
	 * ((c1,c2), (c1)). Then there would be two tuples as partial results for
	 * that row, both are (1, NULL, agg(3)), one is from group by (c1,c2) and
	 * one is from group by (c1). If we cannot tell that the two tuples are
	 * from two different grouping sets, we will merge them incorrectly.
	 *
	 * So we add a hidden column 'GROUPINGSET_ID', representing grouping set
	 * id, to the targetlist of Partial Aggregate node, as well as to the sort
	 * keys and group keys for Finalize Aggregate node. So only tuples coming
	 * from the same grouping set can get merged in the final stage of
	 * aggregation. Note that we need to keep 'GROUPINGSET_ID' at the head of
	 * sort keys in final stage to ensure correctness.
	 *
	 * Below is a plan to illustrate this idea:
	 *
	 * # explain (costs off, verbose)
	 * select c1, c2, c3, avg(c3) from gstest group by grouping sets((c1,c2),(c1),(c2,c3));
	 *                                 QUERY PLAN
	 * ---------------------------------------------------------------------------
	 *  Finalize GroupAggregate
	 *    Output: c1, c2, c3, avg(c3)
	 *    Group Key: (GROUPINGSET_ID()), gstest.c1, gstest.c2, gstest.c3
	 *    -&gt;  Sort
	 *          Output: c1, c2, c3, (PARTIAL avg(c3)), (GROUPINGSET_ID())
	 *          Sort Key: (GROUPINGSET_ID()), gstest.c1, gstest.c2, gstest.c3
	 *          -&gt;  Gather Motion 3:1  (slice1; segments: 3)
	 *                Output: c1, c2, c3, (PARTIAL avg(c3)), (GROUPINGSET_ID())
	 *                -&gt;  Partial GroupAggregate
	 *                      Output: c1, c2, c3, PARTIAL avg(c3), GROUPINGSET_ID()
	 *                      Group Key: gstest.c1, gstest.c2
	 *                      Group Key: gstest.c1
	 *                      Sort Key: gstest.c2, gstest.c3
	 *                        Group Key: gstest.c2, gstest.c3
	 *                      -&gt;  Sort
	 *                            Output: c1, c2, c3
	 *                            Sort Key: gstest.c1, gstest.c2
	 *                            -&gt;  Seq Scan on public.gstest
	 *                                  Output: c1, c2, c3
	 *  Optimizer: Postgres query optimizer
	 * (20 rows)
	 *
	 * Here, we prepare a target list and a corresponding list of SortGroupClauses
	 * for the result of the Partial Aggregate stage.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>parse</name><operator>-&gt;</operator><name>groupingSets</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>GroupingSetId</name> <modifier>*</modifier></type><name>gsetid</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>grouping_sets_tlist</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>SortGroupClause</name> <modifier>*</modifier></type><name>gsetcl</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>gcls</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>tlist</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>gsetid</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>GroupingSetId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>grouping_sets_tlist</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>processed_tlist</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>gsetid_sortref</name></name> <operator>=</operator> <call><name>add_gsetid_tlist</name><argument_list>(<argument><expr><name>grouping_sets_tlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>gsetcl</name> <operator>=</operator> <call><name>create_gsetid_groupclause</name><argument_list>(<argument><expr><name><name>ctx</name><operator>.</operator><name>gsetid_sortref</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>final_groupClause</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><call><name>copyObject</name><argument_list>(<argument><expr><name><name>parse</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>gsetcl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>partial_grouping_target</name></name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>partial_grouping_target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>list_member</name><argument_list>(<argument><expr><name><name>ctx</name><operator>.</operator><name>partial_grouping_target</name><operator>-&gt;</operator><name>exprs</name></name></expr></argument>, <argument><expr><name>gsetid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>add_column_to_pathtarget</name><argument_list>(<argument><expr><name><name>ctx</name><operator>.</operator><name>partial_grouping_target</name></name></expr></argument>,
									 <argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>gsetid</name></expr></argument>, <argument><expr><name><name>ctx</name><operator>.</operator><name>gsetid_sortref</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>gcls</name> <operator>=</operator> <call><name>get_all_rollup_groupclauses</name><argument_list>(<argument><expr><name>rollups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>gcls</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>gcls</name></expr></argument>, <argument><expr><name>gsetcl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>tlist</name> <operator>=</operator> <call><name>make_tlist_from_pathtarget</name><argument_list>(<argument><expr><name><name>ctx</name><operator>.</operator><name>partial_grouping_target</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * The input to the final stage will be sorted by this. It includes the
		 * GROUPINGSET_ID() column.
		 */</comment>
		<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>final_needed_pathkeys</name></name> <operator>=</operator> <call><name>make_pathkeys_for_sortclauses</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>gcls</name></expr></argument>, <argument><expr><name>tlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>partial_grouping_target</name></name> <operator>=</operator> <name>partial_grouping_target</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>final_groupClause</name></name> <operator>=</operator> <name><name>parse</name><operator>-&gt;</operator><name>groupClause</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>final_needed_pathkeys</name></name> <operator>=</operator> <name><name>root</name><operator>-&gt;</operator><name>group_pathkeys</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>gsetid_sortref</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>final_sort_pathkeys</name></name> <operator>=</operator> <name><name>ctx</name><operator>.</operator><name>final_needed_pathkeys</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>final_group_tles</name></name> <operator>=</operator> <call><name>get_common_group_tles</name><argument_list>(<argument><expr><name><name>ctx</name><operator>.</operator><name>partial_grouping_target</name></name></expr></argument>,
												 <argument><expr><name><name>ctx</name><operator>.</operator><name>final_groupClause</name></name></expr></argument>,
												 <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>partial_rel</name><operator>-&gt;</operator><name>reltarget</name></name> <operator>=</operator> <name><name>ctx</name><operator>.</operator><name>partial_grouping_target</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * All set, generate the two-stage paths.
	 */</comment>
	<expr_stmt><expr><call><name>create_two_stage_paths</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ctx</name></expr></argument>, <argument><expr><name>input_rel</name></expr></argument>, <argument><expr><name>output_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Aggregates with DISTINCT arguments are more complicated, and are not
	 * handled by create_two_stage_paths() (except for the case of a single
	 * DQA that happens to be collocated with the input, see
	 * add_first_stage_group_agg_path()). Consider ways to implement them,
	 * too.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>can_hash</name> <operator>||</operator> <name><name>parse</name><operator>-&gt;</operator><name>groupClause</name></name> <operator>==</operator> <name>NIL</name><operator>)</operator> <operator>&amp;&amp;</operator>
		<operator>!</operator><name><name>parse</name><operator>-&gt;</operator><name>groupingSets</name></name> <operator>&amp;&amp;</operator>
		<call><name>list_length</name><argument_list>(<argument><expr><name><name>agg_costs</name><operator>-&gt;</operator><name>distinctAggrefs</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Try possible plans for DISTINCT-qualified aggregate.
		 */</comment>
		<decl_stmt><decl><type><name>cdb_multi_dqas_info</name></type> <name>info</name> <init>= <expr><block>{}</block></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DQAType</name></type> <name>type</name> <init>= <expr><call><name>recognize_dqa_type</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ctx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<switch>switch <condition>(<expr><name>type</name></expr>)</condition>
		<block>{<block_content>
		<case>case <expr><name>SINGLE_DQA</name></expr>:</case>
			<block>{<block_content>
				<expr_stmt><expr><call><name>fetch_single_dqa_info</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>cheapest_path</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ctx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>add_single_dqa_hash_agg_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
											 <argument><expr><name>cheapest_path</name></expr></argument>,
											 <argument><expr><operator>&amp;</operator><name>ctx</name></expr></argument>,
											 <argument><expr><name>output_rel</name></expr></argument>,
											 <argument><expr><name><name>info</name><operator>.</operator><name>input_proj_target</name></name></expr></argument>,
											 <argument><expr><name><name>info</name><operator>.</operator><name>dqa_group_clause</name></name></expr></argument>,
											 <argument><expr><name><name>info</name><operator>.</operator><name>dNumDistinctGroups</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>SINGLE_DQA_WITHAGG</name></expr>:</case>
			<block>{<block_content>
				<expr_stmt><expr><call><name>fetch_single_dqa_info</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>cheapest_path</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ctx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>add_single_mixed_dqa_hash_agg_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
				                                   <argument><expr><name>cheapest_path</name></expr></argument>,
				                                   <argument><expr><operator>&amp;</operator><name>ctx</name></expr></argument>,
				                                   <argument><expr><name>output_rel</name></expr></argument>,
				                                   <argument><expr><name><name>info</name><operator>.</operator><name>input_proj_target</name></name></expr></argument>,
				                                   <argument><expr><name><name>info</name><operator>.</operator><name>dqa_group_clause</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>MULTI_DQAS</name></expr>:</case>
			<block>{<block_content>
				<expr_stmt><expr><call><name>fetch_multi_dqas_info</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>cheapest_path</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ctx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>add_multi_dqas_hash_agg_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
											 <argument><expr><name>cheapest_path</name></expr></argument>,
											 <argument><expr><operator>&amp;</operator><name>ctx</name></expr></argument>,
											 <argument><expr><name>output_rel</name></expr></argument>,
											 <argument><expr><operator>&amp;</operator><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>MULTI_DQAS_WITHAGG</name></expr>:</case>
			<break>break;</break>
		<default>default:</default>
			<break>break;</break>
		</block_content>}</block></switch>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * cdb_create_twostage_distinct_paths
 *
 * Alternative entry point for DISTINCT planning.
 *
 * This is basically an extension of the function create_distinct_paths() in
 * planner.c.  It creates two-stage Aggregate Paths to implement DISTINCT.
 * The caller already constructed a Paths for one-stage plans.
 *
 * 'input_rel' is usually the result of query_planner(), but it can also be
 * the result of windowing and/or GROUP BY planning, if the query contains
 * both DISTINCT and GROUP BY/windowing.
 */</comment>
<function><type><name>void</name></type>
<name>cdb_create_twostage_distinct_paths</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
								   <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>input_rel</name></decl></parameter>,
								   <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>output_rel</name></decl></parameter>,
								   <parameter><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>target</name></decl></parameter>,
								   <parameter><decl><type><name>double</name></type> <name>dNumGroupsTotal</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>parse</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>parse</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>cheapest_path</name> <init>= <expr><name><name>input_rel</name><operator>-&gt;</operator><name>cheapest_total_path</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AggClauseCosts</name></type> <name>zero_agg_costs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>cdb_agg_planning_context</name></type> <name>ctx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>allow_sort</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>allow_hash</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * We are currently unwilling to redistribute a gathered intermediate
	 * across the cluster.  This might change one day.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CdbPathLocus_IsPartitioned</name><argument_list>(<argument><expr><name><name>cheapest_path</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Is the input hashable / sortable?
	 */</comment>
	<expr_stmt><expr><name>allow_sort</name> <operator>=</operator> <call><name>grouping_is_sortable</name><argument_list>(<argument><expr><name><name>parse</name><operator>-&gt;</operator><name>distinctClause</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>parse</name><operator>-&gt;</operator><name>hasDistinctOn</name></name> <operator>||</operator> <operator>!</operator><name>enable_hashagg</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>allow_hash</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if>		<comment type="block">/* policy-based decision not to hash */</comment>
	<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>grouping_is_hashable</name><argument_list>(<argument><expr><name><name>parse</name><operator>-&gt;</operator><name>distinctClause</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>allow_hash</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>allow_hash</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* Set up a dummy AggClauseCosts struct. There are no aggregates. */</comment>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>zero_agg_costs</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>zero_agg_costs</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ctx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>can_sort</name></name> <operator>=</operator> <name>allow_sort</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>can_hash</name></name> <operator>=</operator> <name>allow_hash</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>target</name></name> <operator>=</operator> <name>target</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>partial_grouping_target</name></name> <operator>=</operator> <name>target</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>dNumGroupsTotal</name></name> <operator>=</operator> <name>dNumGroupsTotal</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>agg_costs</name></name> <operator>=</operator> <operator>&amp;</operator><name>zero_agg_costs</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>agg_partial_costs</name></name> <operator>=</operator> <operator>&amp;</operator><name>zero_agg_costs</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>agg_final_costs</name></name> <operator>=</operator> <operator>&amp;</operator><name>zero_agg_costs</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>rollups</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>partial_rel</name></name> <operator>=</operator> <call><name>fetch_upper_rel</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>UPPERREL_CDB_FIRST_STAGE_DISTINCT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Set up these fields to look like a query with a GROUP BY on all the
	 * DISTINCT columns. No HAVING or aggregates; the DISTINCT processing happens
	 * logically after grouping and aggregation, so those have already been
	 * handled in the grouping stage.
	 */</comment>
	<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>hasAggs</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>groupingSets</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>havingQual</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>groupClause</name></name> <operator>=</operator> <name><name>parse</name><operator>-&gt;</operator><name>distinctClause</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>group_tles</name></name> <operator>=</operator> <call><name>get_common_group_tles</name><argument_list>(<argument><expr><name>target</name></expr></argument>, <argument><expr><name><name>parse</name><operator>-&gt;</operator><name>distinctClause</name></name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>final_groupClause</name></name> <operator>=</operator> <name><name>ctx</name><operator>.</operator><name>groupClause</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>final_group_tles</name></name> <operator>=</operator> <name><name>ctx</name><operator>.</operator><name>group_tles</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>gsetid_sortref</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>ctx</name><operator>.</operator><name>can_sort</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * First, if we have any adequately-presorted paths, just stick a
		 * Unique node on those.  Then consider doing an explicit sort of the
		 * cheapest input path and Unique'ing that.
		 *
		 * When we have DISTINCT ON, we must sort by the more rigorous of
		 * DISTINCT and ORDER BY, else it won't have the desired behavior.
		 * Also, if we do have to do an explicit sort, we might as well use
		 * the more rigorous ordering to avoid a second sort later.  (Note
		 * that the parser will have ensured that one clause is a prefix of
		 * the other.)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>parse</name><operator>-&gt;</operator><name>hasDistinctOn</name></name> <operator>&amp;&amp;</operator>
			<call><name>list_length</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>distinct_pathkeys</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator>
			<call><name>list_length</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>sort_pathkeys</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>partial_needed_pathkeys</name></name> <operator>=</operator> <name><name>root</name><operator>-&gt;</operator><name>sort_pathkeys</name></name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>partial_needed_pathkeys</name></name> <operator>=</operator> <name><name>root</name><operator>-&gt;</operator><name>distinct_pathkeys</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/* For explicit-sort case, always use the more rigorous clause */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>distinct_pathkeys</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator>
			<call><name>list_length</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>sort_pathkeys</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>partial_sort_pathkeys</name></name> <operator>=</operator> <name><name>root</name><operator>-&gt;</operator><name>sort_pathkeys</name></name></expr>;</expr_stmt>
			<comment type="block">/* Assert checks that parser didn't mess up... */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>pathkeys_contained_in</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>distinct_pathkeys</name></name></expr></argument>,
										 <argument><expr><name><name>ctx</name><operator>.</operator><name>partial_sort_pathkeys</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>partial_sort_pathkeys</name></name> <operator>=</operator> <name><name>root</name><operator>-&gt;</operator><name>distinct_pathkeys</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>final_needed_pathkeys</name></name> <operator>=</operator> <name><name>ctx</name><operator>.</operator><name>partial_needed_pathkeys</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>final_sort_pathkeys</name></name> <operator>=</operator> <name><name>ctx</name><operator>.</operator><name>partial_sort_pathkeys</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * All set, generate the two-stage paths.
	 */</comment>
	<expr_stmt><expr><call><name>create_two_stage_paths</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ctx</name></expr></argument>, <argument><expr><name>input_rel</name></expr></argument>, <argument><expr><name>output_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Guts of GROUP BY and DISTINCT planning.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>create_two_stage_paths</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>cdb_agg_planning_context</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>,
					   <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>input_rel</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>output_rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>cheapest_path</name> <init>= <expr><name><name>input_rel</name><operator>-&gt;</operator><name>cheapest_total_path</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Consider ways to do the first Aggregate stage.
	 *
	 * The first stage's output is Partially Aggregated. The paths are
	 * collected to the ctx-&gt;partial_rel, by calling add_path(). We do *not*
	 * use add_partial_path(), these partially aggregated paths are considered
	 * more like MPP paths in Greenplum in general.
	 *
	 * First consider sorted Aggregate paths.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>can_sort</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>input_rel-&gt;pathlist</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>path</name> <init>= <expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>is_sorted</name></decl>;</decl_stmt>

			<comment type="block">/*
			 * If the input is neatly distributed along the GROUP BY columns,
			 * there's no point in a two-stage plan. The code in planner.c
			 * already created the straightforward one-stage plan.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>cdbpathlocus_collocates_tlist</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>path</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>group_tles</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * Consider input paths that are already sorted, and the one with
			 * the lowest total cost.
			 */</comment>
			<expr_stmt><expr><name>is_sorted</name> <operator>=</operator> <call><name>pathkeys_contained_in</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>partial_needed_pathkeys</name></name></expr></argument>,
											  <argument><expr><name><name>path</name><operator>-&gt;</operator><name>pathkeys</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>path</name> <operator>==</operator> <name>cheapest_path</name> <operator>||</operator> <name>is_sorted</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>add_first_stage_group_agg_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>is_sorted</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Consider Hash Aggregate over the cheapest input path.
	 *
	 * Hashing is not possible with DQAs.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>can_hash</name></name> <operator>&amp;&amp;</operator>
		<call><name>list_length</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>agg_costs</name><operator>-&gt;</operator><name>distinctAggrefs</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * If the input is neatly distributed along the GROUP BY columns,
		 * there's no point in a two-stage plan. The code in planner.c already
		 * created the straightforward one-stage plan.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>cdbpathlocus_collocates_tlist</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>cheapest_path</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>group_tles</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>add_first_stage_hash_agg_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>cheapest_path</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * We now have partially aggregated paths in ctx-&gt;partial_rel. Consider
	 * different ways of performing the Finalize Aggregate stage.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>partial_rel</name><operator>-&gt;</operator><name>pathlist</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>cheapest_first_stage_path</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>set_cheapest</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>partial_rel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>cheapest_first_stage_path</name> <operator>=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>partial_rel</name><operator>-&gt;</operator><name>cheapest_total_path</name></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>can_sort</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

			<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>ctx-&gt;partial_rel-&gt;pathlist</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>path</name> <init>= <expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>bool</name></type>		<name>is_sorted</name></decl>;</decl_stmt>

				<comment type="block">/*
				 * In two-stage GROUPING SETS paths, the second stage's grouping
				 * will include GROUPINGSET_ID(), which is not included in
				 * root-&gt;pathkeys. The first stage's sort order does not include
				 * that, so we know it's not sorted.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>groupingSets</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>is_sorted</name> <operator>=</operator> <call><name>pathkeys_contained_in</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>final_needed_pathkeys</name></name></expr></argument>,
													  <argument><expr><name><name>path</name><operator>-&gt;</operator><name>pathkeys</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name>is_sorted</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
				<if_stmt><if>if <condition>(<expr><name>path</name> <operator>==</operator> <name>cheapest_first_stage_path</name> <operator>||</operator> <name>is_sorted</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>add_second_stage_group_agg_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>is_sorted</name></expr></argument>,
													<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>output_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>can_hash</name></name> <operator>&amp;&amp;</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>agg_costs</name><operator>-&gt;</operator><name>distinctAggrefs</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>add_second_stage_hash_agg_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>cheapest_first_stage_path</name></expr></argument>,
										   <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>output_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Add a TargetEntry node of type GroupingSetId to the tlist.
 * Return its ressortgroupref.
 */</comment>
<function><type><specifier>static</specifier> <name>Index</name></type>
<name>add_gsetid_tlist</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GroupingSetId</name> <modifier>*</modifier></type><name>gsetid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>tlist</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><name>tle</name> <operator>=</operator> <call><name>lfirst_node</name><argument_list>(<argument><expr><name>TargetEntry</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>GroupingSetId</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"GROUPINGSET_ID already exists in tlist"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>

	<expr_stmt><expr><name>gsetid</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>GroupingSetId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tle</name> <operator>=</operator> <call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator><name>gsetid</name></expr></argument>, <argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
			<argument><expr><literal type="string">"GROUPINGSET_ID"</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assignSortGroupRef</name><argument_list>(<argument><expr><name>tle</name></expr></argument>, <argument><expr><name>tlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tlist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>, <argument><expr><name>tle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>tle</name><operator>-&gt;</operator><name>ressortgroupref</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Add a SortGroupClause node to the groupClause representing the GroupingSetId.
 * Note we insert the new node to the head of groupClause.
 */</comment>
<function><type><specifier>static</specifier> <name>SortGroupClause</name> <modifier>*</modifier></type>
<name>create_gsetid_groupclause</name><parameter_list>(<parameter><decl><type><name>Index</name></type> <name>groupref</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SortGroupClause</name> <modifier>*</modifier></type><name>gc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>         <name>sortop</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>         <name>eqop</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>        <name>hashable</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>get_sort_group_operators</name><argument_list>(<argument><expr><name>INT4OID</name></expr></argument>,
			<argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
			<argument><expr><operator>&amp;</operator><name>sortop</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>eqop</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
			<argument><expr><operator>&amp;</operator><name>hashable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>gc</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>SortGroupClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>gc</name><operator>-&gt;</operator><name>tleSortGroupRef</name></name> <operator>=</operator> <name>groupref</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>gc</name><operator>-&gt;</operator><name>eqop</name></name> <operator>=</operator> <name>eqop</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>gc</name><operator>-&gt;</operator><name>sortop</name></name> <operator>=</operator> <name>sortop</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>gc</name><operator>-&gt;</operator><name>nulls_first</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>gc</name><operator>-&gt;</operator><name>hashable</name></name> <operator>=</operator> <name>hashable</name></expr>;</expr_stmt>

	<return>return <expr><name>gc</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>strip_gsetid_from_pathkeys</name><parameter_list>(<parameter><decl><type><name>Index</name></type> <name>gsetid_sortref</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>pathkeys</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>new_pathkeys</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>gsetid_sortref</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>pathkeys</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>new_pathkeys</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>pathkeys</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PathKey</name>	   <modifier>*</modifier></type><name>pathkey</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>EquivalenceClass</name> <modifier>*</modifier></type><name>eclass</name> <init>= <expr><name><name>pathkey</name><operator>-&gt;</operator><name>pk_eclass</name></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>eclass</name><operator>-&gt;</operator><name>ec_sortref</name></name> <operator>==</operator> <name>gsetid_sortref</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * The GROUPINGSETID_EXPR() should be the last pathkey. But just in
			 * case it's not, any columns after it won't be in right order i
			 * we remove it from the middle.
			 */</comment>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>new_pathkeys</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>new_pathkeys</name></expr></argument>, <argument><expr><name>pathkey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<return>return <expr><name>new_pathkeys</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Create a partially aggregated path from given input 'path' by sorting (if
 * input isn't sorted already).
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
	<name>add_first_stage_group_agg_path</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
							   <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>path</name></decl></parameter>,
							   <parameter><decl><type><name>bool</name></type> <name>is_sorted</name></decl></parameter>,
							   <parameter><decl><type><name>cdb_agg_planning_context</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DQAType</name></type>     <name>dqa_type</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * DISTINCT-qualified aggregates are accepted only in the special
	 * case that the input happens to be collocated with the DISTINCT
	 * argument.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>agg_costs</name><operator>-&gt;</operator><name>distinctAggrefs</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>cdb_multi_dqas_info</name></type> <name>info</name> <init>= <expr><block>{}</block></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>dqa_group_tles</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>dqa_type</name> <operator>=</operator> <call><name>recognize_dqa_type</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* For the query:
		 *     select count(distinct a), sum(b), sum(c) from t;
		 * If t is distributed by (a), we can also use multi stage
		 * agg because two same a cannot be in different segments.
		 * So we should also consider SINGLE_DQA_WITHAGG here.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>dqa_type</name> <operator>!=</operator> <name>SINGLE_DQA</name> <operator>&amp;&amp;</operator> <name>dqa_type</name> <operator>!=</operator> <name>SINGLE_DQA_WITHAGG</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return;</return></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>fetch_single_dqa_info</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If subpath is projection capable, we do not want to generate a
		 * projection plan. The reason is that the projection plan does not
		 * constrain a child tlist when it creates subplan. Thus, GROUP BY expr
		 * may not be found in the scan targetlist.
		 */</comment>
		<expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>apply_projection_to_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>path</name><operator>-&gt;</operator><name>parent</name></name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name><name>info</name><operator>.</operator><name>input_proj_target</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* If the input distribution matches the distinct, we can proceed */</comment>
		<expr_stmt><expr><name>dqa_group_tles</name> <operator>=</operator> <call><name>get_common_group_tles</name><argument_list>(<argument><expr><name><name>info</name><operator>.</operator><name>input_proj_target</name></name></expr></argument>,
											   <argument><expr><name><name>info</name><operator>.</operator><name>dqa_group_clause</name></name></expr></argument>,
											   <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>rollups</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>cdbpathlocus_collocates_tlist</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>path</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>, <argument><expr><name>dqa_group_tles</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_sorted</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>path</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>create_sort_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
										 <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>partial_rel</name></name></expr></argument>,
										 <argument><expr><name>path</name></expr></argument>,
										 <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>partial_sort_pathkeys</name></name></expr></argument>,
										 <argument><expr><operator>-</operator><literal type="number">1.0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>groupingSets</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We have grouping sets, possibly with aggregation.  Make
		 * a GroupingSetsPath.
		 *
		 * NOTE: We don't pass the HAVING quals here. HAVING quals can
		 * only be evaluated in the Finalize stage, after computing the
		 * final aggregate values.
		 */</comment>
		<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>first_stage_agg_path</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>first_stage_agg_path</name> <operator>=</operator>
			<operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>create_groupingsets_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
											  <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>partial_rel</name></name></expr></argument>,
											  <argument><expr><name>path</name></expr></argument>,
											  <argument><expr><name>AGGSPLIT_INITIAL_SERIAL</name></expr></argument>,
											  <argument><expr><name>NIL</name></expr></argument>,
											  <argument><expr><name>AGG_SORTED</name></expr></argument>,
											  <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>rollups</name></name></expr></argument>,
											  <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>agg_partial_costs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>add_path</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>partial_rel</name></name></expr></argument>, <argument><expr><name>first_stage_agg_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>hasAggs</name></name> <operator>||</operator> <name><name>ctx</name><operator>-&gt;</operator><name>groupClause</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>add_path</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>partial_rel</name></name></expr></argument>,
			<argument><expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>create_agg_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
									 <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>partial_rel</name></name></expr></argument>,
									 <argument><expr><name>path</name></expr></argument>,
									 <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>partial_grouping_target</name></name></expr></argument>,
									 <argument><expr><ternary><condition><expr><name><name>ctx</name><operator>-&gt;</operator><name>groupClause</name></name></expr> ?</condition><then> <expr><name>AGG_SORTED</name></expr> </then><else>: <expr><name>AGG_PLAIN</name></expr></else></ternary></expr></argument>,
									 <argument><expr><ternary><condition><expr><name><name>ctx</name><operator>-&gt;</operator><name>hasAggs</name></name></expr> ?</condition><then> <expr><name>AGGSPLIT_INITIAL_SERIAL</name></expr> </then><else>: <expr><name>AGGSPLIT_SIMPLE</name></expr></else></ternary></expr></argument>,
									 <argument><expr><name>false</name></expr></argument>, <comment type="block">/* streaming */</comment>
									 <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>,
									 <argument><expr><name>NIL</name></expr></argument>,
									 <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>agg_partial_costs</name></name></expr></argument>,
									 <argument><expr><call><name>estimate_num_groups_on_segment</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>dNumGroupsTotal</name></name></expr></argument>,
																	<argument><expr><name><name>path</name><operator>-&gt;</operator><name>rows</name></name></expr></argument>, <argument><expr><name><name>path</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Create Finalize Aggregate path, from a partially aggregated input.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>add_second_stage_group_agg_path</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
								<parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>initial_agg_path</name></decl></parameter>,
								<parameter><decl><type><name>bool</name></type> <name>is_sorted</name></decl></parameter>,
								<parameter><decl><type><name>cdb_agg_planning_context</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>,
								<parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>output_rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>path</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CdbPathLocus</name></type> <name>singleQE_locus</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CdbPathLocus</name></type> <name>group_locus</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>need_redistribute</name></decl>;</decl_stmt>

	<comment type="block">/* The input should be distributed, otherwise no point in a two-stage Agg. */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>CdbPathLocus_IsPartitioned</name><argument_list>(<argument><expr><name><name>initial_agg_path</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>group_locus</name> <operator>=</operator> <call><name>choose_grouping_locus</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
										<argument><expr><name>initial_agg_path</name></expr></argument>,
										<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>final_group_tles</name></name></expr></argument>,
										<argument><expr><operator>&amp;</operator><name>need_redistribute</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>need_redistribute</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We consider two different loci for the final result:
	 *
	 * 1. Redistribute the partial result according to GROUP BY columns,
	 *    Sort, Aggregate.
	 *
	 * 2. Gather the partial result to a single process, Sort if needed,
	 *    Aggregate.
	 *
	 * Redistributing the partial result has the advantage that the Finalize
	 * stage can run in parallel. The downside is that a Redistribute Motion
	 * loses any possible input order, so we'll need an extra Sort step even
	 * if the input was already ordered. Also, gathering the partial result
	 * directly to the QD will avoid one Motion, if the final result is needed
	 * in the QD anyway.
	 *
	 * We generate a Path for both, and let add_path() decide which ones
	 * to keep.
	 */</comment>
	<comment type="block">/* Alternative 1: Redistribute -&gt; Sort -&gt; Agg */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>CdbPathLocus_IsHashed</name><argument_list>(<argument><expr><name>group_locus</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>cdbpath_create_motion_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>initial_agg_path</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>,
											 <argument><expr><name>false</name></expr></argument>, <argument><expr><name>group_locus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>final_sort_pathkeys</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>path</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>create_sort_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
											 <argument><expr><name>output_rel</name></expr></argument>,
											 <argument><expr><name>path</name></expr></argument>,
											 <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>final_sort_pathkeys</name></name></expr></argument>,
											 <argument><expr><operator>-</operator><literal type="number">1.0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>path</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>create_agg_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
										<argument><expr><name>output_rel</name></expr></argument>,
										<argument><expr><name>path</name></expr></argument>,
										<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>target</name></name></expr></argument>,
										<argument><expr><operator>(</operator><ternary><condition><expr><name><name>ctx</name><operator>-&gt;</operator><name>final_groupClause</name></name></expr> ?</condition><then> <expr><name>AGG_SORTED</name></expr> </then><else>: <expr><name>AGG_PLAIN</name></expr></else></ternary><operator>)</operator></expr></argument>,
										<argument><expr><ternary><condition><expr><name><name>ctx</name><operator>-&gt;</operator><name>hasAggs</name></name></expr> ?</condition><then> <expr><name>AGGSPLIT_FINAL_DESERIAL</name></expr> </then><else>: <expr><name>AGGSPLIT_SIMPLE</name></expr></else></ternary></expr></argument>,
										<argument><expr><name>false</name></expr></argument>, <comment type="block">/* streaming */</comment>
										<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>final_groupClause</name></name></expr></argument>,
										<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>havingQual</name></name></expr></argument>,
										<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>agg_final_costs</name></name></expr></argument>,
										<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>dNumGroupsTotal</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>pathkeys</name></name> <operator>=</operator> <call><name>strip_gsetid_from_pathkeys</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>gsetid_sortref</name></name></expr></argument>, <argument><expr><name><name>path</name><operator>-&gt;</operator><name>pathkeys</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>add_path</name><argument_list>(<argument><expr><name>output_rel</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Alternative 2: [Sort if needed] -&gt; Gather -&gt; Agg
	 */</comment>
	<expr_stmt><expr><call><name>CdbPathLocus_MakeSingleQE</name><argument_list>(<argument><expr><operator>&amp;</operator><name>singleQE_locus</name></expr></argument>, <argument><expr><call><name>getgpsegmentCount</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>path</name> <operator>=</operator> <name>initial_agg_path</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_sorted</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>path</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>create_sort_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
										 <argument><expr><name>output_rel</name></expr></argument>,
										 <argument><expr><name>path</name></expr></argument>,
										 <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>final_sort_pathkeys</name></name></expr></argument>,
										 <argument><expr><operator>-</operator><literal type="number">1.0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>cdbpath_create_motion_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>,
									  <argument><expr><name><name>path</name><operator>-&gt;</operator><name>pathkeys</name></name></expr></argument>,
									  <argument><expr><name>false</name></expr></argument>, <argument><expr><name>singleQE_locus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>path</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>create_agg_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
									<argument><expr><name>output_rel</name></expr></argument>,
									<argument><expr><name>path</name></expr></argument>,
									<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>target</name></name></expr></argument>,
									<argument><expr><operator>(</operator><ternary><condition><expr><name><name>ctx</name><operator>-&gt;</operator><name>final_groupClause</name></name></expr> ?</condition><then> <expr><name>AGG_SORTED</name></expr> </then><else>: <expr><name>AGG_PLAIN</name></expr></else></ternary><operator>)</operator></expr></argument>,
									<argument><expr><ternary><condition><expr><name><name>ctx</name><operator>-&gt;</operator><name>hasAggs</name></name></expr> ?</condition><then> <expr><name>AGGSPLIT_FINAL_DESERIAL</name></expr> </then><else>: <expr><name>AGGSPLIT_SIMPLE</name></expr></else></ternary></expr></argument>,
									<argument><expr><name>false</name></expr></argument>, <comment type="block">/* streaming */</comment>
									<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>final_groupClause</name></name></expr></argument>,
									<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>havingQual</name></name></expr></argument>,
									<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>agg_final_costs</name></name></expr></argument>,
									<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>dNumGroupsTotal</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>path</name><operator>-&gt;</operator><name>pathkeys</name></name> <operator>=</operator> <call><name>strip_gsetid_from_pathkeys</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>gsetid_sortref</name></name></expr></argument>, <argument><expr><name><name>path</name><operator>-&gt;</operator><name>pathkeys</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>add_path</name><argument_list>(<argument><expr><name>output_rel</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Create a partially aggregated path from given input 'path' by hashing.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>add_first_stage_hash_agg_path</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
							  <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>path</name></decl></parameter>,
							  <parameter><decl><type><name>cdb_agg_planning_context</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>parse</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>parse</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Path</name>       <modifier>*</modifier></type><name>first_stage_agg_path</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>dNumGroups</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>dNumGroups</name> <operator>=</operator> <call><name>estimate_num_groups_on_segment</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>dNumGroupsTotal</name></name></expr></argument>,
												<argument><expr><name><name>path</name><operator>-&gt;</operator><name>rows</name></name></expr></argument>, <argument><expr><name><name>path</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


	<if_stmt><if>if <condition>(<expr><name><name>parse</name><operator>-&gt;</operator><name>groupingSets</name></name> <operator>&amp;&amp;</operator> <name><name>ctx</name><operator>-&gt;</operator><name>new_rollups</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>first_stage_agg_path</name> <operator>=</operator>
			<operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>create_groupingsets_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
											  <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>partial_rel</name></name></expr></argument>,
											  <argument><expr><name>path</name></expr></argument>,
											  <argument><expr><name>AGGSPLIT_INITIAL_SERIAL</name></expr></argument>,
											  <argument><expr><name>NIL</name></expr></argument>,
											  <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>strat</name></name></expr></argument>,
											  <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>new_rollups</name></name></expr></argument>,
											  <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>agg_partial_costs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CdbPathLocus_MakeStrewn</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>first_stage_agg_path</name><operator>-&gt;</operator><name>locus</name></name><operator>)</operator></expr></argument>,
								<argument><expr><call><name>CdbPathLocus_NumSegments</name><argument_list>(<argument><expr><name><name>first_stage_agg_path</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>add_path</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>partial_rel</name></name></expr></argument>, <argument><expr><name>first_stage_agg_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>add_path</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>partial_rel</name></name></expr></argument>,
				 <argument><expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>create_agg_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
										  <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>partial_rel</name></name></expr></argument>,
										  <argument><expr><name>path</name></expr></argument>,
										  <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>partial_grouping_target</name></name></expr></argument>,
										  <argument><expr><name>AGG_HASHED</name></expr></argument>,
										  <argument><expr><ternary><condition><expr><name><name>ctx</name><operator>-&gt;</operator><name>hasAggs</name></name></expr> ?</condition><then> <expr><name>AGGSPLIT_INITIAL_SERIAL</name></expr> </then><else>: <expr><name>AGGSPLIT_SIMPLE</name></expr></else></ternary></expr></argument>,
										  <argument><expr><name>false</name></expr></argument>, <comment type="block">/* streaming */</comment>
										  <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>,
										  <argument><expr><name>NIL</name></expr></argument>,
										  <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>agg_partial_costs</name></name></expr></argument>,
										  <argument><expr><name>dNumGroups</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Create Finalize Aggregate path from a partially aggregated input by hashing.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>add_second_stage_hash_agg_path</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
							   <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>initial_agg_path</name></decl></parameter>,
							   <parameter><decl><type><name>cdb_agg_planning_context</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>,
							   <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>output_rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CdbPathLocus</name></type> <name>group_locus</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>needs_redistribute</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>dNumGroups</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>hashentrysize</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>group_locus</name> <operator>=</operator> <call><name>choose_grouping_locus</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
										<argument><expr><name>initial_agg_path</name></expr></argument>,
										<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>final_group_tles</name></name></expr></argument>,
										<argument><expr><operator>&amp;</operator><name>needs_redistribute</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* if no redistribution is needed, why are we here? */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>needs_redistribute</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Calculate the number of groups in the second stage, per segment.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>CdbPathLocus_IsPartitioned</name><argument_list>(<argument><expr><name>group_locus</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>dNumGroups</name> <operator>=</operator> <call><name>clamp_row_est</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>dNumGroupsTotal</name></name> <operator>/</operator>
								   <call><name>CdbPathLocus_NumSegments</name><argument_list>(<argument><expr><name>group_locus</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>dNumGroups</name> <operator>=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>dNumGroupsTotal</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* Would the hash table fit in memory? */</comment>
	<expr_stmt><expr><name>hashentrysize</name> <operator>=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name><name>initial_agg_path</name><operator>-&gt;</operator><name>pathtarget</name><operator>-&gt;</operator><name>width</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>SizeofMinimalTupleHeader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>enable_hashagg_disk</name> <operator>||</operator>
		<name>hashentrysize</name> <operator>*</operator> <name>dNumGroups</name> <operator>&lt;</operator> <name>work_mem</name> <operator>*</operator> <literal type="number">1024L</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>path</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>cdbpath_create_motion_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>initial_agg_path</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
										  <argument><expr><name>group_locus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>path</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>create_agg_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
										<argument><expr><name>output_rel</name></expr></argument>,
										<argument><expr><name>path</name></expr></argument>,
										<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>target</name></name></expr></argument>,
										<argument><expr><name>AGG_HASHED</name></expr></argument>,
										<argument><expr><ternary><condition><expr><name><name>ctx</name><operator>-&gt;</operator><name>hasAggs</name></name></expr> ?</condition><then> <expr><name>AGGSPLIT_FINAL_DESERIAL</name></expr> </then><else>: <expr><name>AGGSPLIT_SIMPLE</name></expr></else></ternary></expr></argument>,
										<argument><expr><name>false</name></expr></argument>, <comment type="block">/* streaming */</comment>
										<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>final_groupClause</name></name></expr></argument>,
										<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>havingQual</name></name></expr></argument>,
										<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>agg_final_costs</name></name></expr></argument>,
										<argument><expr><name>dNumGroups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>add_path</name><argument_list>(<argument><expr><name>output_rel</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Like in the Group Agg case, if the final result needs to be brough to
	 * the QD, we consider doing the Finalize Aggregate in the QD directly to
	 * avoid another Gather Motion above the Finalize Aggregate. It's less
	 * likely to be a win than with sorted Aggs, because a hashed agg won't
	 * benefit from preserving the input order, but it can still be cheaper if
	 * there are only a few groups.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CdbPathLocus_IsBottleneck</name><argument_list>(<argument><expr><name>group_locus</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<call><name>CdbPathLocus_IsBottleneck</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>final_locus</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>CdbPathLocus</name></type> <name>singleQE_locus</name></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>CdbPathLocus_MakeSingleQE</name><argument_list>(<argument><expr><operator>&amp;</operator><name>singleQE_locus</name></expr></argument>, <argument><expr><call><name>getgpsegmentCount</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>hashentrysize</name> <operator>=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name><name>initial_agg_path</name><operator>-&gt;</operator><name>pathtarget</name><operator>-&gt;</operator><name>width</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>SizeofMinimalTupleHeader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>hashentrysize</name> <operator>*</operator> <name><name>ctx</name><operator>-&gt;</operator><name>dNumGroupsTotal</name></name> <operator>&lt;=</operator> <name>work_mem</name> <operator>*</operator> <literal type="number">1024L</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>path</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>cdbpath_create_motion_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>initial_agg_path</name></expr></argument>,
											  <argument><expr><name>NIL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
											  <argument><expr><name>singleQE_locus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>path</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>create_agg_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
											<argument><expr><name>output_rel</name></expr></argument>,
											<argument><expr><name>path</name></expr></argument>,
											<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>target</name></name></expr></argument>,
											<argument><expr><name>AGG_HASHED</name></expr></argument>,
											<argument><expr><ternary><condition><expr><name><name>ctx</name><operator>-&gt;</operator><name>hasAggs</name></name></expr> ?</condition><then> <expr><name>AGGSPLIT_FINAL_DESERIAL</name></expr> </then><else>: <expr><name>AGGSPLIT_SIMPLE</name></expr></else></ternary></expr></argument>,
											<argument><expr><name>false</name></expr></argument>, <comment type="block">/* streaming */</comment>
											<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>final_groupClause</name></name></expr></argument>,
											<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>havingQual</name></name></expr></argument>,
											<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>agg_final_costs</name></name></expr></argument>,
											<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>dNumGroupsTotal</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>add_path</name><argument_list>(<argument><expr><name>output_rel</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>strip_aggdistinct_mutator</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Aggref</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Aggref</name>	   <modifier>*</modifier></type><name>newAggref</name> <init>= <expr><operator>(</operator><name>Aggref</name> <operator>*</operator><operator>)</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>newAggref</name><operator>-&gt;</operator><name>aggdistinct</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>node</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newAggref</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><call><name>expression_tree_mutator</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>strip_aggdistinct_mutator</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>PathTarget</name> <modifier>*</modifier></type>
<name>strip_aggdistinct</name><parameter_list>(<parameter><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>target</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>copy_pathtarget</name><argument_list>(<argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>exprs</name></name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>strip_aggdistinct_mutator</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>result</name><operator>-&gt;</operator><name>exprs</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Create Paths for an Aggregate with one DISTINCT-qualified aggregate and
 * multi normal aggregate.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>add_single_mixed_dqa_hash_agg_path</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
                                               <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>path</name></decl></parameter>,
                                               <parameter><decl><type><name>cdb_agg_planning_context</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>,
                                               <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>output_rel</name></decl></parameter>,
                                               <parameter><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>input_target</name></decl></parameter>,
                                               <parameter><decl><type><name>List</name>       <modifier>*</modifier></type><name>dqa_group_clause</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>dqa_group_tles</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CdbPathLocus</name></type> <name>distinct_locus</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>distinct_need_redistribute</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CdbPathLocus</name></type> <name>singleQE_locus</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>gp_enable_agg_distinct</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>groupClause</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If subpath is projection capable, we do not want to generate a
	 * projection plan. The reason is that the projection plan does not
	 * constrain a child tlist when it creates subplan. Thus, GROUP BY expr
	 * may not be found in the scan targetlist.
	 */</comment>
	<expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>apply_projection_to_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>path</name><operator>-&gt;</operator><name>parent</name></name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>input_target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>dqa_group_tles</name> <operator>=</operator> <call><name>get_common_group_tles</name><argument_list>(<argument><expr><name>input_target</name></expr></argument>, <argument><expr><name>dqa_group_clause</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>  )</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>distinct_locus</name> <operator>=</operator> <call><name>choose_grouping_locus</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>,
										   <argument><expr><name>dqa_group_tles</name></expr></argument>,
										   <argument><expr><operator>&amp;</operator><name>distinct_need_redistribute</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CdbPathLocus_IsPartitioned</name><argument_list>(<argument><expr><name>distinct_locus</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>distinct_need_redistribute</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>cdbpath_create_motion_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
										  <argument><expr><name>distinct_locus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>path</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>create_agg_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
									<argument><expr><name>output_rel</name></expr></argument>,
									<argument><expr><name>path</name></expr></argument>,
									<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>partial_grouping_target</name></name></expr></argument>,
									<argument><expr><name>AGG_PLAIN</name></expr></argument>,
									<argument><expr><name>AGGSPLIT_INITIAL_SERIAL</name></expr></argument>,
									<argument><expr><name>false</name></expr></argument>, <comment type="block">/* streaming */</comment>
									<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>,
									<argument><expr><name>NIL</name></expr></argument>,
									<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>agg_partial_costs</name></name></expr></argument>, <comment type="block">/* FIXME */</comment>
									<argument><expr><call><name>estimate_num_groups_on_segment</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>dNumGroupsTotal</name></name></expr></argument>,
																   <argument><expr><name><name>path</name><operator>-&gt;</operator><name>rows</name></name></expr></argument>, <argument><expr><name><name>path</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CdbPathLocus_MakeSingleQE</name><argument_list>(<argument><expr><operator>&amp;</operator><name>singleQE_locus</name></expr></argument>, <argument><expr><call><name>getgpsegmentCount</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>cdbpath_create_motion_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>singleQE_locus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>path</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>create_agg_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
									<argument><expr><name>output_rel</name></expr></argument>,
									<argument><expr><name>path</name></expr></argument>,
									<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>target</name></name></expr></argument>,
									<argument><expr><name>AGG_PLAIN</name></expr></argument>,
									<argument><expr><name>AGGSPLIT_FINAL_DESERIAL</name></expr></argument>,
									<argument><expr><name>false</name></expr></argument>, <comment type="block">/* streaming */</comment>
									<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>,
									<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>havingQual</name></name></expr></argument>,
									<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>agg_final_costs</name></name></expr></argument>,
									<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>dNumGroupsTotal</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>add_path</name><argument_list>(<argument><expr><name>output_rel</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Create Paths for an Aggregate with one DISTINCT-qualified aggregate.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>add_single_dqa_hash_agg_path</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
							 <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>path</name></decl></parameter>,
							 <parameter><decl><type><name>cdb_agg_planning_context</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>,
							 <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>output_rel</name></decl></parameter>,
							 <parameter><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>input_target</name></decl></parameter>,
							 <parameter><decl><type><name>List</name>       <modifier>*</modifier></type><name>dqa_group_clause</name></decl></parameter>,
							 <parameter><decl><type><name>double</name></type> <name>dNumDistinctGroups</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>dqa_group_tles</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>num_input_segments</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>group_tles</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CdbPathLocus</name></type> <name>group_locus</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>dNumGroups</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>group_need_redistribute</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CdbPathLocus</name></type> <name>distinct_locus</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>distinct_need_redistribute</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>gp_enable_agg_distinct</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If subpath is projection capable, we do not want to generate a
	 * projection plan. The reason is that the projection plan does not
	 * constrain a child tlist when it creates subplan. Thus, GROUP BY expr
	 * may not be found in the scan targetlist.
	 */</comment>
	<expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>apply_projection_to_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>path</name><operator>-&gt;</operator><name>parent</name></name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>input_target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>CdbPathLocus_IsPartitioned</name><argument_list>(<argument><expr><name><name>path</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>num_input_segments</name> <operator>=</operator> <call><name>CdbPathLocus_NumSegments</name><argument_list>(<argument><expr><name><name>path</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>num_input_segments</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name>dqa_group_tles</name> <operator>=</operator> <call><name>get_common_group_tles</name><argument_list>(<argument><expr><name>input_target</name></expr></argument>, <argument><expr><name>dqa_group_clause</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>distinct_locus</name> <operator>=</operator> <call><name>choose_grouping_locus</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>,
										   <argument><expr><name>dqa_group_tles</name></expr></argument>,
										   <argument><expr><operator>&amp;</operator><name>distinct_need_redistribute</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Calculate the number of groups in the final stage, per segment.
	 * group_locus is the corresponding locus for the final stage.
	 */</comment>
	<expr_stmt><expr><name>group_tles</name> <operator>=</operator> <call><name>get_common_group_tles</name><argument_list>(<argument><expr><name>input_target</name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>group_locus</name> <operator>=</operator> <call><name>choose_grouping_locus</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>,
										<argument><expr><name>group_tles</name></expr></argument>,
										<argument><expr><operator>&amp;</operator><name>group_need_redistribute</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>CdbPathLocus_IsPartitioned</name><argument_list>(<argument><expr><name>group_locus</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>dNumGroups</name> <operator>=</operator> <call><name>clamp_row_est</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>dNumGroupsTotal</name></name> <operator>/</operator>
								   <call><name>CdbPathLocus_NumSegments</name><argument_list>(<argument><expr><name><name>path</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>dNumGroups</name> <operator>=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>dNumGroupsTotal</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>distinct_need_redistribute</name> <operator>||</operator> <operator>!</operator><name>group_need_redistribute</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * 1. If the input's locus matches the DISTINCT, but not GROUP BY:
		 *
		 *  HashAggregate
		 *     -&gt; Redistribute (according to GROUP BY)
		 *         -&gt; HashAggregate (to eliminate duplicates)
		 *             -&gt; input (hashed by GROUP BY + DISTINCT)
		 *
		 * 2. If the input's locus matches the GROUP BY:
		 *
		 *  HashAggregate (to aggregate)
		 *     -&gt; HashAggregate (to eliminate duplicates)
		 *           -&gt; input (hashed by GROUP BY)
		 *
		 * The main planner should already have created the single-stage
		 * Group Agg path.
		 *
		 * XXX: not sure if this makes sense. If hash distinct is a good
		 * idea, why doesn't PostgreSQL's agg node implement that?
		 */</comment>
		<expr_stmt><expr><name>path</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>create_agg_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
										<argument><expr><name>output_rel</name></expr></argument>,
										<argument><expr><name>path</name></expr></argument>,
										<argument><expr><name>input_target</name></expr></argument>,
										<argument><expr><name>AGG_HASHED</name></expr></argument>,
										<argument><expr><name>AGGSPLIT_SIMPLE</name></expr></argument>,
										<argument><expr><name>false</name></expr></argument>, <comment type="block">/* streaming */</comment>
										<argument><expr><name>dqa_group_clause</name></expr></argument>,
										<argument><expr><name>NIL</name></expr></argument>,
										<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>agg_partial_costs</name></name></expr></argument>, <comment type="block">/* FIXME */</comment>
										<argument><expr><call><name>clamp_row_est</name><argument_list>(<argument><expr><name>dNumDistinctGroups</name> <operator>/</operator> <operator>(</operator><name>double</name><operator>)</operator> <name>num_input_segments</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>group_need_redistribute</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>cdbpath_create_motion_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
											  <argument><expr><name>group_locus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>path</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>create_agg_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
										<argument><expr><name>output_rel</name></expr></argument>,
										<argument><expr><name>path</name></expr></argument>,
										<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>target</name></name></expr></argument>,
										<argument><expr><ternary><condition><expr><name><name>ctx</name><operator>-&gt;</operator><name>groupClause</name></name></expr> ?</condition><then> <expr><name>AGG_HASHED</name></expr> </then><else>: <expr><name>AGG_PLAIN</name></expr></else></ternary></expr></argument>,
										<argument><expr><name>AGGSPLIT_DEDUPLICATED</name></expr></argument>,
										<argument><expr><name>false</name></expr></argument>, <comment type="block">/* streaming */</comment>
										<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>,
										<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>havingQual</name></name></expr></argument>,
										<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>agg_final_costs</name></name></expr></argument>,
										<argument><expr><name>dNumGroups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>add_path</name><argument_list>(<argument><expr><name>output_rel</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>CdbPathLocus_IsHashed</name><argument_list>(<argument><expr><name>group_locus</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>double</name></type>		<name>input_rows</name> <init>= <expr><name><name>path</name><operator>-&gt;</operator><name>rows</name></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 *  HashAgg (to aggregate)
		 *     -&gt; HashAgg (to eliminate duplicates)
		 *          -&gt; Redistribute (according to GROUP BY)
		 *               -&gt; Streaming HashAgg (to eliminate duplicates)
		 *                    -&gt; input
		 *
		 * It may seem silly to have two Aggs on top of each other like this,
		 * but the Agg node can't do DISTINCT-aggregation by hashing at the
		 * moment. So we have to do it with two separate Aggs steps.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>gp_enable_dqa_pruning</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>path</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>create_agg_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
											<argument><expr><name>output_rel</name></expr></argument>,
											<argument><expr><name>path</name></expr></argument>,
											<argument><expr><name>input_target</name></expr></argument>,
											<argument><expr><name>AGG_HASHED</name></expr></argument>,
											<argument><expr><name>AGGSPLIT_SIMPLE</name></expr></argument>,
											<argument><expr><name>true</name></expr></argument>, <comment type="block">/* streaming */</comment>
											<argument><expr><name>dqa_group_clause</name></expr></argument>,
											<argument><expr><name>NIL</name></expr></argument>,
											<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>agg_partial_costs</name></name></expr></argument>, <comment type="block">/* FIXME */</comment>
											<argument><expr><call><name>estimate_num_groups_on_segment</name><argument_list>(<argument><expr><name>dNumDistinctGroups</name></expr></argument>,
																		   <argument><expr><name>input_rows</name></expr></argument>, <argument><expr><name><name>path</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>cdbpath_create_motion_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
										  <argument><expr><name>group_locus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>path</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>create_agg_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
										<argument><expr><name>output_rel</name></expr></argument>,
										<argument><expr><name>path</name></expr></argument>,
										<argument><expr><name>input_target</name></expr></argument>,
										<argument><expr><name>AGG_HASHED</name></expr></argument>,
										<argument><expr><name>AGGSPLIT_SIMPLE</name></expr></argument>,
										<argument><expr><name>false</name></expr></argument>, <comment type="block">/* streaming */</comment>
										<argument><expr><name>dqa_group_clause</name></expr></argument>,
										<argument><expr><name>NIL</name></expr></argument>,
										<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>agg_partial_costs</name></name></expr></argument>, <comment type="block">/* FIXME */</comment>
										<argument><expr><call><name>clamp_row_est</name><argument_list>(<argument><expr><name>dNumDistinctGroups</name> <operator>/</operator> <call><name>CdbPathLocus_NumSegments</name><argument_list>(<argument><expr><name>group_locus</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>path</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>create_agg_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
										<argument><expr><name>output_rel</name></expr></argument>,
										<argument><expr><name>path</name></expr></argument>,
										<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>target</name></name></expr></argument>,
										<argument><expr><ternary><condition><expr><name><name>ctx</name><operator>-&gt;</operator><name>groupClause</name></name></expr> ?</condition><then> <expr><name>AGG_HASHED</name></expr> </then><else>: <expr><name>AGG_PLAIN</name></expr></else></ternary></expr></argument>,
										<argument><expr><name>AGGSPLIT_DEDUPLICATED</name></expr></argument>,
										<argument><expr><name>false</name></expr></argument>, <comment type="block">/* streaming */</comment>
										<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>,
										<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>havingQual</name></name></expr></argument>,
										<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>agg_final_costs</name></name></expr></argument>,
										<argument><expr><name>dNumGroups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>add_path</name><argument_list>(<argument><expr><name>output_rel</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>CdbPathLocus_IsHashed</name><argument_list>(<argument><expr><name>distinct_locus</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>double</name></type>			<name>input_rows</name> <init>= <expr><name><name>path</name><operator>-&gt;</operator><name>rows</name></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 *  Finalize Aggregate
		 *     -&gt; Gather Motion
		 *          -&gt; Partial Aggregate
		 *              -&gt; HashAggregate, to remove duplicates
		 *                  -&gt; Redistribute Motion (according to DISTINCT arg)
		 *                      -&gt; Streaming HashAgg (to eliminate duplicates)
		 *                          -&gt; input
		 */</comment>
		<expr_stmt><expr><name>path</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>create_agg_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
										<argument><expr><name>output_rel</name></expr></argument>,
										<argument><expr><name>path</name></expr></argument>,
										<argument><expr><name>input_target</name></expr></argument>,
										<argument><expr><name>AGG_HASHED</name></expr></argument>,
										<argument><expr><name>AGGSPLIT_SIMPLE</name></expr></argument>,
										<argument><expr><name>true</name></expr></argument>, <comment type="block">/* streaming */</comment>
										<argument><expr><name>dqa_group_clause</name></expr></argument>,
										<argument><expr><name>NIL</name></expr></argument>,
										<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>agg_partial_costs</name></name></expr></argument>, <comment type="block">/* FIXME */</comment>
										<argument><expr><call><name>estimate_num_groups_on_segment</name><argument_list>(<argument><expr><name>dNumDistinctGroups</name></expr></argument>,
																	   <argument><expr><name>input_rows</name></expr></argument>, <argument><expr><name><name>path</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>cdbpath_create_motion_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
										  <argument><expr><name>distinct_locus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>path</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>create_agg_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
										<argument><expr><name>output_rel</name></expr></argument>,
										<argument><expr><name>path</name></expr></argument>,
										<argument><expr><name>input_target</name></expr></argument>,
										<argument><expr><name>AGG_HASHED</name></expr></argument>,
										<argument><expr><name>AGGSPLIT_SIMPLE</name></expr></argument>,
										<argument><expr><name>false</name></expr></argument>, <comment type="block">/* streaming */</comment>
										<argument><expr><name>dqa_group_clause</name></expr></argument>,
										<argument><expr><name>NIL</name></expr></argument>,
										<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>agg_partial_costs</name></name></expr></argument>, <comment type="block">/* FIXME */</comment>
										<argument><expr><call><name>clamp_row_est</name><argument_list>(<argument><expr><name>dNumDistinctGroups</name> <operator>/</operator> <call><name>CdbPathLocus_NumSegments</name><argument_list>(<argument><expr><name>distinct_locus</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>path</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>create_agg_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
										<argument><expr><name>output_rel</name></expr></argument>,
										<argument><expr><name>path</name></expr></argument>,
										<argument><expr><call><name>strip_aggdistinct</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>partial_grouping_target</name></name></expr></argument>)</argument_list></call></expr></argument>,
										<argument><expr><ternary><condition><expr><name><name>ctx</name><operator>-&gt;</operator><name>groupClause</name></name></expr> ?</condition><then> <expr><name>AGG_HASHED</name></expr> </then><else>: <expr><name>AGG_PLAIN</name></expr></else></ternary></expr></argument>,
										<argument><expr><name>AGGSPLIT_INITIAL_SERIAL</name> <operator>|</operator> <name>AGGSPLITOP_DEDUPLICATED</name></expr></argument>,
										<argument><expr><name>false</name></expr></argument>, <comment type="block">/* streaming */</comment>
										<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>,
										<argument><expr><name>NIL</name></expr></argument>,
										<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>agg_partial_costs</name></name></expr></argument>,
										<argument><expr><call><name>estimate_num_groups_on_segment</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>dNumGroupsTotal</name></name></expr></argument>, <argument><expr><name>input_rows</name></expr></argument>, <argument><expr><name><name>path</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>cdbpath_create_motion_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
										  <argument><expr><name>group_locus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>path</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>create_agg_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
										<argument><expr><name>output_rel</name></expr></argument>,
										<argument><expr><name>path</name></expr></argument>,
										<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>target</name></name></expr></argument>,
										<argument><expr><ternary><condition><expr><name><name>ctx</name><operator>-&gt;</operator><name>groupClause</name></name></expr> ?</condition><then> <expr><name>AGG_HASHED</name></expr> </then><else>: <expr><name>AGG_PLAIN</name></expr></else></ternary></expr></argument>,
										<argument><expr><name>AGGSPLIT_FINAL_DESERIAL</name> <operator>|</operator> <name>AGGSPLITOP_DEDUPLICATED</name></expr></argument>,
										<argument><expr><name>false</name></expr></argument>, <comment type="block">/* streaming */</comment>
										<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>,
										<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>havingQual</name></name></expr></argument>,
										<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>agg_final_costs</name></name></expr></argument>,
										<argument><expr><name>dNumGroups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>add_path</name><argument_list>(<argument><expr><name>output_rel</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Create Paths for Multiple DISTINCT-qualified aggregates.
 *
 * The goal is that using a single execution path to handle all DQAs, so
 * before removing duplication a SplitTuple node is created. This node handles
 * each input tuple to n output tuples(n is DQA expr number). Each output tuple
 * only contains an AggExprId, one DQA expr and all GROUP by expr. For example,
 * SELECT DQA(a), DQA(b) FROM foo GROUP BY c;
 * After the tuple split, two tuples are generated:
 * -------------------
 * | 1 | a | n/a | c |
 * -------------------
 * -------------------
 * | 2 | n/a | b | c |
 * -------------------
 *
 * In an aggregate executor, if the input tuple contains AggExprId, that means
 * the tuple is split. Each value of AggExprId points to a bitmap set to
 * represent args AttrNumber. In the Agg executor, each transfunc also keeps
 * its own args bitmap set. The transfunc is invoked only if bitmapset matches
 * with each other.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>add_multi_dqas_hash_agg_path</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
							 <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>path</name></decl></parameter>,
							 <parameter><decl><type><name>cdb_agg_planning_context</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>,
							 <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>output_rel</name></decl></parameter>,
							 <parameter><decl><type><name>cdb_multi_dqas_info</name> <modifier>*</modifier></type><name>info</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>dqa_group_tles</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CdbPathLocus</name></type> <name>distinct_locus</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>distinct_need_redistribute</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * If subpath is projection capable, we do not want to generate a
	 * projection plan. The reason is that the projection plan does not
	 * constrain a child tlist when it creates subplan. Thus, GROUP BY expr
	 * may not be found in the scan targetlist.
	 */</comment>
	<expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>apply_projection_to_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>path</name><operator>-&gt;</operator><name>parent</name></name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name><name>info</name><operator>-&gt;</operator><name>input_proj_target</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Finalize Aggregate
	 *   -&gt; Gather Motion
	 *        -&gt; Partial Aggregate
	 *             -&gt; HashAggregate, to remote duplicates
	 *                  -&gt; Redistribute Motion
	 *                       -&gt; TupleSplit (according to DISTINCT expr)
	 *                            -&gt; input
	 */</comment>
	<expr_stmt><expr><name>path</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>create_tup_split_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
										  <argument><expr><name>output_rel</name></expr></argument>,
										  <argument><expr><name>path</name></expr></argument>,
										  <argument><expr><name><name>info</name><operator>-&gt;</operator><name>tup_split_target</name></name></expr></argument>,
										  <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>,
										  <argument><expr><name><name>info</name><operator>-&gt;</operator><name>dqa_expr_lst</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>AggClauseCosts</name></type> <name>DedupCost</name> <init>= <expr><block>{}</block></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>get_agg_clause_costs</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>info</name><operator>-&gt;</operator><name>tup_split_target</name><operator>-&gt;</operator><name>exprs</name></name></expr></argument>,
						 <argument><expr><name>AGGSPLIT_SIMPLE</name></expr></argument>,
						 <argument><expr><operator>&amp;</operator><name>DedupCost</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>gp_enable_dqa_pruning</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * If we are grouping, we charge an additional cpu_operator_cost per
		 * **grouping column** per input tuple for grouping comparisons.
		 *
		 * But in the tuple split case, other columns not for this DQA are
		 * NULLs, the actual cost is way less than the number calculating based
		 * on the length of grouping clause.
		 *
		 * So here we create a dummy grouping clause whose length is 1 (the
		 * most common case of DQA), use it to calculate the cost, then set the
		 * actual one back into the path.
		 */</comment>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>dummy_group_clause</name> <init>= <expr><call><name>list_make1</name><argument_list>(<argument><expr><call><name>list_head</name><argument_list>(<argument><expr><name><name>info</name><operator>-&gt;</operator><name>dqa_group_clause</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>path</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>create_agg_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
										<argument><expr><name>output_rel</name></expr></argument>,
										<argument><expr><name>path</name></expr></argument>,
										<argument><expr><name><name>info</name><operator>-&gt;</operator><name>tup_split_target</name></name></expr></argument>,
										<argument><expr><name>AGG_HASHED</name></expr></argument>,
										<argument><expr><name>AGGSPLIT_SIMPLE</name></expr></argument>,
										<argument><expr><name>true</name></expr></argument>, <comment type="block">/* streaming */</comment>
										<argument><expr><name>dummy_group_clause</name></expr></argument>, <comment type="block">/* only its length 1 is being used here */</comment>
										<argument><expr><name>NIL</name></expr></argument>,
										<argument><expr><operator>&amp;</operator><name>DedupCost</name></expr></argument>,
										<argument><expr><call><name>estimate_num_groups_on_segment</name><argument_list>(<argument><expr><name><name>info</name><operator>-&gt;</operator><name>dNumDistinctGroups</name></name></expr></argument>,
																	   <argument><expr><name><name>path</name><operator>-&gt;</operator><name>rows</name></name></expr></argument>, <argument><expr><name><name>path</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* set the actual group clause back */</comment>
		<expr_stmt><expr><operator>(</operator><operator>(</operator><name>AggPath</name> <operator>*</operator><operator>)</operator><name>path</name><operator>)</operator><operator>-&gt;</operator><name>groupClause</name> <operator>=</operator> <name><name>info</name><operator>-&gt;</operator><name>dqa_group_clause</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>dqa_group_tles</name> <operator>=</operator> <call><name>get_common_group_tles</name><argument_list>(<argument><expr><name><name>info</name><operator>-&gt;</operator><name>tup_split_target</name></name></expr></argument>,
										   <argument><expr><name><name>info</name><operator>-&gt;</operator><name>dqa_group_clause</name></name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>distinct_locus</name> <operator>=</operator> <call><name>choose_grouping_locus</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>dqa_group_tles</name></expr></argument>,
										   <argument><expr><operator>&amp;</operator><name>distinct_need_redistribute</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>distinct_need_redistribute</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>cdbpath_create_motion_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
										  <argument><expr><name>distinct_locus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<decl_stmt><decl><type><name>AggStrategy</name></type> <name>split</name> <init>= <expr><name>AGG_PLAIN</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>DEDUPLICATED_FLAG</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>partial_target</name> <init>= <expr><name><name>info</name><operator>-&gt;</operator><name>partial_target</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>input_rows</name> <init>= <expr><name><name>path</name><operator>-&gt;</operator><name>rows</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>groupClause</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>path</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>create_agg_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
										<argument><expr><name>output_rel</name></expr></argument>,
										<argument><expr><name>path</name></expr></argument>,
										<argument><expr><name><name>info</name><operator>-&gt;</operator><name>tup_split_target</name></name></expr></argument>,
										<argument><expr><name>AGG_HASHED</name></expr></argument>,
										<argument><expr><name>AGGSPLIT_SIMPLE</name></expr></argument>,
										<argument><expr><name>false</name></expr></argument>, <comment type="block">/* streaming */</comment>
										<argument><expr><name><name>info</name><operator>-&gt;</operator><name>dqa_group_clause</name></name></expr></argument>,
										<argument><expr><name>NIL</name></expr></argument>,
										<argument><expr><operator>&amp;</operator><name>DedupCost</name></expr></argument>,
										<argument><expr><call><name>clamp_row_est</name><argument_list>(<argument><expr><name><name>info</name><operator>-&gt;</operator><name>dNumDistinctGroups</name></name> <operator>/</operator> <call><name>CdbPathLocus_NumSegments</name><argument_list>(<argument><expr><name>distinct_locus</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>split</name> <operator>=</operator> <name>AGG_HASHED</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>DEDUPLICATED_FLAG</name> <operator>=</operator> <name>AGGSPLITOP_DEDUPLICATED</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>partial_target</name> <operator>=</operator> <call><name>strip_aggdistinct</name><argument_list>(<argument><expr><name><name>info</name><operator>-&gt;</operator><name>partial_target</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>path</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>create_agg_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
									<argument><expr><name>output_rel</name></expr></argument>,
									<argument><expr><name>path</name></expr></argument>,
									<argument><expr><name>partial_target</name></expr></argument>,
									<argument><expr><name>split</name></expr></argument>,
									<argument><expr><name>AGGSPLIT_INITIAL_SERIAL</name> <operator>|</operator> <name>DEDUPLICATED_FLAG</name></expr></argument>,
									<argument><expr><name>false</name></expr></argument>, <comment type="block">/* streaming */</comment>
									<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>,
									<argument><expr><name>NIL</name></expr></argument>,
									<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>agg_partial_costs</name></name></expr></argument>,
									<argument><expr><call><name>estimate_num_groups_on_segment</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>dNumGroupsTotal</name></name></expr></argument>,
																   <argument><expr><name>input_rows</name></expr></argument>, <argument><expr><name><name>path</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>CdbPathLocus</name></type> <name>singleQE_locus</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>CdbPathLocus_MakeSingleQE</name><argument_list>(<argument><expr><operator>&amp;</operator><name>singleQE_locus</name></expr></argument>, <argument><expr><call><name>getgpsegmentCount</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>cdbpath_create_motion_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
									  <argument><expr><name>path</name></expr></argument>,
									  <argument><expr><name>NIL</name></expr></argument>,
									  <argument><expr><name>false</name></expr></argument>,
									  <argument><expr><name>singleQE_locus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>path</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>create_agg_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
									<argument><expr><name>output_rel</name></expr></argument>,
									<argument><expr><name>path</name></expr></argument>,
									<argument><expr><name><name>info</name><operator>-&gt;</operator><name>final_target</name></name></expr></argument>,
									<argument><expr><name>split</name></expr></argument>,
									<argument><expr><name>AGGSPLIT_FINAL_DESERIAL</name> <operator>|</operator> <name>DEDUPLICATED_FLAG</name></expr></argument>,
									<argument><expr><name>false</name></expr></argument>, <comment type="block">/* streaming */</comment>
									<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>,
									<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>havingQual</name></name></expr></argument>,
									<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>agg_final_costs</name></name></expr></argument>,
									<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>dNumGroupsTotal</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>add_path</name><argument_list>(<argument><expr><name>output_rel</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Get the common expressions in all grouping sets as a target list.
 *
 * In case of a simple GROUP BY, it's just all the grouping column. With
 * multiple grouping sets, identify the set of common entries, and return
 * a list of those. For example, if you do:
 *
 *   GROUP BY GROUPING SETS ((a, b, c), (b, c))
 *
 * the common cols are b and c.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>get_common_group_tles</name><parameter_list>(<parameter><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>target</name></decl></parameter>,
					  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>groupClause</name></decl></parameter>,
					  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>rollups</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>tlist</name> <init>= <expr><call><name>make_tlist_from_pathtarget</name><argument_list>(<argument><expr><name>target</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>group_tles</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>common_groupcols</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>x</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>rollups</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>first</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>rollups</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>RollupData</name> <modifier>*</modifier></type><name>rollup</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>RollupData</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc2</name></decl>;</decl_stmt>

			<macro><name>foreach</name><argument_list>(<argument>lc2</argument>, <argument>rollup-&gt;gsets</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>colidx_lists</name> <init>= <expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc3</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>this_groupcols</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

				<macro><name>foreach</name><argument_list>(<argument>lc3</argument>, <argument>colidx_lists</argument>)</argument_list></macro>
				<block>{<block_content>
					<decl_stmt><decl><type><name>int</name></type>			<name>colidx</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>lc3</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>SortGroupClause</name> <modifier>*</modifier></type><name>sc</name> <init>= <expr><call><name>list_nth</name><argument_list>(<argument><expr><name><name>rollup</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>, <argument><expr><name>colidx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<expr_stmt><expr><name>this_groupcols</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name>this_groupcols</name></expr></argument>, <argument><expr><name><name>sc</name><operator>-&gt;</operator><name>tleSortGroupRef</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block>

				<if_stmt><if>if <condition>(<expr><name>first</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>common_groupcols</name> <operator>=</operator> <name>this_groupcols</name></expr>;</expr_stmt></block_content></block></if>
				<else>else
				<block>{<block_content>
					<expr_stmt><expr><name>common_groupcols</name> <operator>=</operator> <call><name>bms_int_members</name><argument_list>(<argument><expr><name>common_groupcols</name></expr></argument>, <argument><expr><name>this_groupcols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>bms_free</name><argument_list>(<argument><expr><name>this_groupcols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
				<expr_stmt><expr><name>first</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			</block_content>}</block>
		</block_content>}</block>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>groupClause</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>SortGroupClause</name> <modifier>*</modifier></type><name>sc</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>common_groupcols</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name>common_groupcols</name></expr></argument>, <argument><expr><name><name>sc</name><operator>-&gt;</operator><name>tleSortGroupRef</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>x</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>group_tles</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>x</name> <operator>=</operator> <call><name>bms_next_member</name><argument_list>(<argument><expr><name>common_groupcols</name></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><call><name>get_sortgroupref_tle</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>tlist</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>group_tles</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>group_tles</name></expr></argument>, <argument><expr><name>tle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<return>return <expr><name>group_tles</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>get_all_rollup_groupclauses</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>rollups</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>sortcls</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>all_sortrefs</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>rollups</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RollupData</name> <modifier>*</modifier></type><name>rollup</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>RollupData</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc2</name></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>lc2</argument>, <argument>rollup-&gt;gsets</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>colidx_lists</name> <init>= <expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc3</name></decl>;</decl_stmt>

			<macro><name>foreach</name><argument_list>(<argument>lc3</argument>, <argument>colidx_lists</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>int</name></type>			<name>colidx</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>lc3</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>SortGroupClause</name> <modifier>*</modifier></type><name>sc</name> <init>= <expr><call><name>list_nth</name><argument_list>(<argument><expr><name><name>rollup</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>, <argument><expr><name>colidx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>bms_is_member</name><argument_list>(<argument><expr><name><name>sc</name><operator>-&gt;</operator><name>tleSortGroupRef</name></name></expr></argument>, <argument><expr><name>all_sortrefs</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>sortcls</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>sortcls</name></expr></argument>, <argument><expr><name>sc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>all_sortrefs</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name>all_sortrefs</name></expr></argument>, <argument><expr><name><name>sc</name><operator>-&gt;</operator><name>tleSortGroupRef</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block>
		</block_content>}</block>
	</block_content>}</block>
	<return>return <expr><name>sortcls</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Choose a data distribution to perform the grouping.
 *
 * 'group_tles' is a target list that represents the grouping columns,
 * or all the common columns in all the grouping sets if there are
 * multple grouping sets. Use get_common_group_tles() to build that
 * list.
 */</comment>
<function><type><specifier>static</specifier> <name>CdbPathLocus</name></type>
<name>choose_grouping_locus</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>path</name></decl></parameter>,
					  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>group_tles</name></decl></parameter>,
					  <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>need_redistribute_p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CdbPathLocus</name></type> <name>locus</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>need_redistribute</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * If the input is already collected to a single segment, just perform the
	 * aggregation there. We could redistribute it, so that we could perform
	 * the aggregation in parallel, but Motions are pretty expensive so it's
	 * probably not worthwhile.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>CdbPathLocus_IsBottleneck</name><argument_list>(<argument><expr><name><name>path</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>need_redistribute</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CdbPathLocus_MakeNull</name><argument_list>(<argument><expr><operator>&amp;</operator><name>locus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<comment type="block">/* If there are no GROUP BY columns, we have no choice but gather everything to a single node */</comment>
	<if type="elseif">else if <condition>(<expr><operator>!</operator><name>group_tles</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>need_redistribute</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CdbPathLocus_MakeSingleQE</name><argument_list>(<argument><expr><operator>&amp;</operator><name>locus</name></expr></argument>, <argument><expr><call><name>getgpsegmentCount</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<comment type="block">/* If the input is already suitably distributed, no need to redistribute */</comment>
	<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>CdbPathLocus_IsHashedOJ</name><argument_list>(<argument><expr><name><name>path</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			 <call><name>cdbpathlocus_is_hashed_on_tlist</name><argument_list>(<argument><expr><name><name>path</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>, <argument><expr><name>group_tles</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>need_redistribute</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CdbPathLocus_MakeNull</name><argument_list>(<argument><expr><operator>&amp;</operator><name>locus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<comment type="block">/*
	 * If the query's final result locus collocates with the GROUP BY, then
	 * redistribute directly to that locus and avoid a possible redistribute
	 * step later. (We might still need to redistribute the data for later
	 * windowing, LIMIT or similar, but this is a pretty good heuristic.)
	 */</comment>
	<if type="elseif">else if <condition>(<expr><call><name>CdbPathLocus_IsHashed</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>final_locus</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			 <call><name>cdbpathlocus_is_hashed_on_tlist</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>final_locus</name></name></expr></argument>, <argument><expr><name>group_tles</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>need_redistribute</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>locus</name> <operator>=</operator> <name><name>root</name><operator>-&gt;</operator><name>final_locus</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<comment type="block">/*
	 * Construct a new locus from the GROUP BY columns. We greedily use as
	 * many columns as possible, to maximimize distribution. (It might be
	 * cheaper to pick only one or two columns, as long as they distribute
	 * the data evenly enough, but we're not that smart.)
	 */</comment>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>hash_exprs</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>hash_opfamilies</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>hash_sortrefs</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>hash_exprs</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>hash_opfamilies</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>hash_sortrefs</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>group_tles</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>typeoid</name> <init>= <expr><call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>opfamily</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>eqopoid</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>opfamily</name> <operator>=</operator> <call><name>cdb_default_distribution_opfamily_for_type</name><argument_list>(<argument><expr><name>typeoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>opfamily</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * If the datatype isn't mergejoinable, then we cannot represent
			 * the grouping in the locus. Skip such expressions.
			 */</comment>
			<expr_stmt><expr><name>eqopoid</name> <operator>=</operator> <call><name>cdb_eqop_in_hash_opfamily</name><argument_list>(<argument><expr><name>opfamily</name></expr></argument>, <argument><expr><name>typeoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>op_mergejoinable</name><argument_list>(<argument><expr><name>eqopoid</name></expr></argument>, <argument><expr><name>typeoid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>hash_exprs</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>hash_exprs</name></expr></argument>, <argument><expr><name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>hash_opfamilies</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>hash_opfamilies</name></expr></argument>, <argument><expr><name>opfamily</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>hash_sortrefs</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>hash_sortrefs</name></expr></argument>, <argument><expr><name><name>tle</name><operator>-&gt;</operator><name>ressortgroupref</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<if_stmt><if>if <condition>(<expr><name>hash_exprs</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>locus</name> <operator>=</operator> <call><name>cdbpathlocus_from_exprs</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
											<argument><expr><name><name>path</name><operator>-&gt;</operator><name>parent</name></name></expr></argument>,
											<argument><expr><name>hash_exprs</name></expr></argument>,
											<argument><expr><name>hash_opfamilies</name></expr></argument>,
											<argument><expr><name>hash_sortrefs</name></expr></argument>,
											<argument><expr><call><name>getgpsegmentCount</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>CdbPathLocus_MakeSingleQE</name><argument_list>(<argument><expr><operator>&amp;</operator><name>locus</name></expr></argument>, <argument><expr><call><name>getgpsegmentCount</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<expr_stmt><expr><name>need_redistribute</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><operator>*</operator><name>need_redistribute_p</name> <operator>=</operator> <name>need_redistribute</name></expr>;</expr_stmt>
	<return>return <expr><name>locus</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>DQAType</name></type>
<name>recognize_dqa_type</name><parameter_list>(<parameter><decl><type><name>cdb_agg_planning_context</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>    <modifier>*</modifier></type><name>lc</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>lcc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>        <modifier>*</modifier></type><name>dqaArgs</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>INVALID_DQA</name></expr>;</expr_stmt>

	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>ctx-&gt;agg_costs-&gt;distinctAggrefs</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Aggref</name> <modifier>*</modifier></type><name>aggref</name> <init>= <expr><operator>(</operator><name>Aggref</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>SortGroupClause</name> <modifier>*</modifier></type><name>arg_sortcl</name></decl>;</decl_stmt>

		<comment type="block">/* I can not give a case for a DQA have order by yet. */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>aggref</name><operator>-&gt;</operator><name>aggorder</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name><name>ctx</name><operator>-&gt;</operator><name>type</name></name></expr>;</return></block_content></block></if></if_stmt>

		<macro><name>foreach</name> <argument_list>(<argument>lcc</argument>, <argument>aggref-&gt;aggdistinct</argument>)</argument_list></macro>
		<block>{<block_content>
			<expr_stmt><expr><name>arg_sortcl</name> <operator>=</operator> <operator>(</operator><name>SortGroupClause</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lcc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>arg_sortcl</name><operator>-&gt;</operator><name>hashable</name></name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * XXX: I'm not sure if the hashable flag is always set correctly
				 * for DISTINCT args. DISTINCT aggs are never implemented with hashing
				 * in PostgreSQL.
				 */</comment>
				<return>return <expr><name><name>ctx</name><operator>-&gt;</operator><name>type</name></name></expr>;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>

		<comment type="block">/* get the first dqa arguments */</comment>
		<if_stmt><if>if <condition>(<expr><name>dqaArgs</name> <operator>==</operator> <name>NIL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>dqaArgs</name> <operator>=</operator> <name><name>aggref</name><operator>-&gt;</operator><name>args</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>SINGLE_DQA</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<comment type="block">/* if there is another dqa with different args, it's MULTI_DQAS */</comment>
		<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>equal</name><argument_list>(<argument><expr><name>dqaArgs</name></expr></argument>, <argument><expr><name><name>aggref</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>MULTI_DQAS</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<if_stmt><if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>INVALID_DQA</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Check that there are no non-DISTINCT aggregates mixed in. */</comment>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>varnos</name> <init>= <expr><call><name>pull_var_clause</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>ctx</name><operator>-&gt;</operator><name>target</name><operator>-&gt;</operator><name>exprs</name></name></expr></argument>,
									   <argument><expr><name>PVC_INCLUDE_AGGREGATES</name> <operator>|</operator>
									   <name>PVC_INCLUDE_WINDOWFUNCS</name> <operator>|</operator>
									   <name>PVC_INCLUDE_PLACEHOLDERS</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>varnos</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Aggref</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Aggref</name>	   <modifier>*</modifier></type><name>aggref</name> <init>= <expr><operator>(</operator><name>Aggref</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>aggref</name><operator>-&gt;</operator><name>aggdistinct</name></name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* mixing DISTINCT and non-DISTINCT aggs */</comment>
					<if_stmt><if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>SINGLE_DQA</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>SINGLE_DQA_WITHAGG</name></expr>;</expr_stmt></block_content></block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>MULTI_DQAS_WITHAGG</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

					<return>return <expr><name><name>ctx</name><operator>-&gt;</operator><name>type</name></name></expr>;</return>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name><name>ctx</name><operator>-&gt;</operator><name>type</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * fetch_multi_dqas_info
 *
 * 1. fetch all dqas path required information as single dqa's function.
 *
 * 2. append an AggExprId into Pathtarget to indicate which DQA expr is
 * in the output tuple after TupleSplit.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>fetch_multi_dqas_info</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
					  <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>path</name></decl></parameter>,
					  <parameter><decl><type><name>cdb_agg_planning_context</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>,
					  <parameter><decl><type><name>cdb_multi_dqas_info</name> <modifier>*</modifier></type><name>info</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>    <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>    <modifier>*</modifier></type><name>lcc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Index</name></type>		<name>maxRef</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>proj_target</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>num_input_segments</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>num_total_input_rows</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>group_exprs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>dNumDistinctGroups</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>CdbPathLocus_IsPartitioned</name><argument_list>(<argument><expr><name><name>path</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>num_input_segments</name> <operator>=</operator> <call><name>CdbPathLocus_NumSegments</name><argument_list>(<argument><expr><name><name>path</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>num_input_segments</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<expr_stmt><expr><name>num_total_input_rows</name> <operator>=</operator> <name><name>path</name><operator>-&gt;</operator><name>rows</name></name> <operator>*</operator> <name>num_input_segments</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>group_exprs</name> <operator>=</operator> <call><name>get_sortgrouplist_exprs</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>,
										  <argument><expr><call><name>make_tlist_from_pathtarget</name><argument_list>(<argument><expr><name><name>path</name><operator>-&gt;</operator><name>pathtarget</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>proj_target</name> <operator>=</operator> <call><name>copy_pathtarget</name><argument_list>(<argument><expr><name><name>path</name><operator>-&gt;</operator><name>pathtarget</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>proj_target</name><operator>-&gt;</operator><name>sortgrouprefs</name></name></expr>)</condition>
	<block>{<block_content>
		<for>for <control>(<init><decl><type><name>int</name></type> <name>idx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>idx</name> <operator>&lt;</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>proj_target</name><operator>-&gt;</operator><name>exprs</name></name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>idx</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>proj_target</name><operator>-&gt;</operator><name>sortgrouprefs</name><index>[<expr><name>idx</name></expr>]</index></name> <operator>&gt;</operator> <name>maxRef</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>maxRef</name> <operator>=</operator> <name><name>proj_target</name><operator>-&gt;</operator><name>sortgrouprefs</name><index>[<expr><name>idx</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>proj_target</name><operator>-&gt;</operator><name>sortgrouprefs</name></name> <operator>=</operator> <operator>(</operator><name>Index</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>proj_target</name><operator>-&gt;</operator><name>exprs</name></name></expr></argument>)</argument_list></call> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Index</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>dqa_expr_lst</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * assign numDisDQAs and agg_args_id_bms
	 *
	 * find all DQAs with different args, count the number, store their args bitmapsets
	 */</comment>
	<expr_stmt><expr><name>dNumDistinctGroups</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<macro><name>forboth</name><argument_list>(<argument>lc</argument>, <argument>ctx-&gt;agg_partial_costs-&gt;distinctAggrefs</argument>,
	        <argument>lcc</argument>, <argument>ctx-&gt;agg_final_costs-&gt;distinctAggrefs</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Aggref</name>	        <modifier>*</modifier></type><name>aggref</name> <init>= <expr><operator>(</operator><name>Aggref</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Aggref</name>	        <modifier>*</modifier></type><name>aggref_final</name> <init>= <expr><operator>(</operator><name>Aggref</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lcc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>SortGroupClause</name> <modifier>*</modifier></type><name>arg_sortcl</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TargetEntry</name>     <modifier>*</modifier></type><name>arg_tle</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>        <modifier>*</modifier></type><name>lc2</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Bitmapset</name>       <modifier>*</modifier></type><name>bms</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>		   <modifier>*</modifier></type><name>this_dqa_group_exprs</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>this_dqa_group_exprs</name> <operator>=</operator> <call><name>list_copy</name><argument_list>(<argument><expr><name>group_exprs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<macro><name>foreach</name> <argument_list>(<argument>lc2</argument>, <argument>aggref-&gt;aggdistinct</argument>)</argument_list></macro>
		<block>{<block_content>
			<expr_stmt><expr><name>arg_sortcl</name> <operator>=</operator> <operator>(</operator><name>SortGroupClause</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>arg_tle</name> <operator>=</operator> <call><name>get_sortgroupclause_tle</name><argument_list>(<argument><expr><name>arg_sortcl</name></expr></argument>, <argument><expr><name><name>aggref</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<decl_stmt><decl><type><name>ListCell</name>    <modifier>*</modifier></type><name>lc3</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>         <name>dqa_idx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Expr</name>		<modifier>*</modifier></type><name>naked_tle_expr</name> <init>= <expr><name><name>arg_tle</name><operator>-&gt;</operator><name>expr</name></name></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * When conversions between two binary-compatible types happen in
			 * DQA expressions, the expr(s) in arg_tle and proj_target-&gt;exprs
			 * may be wrapped with a RelabelType node. The RelabelType node doesn't
			 * affect the semantics, so we ignore it here.
			 * For conversions that are not binary-compatible, the exprs are wrapped
			 * with other types of node, e.g., CoerceViaIO.
			 * Relevent bug report: https://github.com/greenplum-db/gpdb/issues/14096
			 */</comment>
			<while>while <condition>(<expr><name>naked_tle_expr</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>naked_tle_expr</name></expr></argument>, <argument><expr><name>RelabelType</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>naked_tle_expr</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>RelabelType</name> <operator>*</operator><operator>)</operator> <name>naked_tle_expr</name><operator>)</operator><operator>-&gt;</operator><name>arg</name></expr>;</expr_stmt></block_content></block></while>

			<macro><name>foreach</name> <argument_list>(<argument>lc3</argument>, <argument>proj_target-&gt;exprs</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Expr</name>    <modifier>*</modifier></type><name>expr</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc3</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Expr</name>	<modifier>*</modifier></type><name>naked_expr</name> <init>= <expr><name>expr</name></expr></init></decl>;</decl_stmt>
				<comment type="block">/* Ignore the RelabelType node. */</comment>
				<while>while <condition>(<expr><name>naked_expr</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>naked_expr</name></expr></argument>, <argument><expr><name>RelabelType</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>naked_expr</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>RelabelType</name> <operator>*</operator><operator>)</operator> <name>naked_expr</name><operator>)</operator><operator>-&gt;</operator><name>arg</name></expr>;</expr_stmt></block_content></block></while>

				<if_stmt><if>if <condition>(<expr><call><name>equal</name><argument_list>(<argument><expr><name>naked_tle_expr</name></expr></argument>, <argument><expr><name>naked_expr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<break>break;</break></block_content></block></if></if_stmt>

				<expr_stmt><expr><name>dqa_idx</name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block>

			<comment type="block">/*
			 * DQA expr is not in PathTarget
			 *
			 * SELECT DQA(a + b) from foo;
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>dqa_idx</name> <operator>==</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>proj_target</name><operator>-&gt;</operator><name>exprs</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>add_column_to_pathtarget</name><argument_list>(<argument><expr><name>proj_target</name></expr></argument>, <argument><expr><name><name>arg_tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><operator>++</operator><name>maxRef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<decl_stmt><decl><type><name>SortGroupClause</name> <modifier>*</modifier></type><name>sortcl</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>sortcl</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>arg_sortcl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>sortcl</name><operator>-&gt;</operator><name>tleSortGroupRef</name></name> <operator>=</operator> <name>maxRef</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>sortcl</name><operator>-&gt;</operator><name>hashable</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>	<comment type="block">/* we verified earlier that it's hashable */</comment>

				<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>dqa_group_clause</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>info</name><operator>-&gt;</operator><name>dqa_group_clause</name></name></expr></argument>, <argument><expr><name>sortcl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>this_dqa_group_exprs</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>this_dqa_group_exprs</name></expr></argument>, <argument><expr><name><name>arg_tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>bms</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name>bms</name></expr></argument>, <argument><expr><name>maxRef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name><name>proj_target</name><operator>-&gt;</operator><name>sortgrouprefs</name><index>[<expr><name>dqa_idx</name></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * DQA expr in PathTarget but no reference
				 *
				 * SELECT DQA(a) FROM foo ;
				 */</comment>
				<expr_stmt><expr><name><name>proj_target</name><operator>-&gt;</operator><name>sortgrouprefs</name><index>[<expr><name>dqa_idx</name></expr>]</index></name> <operator>=</operator> <operator>++</operator><name>maxRef</name></expr>;</expr_stmt>

				<decl_stmt><decl><type><name>SortGroupClause</name> <modifier>*</modifier></type><name>sortcl</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>sortcl</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>arg_sortcl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>sortcl</name><operator>-&gt;</operator><name>tleSortGroupRef</name></name> <operator>=</operator> <name>maxRef</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>sortcl</name><operator>-&gt;</operator><name>hashable</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>	<comment type="block">/* we verified earlier that it's hashable */</comment>

				<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>dqa_group_clause</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>info</name><operator>-&gt;</operator><name>dqa_group_clause</name></name></expr></argument>, <argument><expr><name>sortcl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>this_dqa_group_exprs</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>this_dqa_group_exprs</name></expr></argument>, <argument><expr><name><name>arg_tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>bms</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name>bms</name></expr></argument>, <argument><expr><name>maxRef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/*
				 * DQA expr in PathTarget and referenced by GROUP BY clause
				 *
				 * SELECT DQA(a) FROM foo GROUP BY a;
				 */</comment>
				<decl_stmt><decl><type><name>Index</name></type> <name>exprRef</name> <init>= <expr><name><name>proj_target</name><operator>-&gt;</operator><name>sortgrouprefs</name><index>[<expr><name>dqa_idx</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
				<expr_stmt><expr><name>bms</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name>bms</name></expr></argument>, <argument><expr><name>exprRef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block>

		<comment type="block">/*
		 * DQA(a, b) and DQA(b, a) and their filter is same, as well as, they
		 * do not contain volatile expression, then they can share one split
		 * tuple.
		 */</comment>
		<decl_stmt><decl><type><name>Index</name></type> <name>agg_expr_id</name></decl> ;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>contain_volatile_functions</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name><name>aggref</name><operator>-&gt;</operator><name>aggfilter</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc_dqa</name></decl>;</decl_stmt>
			<expr_stmt><expr><name>agg_expr_id</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<macro><name>foreach</name> <argument_list>(<argument>lc_dqa</argument>, <argument>info-&gt;dqa_expr_lst</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>DQAExpr</name> <modifier>*</modifier></type><name>dqaExpr</name> <init>= <expr><operator>(</operator><name>DQAExpr</name> <operator>*</operator><operator>)</operator><call><name>lfirst</name><argument_list>(<argument><expr><name>lc_dqa</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>bms_equal</name><argument_list>(<argument><expr><name>bms</name></expr></argument>, <argument><expr><name><name>dqaExpr</name><operator>-&gt;</operator><name>agg_args_id_bms</name></name></expr></argument>)</argument_list></call>
					<operator>&amp;&amp;</operator> <call><name>equal</name><argument_list>(<argument><expr><name><name>aggref</name><operator>-&gt;</operator><name>aggfilter</name></name></expr></argument>, <argument><expr><name><name>dqaExpr</name><operator>-&gt;</operator><name>agg_filter</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<break>break;</break></block_content></block></if></if_stmt>

				<expr_stmt><expr><name>agg_expr_id</name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>agg_expr_id</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>info</name><operator>-&gt;</operator><name>dqa_expr_lst</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/* If DQA(expr1) FILTER (WHERE expr2) is different with previous, create new one */</comment>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>agg_expr_id</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>==</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>info</name><operator>-&gt;</operator><name>dqa_expr_lst</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>DQAExpr</name> <modifier>*</modifier></type><name>dqaExpr</name><init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>DQAExpr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>dqaExpr</name><operator>-&gt;</operator><name>agg_expr_id</name></name> <operator>=</operator> <name>agg_expr_id</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>dqaExpr</name><operator>-&gt;</operator><name>agg_args_id_bms</name></name> <operator>=</operator> <name>bms</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>dqaExpr</name><operator>-&gt;</operator><name>agg_filter</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator><call><name>copyObject</name><argument_list>(<argument><expr><name><name>aggref</name><operator>-&gt;</operator><name>aggfilter</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>dqa_expr_lst</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>info</name><operator>-&gt;</operator><name>dqa_expr_lst</name></name></expr></argument>, <argument><expr><name>dqaExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * How many distinct combinations of GROUP BY columns and the
			 * DISTINCT arguments of this aggregate are there? Add it to the
			 * total.
			 */</comment>
			<expr_stmt><expr><name>dNumDistinctGroups</name> <operator>+=</operator> <call><name>estimate_num_groups</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
			                                          <argument><expr><name>this_dqa_group_exprs</name></expr></argument>,
			                                          <argument><expr><name>num_total_input_rows</name></expr></argument>,
			                                          <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* assign an agg_expr_id value to aggref*/</comment>
		<expr_stmt><expr><name><name>aggref</name><operator>-&gt;</operator><name>agg_expr_id</name></name> <operator>=</operator> <name>agg_expr_id</name></expr>;</expr_stmt>

		<comment type="block">/* rid of filter in aggref */</comment>
		<expr_stmt><expr><name><name>aggref</name><operator>-&gt;</operator><name>aggfilter</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>aggref_final</name><operator>-&gt;</operator><name>aggfilter</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>dNumDistinctGroups</name></name> <operator>=</operator> <name>dNumDistinctGroups</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>input_proj_target</name></name> <operator>=</operator> <name>proj_target</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>tup_split_target</name></name> <operator>=</operator> <call><name>copy_pathtarget</name><argument_list>(<argument><expr><name>proj_target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AggExprId</name> <modifier>*</modifier></type><name>a_expr_id</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>AggExprId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>add_column_to_pathtarget</name><argument_list>(<argument><expr><name><name>info</name><operator>-&gt;</operator><name>tup_split_target</name></name></expr></argument>, <argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator><name>a_expr_id</name></expr></argument>, <argument><expr><operator>++</operator><name>maxRef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>Oid</name></type> <name>eqop</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>hashable</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>SortGroupClause</name> <modifier>*</modifier></type><name>sortcl</name></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>get_sort_group_operators</name><argument_list>(<argument><expr><name>INT4OID</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>eqop</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hashable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>sortcl</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>SortGroupClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sortcl</name><operator>-&gt;</operator><name>tleSortGroupRef</name></name> <operator>=</operator> <name>maxRef</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sortcl</name><operator>-&gt;</operator><name>hashable</name></name> <operator>=</operator> <name>hashable</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sortcl</name><operator>-&gt;</operator><name>eqop</name></name> <operator>=</operator> <name>eqop</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>dqa_group_clause</name></name> <operator>=</operator> <call><name>lcons</name><argument_list>(<argument><expr><name>sortcl</name></expr></argument>, <argument><expr><name><name>info</name><operator>-&gt;</operator><name>dqa_group_clause</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>dqa_group_clause</name></name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name><name>info</name><operator>-&gt;</operator><name>dqa_group_clause</name></name></expr></argument>,
										 <argument><expr><call><name>list_copy</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>partial_target</name></name><operator>=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>partial_grouping_target</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>final_target</name></name> <operator>=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>target</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * fetch_single_dqa_info
 *
 * fetch single dqa path required information and store in cdb_multi_dqas_info
 *
 * info-&gt;input_target contains subpath target expr + all DISTINCT expr
 *
 * info-&gt;dqa_group_clause contains DISTINCT expr + GROUP BY expr
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>fetch_single_dqa_info</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
					  <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>path</name></decl></parameter>,
					  <parameter><decl><type><name>cdb_agg_planning_context</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>,
					  <parameter><decl><type><name>cdb_multi_dqas_info</name> <modifier>*</modifier></type><name>info</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Index</name></type>		<name>maxRef</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>dqa_group_exprs</name></decl>;</decl_stmt>

	<comment type="block">/* Prepare a modifiable copy of the input path target */</comment>
	<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>input_proj_target</name></name> <operator>=</operator> <call><name>copy_pathtarget</name><argument_list>(<argument><expr><name><name>path</name><operator>-&gt;</operator><name>pathtarget</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>maxRef</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>exprLst</name> <init>= <expr><name><name>info</name><operator>-&gt;</operator><name>input_proj_target</name><operator>-&gt;</operator><name>exprs</name></name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>info</name><operator>-&gt;</operator><name>input_proj_target</name><operator>-&gt;</operator><name>sortgrouprefs</name></name></expr>)</condition>
	<block>{<block_content>
		<for>for <control>(<init><decl><type><name>int</name></type> <name>idx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>idx</name> <operator>&lt;</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>exprLst</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>idx</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>info</name><operator>-&gt;</operator><name>input_proj_target</name><operator>-&gt;</operator><name>sortgrouprefs</name><index>[<expr><name>idx</name></expr>]</index></name> <operator>&gt;</operator> <name>maxRef</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>maxRef</name> <operator>=</operator> <name><name>info</name><operator>-&gt;</operator><name>input_proj_target</name><operator>-&gt;</operator><name>sortgrouprefs</name><index>[<expr><name>idx</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>input_proj_target</name><operator>-&gt;</operator><name>sortgrouprefs</name></name> <operator>=</operator> <operator>(</operator><name>Index</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>exprLst</name></expr></argument>)</argument_list></call> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Index</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name>dqa_group_exprs</name> <operator>=</operator> <call><name>get_sortgrouplist_exprs</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>,
											  <argument><expr><call><name>make_tlist_from_pathtarget</name><argument_list>(<argument><expr><name><name>path</name><operator>-&gt;</operator><name>pathtarget</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>Aggref</name>	   <modifier>*</modifier></type><name>aggref</name> <init>= <expr><call><name>list_nth</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>agg_costs</name><operator>-&gt;</operator><name>distinctAggrefs</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SortGroupClause</name> <modifier>*</modifier></type><name>arg_sortcl</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SortGroupClause</name> <modifier>*</modifier></type><name>sortcl</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>arg_tle</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>idx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lcc</name></decl>;</decl_stmt>

	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>aggref-&gt;aggdistinct</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><name>arg_sortcl</name> <operator>=</operator> <operator>(</operator><name>SortGroupClause</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>arg_tle</name> <operator>=</operator> <call><name>get_sortgroupref_tle</name><argument_list>(<argument><expr><name><name>arg_sortcl</name><operator>-&gt;</operator><name>tleSortGroupRef</name></name></expr></argument>, <argument><expr><name><name>aggref</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Now find this expression in the sub-path's target list */</comment>
		<expr_stmt><expr><name>idx</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<macro><name>foreach</name><argument_list>(<argument>lcc</argument>, <argument>info-&gt;input_proj_target-&gt;exprs</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Expr</name>		<modifier>*</modifier></type><name>expr</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lcc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>equal</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>arg_tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>idx</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block>

		<if_stmt><if>if <condition>(<expr><name>idx</name> <operator>==</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>info</name><operator>-&gt;</operator><name>input_proj_target</name><operator>-&gt;</operator><name>exprs</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>add_column_to_pathtarget</name><argument_list>(<argument><expr><name><name>info</name><operator>-&gt;</operator><name>input_proj_target</name></name></expr></argument>, <argument><expr><name><name>arg_tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><operator>++</operator><name>maxRef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name><name>info</name><operator>-&gt;</operator><name>input_proj_target</name><operator>-&gt;</operator><name>sortgrouprefs</name><index>[<expr><name>idx</name></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>input_proj_target</name><operator>-&gt;</operator><name>sortgrouprefs</name><index>[<expr><name>idx</name></expr>]</index></name> <operator>=</operator> <operator>++</operator><name>maxRef</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>sortcl</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>arg_sortcl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sortcl</name><operator>-&gt;</operator><name>tleSortGroupRef</name></name> <operator>=</operator> <name><name>info</name><operator>-&gt;</operator><name>input_proj_target</name><operator>-&gt;</operator><name>sortgrouprefs</name><index>[<expr><name>idx</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sortcl</name><operator>-&gt;</operator><name>hashable</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>	<comment type="block">/* we verified earlier that it's hashable */</comment>

		<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>dqa_group_clause</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>info</name><operator>-&gt;</operator><name>dqa_group_clause</name></name></expr></argument>, <argument><expr><name>sortcl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>dqa_group_exprs</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>dqa_group_exprs</name></expr></argument>, <argument><expr><name><name>arg_tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>dqa_group_clause</name></name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><call><name>list_copy</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>)</argument_list></call></expr></argument>,
										 <argument><expr><name><name>info</name><operator>-&gt;</operator><name>dqa_group_clause</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Estimate how many groups there are in DISTINCT + GROUP BY, per segment.
	 * For example in query:
	 *
	 * select count(distinct c) from t group by b;
	 *
	 * dNumDistinctGroups is the estimate of distinct combinations of b and c.
	 */</comment>
	<decl_stmt><decl><type><name>double</name></type>		<name>num_total_input_rows</name></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>CdbPathLocus_IsPartitioned</name><argument_list>(<argument><expr><name><name>path</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>num_total_input_rows</name> <operator>=</operator> <name><name>path</name><operator>-&gt;</operator><name>rows</name></name> <operator>*</operator> <call><name>CdbPathLocus_NumSegments</name><argument_list>(<argument><expr><name><name>path</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>num_total_input_rows</name> <operator>=</operator> <name><name>path</name><operator>-&gt;</operator><name>rows</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>dNumDistinctGroups</name></name> <operator>=</operator> <call><name>estimate_num_groups</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
												   <argument><expr><name>dqa_group_exprs</name></expr></argument>,
												   <argument><expr><name>num_total_input_rows</name></expr></argument>,
												   <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Prepare the input path for sorted Agg node.
 *
 * The input to a (sorted) Agg node must be:
 *
 * 1. distributed so that rows belonging to the same group reside on the
 *    same segment, and
 *
 * 2. sorted according to the pathkeys.
 *
 * If the input is already suitably distributed, this is no different from
 * upstream, and we just add a Sort node if the input isn't already sorted.
 *
 * This also works for the degenerate case with no pathkeys, which means
 * simple aggregation without grouping. For that, all the rows must be
 * brought to a single node, but no sorting is needed.
 *
 * For non-sorted input, the logic is the same as in choose_grouping_locus()
 * (in fact this uses choose_grouping_locus()), except that if the input
 * is already sorted, we prefer to gather it to a single node to make
 * use of the pre-existing order, instead of redistributing and resorting
 * it.
 */</comment>
<function><type><name>Path</name> <modifier>*</modifier></type>
<name>cdb_prepare_path_for_sorted_agg</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
								<parameter><decl><type><name>bool</name></type> <name>is_sorted</name></decl></parameter>,
								<comment type="block">/* args corresponding to create_sort_path */</comment>
								<parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>,
								<parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>subpath</name></decl></parameter>,
								<parameter><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>target</name></decl></parameter>,
								<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>group_pathkeys</name></decl></parameter>,
								<parameter><decl><type><name>double</name></type> <name>limit_tuples</name></decl></parameter>,
								<comment type="block">/* extra arguments */</comment>
								<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>groupClause</name></decl></parameter>,
								<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>rollups</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CdbPathLocus</name></type> <name>locus</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>need_redistribute</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * If the input is already collected to a single segment, just add a Sort
	 * node (if needed). We could redistribute it, so that we could perform the
	 * aggregation in parallel, but Motions are pretty expensive so it's
	 * probably not worthwhile.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>CdbPathLocus_IsBottleneck</name><argument_list>(<argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>need_redistribute</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>group_tles</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>group_tles</name> <operator>=</operator> <call><name>get_common_group_tles</name><argument_list>(<argument><expr><name>target</name></expr></argument>,
										   <argument><expr><name>groupClause</name></expr></argument>,
										   <argument><expr><name>rollups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>locus</name> <operator>=</operator> <call><name>choose_grouping_locus</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>subpath</name></expr></argument>, <argument><expr><name>group_tles</name></expr></argument>,
									  <argument><expr><operator>&amp;</operator><name>need_redistribute</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>need_redistribute</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_sorted</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>subpath</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>create_sort_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
												<argument><expr><name>rel</name></expr></argument>,
												<argument><expr><name>subpath</name></expr></argument>,
												<argument><expr><name>group_pathkeys</name></expr></argument>,
												<argument><expr><operator>-</operator><literal type="number">1.0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<return>return <expr><name>subpath</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>is_sorted</name> <operator>&amp;&amp;</operator> <name>group_pathkeys</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * The input is already conveniently sorted. We could redistribute
		 * it by the grouping keys, but then we'd need to re-sort it. That
		 * doesn't seem like a good idea, so we prefer to gather it all, and
		 * take advantage of the sort order.
		 */</comment>
		<expr_stmt><expr><call><name>CdbPathLocus_MakeSingleQE</name><argument_list>(<argument><expr><operator>&amp;</operator><name>locus</name></expr></argument>, <argument><expr><call><name>getgpsegmentCount</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>subpath</name> <operator>=</operator> <call><name>cdbpath_create_motion_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
											 <argument><expr><name>subpath</name></expr></argument>,
											 <argument><expr><name>group_pathkeys</name></expr></argument>,
											 <argument><expr><name>false</name></expr></argument>, <argument><expr><name>locus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><operator>!</operator><name>is_sorted</name> <operator>&amp;&amp;</operator> <name>group_pathkeys</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * If we need to redistribute, it's usually best to redistribute
		 * the data first, and then sort in parallel on each segment.
		 *
		 * But if we don't have any expressions to redistribute on, i.e.
		 * if we are gathering all data to a single node to perform the
		 * aggregation, then it's better to sort all the data on the
		 * segments first, in parallel, and do a order-preserving motion
		 * to merge the inputs.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>CdbPathLocus_IsPartitioned</name><argument_list>(<argument><expr><name>locus</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>subpath</name> <operator>=</operator> <call><name>cdbpath_create_motion_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>subpath</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>,
												 <argument><expr><name>false</name></expr></argument>, <argument><expr><name>locus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>subpath</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>create_sort_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
											<argument><expr><name>rel</name></expr></argument>,
											<argument><expr><name>subpath</name></expr></argument>,
											<argument><expr><name>group_pathkeys</name></expr></argument>,
											<argument><expr><operator>-</operator><literal type="number">1.0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CdbPathLocus_IsPartitioned</name><argument_list>(<argument><expr><name>locus</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>subpath</name> <operator>=</operator> <call><name>cdbpath_create_motion_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>subpath</name></expr></argument>,
												 <argument><expr><name>group_pathkeys</name></expr></argument>,
												 <argument><expr><name>false</name></expr></argument>, <argument><expr><name>locus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * The grouping doesn't require any sorting, i.e. the GROUP BY
		 * consists entirely of (pseudo-)constants.
		 *
		 * The locus could be Hashed, which is a bit silly because with
		 * all-constant grouping keys, all the rows will end up on a
		 * single QE anyway. We could mark the locus as SingleQE here, so
		 * that in simple cases where the result needs to end up in the QD,
		 * the planner could Gather the result there directly. However, in
		 * other cases hashing the result to one QE node is more helpful
		 * for the plan above this.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>group_pathkeys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>subpath</name> <operator>=</operator> <call><name>cdbpath_create_motion_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
											 <argument><expr><name>subpath</name></expr></argument>,
											 <argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>pathkeys</name></name></expr></argument>,
											 <argument><expr><name>false</name></expr></argument>, <argument><expr><name>locus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>subpath</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Prepare the input path for hashed Agg node.
 *
 * This is much simpler than the sorted case. We only need to care about
 * distribution, not sorting.
 */</comment>
<function><type><name>Path</name> <modifier>*</modifier></type>
<name>cdb_prepare_path_for_hashed_agg</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
								<parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>subpath</name></decl></parameter>,
								<parameter><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>target</name></decl></parameter>,
								<comment type="block">/* extra arguments */</comment>
								<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>groupClause</name></decl></parameter>,
								<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>rollups</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>group_tles</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CdbPathLocus</name></type> <name>locus</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>need_redistribute</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>CdbPathLocus_IsBottleneck</name><argument_list>(<argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>subpath</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>group_tles</name> <operator>=</operator> <call><name>get_common_group_tles</name><argument_list>(<argument><expr><name>target</name></expr></argument>,
									   <argument><expr><name>groupClause</name></expr></argument>,
									   <argument><expr><name>rollups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>locus</name> <operator>=</operator> <call><name>choose_grouping_locus</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
								  <argument><expr><name>subpath</name></expr></argument>,
								  <argument><expr><name>group_tles</name></expr></argument>,
								  <argument><expr><operator>&amp;</operator><name>need_redistribute</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Redistribute if needed.
	 *
	 * The hash agg doesn't care about input order, and it destroys any
	 * order there was, so don't bother with a order-preserving Motion even
	 * if we could.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>need_redistribute</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>subpath</name> <operator>=</operator> <call><name>cdbpath_create_motion_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
											 <argument><expr><name>subpath</name></expr></argument>,
											 <argument><expr><name>NIL</name></expr></argument> <comment type="block">/* pathkeys */</comment>,
											 <argument><expr><name>false</name></expr></argument>,
											 <argument><expr><name>locus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>subpath</name></expr>;</return>
</block_content>}</block></function>
</unit>
