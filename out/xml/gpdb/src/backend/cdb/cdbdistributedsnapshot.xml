<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/backend/cdb/cdbdistributedsnapshot.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * cdbdistributedsnapshot.c
 *
 * Portions Copyright (c) 2007-2008, Greenplum inc
 * Portions Copyright (c) 2012-Present VMware, Inc. or its affiliates.
 *
 *
 * IDENTIFICATION
 *	    src/backend/cdb/cdbdistributedsnapshot.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbdistributedsnapshot.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdblocaldistribxact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/distributedlog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/transam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbvars.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/guc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/snapmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/procarray.h"</cpp:file></cpp:include>

<function><type><name>int</name></type>
<name>GetMaxSnapshotDistributedXidCount</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>GetMaxSnapshotXidCount</name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * DistributedSnapshotWithLocalMapping_CommittedTest
 *		Is the given XID still-in-progress according to the
 *      distributed snapshot?  Or, is the transaction strictly local
 *      and needs to be tested with the local snapshot?
 */</comment>
<function><type><name>DistributedSnapshotCommitted</name></type>
<name>DistributedSnapshotWithLocalMapping_CommittedTest</name><parameter_list>(
												  <parameter><decl><type><name>DistributedSnapshotWithLocalMapping</name> <modifier>*</modifier></type><name>dslm</name></decl></parameter>,
												  <parameter><decl><type><name>TransactionId</name></type> <name>localXid</name></decl></parameter>,
												  <parameter><decl><type><name>bool</name></type> <name>isVacuumCheck</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DistributedSnapshot</name> <modifier>*</modifier></type><name>ds</name> <init>= <expr><operator>&amp;</operator><name><name>dslm</name><operator>-&gt;</operator><name>ds</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DistributedTransactionId</name></type> <name>distribXid</name> <init>= <expr><name>InvalidDistributedTransactionId</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>IS_QUERY_DISPATCHER</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Return early if local xid is not normal as it cannot have distributed
	 * xid associated with it.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TransactionIdIsNormal</name><argument_list>(<argument><expr><name>localXid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>DISTRIBUTEDSNAPSHOT_COMMITTED_IGNORE</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Checking the distributed committed log can be expensive, so make a scan
	 * through our cache in distributed snapshot looking for a possible
	 * corresponding local xid only if it has value in checking.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>dslm</name><operator>-&gt;</operator><name>currentLocalXidsCount</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>TransactionIdIsNormal</name><argument_list>(<argument><expr><name><name>dslm</name><operator>-&gt;</operator><name>minCachedLocalXid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>TransactionIdIsNormal</name><argument_list>(<argument><expr><name><name>dslm</name><operator>-&gt;</operator><name>maxCachedLocalXid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>TransactionIdEquals</name><argument_list>(<argument><expr><name>localXid</name></expr></argument>, <argument><expr><name><name>dslm</name><operator>-&gt;</operator><name>minCachedLocalXid</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
			<call><name>TransactionIdEquals</name><argument_list>(<argument><expr><name>localXid</name></expr></argument>, <argument><expr><name><name>dslm</name><operator>-&gt;</operator><name>maxCachedLocalXid</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>DISTRIBUTEDSNAPSHOT_COMMITTED_INPROGRESS</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>TransactionIdFollows</name><argument_list>(<argument><expr><name>localXid</name></expr></argument>, <argument><expr><name><name>dslm</name><operator>-&gt;</operator><name>minCachedLocalXid</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<call><name>TransactionIdPrecedes</name><argument_list>(<argument><expr><name>localXid</name></expr></argument>, <argument><expr><name><name>dslm</name><operator>-&gt;</operator><name>maxCachedLocalXid</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>dslm</name><operator>-&gt;</operator><name>currentLocalXidsCount</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>dslm</name><operator>-&gt;</operator><name>inProgressMappedLocalXids</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name><name>dslm</name><operator>-&gt;</operator><name>inProgressMappedLocalXids</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>TransactionIdEquals</name><argument_list>(<argument><expr><name>localXid</name></expr></argument>, <argument><expr><name><name>dslm</name><operator>-&gt;</operator><name>inProgressMappedLocalXids</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>DISTRIBUTEDSNAPSHOT_COMMITTED_INPROGRESS</name></expr>;</return></block_content></block></if></if_stmt>
			</block_content>}</block></for>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Is this local xid in a process-local cache we maintain?
	 *
	 * If we found xact in cache, the distribXid must be a valid gxid.
	 * We added it to cache in LocalDistribXactCache_AddCommitted()
	 * and there is nowhere to update distribXid to InvalidDistributedTransactionId.
	 * So that distribXid in cache must be valid or we don't find it
	 * in cache (never added or removed by cache LRU).
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>LocalDistribXactCache_CommittedFind</name><argument_list>(<argument><expr><name>localXid</name></expr></argument>,
											<argument><expr><operator>&amp;</operator><name>distribXid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Ok, now we must consult the distributed log.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>DistributedLog_CommittedCheck</name><argument_list>(<argument><expr><name>localXid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>distribXid</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * We found it in the distributed log.
			 */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>distribXid</name> <operator>!=</operator> <name>InvalidDistributedTransactionId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Since we did not find it in our process local cache, add it.
			 */</comment>
			<expr_stmt><expr><call><name>LocalDistribXactCache_AddCommitted</name><argument_list>(<argument><expr><name>localXid</name></expr></argument>,
											   <argument><expr><name>distribXid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * The distributedlog doesn't know of the transaction. It can be
			 * local-only, or still in-progress. The caller will proceed to do
			 * a local visibility check, which will determine which it is.
			 */</comment>
			<return>return <expr><name>DISTRIBUTEDSNAPSHOT_COMMITTED_UNKNOWN</name></expr>;</return>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>distribXid</name> <operator>!=</operator> <name>InvalidDistributedTransactionId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>ds</name><operator>-&gt;</operator><name>xminAllDistributedSnapshots</name></name> <operator>!=</operator> <name>InvalidDistributedTransactionId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If this distributed transaction is older than all the distributed
	 * snapshots, then we can ignore it from now on.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>ds</name><operator>-&gt;</operator><name>xmin</name></name> <operator>&gt;=</operator> <name><name>ds</name><operator>-&gt;</operator><name>xminAllDistributedSnapshots</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>distribXid</name> <operator>&lt;</operator> <name><name>ds</name><operator>-&gt;</operator><name>xminAllDistributedSnapshots</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>DISTRIBUTEDSNAPSHOT_COMMITTED_IGNORE</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If called to check for purpose of vacuum, in-progress is not
	 * interesting to check and hence just return.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>isVacuumCheck</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>DISTRIBUTEDSNAPSHOT_COMMITTED_INPROGRESS</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Any xid &lt; xmin is not in-progress */</comment>
	<if_stmt><if>if <condition>(<expr><name>distribXid</name> <operator>&lt;</operator> <name><name>ds</name><operator>-&gt;</operator><name>xmin</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>DISTRIBUTEDSNAPSHOT_COMMITTED_VISIBLE</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Any xid &gt;= xmax is in-progress, distributed xmax points to the
	 * latestCompletedGxid + 1.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>distribXid</name> <operator>&gt;=</operator> <name><name>ds</name><operator>-&gt;</operator><name>xmax</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><operator>(</operator><ternary><condition><expr><name>Debug_print_snapshot_dtm</name></expr> ?</condition><then> <expr><name>LOG</name></expr> </then><else>: <expr><name>DEBUG5</name></expr></else></ternary><operator>)</operator></expr></argument>,
			 <argument><expr><literal type="string">"distributedsnapshot committed but invisible: distribXid "</literal><name>UINT64_FORMAT</name><literal type="string">" dxmax "</literal><name>UINT64_FORMAT</name><literal type="string">" dxmin "</literal><name>UINT64_FORMAT</name><literal type="string">" distribSnapshotId %d"</literal></expr></argument>,
			 <argument><expr><name>distribXid</name></expr></argument>, <argument><expr><name><name>ds</name><operator>-&gt;</operator><name>xmax</name></name></expr></argument>, <argument><expr><name><name>ds</name><operator>-&gt;</operator><name>xmin</name></name></expr></argument>, <argument><expr><name><name>ds</name><operator>-&gt;</operator><name>distribSnapshotId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return <expr><name>DISTRIBUTEDSNAPSHOT_COMMITTED_INPROGRESS</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>ds</name><operator>-&gt;</operator><name>count</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>distribXid</name> <operator>==</operator> <name><name>ds</name><operator>-&gt;</operator><name>inProgressXidArray</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Save the relationship to the local xid so we may avoid checking
			 * the distributed committed log in a subsequent check. We can
			 * only record local xids till cache size permits.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>dslm</name><operator>-&gt;</operator><name>currentLocalXidsCount</name></name> <operator>&lt;</operator> <name><name>ds</name><operator>-&gt;</operator><name>count</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>dslm</name><operator>-&gt;</operator><name>inProgressMappedLocalXids</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>dslm</name><operator>-&gt;</operator><name>inProgressMappedLocalXids</name><index>[<expr><name><name>dslm</name><operator>-&gt;</operator><name>currentLocalXidsCount</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator>
					<name>localXid</name></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name><name>dslm</name><operator>-&gt;</operator><name>minCachedLocalXid</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
					<call><name>TransactionIdPrecedes</name><argument_list>(<argument><expr><name>localXid</name></expr></argument>, <argument><expr><name><name>dslm</name><operator>-&gt;</operator><name>minCachedLocalXid</name></name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>dslm</name><operator>-&gt;</operator><name>minCachedLocalXid</name></name> <operator>=</operator> <name>localXid</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name><name>dslm</name><operator>-&gt;</operator><name>maxCachedLocalXid</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
					<call><name>TransactionIdFollows</name><argument_list>(<argument><expr><name>localXid</name></expr></argument>, <argument><expr><name><name>dslm</name><operator>-&gt;</operator><name>maxCachedLocalXid</name></name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>dslm</name><operator>-&gt;</operator><name>maxCachedLocalXid</name></name> <operator>=</operator> <name>localXid</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>

			<return>return <expr><name>DISTRIBUTEDSNAPSHOT_COMMITTED_INPROGRESS</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Leverage the fact that ds-&gt;inProgressXidArray is sorted in
		 * ascending order based on distribXid while creating the snapshot in
		 * CreateDistributedSnapshot(). So, can fail fast once known are
		 * lower than rest of them.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>distribXid</name> <operator>&lt;</operator> <name><name>ds</name><operator>-&gt;</operator><name>inProgressXidArray</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Not in-progress, therefore visible.
	 */</comment>
	<return>return <expr><name>DISTRIBUTEDSNAPSHOT_COMMITTED_VISIBLE</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Reset all fields except maxCount and the malloc'd pointer for
 * inProgressXidArray.
 */</comment>
<function><type><name>void</name></type>
<name>DistributedSnapshot_Reset</name><parameter_list>(<parameter><decl><type><name>DistributedSnapshot</name> <modifier>*</modifier></type><name>distributedSnapshot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>distributedSnapshot</name><operator>-&gt;</operator><name>xminAllDistributedSnapshots</name></name> <operator>=</operator> <name>InvalidDistributedTransactionId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>distributedSnapshot</name><operator>-&gt;</operator><name>distribSnapshotId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>distributedSnapshot</name><operator>-&gt;</operator><name>xmin</name></name> <operator>=</operator> <name>InvalidDistributedTransactionId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>distributedSnapshot</name><operator>-&gt;</operator><name>xmax</name></name> <operator>=</operator> <name>InvalidDistributedTransactionId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>distributedSnapshot</name><operator>-&gt;</operator><name>count</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>distributedSnapshot</name><operator>-&gt;</operator><name>inProgressXidArray</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>distributedSnapshot</name><operator>-&gt;</operator><name>inProgressXidArray</name></name> <operator>=</operator>
			<operator>(</operator><name>DistributedTransactionId</name><operator>*</operator><operator>)</operator> <call><name>malloc</name><argument_list>(<argument><expr><call><name>GetMaxSnapshotDistributedXidCount</name><argument_list>()</argument_list></call> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>DistributedTransactionId</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>distributedSnapshot</name><operator>-&gt;</operator><name>inProgressXidArray</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Make a copy of a DistributedSnapshot, allocating memory for the in-progress
 * array if necessary.
 *
 * Note: 'target' should be from a static variable, like the argument of GetSnapshotData()
 */</comment>
<function><type><name>void</name></type>
<name>DistributedSnapshot_Copy</name><parameter_list>(<parameter><decl><type><name>DistributedSnapshot</name> <modifier>*</modifier></type><name>target</name></decl></parameter>,
						 <parameter><decl><type><name>DistributedSnapshot</name> <modifier>*</modifier></type><name>source</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>DistributedSnapshot_Reset</name><argument_list>(<argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>source</name><operator>-&gt;</operator><name>xminAllDistributedSnapshots</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>source</name><operator>-&gt;</operator><name>xminAllDistributedSnapshots</name></name> <operator>&lt;=</operator> <name><name>source</name><operator>-&gt;</operator><name>xmin</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><operator>(</operator><ternary><condition><expr><name>Debug_print_full_dtm</name></expr> ?</condition><then> <expr><name>LOG</name></expr> </then><else>: <expr><name>DEBUG5</name></expr></else></ternary><operator>)</operator></expr></argument>,
		 <argument><expr><literal type="string">"DistributedSnapshot_Copy target inProgressXidArray %p, and "</literal>
		 <literal type="string">"source count %d, inProgressXidArray %p"</literal></expr></argument>,
		 <argument><expr><name><name>target</name><operator>-&gt;</operator><name>inProgressXidArray</name></name></expr></argument>,
		 <argument><expr><name><name>source</name><operator>-&gt;</operator><name>count</name></name></expr></argument>,
		 <argument><expr><name><name>source</name><operator>-&gt;</operator><name>inProgressXidArray</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>target</name><operator>-&gt;</operator><name>xminAllDistributedSnapshots</name></name> <operator>=</operator> <name><name>source</name><operator>-&gt;</operator><name>xminAllDistributedSnapshots</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>target</name><operator>-&gt;</operator><name>distribSnapshotId</name></name> <operator>=</operator> <name><name>source</name><operator>-&gt;</operator><name>distribSnapshotId</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>target</name><operator>-&gt;</operator><name>xmin</name></name> <operator>=</operator> <name><name>source</name><operator>-&gt;</operator><name>xmin</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>target</name><operator>-&gt;</operator><name>xmax</name></name> <operator>=</operator> <name><name>source</name><operator>-&gt;</operator><name>xmax</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>target</name><operator>-&gt;</operator><name>count</name></name> <operator>=</operator> <name><name>source</name><operator>-&gt;</operator><name>count</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>source</name><operator>-&gt;</operator><name>count</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>target</name><operator>-&gt;</operator><name>inProgressXidArray</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>target</name><operator>-&gt;</operator><name>inProgressXidArray</name></name> <operator>=</operator>
			<operator>(</operator><name>DistributedTransactionId</name><operator>*</operator><operator>)</operator> <call><name>malloc</name><argument_list>(<argument><expr><call><name>GetMaxSnapshotDistributedXidCount</name><argument_list>()</argument_list></call> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>DistributedTransactionId</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>target</name><operator>-&gt;</operator><name>inProgressXidArray</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>source</name><operator>-&gt;</operator><name>count</name></name> <operator>&lt;=</operator> <call><name>GetMaxSnapshotDistributedXidCount</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>target</name><operator>-&gt;</operator><name>inProgressXidArray</name></name></expr></argument>,
			<argument><expr><name><name>source</name><operator>-&gt;</operator><name>inProgressXidArray</name></name></expr></argument>,
			<argument><expr><name><name>source</name><operator>-&gt;</operator><name>count</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>DistributedTransactionId</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>DistributedSnapshot_SerializeSize</name><parameter_list>(<parameter><decl><type><name>DistributedSnapshot</name> <modifier>*</modifier></type><name>ds</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><sizeof>sizeof<argument_list>(<argument><expr><name>DistributedSnapshotId</name></expr></argument>)</argument_list></sizeof> <operator>+</operator>
	<comment type="block">/* xminAllDistributedSnapshots, xmin, xmax */</comment>
		<literal type="number">3</literal> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>DistributedTransactionId</name></expr></argument>)</argument_list></sizeof> <operator>+</operator>
	<comment type="block">/* count */</comment>
		<sizeof>sizeof<argument_list>(<argument><expr><name>int32</name></expr></argument>)</argument_list></sizeof> <operator>+</operator>
	<comment type="block">/* Size of inProgressXidArray */</comment>
		<sizeof>sizeof<argument_list>(<argument><expr><name>DistributedTransactionId</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>ds</name><operator>-&gt;</operator><name>count</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>DistributedSnapshot_Serialize</name><parameter_list>(<parameter><decl><type><name>DistributedSnapshot</name> <modifier>*</modifier></type><name>ds</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>p</name> <init>= <expr><name>buf</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ds</name><operator>-&gt;</operator><name>xminAllDistributedSnapshots</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>DistributedTransactionId</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>p</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>DistributedTransactionId</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ds</name><operator>-&gt;</operator><name>distribSnapshotId</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>DistributedSnapshotId</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>p</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>DistributedSnapshotId</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ds</name><operator>-&gt;</operator><name>xmin</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>DistributedTransactionId</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>p</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>DistributedTransactionId</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ds</name><operator>-&gt;</operator><name>xmax</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>DistributedTransactionId</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>p</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>DistributedTransactionId</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ds</name><operator>-&gt;</operator><name>count</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>p</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int32</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>ds</name><operator>-&gt;</operator><name>inProgressXidArray</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>DistributedTransactionId</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>ds</name><operator>-&gt;</operator><name>count</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>p</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>DistributedTransactionId</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>ds</name><operator>-&gt;</operator><name>count</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name>p</name> <operator>-</operator> <name>buf</name><operator>)</operator> <operator>==</operator> <call><name>DistributedSnapshot_SerializeSize</name><argument_list>(<argument><expr><name>ds</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><name>p</name> <operator>-</operator> <name>buf</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>DistributedSnapshot_Deserialize</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>DistributedSnapshot</name> <modifier>*</modifier></type><name>ds</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name>buf</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ds</name><operator>-&gt;</operator><name>xminAllDistributedSnapshots</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>DistributedTransactionId</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>p</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>DistributedTransactionId</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ds</name><operator>-&gt;</operator><name>distribSnapshotId</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>DistributedSnapshotId</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>p</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>DistributedSnapshotId</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ds</name><operator>-&gt;</operator><name>xmin</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>DistributedTransactionId</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>p</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>DistributedTransactionId</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ds</name><operator>-&gt;</operator><name>xmax</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>DistributedTransactionId</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>p</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>DistributedTransactionId</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ds</name><operator>-&gt;</operator><name>count</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>p</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int32</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>ds</name><operator>-&gt;</operator><name>count</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>xipsize</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>DistributedTransactionId</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>ds</name><operator>-&gt;</operator><name>count</name></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>ds</name><operator>-&gt;</operator><name>inProgressXidArray</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>ds</name><operator>-&gt;</operator><name>inProgressXidArray</name></name> <operator>=</operator>
				<operator>(</operator><name>DistributedTransactionId</name> <operator>*</operator><operator>)</operator><call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>DistributedTransactionId</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <call><name>GetMaxSnapshotXidCount</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>ds</name><operator>-&gt;</operator><name>inProgressXidArray</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>ds</name><operator>-&gt;</operator><name>inProgressXidArray</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>xipsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>p</name> <operator>+=</operator> <name>xipsize</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name>p</name> <operator>-</operator> <name>buf</name><operator>)</operator> <operator>==</operator> <call><name>DistributedSnapshot_SerializeSize</name><argument_list>(<argument><expr><name>ds</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><operator>(</operator><name>p</name> <operator>-</operator> <name>buf</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>
</unit>
