<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/backend/cdb/cdbappendonlystorageformat.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * cdbappendonlystorageformat.c
 *
 * Portions Copyright (c) 2007-2009, Greenplum inc
 * Portions Copyright (c) 2012-Present VMware, Inc. or its affiliates.
 *
 *
 * IDENTIFICATION
 *	    src/backend/cdb/cdbappendonlystorageformat.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbappendonlystorage_int.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbappendonlystorage.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbappendonlystorageformat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"port/pg_crc32c.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/guc.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_AOHEADER_CHECK_ERROR_STR</name></cpp:macro> <cpp:value>300</cpp:value></cpp:define>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>AoHeaderCheckErrorStr</name><index>[<expr><name>MAX_AOHEADER_CHECK_ERROR_STR</name></expr>]</index></name> <init>= <expr><literal type="string">"\0"</literal></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>pg_crc32</name></type>
<name>AppendOnlyStorageFormat_ComputeHeaderChecksum</name><parameter_list>(
											  <parameter><decl><type><name>uint8</name> <modifier>*</modifier></type><name>headerPtr</name></decl></parameter>,
											  <parameter><decl><type><name>int32</name></type> <name>headerLen</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>pg_crc32</name></type>	<name>crc</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>headerPtr</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Compute CRC of the header. The header length does not include the
	 * header checksum.
	 */</comment>
	<expr_stmt><expr><call><name>INIT_CRC32C</name><argument_list>(<argument><expr><name>crc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMP_CRC32C</name><argument_list>(<argument><expr><name>crc</name></expr></argument>, <argument><expr><name>headerPtr</name></expr></argument>, <argument><expr><name>headerLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * By historical accident, the checksum calculated for append-only blocks
	 * is *not* inverted, like CRC-32C checksums usually are.
	 */</comment>
	<comment type="block">/* FIN_CRC32C(crc); */</comment>

	<return>return <expr><name>crc</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>pg_crc32</name></type>
<name>AppendOnlyStorageFormat_ComputeBlockChecksum</name><parameter_list>(
											 <parameter><decl><type><name>uint8</name> <modifier>*</modifier></type><name>headerPtr</name></decl></parameter>,
											 <parameter><decl><type><name>int32</name></type> <name>headerLen</name></decl></parameter>,
											 <parameter><decl><type><name>int32</name></type> <name>overallBlockLen</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int32</name></type>		<name>dataOffset</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pg_crc32</name></type>	<name>crc</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>headerPtr</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * The block checksum covers right after the header checksum through the
	 * end of the whole block (including the optional firstRowNum).
	 */</comment>
	<expr_stmt><expr><name>dataOffset</name> <operator>=</operator> <name>headerLen</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>pg_crc32</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

	<comment type="block">/* Compute CRC of the header. */</comment>
	<expr_stmt><expr><call><name>INIT_CRC32C</name><argument_list>(<argument><expr><name>crc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMP_CRC32C</name><argument_list>(<argument><expr><name>crc</name></expr></argument>, <argument><expr><name>headerPtr</name> <operator>+</operator> <name>dataOffset</name></expr></argument>, <argument><expr><name>overallBlockLen</name> <operator>-</operator> <name>dataOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * By historical accident, the checksum calculated for append-only blocks
	 * is *not* inverted, like CRC-32C checksums usually are.
	 */</comment>
	<comment type="block">/* FIN_CRC32C(crc); */</comment>

	<return>return <expr><name>crc</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32</name></type>
<name>AppendOnlyStorageFormat_RegularHeaderLenNeeded</name><parameter_list>(
											   <parameter><decl><type><name>bool</name></type> <name>usingChecksum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name>AoHeader_RegularSize</name> <operator>+</operator>
		<operator>(</operator><ternary><condition><expr><name>usingChecksum</name></expr> ?</condition><then> <expr><literal type="number">2</literal> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>pg_crc32</name></expr></argument>)</argument_list></sizeof></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>AppendOnlyStorageFormat_AddFirstRowNum</name><parameter_list>(
									   <parameter><decl><type><name>uint8</name> <modifier>*</modifier></type><name>headerPtr</name></decl></parameter>,
									   <parameter><decl><type><name>bool</name></type> <name>usingChecksums</name></decl></parameter>,
									   <parameter><decl><type><name>int64</name></type> <name>firstRowNum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AOSmallContentHeader</name> <modifier>*</modifier></type><name>blockHeader</name> <init>= <expr><operator>(</operator><name>AOSmallContentHeader</name> <operator>*</operator><operator>)</operator> <name>headerPtr</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>int32</name></type>		<name>offsetToFirstRowNum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name>	   <modifier>*</modifier></type><name>firstRowNumPtr</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AoHeader_IsLong</name><argument_list>(<argument><expr><call><name>AOSmallContentHeaderGet_headerKind</name><argument_list>(<argument><expr><name>blockHeader</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>offsetToFirstRowNum</name> <operator>=</operator> <name>AoHeader_RegularSize</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>offsetToFirstRowNum</name> <operator>=</operator> <name>AoHeader_LongSize</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>usingChecksums</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>offsetToFirstRowNum</name> <operator>+=</operator> <literal type="number">2</literal> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>pg_crc32</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<comment type="block">/* Header and Block checksums. */</comment>

	<expr_stmt><expr><name>firstRowNumPtr</name> <operator>=</operator> <operator>(</operator><name>int64</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>headerPtr</name><index>[<expr><name>offsetToFirstRowNum</name></expr>]</index></name></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>firstRowNumPtr</name> <operator>=</operator> <name>firstRowNum</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>elogif</name><argument_list>(<argument><expr><name>Debug_appendonly_print_storage_headers</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>,
		   <argument><expr><literal type="string">"Append-Only storage first row number header result: block_bytes_0_3 0x%X, block_bytes_4_7 0x%X, "</literal>
		   <literal type="string">"firstRowNum "</literal> <name>INT64_FORMAT</name></expr></argument>,
		   <argument><expr><name><name>blockHeader</name><operator>-&gt;</operator><name>smallcontent_bytes_0_3</name></name></expr></argument>,
		   <argument><expr><name><name>blockHeader</name><operator>-&gt;</operator><name>smallcontent_bytes_4_7</name></name></expr></argument>,
		   <argument><expr><name>firstRowNum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>AppendOnlyStorageFormat_AddBlockHeaderChecksums</name><parameter_list>(
												<parameter><decl><type><name>uint8</name> <modifier>*</modifier></type><name>headerPtr</name></decl></parameter>,
												<parameter><decl><type><name>bool</name></type> <name>isCompressed</name></decl></parameter>,
												<parameter><decl><type><name>bool</name></type> <name>hasFirstRowNum</name></decl></parameter>,
												<parameter><decl><type><name>int</name></type> <name>version</name></decl></parameter>,
												<parameter><decl><type><name>int32</name></type> <name>dataLength</name></decl></parameter>,
												<parameter><decl><type><name>int32</name></type> <name>compressedLength</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AOSmallContentHeader</name> <modifier>*</modifier></type><name>blockHeader</name> <init>= <expr><operator>(</operator><name>AOSmallContentHeader</name> <operator>*</operator><operator>)</operator> <name>headerPtr</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>AoHeaderKind</name></type> <name>headerKind</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>int32</name></type>		<name>firstHeaderLen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>firstHeaderAndBlockChecksumLen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>offset</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>extHeaderOffset</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>overallBlockLen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pg_crc32</name>   <modifier>*</modifier></type><name>blockChecksumPtr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pg_crc32</name>   <modifier>*</modifier></type><name>headerChecksumPtr</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>headerKind</name> <operator>=</operator> <call><name>AOSmallContentHeaderGet_headerKind</name><argument_list>(<argument><expr><name>blockHeader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>firstHeaderLen</name> <operator>=</operator> <name>AoHeader_RegularSize</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>firstHeaderAndBlockChecksumLen</name> <operator>=</operator> <name>firstHeaderLen</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>pg_crc32</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<comment type="block">/* Block checksum. */</comment>

	<expr_stmt><expr><name>offset</name> <operator>=</operator> <name>firstHeaderAndBlockChecksumLen</name> <operator>+</operator>
		<sizeof>sizeof<argument_list>(<argument><expr><name>pg_crc32</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<comment type="block">/* Header checksum. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>AoHeader_IsLong</name><argument_list>(<argument><expr><name>headerKind</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>extHeaderOffset</name> <operator>=</operator> <name>offset</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>offset</name> <operator>+=</operator> <name>AoHeader_RegularSize</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>extHeaderOffset</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>hasFirstRowNum</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>offset</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int64</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>overallBlockLen</name> <operator>=</operator> <name>offset</name> <operator>+</operator>
		<call><name>AOStorage_RoundUp</name><argument_list>(
						  <argument><expr><operator>(</operator><ternary><condition><expr><name>isCompressed</name></expr> ?</condition><then> <expr><name>compressedLength</name></expr> </then><else>: <expr><name>dataLength</name></expr></else></ternary><operator>)</operator></expr></argument>,
						  <argument><expr><name>version</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Calculate Block checksum first since it is included in the header
	 * checksum.
	 */</comment>
	<expr_stmt><expr><name>blockChecksumPtr</name> <operator>=</operator> <operator>(</operator><name>pg_crc32</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>headerPtr</name><index>[<expr><name>firstHeaderLen</name></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>blockChecksumPtr</name> <operator>=</operator> <call><name>AppendOnlyStorageFormat_ComputeBlockChecksum</name><argument_list>(
																	 <argument><expr><name>headerPtr</name></expr></argument>,
																	 <argument><expr><name>firstHeaderAndBlockChecksumLen</name></expr></argument>,
																	 <argument><expr><name>overallBlockLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Now the Header checksum after the header and block checksum.
	 */</comment>
	<expr_stmt><expr><name>headerChecksumPtr</name> <operator>=</operator> <operator>(</operator><name>pg_crc32</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>headerPtr</name><index>[<expr><name>firstHeaderAndBlockChecksumLen</name></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>headerChecksumPtr</name> <operator>=</operator> <call><name>AppendOnlyStorageFormat_ComputeHeaderChecksum</name><argument_list>(
																	   <argument><expr><name>headerPtr</name></expr></argument>,
																	   <argument><expr><name>firstHeaderAndBlockChecksumLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>Debug_appendonly_print_storage_headers</name></expr>)</condition>
	<block>{<block_content>
		<switch>switch <condition>(<expr><name>headerKind</name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>AoHeaderKind_SmallContent</name></expr>:</case>
			<case>case <expr><name>AoHeaderKind_LargeContent</name></expr>:</case>
			<case>case <expr><name>AoHeaderKind_NonBulkDenseContent</name></expr>:</case>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
					 <argument><expr><literal type="string">"Append-Only storage make with checksums block header result: block_bytes_0_3 0x%X, block_bytes_4_7 0x%X, "</literal>
					 <literal type="string">"header checksum 0x%08X, block checksum 0x%08X, overallBlockLen %d"</literal></expr></argument>,
					 <argument><expr><name><name>blockHeader</name><operator>-&gt;</operator><name>smallcontent_bytes_0_3</name></name></expr></argument>,
					 <argument><expr><name><name>blockHeader</name><operator>-&gt;</operator><name>smallcontent_bytes_4_7</name></name></expr></argument>,
					 <argument><expr><operator>*</operator><name>headerChecksumPtr</name></expr></argument>,
					 <argument><expr><operator>*</operator><name>blockChecksumPtr</name></expr></argument>,
					 <argument><expr><name>overallBlockLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>AoHeaderKind_BulkDenseContent</name></expr>:</case>
				<block>{<block_content>
					<decl_stmt><decl><type><name>AOBulkDenseContentHeader</name> <modifier>*</modifier></type><name>bulkDenseHeader</name> <init>= <expr><operator>(</operator><name>AOBulkDenseContentHeader</name> <operator>*</operator><operator>)</operator> <name>headerPtr</name></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>AOBulkDenseContentHeaderExt</name> <modifier>*</modifier></type><name>bulkDenseHeaderExt</name></decl>;</decl_stmt>

					<expr_stmt><expr><name>bulkDenseHeaderExt</name> <operator>=</operator>
						<operator>(</operator><name>AOBulkDenseContentHeaderExt</name> <operator>*</operator><operator>)</operator>
						<operator>(</operator><name>headerPtr</name> <operator>+</operator> <name>extHeaderOffset</name><operator>)</operator></expr>;</expr_stmt>

					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
						 <argument><expr><literal type="string">"Append-Only storage make with checksums Bulk Dense Content header result: "</literal>
						 <literal type="string">"bulkdensecontent_bytes_0_3 0x%X, bulkdensecontent_bytes_4_7 0x%X "</literal>
						 <literal type="string">"bulkdensecontent_ext_bytes_0_3 0x%X, bulkdensecontent_ext_bytes_4_7 0x%X, "</literal>
						 <literal type="string">"header checksum 0x%08X, block checksum 0x%08X, overallBlockLen %d"</literal></expr></argument>,
						 <argument><expr><name><name>bulkDenseHeader</name><operator>-&gt;</operator><name>bulkdensecontent_bytes_0_3</name></name></expr></argument>,
						 <argument><expr><name><name>bulkDenseHeader</name><operator>-&gt;</operator><name>bulkdensecontent_bytes_4_7</name></name></expr></argument>,
						 <argument><expr><name><name>bulkDenseHeaderExt</name><operator>-&gt;</operator><name>bulkdensecontent_ext_bytes_0_3</name></name></expr></argument>,
						 <argument><expr><name><name>bulkDenseHeaderExt</name><operator>-&gt;</operator><name>bulkdensecontent_ext_bytes_4_7</name></name></expr></argument>,
						 <argument><expr><operator>*</operator><name>headerChecksumPtr</name></expr></argument>,
						 <argument><expr><operator>*</operator><name>blockChecksumPtr</name></expr></argument>,
						 <argument><expr><name>overallBlockLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block>

			<default>default:</default>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unexpected Append-Only header kind %d"</literal></expr></argument>,
								<argument><expr><name>headerKind</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
		</block_content>}</block></switch>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>AppendOnlyStorageFormat_MakeSmallContentHeader</name><parameter_list>(
											   <parameter><decl><type><name>uint8</name> <modifier>*</modifier></type><name>headerPtr</name></decl></parameter>,
											   <parameter><decl><type><name>bool</name></type> <name>usingChecksums</name></decl></parameter>,
											   <parameter><decl><type><name>bool</name></type> <name>hasFirstRowNum</name></decl></parameter>,
											   <parameter><decl><type><name>int</name></type> <name>version</name></decl></parameter>,
											   <parameter><decl><type><name>int64</name></type> <name>firstRowNum</name></decl></parameter>,
											   <parameter><decl><type><name>int</name></type> <name>executorKind</name></decl></parameter>,
											   <parameter><decl><type><name>int</name></type> <name>rowCount</name></decl></parameter>,
											   <parameter><decl><type><name>int32</name></type> <name>dataLength</name></decl></parameter>,
											   <parameter><decl><type><name>int32</name></type> <name>compressedLength</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AOSmallContentHeader</name> <modifier>*</modifier></type><name>blockHeader</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>bool</name></type>		<name>isCompressed</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>headerPtr</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>blockHeader</name> <operator>=</operator> <operator>(</operator><name>AOSmallContentHeader</name> <operator>*</operator><operator>)</operator> <name>headerPtr</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>elogif</name><argument_list>(<argument><expr><name>Debug_appendonly_print_storage_headers</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>,
		   <argument><expr><literal type="string">"Append-Only storage make Small Content header parameters: wantChecksum = %s, hasFirstRowNum %s, executorKind = %d, "</literal>
		   <literal type="string">"rowCount = %d, dataLength %d, compressedLength %d"</literal></expr></argument>,
		   <argument><expr><operator>(</operator><ternary><condition><expr><name>usingChecksums</name></expr> ?</condition><then> <expr><literal type="string">"true"</literal></expr> </then><else>: <expr><literal type="string">"false"</literal></expr></else></ternary><operator>)</operator></expr></argument>,
		   <argument><expr><operator>(</operator><ternary><condition><expr><name>hasFirstRowNum</name></expr> ?</condition><then> <expr><literal type="string">"true"</literal></expr> </then><else>: <expr><literal type="string">"false"</literal></expr></else></ternary><operator>)</operator></expr></argument>,
		   <argument><expr><name>executorKind</name></expr></argument>,
		   <argument><expr><name>rowCount</name></expr></argument>,
		   <argument><expr><name>dataLength</name></expr></argument>,
		   <argument><expr><name>compressedLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Zero out whole header */</comment>
	<expr_stmt><expr><call><name>AOSmallContentHeaderInit_Init</name><argument_list>(<argument><expr><name>blockHeader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>AOSmallContentHeaderInit_headerKind</name><argument_list>(<argument><expr><name>blockHeader</name></expr></argument>, <argument><expr><name>AoHeaderKind_SmallContent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AOSmallContentHeaderInit_executorBlockKind</name><argument_list>(<argument><expr><name>blockHeader</name></expr></argument>, <argument><expr><name>executorKind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AOSmallContentHeaderInit_rowCount</name><argument_list>(<argument><expr><name>blockHeader</name></expr></argument>, <argument><expr><name>rowCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AOSmallContentHeaderInit_dataLength</name><argument_list>(<argument><expr><name>blockHeader</name></expr></argument>, <argument><expr><name>dataLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AOSmallContentHeaderInit_hasFirstRowNum</name><argument_list>(<argument><expr><name>blockHeader</name></expr></argument>, <argument><expr><name>hasFirstRowNum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>isCompressed</name> <operator>=</operator> <operator>(</operator><name>compressedLength</name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>isCompressed</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>AOSmallContentHeaderInit_compressedLength</name><argument_list>(<argument><expr><name>blockHeader</name></expr></argument>, <argument><expr><name>compressedLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Add the optional firstRowNum.
	 *
	 * NOTE: This is not part of the 8-byte (64-bit) header because it is so
	 * big. NOTE: And, it is not covered by the header checksum because in
	 * order to NOTE: determine if we should checksum more data we would need
	 * to examine NOTE: the header data not verified by checksum yet...
	 *
	 * So, the firstRowNum is extra data between the header (and checksums)
	 * and the content.  We must add it before computing the checksum.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>hasFirstRowNum</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>AppendOnlyStorageFormat_AddFirstRowNum</name><argument_list>(
											   <argument><expr><name>headerPtr</name></expr></argument>,
											   <argument><expr><name>usingChecksums</name></expr></argument>,
											   <argument><expr><name>firstRowNum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>usingChecksums</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>AppendOnlyStorageFormat_AddBlockHeaderChecksums</name><argument_list>(
														<argument><expr><name>headerPtr</name></expr></argument>,
														<argument><expr><name>isCompressed</name></expr></argument>,
														<argument><expr><name>hasFirstRowNum</name></expr></argument>,
														<argument><expr><name>version</name></expr></argument>,
														<argument><expr><name>dataLength</name></expr></argument>,
														<argument><expr><name>compressedLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>elogif</name><argument_list>(<argument><expr><name>Debug_appendonly_print_storage_headers</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>,
			   <argument><expr><literal type="string">"Append-Only storage make Small Content header result: smallcontent_bytes_0_3 0x%X, smallcontent_bytes_4_7 0x%X"</literal></expr></argument>,
			   <argument><expr><name><name>blockHeader</name><operator>-&gt;</operator><name>smallcontent_bytes_0_3</name></name></expr></argument>,
			   <argument><expr><name><name>blockHeader</name><operator>-&gt;</operator><name>smallcontent_bytes_4_7</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><name>char</name> <modifier>*</modifier></type>
<name>AppendOnlyStorageFormat_SmallContentHeaderStr</name><parameter_list>(
											  <parameter><decl><type><name>uint8</name> <modifier>*</modifier></type><name>headerPtr</name></decl></parameter>,
											  <parameter><decl><type><name>bool</name></type> <name>usingChecksums</name></decl></parameter>,
											  <parameter><decl><type><name>int</name></type> <name>version</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AOSmallContentHeader</name> <modifier>*</modifier></type><name>blockHeader</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AoHeaderKind</name></type> <name>aoHeaderKind</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>int32</name></type>		<name>headerLen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>wholeHeaderLen</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>int</name></type>			<name>executorBlockKind</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>rowCount</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>dataLength</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>compressedLength</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>overallBlockLen</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>pg_crc32</name>   <modifier>*</modifier></type><name>blockChecksumPtr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pg_crc32</name></type>	<name>blockChecksum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pg_crc32</name>   <modifier>*</modifier></type><name>headerChecksumPtr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pg_crc32</name></type>	<name>headerChecksum</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>headerPtr</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>blockHeader</name> <operator>=</operator> <operator>(</operator><name>AOSmallContentHeader</name> <operator>*</operator><operator>)</operator> <name>headerPtr</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>aoHeaderKind</name> <operator>=</operator> <call><name>AOSmallContentHeaderGet_headerKind</name><argument_list>(<argument><expr><name>blockHeader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>headerLen</name> <operator>=</operator> <name>AoHeader_RegularSize</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>executorBlockKind</name> <operator>=</operator> <call><name>AOSmallContentHeaderGet_executorBlockKind</name><argument_list>(<argument><expr><name>blockHeader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>rowCount</name> <operator>=</operator> <call><name>AOSmallContentHeaderGet_rowCount</name><argument_list>(<argument><expr><name>blockHeader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>wholeHeaderLen</name> <operator>=</operator> <name>headerLen</name> <operator>+</operator>
		<operator>(</operator><ternary><condition><expr><name>usingChecksums</name></expr> ?</condition><then> <expr><literal type="number">2</literal> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>pg_crc32</name></expr></argument>)</argument_list></sizeof></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>

	<expr_stmt><expr><name>dataLength</name> <operator>=</operator> <call><name>AOSmallContentHeaderGet_dataLength</name><argument_list>(<argument><expr><name>blockHeader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>compressedLength</name> <operator>=</operator> <call><name>AOSmallContentHeaderGet_compressedLength</name><argument_list>(<argument><expr><name>blockHeader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>overallBlockLen</name> <operator>=</operator> <name>wholeHeaderLen</name> <operator>+</operator>
		<call><name>AOStorage_RoundUp</name><argument_list>(
						  <argument><expr><operator>(</operator><ternary><condition><expr><name>compressedLength</name> <operator>==</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name>dataLength</name></expr> </then><else>: <expr><name>compressedLength</name></expr></else></ternary><operator>)</operator></expr></argument>,
						  <argument><expr><name>version</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>usingChecksums</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>blockChecksumPtr</name> <operator>=</operator> <operator>(</operator><name>pg_crc32</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>headerPtr</name><index>[<expr><name>headerLen</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>blockChecksum</name> <operator>=</operator> <operator>*</operator><name>blockChecksumPtr</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>headerLen</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>pg_crc32</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

		<expr_stmt><expr><name>headerChecksumPtr</name> <operator>=</operator> <operator>(</operator><name>pg_crc32</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>headerPtr</name><index>[<expr><name>headerLen</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>headerChecksum</name> <operator>=</operator> <operator>*</operator><name>headerChecksumPtr</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>blockChecksum</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>headerChecksum</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"Append-Only storage Small Content header: "</literal>
					<literal type="string">"smallcontent_bytes_0_3 0x%X, smallcontent_bytes_4_7 0x%X, "</literal>
					<literal type="string">"headerKind = %d, "</literal>
					<literal type="string">"executorBlockKind = %d, "</literal>
					<literal type="string">"rowCount = %d, usingChecksums = %s, header checksum 0x%08X, block checksum 0x%08X, "</literal>
					<literal type="string">"dataLength %d, compressedLength %d, overallBlockLen %d"</literal></expr></argument>,
					<argument><expr><name><name>blockHeader</name><operator>-&gt;</operator><name>smallcontent_bytes_0_3</name></name></expr></argument>,
					<argument><expr><name><name>blockHeader</name><operator>-&gt;</operator><name>smallcontent_bytes_4_7</name></name></expr></argument>,
					<argument><expr><name>aoHeaderKind</name></expr></argument>,
					<argument><expr><name>executorBlockKind</name></expr></argument>,
					<argument><expr><name>rowCount</name></expr></argument>,
					<argument><expr><operator>(</operator><ternary><condition><expr><name>usingChecksums</name></expr> ?</condition><then> <expr><literal type="string">"true"</literal></expr> </then><else>: <expr><literal type="string">"false"</literal></expr></else></ternary><operator>)</operator></expr></argument>,
					<argument><expr><name>headerChecksum</name></expr></argument>,
					<argument><expr><name>blockChecksum</name></expr></argument>,
					<argument><expr><name>dataLength</name></expr></argument>,
					<argument><expr><name>compressedLength</name></expr></argument>,
					<argument><expr><name>overallBlockLen</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>char</name> <modifier>*</modifier></type>
<name>AppendOnlyStorageFormat_LargeContentHeaderStr</name><parameter_list>(
											  <parameter><decl><type><name>uint8</name> <modifier>*</modifier></type><name>headerPtr</name></decl></parameter>,
											  <parameter><decl><type><name>bool</name></type> <name>usingChecksums</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AOLargeContentHeader</name> <modifier>*</modifier></type><name>blockHeader</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AoHeaderKind</name></type> <name>aoHeaderKind</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>int32</name></type>		<name>headerLen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>wholeHeaderLen</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>int</name></type>			<name>executorBlockKind</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>rowCount</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>largeContentLength</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>overallBlockLen</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>pg_crc32</name>   <modifier>*</modifier></type><name>blockChecksumPtr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pg_crc32</name></type>	<name>blockChecksum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pg_crc32</name>   <modifier>*</modifier></type><name>headerChecksumPtr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pg_crc32</name></type>	<name>headerChecksum</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>headerPtr</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>blockHeader</name> <operator>=</operator> <operator>(</operator><name>AOLargeContentHeader</name> <operator>*</operator><operator>)</operator> <name>headerPtr</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>aoHeaderKind</name> <operator>=</operator> <call><name>AOLargeContentHeaderGet_headerKind</name><argument_list>(<argument><expr><name>blockHeader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>headerLen</name> <operator>=</operator> <name>AoHeader_RegularSize</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>executorBlockKind</name> <operator>=</operator> <call><name>AOLargeContentHeaderGet_executorBlockKind</name><argument_list>(<argument><expr><name>blockHeader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>rowCount</name> <operator>=</operator> <call><name>AOLargeContentHeaderGet_largeRowCount</name><argument_list>(<argument><expr><name>blockHeader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>wholeHeaderLen</name> <operator>=</operator> <name>headerLen</name> <operator>+</operator>
		<operator>(</operator><ternary><condition><expr><name>usingChecksums</name></expr> ?</condition><then> <expr><literal type="number">2</literal> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>pg_crc32</name></expr></argument>)</argument_list></sizeof></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>

	<expr_stmt><expr><name>largeContentLength</name> <operator>=</operator> <call><name>AOLargeContentHeaderGet_largeContentLength</name><argument_list>(<argument><expr><name>blockHeader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>overallBlockLen</name> <operator>=</operator> <name>wholeHeaderLen</name></expr>;</expr_stmt>
	<comment type="block">/* No data with this kind of header. */</comment>

	<if_stmt><if>if <condition>(<expr><name>usingChecksums</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>blockChecksumPtr</name> <operator>=</operator> <operator>(</operator><name>pg_crc32</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>headerPtr</name><index>[<expr><name>headerLen</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>blockChecksum</name> <operator>=</operator> <operator>*</operator><name>blockChecksumPtr</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>headerLen</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>pg_crc32</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

		<expr_stmt><expr><name>headerChecksumPtr</name> <operator>=</operator> <operator>(</operator><name>pg_crc32</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>headerPtr</name><index>[<expr><name>headerLen</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>headerChecksum</name> <operator>=</operator> <operator>*</operator><name>headerChecksumPtr</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>blockChecksum</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>headerChecksum</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"Append-Only storage Large Content header: "</literal>
					<literal type="string">"largecontent_bytes_0_3 0x%X, largecontent_bytes_4_7 0x%X, "</literal>
					<literal type="string">"headerKind = %d, "</literal>
					<literal type="string">"executorBlockKind = %d, "</literal>
					<literal type="string">"rowCount = %d, usingChecksums = %s, header checksum 0x%08X, block checksum 0x%08X, "</literal>
					<literal type="string">"largeContentLength %d, overallBlockLen %d"</literal></expr></argument>,
					<argument><expr><name><name>blockHeader</name><operator>-&gt;</operator><name>largecontent_bytes_0_3</name></name></expr></argument>,
					<argument><expr><name><name>blockHeader</name><operator>-&gt;</operator><name>largecontent_bytes_4_7</name></name></expr></argument>,
					<argument><expr><name>aoHeaderKind</name></expr></argument>,
					<argument><expr><name>executorBlockKind</name></expr></argument>,
					<argument><expr><name>rowCount</name></expr></argument>,
					<argument><expr><operator>(</operator><ternary><condition><expr><name>usingChecksums</name></expr> ?</condition><then> <expr><literal type="string">"true"</literal></expr> </then><else>: <expr><literal type="string">"false"</literal></expr></else></ternary><operator>)</operator></expr></argument>,
					<argument><expr><name>headerChecksum</name></expr></argument>,
					<argument><expr><name>blockChecksum</name></expr></argument>,
					<argument><expr><name>largeContentLength</name></expr></argument>,
					<argument><expr><name>overallBlockLen</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>char</name> <modifier>*</modifier></type>
<name>AppendOnlyStorageFormat_NonBulkDenseContentHeaderStr</name><parameter_list>(
													 <parameter><decl><type><name>uint8</name> <modifier>*</modifier></type><name>headerPtr</name></decl></parameter>,
													 <parameter><decl><type><name>bool</name></type> <name>usingChecksums</name></decl></parameter>,
													 <parameter><decl><type><name>int</name></type> <name>version</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AONonBulkDenseContentHeader</name> <modifier>*</modifier></type><name>blockHeader</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AoHeaderKind</name></type> <name>aoHeaderKind</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>int32</name></type>		<name>headerLen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>wholeHeaderLen</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>int</name></type>			<name>executorBlockKind</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>rowCount</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>dataLength</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>overallBlockLen</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>pg_crc32</name>   <modifier>*</modifier></type><name>blockChecksumPtr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pg_crc32</name></type>	<name>blockChecksum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pg_crc32</name>   <modifier>*</modifier></type><name>headerChecksumPtr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pg_crc32</name></type>	<name>headerChecksum</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>headerPtr</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>blockHeader</name> <operator>=</operator> <operator>(</operator><name>AONonBulkDenseContentHeader</name> <operator>*</operator><operator>)</operator> <name>headerPtr</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>aoHeaderKind</name> <operator>=</operator> <call><name>AONonBulkDenseContentHeaderGet_headerKind</name><argument_list>(<argument><expr><name>blockHeader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>headerLen</name> <operator>=</operator> <name>AoHeader_RegularSize</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>executorBlockKind</name> <operator>=</operator> <call><name>AONonBulkDenseContentHeaderGet_executorBlockKind</name><argument_list>(<argument><expr><name>blockHeader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>rowCount</name> <operator>=</operator> <call><name>AONonBulkDenseContentHeaderGet_largeRowCount</name><argument_list>(<argument><expr><name>blockHeader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>wholeHeaderLen</name> <operator>=</operator> <name>headerLen</name> <operator>+</operator>
		<operator>(</operator><ternary><condition><expr><name>usingChecksums</name></expr> ?</condition><then> <expr><literal type="number">2</literal> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>pg_crc32</name></expr></argument>)</argument_list></sizeof></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>

	<expr_stmt><expr><name>dataLength</name> <operator>=</operator> <call><name>AONonBulkDenseContentHeaderGet_dataLength</name><argument_list>(<argument><expr><name>blockHeader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>overallBlockLen</name> <operator>=</operator> <name>wholeHeaderLen</name> <operator>+</operator>
		<call><name>AOStorage_RoundUp</name><argument_list>(
						  <argument><expr><name>dataLength</name></expr></argument>,
						  <argument><expr><name>version</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>usingChecksums</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>blockChecksumPtr</name> <operator>=</operator> <operator>(</operator><name>pg_crc32</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>headerPtr</name><index>[<expr><name>headerLen</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>blockChecksum</name> <operator>=</operator> <operator>*</operator><name>blockChecksumPtr</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>headerLen</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>pg_crc32</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

		<expr_stmt><expr><name>headerChecksumPtr</name> <operator>=</operator> <operator>(</operator><name>pg_crc32</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>headerPtr</name><index>[<expr><name>headerLen</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>headerChecksum</name> <operator>=</operator> <operator>*</operator><name>headerChecksumPtr</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>blockChecksum</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>headerChecksum</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"Append-Only storage Large Content header: "</literal>
					<literal type="string">"nonbulkdensecontent_bytes_0_3 0x%X, nonbulkdensecontent_bytes_4_7 0x%X, "</literal>
					<literal type="string">"headerKind = %d, "</literal>
					<literal type="string">"executorBlockKind = %d, "</literal>
					<literal type="string">"rowCount = %d, usingChecksums = %s, header checksum 0x%08X, block checksum 0x%08X, "</literal>
					<literal type="string">"dataLength %d, overallBlockLen %d"</literal></expr></argument>,
					<argument><expr><name><name>blockHeader</name><operator>-&gt;</operator><name>nonbulkdensecontent_bytes_0_3</name></name></expr></argument>,
					<argument><expr><name><name>blockHeader</name><operator>-&gt;</operator><name>nonbulkdensecontent_bytes_4_7</name></name></expr></argument>,
					<argument><expr><name>aoHeaderKind</name></expr></argument>,
					<argument><expr><name>executorBlockKind</name></expr></argument>,
					<argument><expr><name>rowCount</name></expr></argument>,
					<argument><expr><operator>(</operator><ternary><condition><expr><name>usingChecksums</name></expr> ?</condition><then> <expr><literal type="string">"true"</literal></expr> </then><else>: <expr><literal type="string">"false"</literal></expr></else></ternary><operator>)</operator></expr></argument>,
					<argument><expr><name>headerChecksum</name></expr></argument>,
					<argument><expr><name>blockChecksum</name></expr></argument>,
					<argument><expr><name>dataLength</name></expr></argument>,
					<argument><expr><name>overallBlockLen</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>char</name> <modifier>*</modifier></type>
<name>AppendOnlyStorageFormat_BulkDenseContentHeaderStr</name><parameter_list>(
												  <parameter><decl><type><name>uint8</name> <modifier>*</modifier></type><name>headerPtr</name></decl></parameter>,
												  <parameter><decl><type><name>bool</name></type> <name>usingChecksums</name></decl></parameter>,
												  <parameter><decl><type><name>int</name></type> <name>version</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AOBulkDenseContentHeader</name> <modifier>*</modifier></type><name>blockHeader</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AoHeaderKind</name></type> <name>aoHeaderKind</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>AOBulkDenseContentHeaderExt</name> <modifier>*</modifier></type><name>extHeader</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>firstHeaderLen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>firstHeaderAndChecksumsLen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>extHeaderLen</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>int</name></type>			<name>executorBlockKind</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>rowCount</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>dataLength</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>compressedLength</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>overallBlockLen</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>pg_crc32</name>   <modifier>*</modifier></type><name>blockChecksumPtr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pg_crc32</name></type>	<name>blockChecksum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pg_crc32</name>   <modifier>*</modifier></type><name>headerChecksumPtr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pg_crc32</name></type>	<name>headerChecksum</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>headerPtr</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>blockHeader</name> <operator>=</operator> <operator>(</operator><name>AOBulkDenseContentHeader</name> <operator>*</operator><operator>)</operator> <name>headerPtr</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>aoHeaderKind</name> <operator>=</operator> <call><name>AOBulkDenseContentHeaderGet_headerKind</name><argument_list>(<argument><expr><name>blockHeader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * The first header and extension header are both is 64-bits.
	 */</comment>
	<expr_stmt><expr><name>firstHeaderLen</name> <operator>=</operator> <name>AoHeader_RegularSize</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>extHeaderLen</name> <operator>=</operator> <name>AoHeader_RegularSize</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>executorBlockKind</name> <operator>=</operator> <call><name>AOBulkDenseContentHeaderGet_executorBlockKind</name><argument_list>(<argument><expr><name>blockHeader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>firstHeaderAndChecksumsLen</name> <operator>=</operator>
		<name>firstHeaderLen</name> <operator>+</operator>
		<operator>(</operator><ternary><condition><expr><name>usingChecksums</name></expr> ?</condition><then> <expr><literal type="number">2</literal> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>pg_crc32</name></expr></argument>)</argument_list></sizeof></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>

	<comment type="block">/*
	 * The extension header is in the data portion with first row number.
	 */</comment>
	<expr_stmt><expr><name>extHeader</name> <operator>=</operator> <operator>(</operator><name>AOBulkDenseContentHeaderExt</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name>headerPtr</name> <operator>+</operator> <name>firstHeaderAndChecksumsLen</name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>rowCount</name> <operator>=</operator> <call><name>AOBulkDenseContentHeaderExtGet_largeRowCount</name><argument_list>(<argument><expr><name>extHeader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>dataLength</name> <operator>=</operator> <call><name>AOBulkDenseContentHeaderGet_dataLength</name><argument_list>(<argument><expr><name>blockHeader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>compressedLength</name> <operator>=</operator> <call><name>AOBulkDenseContentHeaderGet_compressedLength</name><argument_list>(<argument><expr><name>blockHeader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>overallBlockLen</name> <operator>=</operator> <name>firstHeaderAndChecksumsLen</name> <operator>+</operator>
		<name>extHeaderLen</name> <operator>+</operator>
		<operator>(</operator><ternary><condition><expr><call><name>AOBulkDenseContentHeaderGet_hasFirstRowNum</name><argument_list>(<argument><expr><name>blockHeader</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><sizeof>sizeof<argument_list>(<argument><expr><name>int64</name></expr></argument>)</argument_list></sizeof></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator> <operator>+</operator>
		<call><name>AOStorage_RoundUp</name><argument_list>(
						  <argument><expr><operator>(</operator><ternary><condition><expr><name>compressedLength</name> <operator>==</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name>dataLength</name></expr> </then><else>: <expr><name>compressedLength</name></expr></else></ternary><operator>)</operator></expr></argument>,
						  <argument><expr><name>version</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>usingChecksums</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>blockChecksumPtr</name> <operator>=</operator> <operator>(</operator><name>pg_crc32</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>headerPtr</name><index>[<expr><name>firstHeaderLen</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>blockChecksum</name> <operator>=</operator> <operator>*</operator><name>blockChecksumPtr</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>headerChecksumPtr</name> <operator>=</operator> <operator>(</operator><name>pg_crc32</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>headerPtr</name><index>[<expr><name>firstHeaderLen</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>pg_crc32</name></expr></argument>)</argument_list></sizeof></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>headerChecksum</name> <operator>=</operator> <operator>*</operator><name>headerChecksumPtr</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>blockChecksum</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>headerChecksum</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"Append-Only storage Bulk Dense Content header: "</literal>
					<literal type="string">"bulkdensecontent_bytes_0_3 0x%X, bulkdensecontent_bytes_4_7 0x%X, "</literal>
					<literal type="string">"bulkdensecontent_ext_bytes_0_3 0x%X, bulkdensecontent_ext_bytes_4_7 0x%X, "</literal>
					<literal type="string">"headerKind = %d, "</literal>
					<literal type="string">"executorBlockKind = %d, "</literal>
					<literal type="string">"rowCount = %d, usingChecksums = %s, header checksum 0x%08X, block checksum 0x%08X, "</literal>
					<literal type="string">"dataLength %d, compressedLength %d, overallBlockLen %d"</literal></expr></argument>,
					<argument><expr><name><name>blockHeader</name><operator>-&gt;</operator><name>bulkdensecontent_bytes_0_3</name></name></expr></argument>,
					<argument><expr><name><name>blockHeader</name><operator>-&gt;</operator><name>bulkdensecontent_bytes_4_7</name></name></expr></argument>,
					<argument><expr><name><name>extHeader</name><operator>-&gt;</operator><name>bulkdensecontent_ext_bytes_0_3</name></name></expr></argument>,
					<argument><expr><name><name>extHeader</name><operator>-&gt;</operator><name>bulkdensecontent_ext_bytes_4_7</name></name></expr></argument>,
					<argument><expr><name>aoHeaderKind</name></expr></argument>,
					<argument><expr><name>executorBlockKind</name></expr></argument>,
					<argument><expr><name>rowCount</name></expr></argument>,
					<argument><expr><operator>(</operator><ternary><condition><expr><name>usingChecksums</name></expr> ?</condition><then> <expr><literal type="string">"true"</literal></expr> </then><else>: <expr><literal type="string">"false"</literal></expr></else></ternary><operator>)</operator></expr></argument>,
					<argument><expr><name>headerChecksum</name></expr></argument>,
					<argument><expr><name>blockChecksum</name></expr></argument>,
					<argument><expr><name>dataLength</name></expr></argument>,
					<argument><expr><name>compressedLength</name></expr></argument>,
					<argument><expr><name>overallBlockLen</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>char</name> <modifier>*</modifier></type>
<name>AppendOnlyStorageFormat_BlockHeaderStr</name><parameter_list>(
									   <parameter><decl><type><name>uint8</name> <modifier>*</modifier></type><name>headerPtr</name></decl></parameter>,
									   <parameter><decl><type><name>bool</name></type> <name>usingChecksums</name></decl></parameter>,
									   <parameter><decl><type><name>int</name></type> <name>version</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AOSmallContentHeader</name> <modifier>*</modifier></type><name>blockHeader</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>AoHeaderKind</name></type> <name>aoHeaderKind</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>str</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>blockHeader</name> <operator>=</operator> <operator>(</operator><name>AOSmallContentHeader</name> <operator>*</operator><operator>)</operator> <name>headerPtr</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>aoHeaderKind</name> <operator>=</operator> <call><name>AOSmallContentHeaderGet_headerKind</name><argument_list>(<argument><expr><name>blockHeader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<switch>switch <condition>(<expr><name>aoHeaderKind</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>AoHeaderKind_SmallContent</name></expr>:</case>
			<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>AppendOnlyStorageFormat_SmallContentHeaderStr</name><argument_list>(
																<argument><expr><name>headerPtr</name></expr></argument>,
																<argument><expr><name>usingChecksums</name></expr></argument>,
																<argument><expr><name>version</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>AoHeaderKind_LargeContent</name></expr>:</case>
			<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>AppendOnlyStorageFormat_LargeContentHeaderStr</name><argument_list>(
																<argument><expr><name>headerPtr</name></expr></argument>,
																<argument><expr><name>usingChecksums</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>AoHeaderKind_NonBulkDenseContent</name></expr>:</case>
			<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>AppendOnlyStorageFormat_NonBulkDenseContentHeaderStr</name><argument_list>(
																	   <argument><expr><name>headerPtr</name></expr></argument>,
																	   <argument><expr><name>usingChecksums</name></expr></argument>,
																	   <argument><expr><name>version</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>AoHeaderKind_BulkDenseContent</name></expr>:</case>
			<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>AppendOnlyStorageFormat_BulkDenseContentHeaderStr</name><argument_list>(
																	<argument><expr><name>headerPtr</name></expr></argument>,
																	<argument><expr><name>usingChecksums</name></expr></argument>,
																	<argument><expr><name>version</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<default>default:</default>
			<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"Append-Only storage header kind %d unknown"</literal></expr></argument>,
						   <argument><expr><name>aoHeaderKind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<return>return <expr><name>str</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * errdetail_appendonly_storage_smallcontent_header
 *
 * Add an errdetail() line showing the Append-Only Storage block header.
 */</comment>
<function><type><name>void</name></type>
<name>errdetail_appendonly_storage_smallcontent_header</name><parameter_list>(
												 <parameter><decl><type><name>uint8</name> <modifier>*</modifier></type><name>headerPtr</name></decl></parameter>,
												 <parameter><decl><type><name>bool</name></type> <name>usingChecksums</name></decl></parameter>,
												 <parameter><decl><type><name>int</name></type> <name>version</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>str</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>AppendOnlyStorageFormat_SmallContentHeaderStr</name><argument_list>(
														<argument><expr><name>headerPtr</name></expr></argument>,
														<argument><expr><name>usingChecksums</name></expr></argument>,
														<argument><expr><name>version</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * errdetail_appendonly_storage_largecontent_header
 *
 * Add an errdetail() line showing the Append-Only Storage block header.
 */</comment>
<function><type><name>void</name></type>
<name>errdetail_appendonly_storage_largecontent_header</name><parameter_list>(
												 <parameter><decl><type><name>uint8</name> <modifier>*</modifier></type><name>headerPtr</name></decl></parameter>,
												 <parameter><decl><type><name>bool</name></type> <name>usingChecksums</name></decl></parameter>,
												 <parameter><decl><type><name>int</name></type> <name>version</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>str</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>AppendOnlyStorageFormat_LargeContentHeaderStr</name><argument_list>(
														<argument><expr><name>headerPtr</name></expr></argument>,
														<argument><expr><name>usingChecksums</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * errdetail_appendonly_storage_nonbulkdensecontent_header
 *
 * Add an errdetail() line showing the Append-Only Storage block header.
 */</comment>
<function><type><name>void</name></type>
<name>errdetail_appendonly_storage_nonbulkdensecontent_header</name><parameter_list>(
														<parameter><decl><type><name>uint8</name> <modifier>*</modifier></type><name>headerPtr</name></decl></parameter>,
														<parameter><decl><type><name>bool</name></type> <name>usingChecksums</name></decl></parameter>,
														<parameter><decl><type><name>int</name></type> <name>version</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>str</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>AppendOnlyStorageFormat_NonBulkDenseContentHeaderStr</name><argument_list>(
															   <argument><expr><name>headerPtr</name></expr></argument>,
															   <argument><expr><name>usingChecksums</name></expr></argument>,
															   <argument><expr><name>version</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * errdetail_appendonly_storage_bulkdensecontent_header
 *
 * Add an errdetail() line showing the Append-Only Storage block header.
 */</comment>
<function><type><name>void</name></type>
<name>errdetail_appendonly_storage_bulkdensecontent_header</name><parameter_list>(
													 <parameter><decl><type><name>uint8</name> <modifier>*</modifier></type><name>headerPtr</name></decl></parameter>,
													 <parameter><decl><type><name>bool</name></type> <name>usingChecksums</name></decl></parameter>,
													 <parameter><decl><type><name>int</name></type> <name>version</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>str</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>AppendOnlyStorageFormat_BulkDenseContentHeaderStr</name><argument_list>(
															<argument><expr><name>headerPtr</name></expr></argument>,
															<argument><expr><name>usingChecksums</name></expr></argument>,
															<argument><expr><name>version</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * errdetail_appendonly_storage_content_header
 *
 * Add an errdetail() line showing the Append-Only Storage content (Small, Large, Dense) header.
 */</comment>
<function><type><name>void</name></type>
<name>errdetail_appendonly_storage_content_header</name><parameter_list>(
											<parameter><decl><type><name>uint8</name> <modifier>*</modifier></type><name>header</name></decl></parameter>,
											<parameter><decl><type><name>bool</name></type> <name>usingChecksum</name></decl></parameter>,
											<parameter><decl><type><name>int</name></type> <name>version</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AOSmallContentHeader</name> <modifier>*</modifier></type><name>blockHeader</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>AoHeaderKind</name></type> <name>aoHeaderKind</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>blockHeader</name> <operator>=</operator> <operator>(</operator><name>AOSmallContentHeader</name> <operator>*</operator><operator>)</operator> <name>header</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>aoHeaderKind</name> <operator>=</operator> <call><name>AOSmallContentHeaderGet_headerKind</name><argument_list>(<argument><expr><name>blockHeader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<switch>switch <condition>(<expr><name>aoHeaderKind</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>AoHeaderKind_SmallContent</name></expr>:</case>
			<expr_stmt><expr><call><name>errdetail_appendonly_storage_smallcontent_header</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr><name>usingChecksum</name></expr></argument>, <argument><expr><name>version</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>AoHeaderKind_LargeContent</name></expr>:</case>
			<expr_stmt><expr><call><name>errdetail_appendonly_storage_largecontent_header</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr><name>usingChecksum</name></expr></argument>, <argument><expr><name>version</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>AoHeaderKind_NonBulkDenseContent</name></expr>:</case>
			<expr_stmt><expr><call><name>errdetail_appendonly_storage_nonbulkdensecontent_header</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr><name>usingChecksum</name></expr></argument>, <argument><expr><name>version</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>AoHeaderKind_BulkDenseContent</name></expr>:</case>
			<expr_stmt><expr><call><name>errdetail_appendonly_storage_bulkdensecontent_header</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr><name>usingChecksum</name></expr></argument>, <argument><expr><name>version</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<default>default:</default>
			<expr_stmt><expr><call><name>errdetail</name><argument_list>(
				<argument><expr><literal type="string">"Append-Only storage header kind %d unknown"</literal></expr></argument>,
				<argument><expr><name>aoHeaderKind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>
</block_content>}</block></function>


<function><type><name>void</name></type>
<name>AppendOnlyStorageFormat_MakeLargeContentHeader</name><parameter_list>(
											   <parameter><decl><type><name>uint8</name> <modifier>*</modifier></type><name>headerPtr</name></decl></parameter>,
											   <parameter><decl><type><name>bool</name></type> <name>usingChecksums</name></decl></parameter>,
											   <parameter><decl><type><name>bool</name></type> <name>hasFirstRowNum</name></decl></parameter>,
											   <parameter><decl><type><name>int</name></type> <name>version</name></decl></parameter>,
											   <parameter><decl><type><name>int64</name></type> <name>firstRowNum</name></decl></parameter>,
											   <parameter><decl><type><name>int</name></type> <name>executorKind</name></decl></parameter>,
											   <parameter><decl><type><name>int</name></type> <name>largeRowCount</name></decl></parameter>,
											   <parameter><decl><type><name>int32</name></type> <name>largeContentLength</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AOLargeContentHeader</name> <modifier>*</modifier></type><name>largeContentHeader</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>headerPtr</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>largeContentHeader</name> <operator>=</operator> <operator>(</operator><name>AOLargeContentHeader</name> <operator>*</operator><operator>)</operator> <name>headerPtr</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>elogif</name><argument_list>(<argument><expr><name>Debug_appendonly_print_storage_headers</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>,
		   <argument><expr><literal type="string">"Append-Only Storage make LargeContent header parameters: usingChecksums = %s, executorKind = %d, "</literal>
		   <literal type="string">"largeRowCount = %d, largeContentLength %d"</literal></expr></argument>,
		   <argument><expr><operator>(</operator><ternary><condition><expr><name>usingChecksums</name></expr> ?</condition><then> <expr><literal type="string">"true"</literal></expr> </then><else>: <expr><literal type="string">"false"</literal></expr></else></ternary><operator>)</operator></expr></argument>,
		   <argument><expr><name>executorKind</name></expr></argument>,
		   <argument><expr><name>largeRowCount</name></expr></argument>,
		   <argument><expr><name>largeContentLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Zero out whole header */</comment>
	<expr_stmt><expr><call><name>AOLargeContentHeaderInit_Init</name><argument_list>(<argument><expr><name>largeContentHeader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>AOLargeContentHeaderInit_headerKind</name><argument_list>(<argument><expr><name>largeContentHeader</name></expr></argument>, <argument><expr><name>AoHeaderKind_LargeContent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AOLargeContentHeaderInit_executorBlockKind</name><argument_list>(<argument><expr><name>largeContentHeader</name></expr></argument>, <argument><expr><name>executorKind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AOLargeContentHeaderInit_largeRowCount</name><argument_list>(<argument><expr><name>largeContentHeader</name></expr></argument>, <argument><expr><name>largeRowCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AOLargeContentHeaderInit_largeContentLength</name><argument_list>(<argument><expr><name>largeContentHeader</name></expr></argument>, <argument><expr><name>largeContentLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AOLargeContentHeaderInit_hasFirstRowNum</name><argument_list>(<argument><expr><name>largeContentHeader</name></expr></argument>, <argument><expr><name>hasFirstRowNum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Add the optional firstRowNum.
	 *
	 * NOTE: This is not part of the 8-byte (64-bit) header because it is so
	 * big. NOTE: And, it is not covered by the header checksum because in
	 * order to NOTE: determine if we should checksum more data we would need
	 * to examine NOTE: the header data not verified by checksum yet...
	 *
	 * So, the firstRowNum is extra data between the header (and checksums)
	 * and the content.  We must add it before computing the checksum.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>hasFirstRowNum</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>AppendOnlyStorageFormat_AddFirstRowNum</name><argument_list>(
											   <argument><expr><name>headerPtr</name></expr></argument>,
											   <argument><expr><name>usingChecksums</name></expr></argument>,
											   <argument><expr><name>firstRowNum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>usingChecksums</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* UNDONE: Set 2nd checksum to 0 when there is no content??? */</comment>
		<expr_stmt><expr><call><name>AppendOnlyStorageFormat_AddBlockHeaderChecksums</name><argument_list>(
														<argument><expr><name>headerPtr</name></expr></argument>,
														 <comment type="block">/* isCompressed */</comment> <argument><expr><name>false</name></expr></argument>,
														 <comment type="block">/* hasFirstRowNum */</comment> <argument><expr><name>false</name></expr></argument>,
														<argument><expr><name>version</name></expr></argument>,
														 <comment type="block">/* dataLength */</comment> <argument><expr><literal type="number">0</literal></expr></argument>,
														 <comment type="block">/* compressedLength */</comment> <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>elogif</name><argument_list>(<argument><expr><name>Debug_appendonly_print_storage_headers</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>,
			   <argument><expr><literal type="string">"Append-Only storage make block header result: block_bytes_0_3 0x%X, block_bytes_4_7 0x%X"</literal></expr></argument>,
			   <argument><expr><name><name>largeContentHeader</name><operator>-&gt;</operator><name>largecontent_bytes_0_3</name></name></expr></argument>,
			   <argument><expr><name><name>largeContentHeader</name><operator>-&gt;</operator><name>largecontent_bytes_4_7</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>AppendOnlyStorageFormat_MakeNonBulkDenseContentHeader</name><parameter_list>(
													  <parameter><decl><type><name>uint8</name> <modifier>*</modifier></type><name>headerPtr</name></decl></parameter>,
													  <parameter><decl><type><name>bool</name></type> <name>usingChecksums</name></decl></parameter>,
													  <parameter><decl><type><name>bool</name></type> <name>hasFirstRowNum</name></decl></parameter>,
													  <parameter><decl><type><name>int</name></type> <name>version</name></decl></parameter>,
													  <parameter><decl><type><name>int64</name></type> <name>firstRowNum</name></decl></parameter>,
													  <parameter><decl><type><name>int</name></type> <name>executorKind</name></decl></parameter>,
													  <parameter><decl><type><name>int</name></type> <name>rowCount</name></decl></parameter>,
													  <parameter><decl><type><name>int32</name></type> <name>dataLength</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AONonBulkDenseContentHeader</name> <modifier>*</modifier></type><name>blockHeader</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>headerPtr</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>blockHeader</name> <operator>=</operator> <operator>(</operator><name>AONonBulkDenseContentHeader</name> <operator>*</operator><operator>)</operator> <name>headerPtr</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>elogif</name><argument_list>(<argument><expr><name>Debug_appendonly_print_storage_headers</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>,
		   <argument><expr><literal type="string">"Append-Only storage make Non-Bulk Dense Content header parameters: wantChecksum = %s, hasFirstRowNum %s, executorKind = %d, "</literal>
		   <literal type="string">"rowCount = %d, dataLength %d"</literal></expr></argument>,
		   <argument><expr><operator>(</operator><ternary><condition><expr><name>usingChecksums</name></expr> ?</condition><then> <expr><literal type="string">"true"</literal></expr> </then><else>: <expr><literal type="string">"false"</literal></expr></else></ternary><operator>)</operator></expr></argument>,
		   <argument><expr><operator>(</operator><ternary><condition><expr><name>hasFirstRowNum</name></expr> ?</condition><then> <expr><literal type="string">"true"</literal></expr> </then><else>: <expr><literal type="string">"false"</literal></expr></else></ternary><operator>)</operator></expr></argument>,
		   <argument><expr><name>executorKind</name></expr></argument>,
		   <argument><expr><name>rowCount</name></expr></argument>,
		   <argument><expr><name>dataLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Zero out whole header */</comment>
	<expr_stmt><expr><call><name>AONonBulkDenseContentHeaderInit_Init</name><argument_list>(<argument><expr><name>blockHeader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>AONonBulkDenseContentHeaderInit_headerKind</name><argument_list>(<argument><expr><name>blockHeader</name></expr></argument>, <argument><expr><name>AoHeaderKind_NonBulkDenseContent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AONonBulkDenseContentHeaderInit_executorBlockKind</name><argument_list>(<argument><expr><name>blockHeader</name></expr></argument>, <argument><expr><name>executorKind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AONonBulkDenseContentHeaderInit_largeRowCount</name><argument_list>(<argument><expr><name>blockHeader</name></expr></argument>, <argument><expr><name>rowCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AONonBulkDenseContentHeaderInit_dataLength</name><argument_list>(<argument><expr><name>blockHeader</name></expr></argument>, <argument><expr><name>dataLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AONonBulkDenseContentHeaderInit_hasFirstRowNum</name><argument_list>(<argument><expr><name>blockHeader</name></expr></argument>, <argument><expr><name>hasFirstRowNum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Add the optional firstRowNum.
	 *
	 * NOTE: This is not part of the 8-byte (64-bit) header because it is so
	 * big. And, it is not covered by the header checksum because in order to
	 * determine if we should checksum more data we would need to examine the
	 * header data not verified by checksum yet.
	 *
	 * So, the firstRowNum is extra data between the header (and checksums)
	 * and the content.  We must add it before computing the checksum.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>hasFirstRowNum</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>AppendOnlyStorageFormat_AddFirstRowNum</name><argument_list>(
											   <argument><expr><name>headerPtr</name></expr></argument>,
											   <argument><expr><name>usingChecksums</name></expr></argument>,
											   <argument><expr><name>firstRowNum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>usingChecksums</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>AppendOnlyStorageFormat_AddBlockHeaderChecksums</name><argument_list>(
														<argument><expr><name>headerPtr</name></expr></argument>,
														 <comment type="block">/* isCompressed */</comment> <argument><expr><name>false</name></expr></argument>,
														<argument><expr><name>hasFirstRowNum</name></expr></argument>,
														<argument><expr><name>version</name></expr></argument>,
														<argument><expr><name>dataLength</name></expr></argument>,
														 <comment type="block">/* compressedLength */</comment> <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>elogif</name><argument_list>(<argument><expr><name>Debug_appendonly_print_storage_headers</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>,
			   <argument><expr><literal type="string">"Append-Only storage make Bulk Dense Content header result: nonbulkdensecontent_bytes_0_3 0x%X, nonbulkdensecontent_bytes_4_7 0x%X"</literal></expr></argument>,
			   <argument><expr><name><name>blockHeader</name><operator>-&gt;</operator><name>nonbulkdensecontent_bytes_0_3</name></name></expr></argument>,
			   <argument><expr><name><name>blockHeader</name><operator>-&gt;</operator><name>nonbulkdensecontent_bytes_4_7</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

</block_content>}</block></function>


<function><type><name>void</name></type>
<name>AppendOnlyStorageFormat_MakeBulkDenseContentHeader</name><parameter_list>(
												   <parameter><decl><type><name>uint8</name> <modifier>*</modifier></type><name>headerPtr</name></decl></parameter>,
												   <parameter><decl><type><name>bool</name></type> <name>usingChecksums</name></decl></parameter>,
												   <parameter><decl><type><name>bool</name></type> <name>hasFirstRowNum</name></decl></parameter>,
												   <parameter><decl><type><name>int</name></type> <name>version</name></decl></parameter>,
												   <parameter><decl><type><name>int64</name></type> <name>firstRowNum</name></decl></parameter>,
												   <parameter><decl><type><name>int</name></type> <name>executorKind</name></decl></parameter>,
												   <parameter><decl><type><name>int</name></type> <name>rowCount</name></decl></parameter>,
												   <parameter><decl><type><name>int32</name></type> <name>dataLength</name></decl></parameter>,
												   <parameter><decl><type><name>int32</name></type> <name>compressedLength</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AOBulkDenseContentHeader</name> <modifier>*</modifier></type><name>blockHeader</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>firstHeaderAndChecksumsLen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AOBulkDenseContentHeaderExt</name> <modifier>*</modifier></type><name>extHeader</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>bool</name></type>		<name>isCompressed</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>headerPtr</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>blockHeader</name> <operator>=</operator> <operator>(</operator><name>AOBulkDenseContentHeader</name> <operator>*</operator><operator>)</operator> <name>headerPtr</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>firstHeaderAndChecksumsLen</name> <operator>=</operator>
		<name>AoHeader_RegularSize</name> <operator>+</operator>
		<operator>(</operator><ternary><condition><expr><name>usingChecksums</name></expr> ?</condition><then> <expr><literal type="number">2</literal> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>pg_crc32</name></expr></argument>)</argument_list></sizeof></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>

	<comment type="block">/*
	 * The extension header is in the data portion with first row number.
	 */</comment>
	<expr_stmt><expr><name>extHeader</name> <operator>=</operator> <operator>(</operator><name>AOBulkDenseContentHeaderExt</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name>headerPtr</name> <operator>+</operator> <name>firstHeaderAndChecksumsLen</name><operator>)</operator></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>elogif</name><argument_list>(<argument><expr><name>Debug_appendonly_print_storage_headers</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>,
		   <argument><expr><literal type="string">"Append-Only storage make Bulk Dense Content header parameters: wantChecksum = %s, hasFirstRowNum %s, executorKind = %d, "</literal>
		   <literal type="string">"rowCount = %d, dataLength %d, compressedLength %d"</literal></expr></argument>,
		   <argument><expr><operator>(</operator><ternary><condition><expr><name>usingChecksums</name></expr> ?</condition><then> <expr><literal type="string">"true"</literal></expr> </then><else>: <expr><literal type="string">"false"</literal></expr></else></ternary><operator>)</operator></expr></argument>,
		   <argument><expr><operator>(</operator><ternary><condition><expr><name>hasFirstRowNum</name></expr> ?</condition><then> <expr><literal type="string">"true"</literal></expr> </then><else>: <expr><literal type="string">"false"</literal></expr></else></ternary><operator>)</operator></expr></argument>,
		   <argument><expr><name>executorKind</name></expr></argument>,
		   <argument><expr><name>rowCount</name></expr></argument>,
		   <argument><expr><name>dataLength</name></expr></argument>,
		   <argument><expr><name>compressedLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Zero out whole header */</comment>
	<expr_stmt><expr><call><name>AOBulkDenseContentHeaderInit_Init</name><argument_list>(<argument><expr><name>blockHeader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>AOBulkDenseContentHeaderInit_headerKind</name><argument_list>(<argument><expr><name>blockHeader</name></expr></argument>, <argument><expr><name>AoHeaderKind_BulkDenseContent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AOBulkDenseContentHeaderInit_executorBlockKind</name><argument_list>(<argument><expr><name>blockHeader</name></expr></argument>, <argument><expr><name>executorKind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AOBulkDenseContentHeaderInit_dataLength</name><argument_list>(<argument><expr><name>blockHeader</name></expr></argument>, <argument><expr><name>dataLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AOBulkDenseContentHeaderInit_hasFirstRowNum</name><argument_list>(<argument><expr><name>blockHeader</name></expr></argument>, <argument><expr><name>hasFirstRowNum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>isCompressed</name> <operator>=</operator> <operator>(</operator><name>compressedLength</name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>isCompressed</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>AOBulkDenseContentHeaderInit_compressedLength</name><argument_list>(<argument><expr><name>blockHeader</name></expr></argument>, <argument><expr><name>compressedLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Zero out whole extension */</comment>
	<expr_stmt><expr><call><name>AOBulkDenseContentHeaderExtInit_Init</name><argument_list>(<argument><expr><name>extHeader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AOBulkDenseContentHeaderExtInit_largeRowCount</name><argument_list>(<argument><expr><name>extHeader</name></expr></argument>, <argument><expr><name>rowCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Add the optional firstRowNum.
	 *
	 * NOTE: This is not part of the 8-byte (64-bit) header because it is so
	 * big. And, it is not covered by the header checksum because in order to
	 * determine if we should checksum more data we would need to examine the
	 * header data not verified by checksum yet.
	 *
	 * So, the firstRowNum is extra data between the header (and checksums)
	 * and the content.  We must add it before computing the checksum.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>hasFirstRowNum</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>AppendOnlyStorageFormat_AddFirstRowNum</name><argument_list>(
											   <argument><expr><name>headerPtr</name></expr></argument>,
											   <argument><expr><name>usingChecksums</name></expr></argument>,
											   <argument><expr><name>firstRowNum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>usingChecksums</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>AppendOnlyStorageFormat_AddBlockHeaderChecksums</name><argument_list>(
														<argument><expr><name>headerPtr</name></expr></argument>,
														<argument><expr><name>isCompressed</name></expr></argument>,
														<argument><expr><name>hasFirstRowNum</name></expr></argument>,
														<argument><expr><name>version</name></expr></argument>,
														<argument><expr><name>dataLength</name></expr></argument>,
														<argument><expr><name>compressedLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>elogif</name><argument_list>(<argument><expr><name>Debug_appendonly_print_storage_headers</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>,
			   <argument><expr><literal type="string">"Append-Only storage make Bulk Dense Content header result: "</literal>
			   <literal type="string">"bulkdensecontent_bytes_0_3 0x%X, bulkdensecontent_bytes_4_7 0x%X "</literal>
			   <literal type="string">"bulkdensecontent_ext_bytes_0_3 0x%X, bulkdensecontent_ext_bytes_4_7 0x%X "</literal></expr></argument>,
			   <argument><expr><name><name>blockHeader</name><operator>-&gt;</operator><name>bulkdensecontent_bytes_0_3</name></name></expr></argument>,
			   <argument><expr><name><name>blockHeader</name><operator>-&gt;</operator><name>bulkdensecontent_bytes_4_7</name></name></expr></argument>,
			   <argument><expr><name><name>extHeader</name><operator>-&gt;</operator><name>bulkdensecontent_ext_bytes_0_3</name></name></expr></argument>,
			   <argument><expr><name><name>extHeader</name><operator>-&gt;</operator><name>bulkdensecontent_ext_bytes_4_7</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ASSERT_CHECKING</name></cpp:ifdef>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>checkHeaderLen</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int32</name></type>		<name>checkLength</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int32</name></type>		<name>checkBlockLimitLen</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int32</name></type>		<name>checkOverallBlockLen</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int32</name></type>		<name>checkOffset</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int32</name></type>		<name>checkUncompressedLen</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>checkExecutorBlockKind</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>checkHasFirstRowNum</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int64</name></type>		<name>checkFirstRowNum</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>checkRowCount</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>checkIsCompressed</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int32</name></type>		<name>checkCompressedLen</name></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>AOHeaderCheckError</name></type> <name>checkError</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>checkHeaderLen</name> <operator>=</operator> <name>firstHeaderAndChecksumsLen</name> <operator>+</operator>
			<name>AoHeader_RegularSize</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>hasFirstRowNum</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>checkHeaderLen</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int64</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>compressedLength</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>checkLength</name> <operator>=</operator> <name>dataLength</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>checkLength</name> <operator>=</operator> <name>compressedLength</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><name>checkBlockLimitLen</name> <operator>=</operator> <name>checkHeaderLen</name> <operator>+</operator>
			<call><name>AOStorage_RoundUp</name><argument_list>(<argument><expr><name>checkLength</name></expr></argument>, <argument><expr><name>version</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>checkError</name> <operator>=</operator>
			<call><name>AppendOnlyStorageFormat_GetBulkDenseContentHeaderInfo</name><argument_list>(
																  <argument><expr><name>headerPtr</name></expr></argument>,
																  <argument><expr><name>checkHeaderLen</name></expr></argument>,
																  <argument><expr><name>usingChecksums</name></expr></argument>,
																  <argument><expr><name>checkBlockLimitLen</name></expr></argument>,
																  <argument><expr><operator>&amp;</operator><name>checkOverallBlockLen</name></expr></argument>,
																  <argument><expr><operator>&amp;</operator><name>checkOffset</name></expr></argument>,
																  <argument><expr><operator>&amp;</operator><name>checkUncompressedLen</name></expr></argument>,
																  <argument><expr><operator>&amp;</operator><name>checkExecutorBlockKind</name></expr></argument>,
																  <argument><expr><operator>&amp;</operator><name>checkHasFirstRowNum</name></expr></argument>,
																  <argument><expr><name>version</name></expr></argument>,
																  <argument><expr><operator>&amp;</operator><name>checkFirstRowNum</name></expr></argument>,
																  <argument><expr><operator>&amp;</operator><name>checkRowCount</name></expr></argument>,
																  <argument><expr><operator>&amp;</operator><name>checkIsCompressed</name></expr></argument>,
																  <argument><expr><operator>&amp;</operator><name>checkCompressedLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>checkError</name> <operator>!=</operator> <name>AOHeaderCheckOk</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"problem making append-only storage header of type bulk dense content"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Header check error %d, detail: '%s'"</literal></expr></argument>,
							   <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>checkError</name></expr></argument>,
							   <argument><expr><call><name>AppendOnlyStorageFormat_GetHeaderCheckErrorStr</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>checkOverallBlockLen</name> <operator>!=</operator> <name>checkBlockLimitLen</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"problem making append-only storage header of type bulk dense content"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Found block length %d, expected %d"</literal></expr></argument>,
							   <argument><expr><name>checkOverallBlockLen</name></expr></argument>, <argument><expr><name>checkBlockLimitLen</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>checkOffset</name> <operator>!=</operator> <name>checkHeaderLen</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"problem making append-only storage header of type bulk dense content"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Found data offset %d, expected %d"</literal></expr></argument>,
							   <argument><expr><name>checkOffset</name></expr></argument>, <argument><expr><name>checkHeaderLen</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>checkUncompressedLen</name> <operator>!=</operator> <name>dataLength</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"problem making append-only storage header of type bulk dense content"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Found uncompressed length %d, expected %d"</literal></expr></argument>,
							   <argument><expr><name>checkUncompressedLen</name></expr></argument>, <argument><expr><name>dataLength</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>checkExecutorBlockKind</name> <operator>!=</operator> <name>executorKind</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"problem making append-only storage header of type bulk dense content"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Found executor kind %d, expected %d"</literal></expr></argument>,
							   <argument><expr><name>checkExecutorBlockKind</name></expr></argument>, <argument><expr><name>executorKind</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>checkHasFirstRowNum</name> <operator>!=</operator> <name>hasFirstRowNum</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"problem making append-only storage header of type bulk dense content"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Found has first row number flag %s, expected %s"</literal></expr></argument>,
							   <argument><expr><operator>(</operator><ternary><condition><expr><name>checkHasFirstRowNum</name></expr> ?</condition><then> <expr><literal type="string">"true"</literal></expr> </then><else>: <expr><literal type="string">"false"</literal></expr></else></ternary><operator>)</operator></expr></argument>,
							   <argument><expr><operator>(</operator><ternary><condition><expr><name>hasFirstRowNum</name></expr> ?</condition><then> <expr><literal type="string">"true"</literal></expr> </then><else>: <expr><literal type="string">"false"</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>hasFirstRowNum</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>checkFirstRowNum</name> <operator>!=</operator> <name>firstRowNum</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"problem making append-only storage header of type bulk dense content"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Found first row number "</literal> <name>INT64_FORMAT</name> <literal type="string">", expected "</literal> <name>INT64_FORMAT</name></expr></argument>,
								   <argument><expr><name>checkFirstRowNum</name></expr></argument>, <argument><expr><name>firstRowNum</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>checkRowCount</name> <operator>!=</operator> <name>rowCount</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"problem making append-only storage header of type bulk dense content"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Found row count %d, expected %d"</literal></expr></argument>,
							   <argument><expr><name>checkRowCount</name></expr></argument>, <argument><expr><name>rowCount</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>checkIsCompressed</name> <operator>!=</operator> <name>isCompressed</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"problem making append-only storage header of type bulk dense content"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Found is compressed flag %s, expected %s"</literal></expr></argument>,
							   <argument><expr><operator>(</operator><ternary><condition><expr><name>checkIsCompressed</name></expr> ?</condition><then> <expr><literal type="string">"true"</literal></expr> </then><else>: <expr><literal type="string">"false"</literal></expr></else></ternary><operator>)</operator></expr></argument>,
							   <argument><expr><operator>(</operator><ternary><condition><expr><name>isCompressed</name></expr> ?</condition><then> <expr><literal type="string">"true"</literal></expr> </then><else>: <expr><literal type="string">"false"</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>checkCompressedLen</name> <operator>!=</operator> <name>compressedLength</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"problem making append-only storage header of type bulk dense content"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Found data length %d, expected %d"</literal></expr></argument>,
							   <argument><expr><name>checkCompressedLen</name></expr></argument>, <argument><expr><name>dataLength</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/*
 * Return a string message for the last check error.
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>AppendOnlyStorageFormat_GetHeaderCheckErrorStr</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name>AoHeaderCheckErrorStr</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>AOHeaderCheckError</name></type>
<name>AppendOnlyStorageFormat_GetHeaderInfo</name><parameter_list>(
									  <parameter><decl><type><name>uint8</name> <modifier>*</modifier></type><name>headerPtr</name></decl></parameter>,
									  <parameter><decl><type><name>bool</name></type> <name>usingChecksums</name></decl></parameter>,
									  <parameter><decl><type><name>AoHeaderKind</name> <modifier>*</modifier></type><name>headerKind</name></decl></parameter>,
									  <parameter><decl><type><name>int32</name> <modifier>*</modifier></type><name>actualHeaderLen</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AOHeader</name>   <modifier>*</modifier></type><name>header</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>headerPtr</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>headerKind</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>header</name> <operator>=</operator> <operator>(</operator><name>AOHeader</name> <operator>*</operator><operator>)</operator> <name>headerPtr</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>header</name><operator>-&gt;</operator><name>header_bytes_0_3</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>AoHeaderCheckErrorStr</name></expr></argument>,
				 <argument><expr><name>MAX_AOHEADER_CHECK_ERROR_STR</name></expr></argument>,
				 <argument><expr><literal type="string">"Append-only storage header is invalid -- first 32 bits are all zeroes (header_bytes_0_3 0x%08x, header_bytes_4_7 0x%08x)"</literal></expr></argument>,
				 <argument><expr><name><name>header</name><operator>-&gt;</operator><name>header_bytes_0_3</name></name></expr></argument>, <argument><expr><name><name>header</name><operator>-&gt;</operator><name>header_bytes_4_7</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return <expr><name>AOHeaderCheckFirst32BitsAllZeroes</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>AOHeaderGet_reserved0</name><argument_list>(<argument><expr><name>header</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>AoHeaderCheckErrorStr</name></expr></argument>,
				 <argument><expr><name>MAX_AOHEADER_CHECK_ERROR_STR</name></expr></argument>,
				 <argument><expr><literal type="string">"Append-only storage header is invalid -- reserved bit 0 of the header is not zero (header_bytes_0_3 0x%08x, header_bytes_4_7 0x%08x)"</literal></expr></argument>,
				 <argument><expr><name><name>header</name><operator>-&gt;</operator><name>header_bytes_0_3</name></name></expr></argument>, <argument><expr><name><name>header</name><operator>-&gt;</operator><name>header_bytes_4_7</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return <expr><name>AOHeaderCheckReservedBit0Not0</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><operator>*</operator><name>headerKind</name> <operator>=</operator> <call><name>AOHeaderGet_headerKind</name><argument_list>(<argument><expr><name>header</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>headerKind</name> <operator>==</operator> <name>AoHeaderKind_None</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>AoHeaderCheckErrorStr</name></expr></argument>,
				 <argument><expr><name>MAX_AOHEADER_CHECK_ERROR_STR</name></expr></argument>,
				 <argument><expr><literal type="string">"Append-only storage header is invalid -- invalid value 0 (none) for header kind (header_bytes_0_3 0x%08x, header_bytes_4_7 0x%08x)"</literal></expr></argument>,
				 <argument><expr><name><name>header</name><operator>-&gt;</operator><name>header_bytes_0_3</name></name></expr></argument>, <argument><expr><name><name>header</name><operator>-&gt;</operator><name>header_bytes_4_7</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return <expr><name>AOHeaderCheckInvalidHeaderKindNone</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>headerKind</name> <operator>&gt;=</operator> <name>MaxAoHeaderKind</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>AoHeaderCheckErrorStr</name></expr></argument>,
				 <argument><expr><name>MAX_AOHEADER_CHECK_ERROR_STR</name></expr></argument>,
				 <argument><expr><literal type="string">"Append-only storage header is invalid -- invalid header kind value %d (header_bytes_0_3 0x%08x, header_bytes_4_7 0x%08x)"</literal></expr></argument>,
				 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <operator>*</operator><name>headerKind</name></expr></argument>,
				 <argument><expr><name><name>header</name><operator>-&gt;</operator><name>header_bytes_0_3</name></name></expr></argument>, <argument><expr><name><name>header</name><operator>-&gt;</operator><name>header_bytes_4_7</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return <expr><name>AOHeaderCheckInvalidHeaderKind</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<switch>switch <condition>(<expr><operator>*</operator><name>headerKind</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>AoHeaderKind_SmallContent</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>AOSmallContentHeader</name> <modifier>*</modifier></type><name>blockHeader</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>blockHeader</name> <operator>=</operator> <operator>(</operator><name>AOSmallContentHeader</name> <operator>*</operator><operator>)</operator> <name>headerPtr</name></expr>;</expr_stmt>

				<expr_stmt><expr><operator>*</operator><name>actualHeaderLen</name> <operator>=</operator>
					<name>AoHeader_RegularSize</name> <operator>+</operator>
					<operator>(</operator><ternary><condition><expr><name>usingChecksums</name></expr> ?</condition><then> <expr><literal type="number">2</literal> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>pg_crc32</name></expr></argument>)</argument_list></sizeof></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>AOSmallContentHeaderGet_hasFirstRowNum</name><argument_list>(<argument><expr><name>blockHeader</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><operator>(</operator><operator>*</operator><name>actualHeaderLen</name><operator>)</operator> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int64</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>AoHeaderKind_LargeContent</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>AOLargeContentHeader</name> <modifier>*</modifier></type><name>largeContentHeader</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>largeContentHeader</name> <operator>=</operator> <operator>(</operator><name>AOLargeContentHeader</name> <operator>*</operator><operator>)</operator> <name>headerPtr</name></expr>;</expr_stmt>

				<expr_stmt><expr><operator>*</operator><name>actualHeaderLen</name> <operator>=</operator>
					<name>AoHeader_RegularSize</name> <operator>+</operator>
					<operator>(</operator><ternary><condition><expr><name>usingChecksums</name></expr> ?</condition><then> <expr><literal type="number">2</literal> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>pg_crc32</name></expr></argument>)</argument_list></sizeof></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>AOLargeContentHeaderGet_hasFirstRowNum</name><argument_list>(<argument><expr><name>largeContentHeader</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><operator>(</operator><operator>*</operator><name>actualHeaderLen</name><operator>)</operator> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int64</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>AoHeaderKind_NonBulkDenseContent</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>AONonBulkDenseContentHeader</name> <modifier>*</modifier></type><name>denseContentHeader</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>denseContentHeader</name> <operator>=</operator> <operator>(</operator><name>AONonBulkDenseContentHeader</name> <operator>*</operator><operator>)</operator> <name>headerPtr</name></expr>;</expr_stmt>

				<expr_stmt><expr><operator>*</operator><name>actualHeaderLen</name> <operator>=</operator>
					<name>AoHeader_RegularSize</name> <operator>+</operator>
					<operator>(</operator><ternary><condition><expr><name>usingChecksums</name></expr> ?</condition><then> <expr><literal type="number">2</literal> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>pg_crc32</name></expr></argument>)</argument_list></sizeof></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>AONonBulkDenseContentHeaderGet_hasFirstRowNum</name><argument_list>(<argument><expr><name>denseContentHeader</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><operator>(</operator><operator>*</operator><name>actualHeaderLen</name><operator>)</operator> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int64</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>AoHeaderKind_BulkDenseContent</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>AOBulkDenseContentHeader</name> <modifier>*</modifier></type><name>blockHeader</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>blockHeader</name> <operator>=</operator> <operator>(</operator><name>AOBulkDenseContentHeader</name> <operator>*</operator><operator>)</operator> <name>headerPtr</name></expr>;</expr_stmt>

				<expr_stmt><expr><operator>*</operator><name>actualHeaderLen</name> <operator>=</operator>
					<name>AoHeader_LongSize</name> <operator>+</operator>
					<operator>(</operator><ternary><condition><expr><name>usingChecksums</name></expr> ?</condition><then> <expr><literal type="number">2</literal> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>pg_crc32</name></expr></argument>)</argument_list></sizeof></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>AOBulkDenseContentHeaderGet_hasFirstRowNum</name><argument_list>(<argument><expr><name>blockHeader</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><operator>(</operator><operator>*</operator><name>actualHeaderLen</name><operator>)</operator> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int64</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block>
			<break>break;</break>

		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Unexpected Append-Only header kind %d"</literal></expr></argument>,
				 <argument><expr><operator>*</operator><name>headerKind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<return>return <expr><name>AOHeaderCheckOk</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>AOHeaderCheckError</name></type>
<name>AppendOnlyStorageFormat_GetSmallContentHeaderInfo</name><parameter_list>(
												  <parameter><decl><type><name>uint8</name> <modifier>*</modifier></type><name>headerPtr</name></decl></parameter>,
												  <parameter><decl><type><name>int</name></type> <name>headerLen</name></decl></parameter>,
												  <parameter><decl><type><name>bool</name></type> <name>usingChecksums</name></decl></parameter>,
												  <parameter><decl><type><name>int32</name></type> <name>blockLimitLen</name></decl></parameter>,
												  <parameter><decl><type><name>int32</name> <modifier>*</modifier></type><name>overallBlockLen</name></decl></parameter>,
												  <parameter><decl><type><name>int32</name> <modifier>*</modifier></type><name>offset</name></decl></parameter>,
												  <parameter><decl><type><name>int32</name> <modifier>*</modifier></type><name>uncompressedLen</name></decl></parameter>,
												  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>executorBlockKind</name></decl></parameter>,
												  <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>hasFirstRowNum</name></decl></parameter>,
												  <parameter><decl><type><name>int</name></type> <name>version</name></decl></parameter>,
												  <parameter><decl><type><name>int64</name> <modifier>*</modifier></type><name>firstRowNum</name></decl></parameter>,
												  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>rowCount</name></decl></parameter>,
												  <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isCompressed</name></decl></parameter>,
												  <parameter><decl><type><name>int32</name> <modifier>*</modifier></type><name>compressedLen</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AOSmallContentHeader</name> <modifier>*</modifier></type><name>blockHeader</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>length</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>headerPtr</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>blockHeader</name> <operator>=</operator> <operator>(</operator><name>AOSmallContentHeader</name> <operator>*</operator><operator>)</operator> <name>headerPtr</name></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>executorBlockKind</name> <operator>=</operator> <call><name>AOSmallContentHeaderGet_executorBlockKind</name><argument_list>(<argument><expr><name>blockHeader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>hasFirstRowNum</name> <operator>=</operator> <call><name>AOSmallContentHeaderGet_hasFirstRowNum</name><argument_list>(<argument><expr><name>blockHeader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>rowCount</name> <operator>=</operator> <call><name>AOSmallContentHeaderGet_rowCount</name><argument_list>(<argument><expr><name>blockHeader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>offset</name> <operator>=</operator> <name>AoHeader_RegularSize</name> <operator>+</operator>
		<operator>(</operator><ternary><condition><expr><name>usingChecksums</name></expr> ?</condition><then> <expr><literal type="number">2</literal> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>pg_crc32</name></expr></argument>)</argument_list></sizeof></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>hasFirstRowNum</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int64</name>	   <modifier>*</modifier></type><name>firstRowNumPtr</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>firstRowNumPtr</name> <operator>=</operator> <operator>(</operator><name>int64</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>headerPtr</name><index>[<expr><operator>*</operator><name>offset</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>firstRowNum</name> <operator>=</operator> <operator>*</operator><name>firstRowNumPtr</name></expr>;</expr_stmt>

		<expr_stmt><expr><operator>(</operator><operator>*</operator><name>offset</name><operator>)</operator> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int64</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>firstRowNum</name> <operator>=</operator> <call><name>INT64CONST</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>offset</name> <operator>!=</operator> <name>headerLen</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Content offset %d doesn't equal header length parameter %d"</literal></expr></argument>,
			 <argument><expr><operator>*</operator><name>offset</name></expr></argument>,
			 <argument><expr><name>headerLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><operator>*</operator><name>uncompressedLen</name> <operator>=</operator> <call><name>AOSmallContentHeaderGet_dataLength</name><argument_list>(<argument><expr><name>blockHeader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>compressedLen</name> <operator>=</operator> <call><name>AOSmallContentHeaderGet_compressedLength</name><argument_list>(<argument><expr><name>blockHeader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>compressedLen</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>isCompressed</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>length</name> <operator>=</operator> <operator>*</operator><name>uncompressedLen</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>isCompressed</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>length</name> <operator>=</operator> <operator>*</operator><name>compressedLen</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * UNDONE: Fix doCompressAppend to supply slightly less output
		 * buffer... UNDONE: so we can make this comparison &gt;=.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>compressedLen</name> <operator>&gt;</operator> <operator>*</operator><name>uncompressedLen</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>AoHeaderCheckErrorStr</name></expr></argument>,
					 <argument><expr><name>MAX_AOHEADER_CHECK_ERROR_STR</name></expr></argument>,
					 <argument><expr><literal type="string">"Append-only storage header is invalid -- compressed length %d is &gt; uncompressed length %d "</literal>
					 <literal type="string">"(smallcontent_bytes_0_3 0x%08x, smallcontent_bytes_4_7 0x%08x)"</literal></expr></argument>,
					 <argument><expr><operator>*</operator><name>compressedLen</name></expr></argument>,
					 <argument><expr><operator>*</operator><name>uncompressedLen</name></expr></argument>,
					 <argument><expr><name><name>blockHeader</name><operator>-&gt;</operator><name>smallcontent_bytes_0_3</name></name></expr></argument>, <argument><expr><name><name>blockHeader</name><operator>-&gt;</operator><name>smallcontent_bytes_4_7</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>AOHeaderCheckInvalidCompressedLen</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><operator>*</operator><name>overallBlockLen</name> <operator>=</operator> <operator>*</operator><name>offset</name> <operator>+</operator>
		<call><name>AOStorage_RoundUp</name><argument_list>(<argument><expr><name>length</name></expr></argument>, <argument><expr><name>version</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>overallBlockLen</name> <operator>&gt;</operator> <name>blockLimitLen</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>AoHeaderCheckErrorStr</name></expr></argument>,
				 <argument><expr><name>MAX_AOHEADER_CHECK_ERROR_STR</name></expr></argument>,
				 <argument><expr><literal type="string">"Append-only storage header is invalid -- overall block length %d is &gt; block limit length %d "</literal>
				 <literal type="string">"(smallcontent_bytes_0_3 0x%08x, smallcontent_bytes_4_7 0x%08x)"</literal></expr></argument>,
				 <argument><expr><operator>*</operator><name>overallBlockLen</name></expr></argument>,
				 <argument><expr><name>blockLimitLen</name></expr></argument>,
				 <argument><expr><name><name>blockHeader</name><operator>-&gt;</operator><name>smallcontent_bytes_0_3</name></name></expr></argument>, <argument><expr><name><name>blockHeader</name><operator>-&gt;</operator><name>smallcontent_bytes_4_7</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>AOHeaderCheckInvalidOverallBlockLen</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>AOHeaderCheckOk</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32</name></type>
<name>AppendOnlyStorageFormat_GetCompressedLen</name><parameter_list>(
										 <parameter><decl><type><name>uint8</name> <modifier>*</modifier></type><name>headerPtr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AOSmallContentHeader</name> <modifier>*</modifier></type><name>blockHeader</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>headerPtr</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>blockHeader</name> <operator>=</operator> <operator>(</operator><name>AOSmallContentHeader</name> <operator>*</operator><operator>)</operator> <name>headerPtr</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>blockHeader</name><operator>-&gt;</operator><name>smallcontent_bytes_0_3</name></name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>AOSmallContentHeaderGet_compressedLength</name><argument_list>(<argument><expr><name>blockHeader</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>AOHeaderCheckError</name></type>
<name>AppendOnlyStorageFormat_GetLargeContentHeaderInfo</name><parameter_list>(
												  <parameter><decl><type><name>uint8</name> <modifier>*</modifier></type><name>headerPtr</name></decl></parameter>,
												  <parameter><decl><type><name>int</name></type> <name>headerLen</name></decl></parameter>,
												  <parameter><decl><type><name>bool</name></type> <name>usingChecksums</name></decl></parameter>,
												  <parameter><decl><type><name>int32</name> <modifier>*</modifier></type><name>largeContentLen</name></decl></parameter>,
												  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>executorBlockKind</name></decl></parameter>,
												  <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>hasFirstRowNum</name></decl></parameter>,
												  <parameter><decl><type><name>int64</name> <modifier>*</modifier></type><name>firstRowNum</name></decl></parameter>,
												  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>largeRowCount</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AOLargeContentHeader</name> <modifier>*</modifier></type><name>largeContentHeader</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>offset</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>headerPtr</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>largeContentHeader</name> <operator>=</operator> <operator>(</operator><name>AOLargeContentHeader</name> <operator>*</operator><operator>)</operator> <name>headerPtr</name></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>executorBlockKind</name> <operator>=</operator> <call><name>AOLargeContentHeaderGet_executorBlockKind</name><argument_list>(<argument><expr><name>largeContentHeader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>hasFirstRowNum</name> <operator>=</operator> <call><name>AOLargeContentHeaderGet_hasFirstRowNum</name><argument_list>(<argument><expr><name>largeContentHeader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>largeRowCount</name> <operator>=</operator> <call><name>AOLargeContentHeaderGet_largeRowCount</name><argument_list>(<argument><expr><name>largeContentHeader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>largeContentLen</name> <operator>=</operator> <call><name>AOLargeContentHeaderGet_largeContentLength</name><argument_list>(<argument><expr><name>largeContentHeader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>largeContentLen</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>AoHeaderCheckErrorStr</name></expr></argument>,
				 <argument><expr><name>MAX_AOHEADER_CHECK_ERROR_STR</name></expr></argument>,
				 <argument><expr><literal type="string">"Append-only storage header is invalid -- large content length is zero "</literal>
				 <literal type="string">"(block_bytes_0_3 0x%08x, block_bytes_4_7 0x%08x)"</literal></expr></argument>,
				 <argument><expr><name><name>largeContentHeader</name><operator>-&gt;</operator><name>largecontent_bytes_0_3</name></name></expr></argument>, <argument><expr><name><name>largeContentHeader</name><operator>-&gt;</operator><name>largecontent_bytes_4_7</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>AOHeaderCheckLargeContentLenIsZero</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>offset</name> <operator>=</operator> <name>AoHeader_RegularSize</name> <operator>+</operator>
		<operator>(</operator><ternary><condition><expr><name>usingChecksums</name></expr> ?</condition><then> <expr><literal type="number">2</literal> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>pg_crc32</name></expr></argument>)</argument_list></sizeof></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>hasFirstRowNum</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int64</name>	   <modifier>*</modifier></type><name>firstRowNumPtr</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>firstRowNumPtr</name> <operator>=</operator> <operator>(</operator><name>int64</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>headerPtr</name><index>[<expr><name>offset</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>firstRowNum</name> <operator>=</operator> <operator>*</operator><name>firstRowNumPtr</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>offset</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int64</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>firstRowNum</name> <operator>=</operator> <call><name>INT64CONST</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>offset</name> <operator>!=</operator> <name>headerLen</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Content offset %d doesn't equal header length parameter %d"</literal></expr></argument>,
			 <argument><expr><name>offset</name></expr></argument>,
			 <argument><expr><name>headerLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>AOHeaderCheckOk</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>AOHeaderCheckError</name></type>
<name>AppendOnlyStorageFormat_GetNonBulkDenseContentHeaderInfo</name><parameter_list>(
														 <parameter><decl><type><name>uint8</name> <modifier>*</modifier></type><name>headerPtr</name></decl></parameter>,
														 <parameter><decl><type><name>int</name></type> <name>headerLen</name></decl></parameter>,
														 <parameter><decl><type><name>bool</name></type> <name>usingChecksums</name></decl></parameter>,
														 <parameter><decl><type><name>int32</name></type> <name>blockLimitLen</name></decl></parameter>,
														 <parameter><decl><type><name>int32</name> <modifier>*</modifier></type><name>overallBlockLen</name></decl></parameter>,
														 <parameter><decl><type><name>int32</name> <modifier>*</modifier></type><name>offset</name></decl></parameter>,
														 <parameter><decl><type><name>int32</name> <modifier>*</modifier></type><name>uncompressedLen</name></decl></parameter>,
														 <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>executorBlockKind</name></decl></parameter>,
														 <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>hasFirstRowNum</name></decl></parameter>,
														 <parameter><decl><type><name>int</name></type> <name>version</name></decl></parameter>,
														 <parameter><decl><type><name>int64</name> <modifier>*</modifier></type><name>firstRowNum</name></decl></parameter>,
														 <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>rowCount</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AONonBulkDenseContentHeader</name> <modifier>*</modifier></type><name>blockHeader</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>headerPtr</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>blockHeader</name> <operator>=</operator> <operator>(</operator><name>AONonBulkDenseContentHeader</name> <operator>*</operator><operator>)</operator> <name>headerPtr</name></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>executorBlockKind</name> <operator>=</operator> <call><name>AONonBulkDenseContentHeaderGet_executorBlockKind</name><argument_list>(<argument><expr><name>blockHeader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>hasFirstRowNum</name> <operator>=</operator> <call><name>AONonBulkDenseContentHeaderGet_hasFirstRowNum</name><argument_list>(<argument><expr><name>blockHeader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>rowCount</name> <operator>=</operator> <call><name>AONonBulkDenseContentHeaderGet_largeRowCount</name><argument_list>(<argument><expr><name>blockHeader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>offset</name> <operator>=</operator> <name>AoHeader_RegularSize</name> <operator>+</operator>
		<operator>(</operator><ternary><condition><expr><name>usingChecksums</name></expr> ?</condition><then> <expr><literal type="number">2</literal> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>pg_crc32</name></expr></argument>)</argument_list></sizeof></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>hasFirstRowNum</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int64</name>	   <modifier>*</modifier></type><name>firstRowNumPtr</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>firstRowNumPtr</name> <operator>=</operator> <operator>(</operator><name>int64</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>headerPtr</name><index>[<expr><operator>*</operator><name>offset</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>firstRowNum</name> <operator>=</operator> <operator>*</operator><name>firstRowNumPtr</name></expr>;</expr_stmt>

		<expr_stmt><expr><operator>(</operator><operator>*</operator><name>offset</name><operator>)</operator> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int64</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>firstRowNum</name> <operator>=</operator> <call><name>INT64CONST</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>offset</name> <operator>!=</operator> <name>headerLen</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Content offset %d doesn't equal header length parameter %d"</literal></expr></argument>,
			 <argument><expr><operator>*</operator><name>offset</name></expr></argument>,
			 <argument><expr><name>headerLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><operator>*</operator><name>uncompressedLen</name> <operator>=</operator> <call><name>AONonBulkDenseContentHeaderGet_dataLength</name><argument_list>(<argument><expr><name>blockHeader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>overallBlockLen</name> <operator>=</operator> <operator>*</operator><name>offset</name> <operator>+</operator>
		<call><name>AOStorage_RoundUp</name><argument_list>(<argument><expr><operator>*</operator><name>uncompressedLen</name></expr></argument>, <argument><expr><name>version</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>overallBlockLen</name> <operator>&gt;</operator> <name>blockLimitLen</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>AoHeaderCheckErrorStr</name></expr></argument>,
				 <argument><expr><name>MAX_AOHEADER_CHECK_ERROR_STR</name></expr></argument>,
				 <argument><expr><literal type="string">"Append-only storage header is invalid -- overall block length %d is &gt; block limit length %d "</literal>
				 <literal type="string">"(nonbulkdensecontent_bytes_0_3 0x%08x, nonbulkdensecontent_bytes_4_7 0x%08x)"</literal></expr></argument>,
				 <argument><expr><operator>*</operator><name>overallBlockLen</name></expr></argument>,
				 <argument><expr><name>blockLimitLen</name></expr></argument>,
				 <argument><expr><name><name>blockHeader</name><operator>-&gt;</operator><name>nonbulkdensecontent_bytes_0_3</name></name></expr></argument>, <argument><expr><name><name>blockHeader</name><operator>-&gt;</operator><name>nonbulkdensecontent_bytes_4_7</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>AOHeaderCheckInvalidOverallBlockLen</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>AOHeaderCheckOk</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>AOHeaderCheckError</name></type>
<name>AppendOnlyStorageFormat_GetBulkDenseContentHeaderInfo</name><parameter_list>(
													  <parameter><decl><type><name>uint8</name> <modifier>*</modifier></type><name>headerPtr</name></decl></parameter>,
													  <parameter><decl><type><name>int</name></type> <name>headerLen</name></decl></parameter>,
													  <parameter><decl><type><name>bool</name></type> <name>usingChecksums</name></decl></parameter>,
													  <parameter><decl><type><name>int32</name></type> <name>blockLimitLen</name></decl></parameter>,
													  <parameter><decl><type><name>int32</name> <modifier>*</modifier></type><name>overallBlockLen</name></decl></parameter>,
													  <parameter><decl><type><name>int32</name> <modifier>*</modifier></type><name>offset</name></decl></parameter>,
													  <parameter><decl><type><name>int32</name> <modifier>*</modifier></type><name>uncompressedLen</name></decl></parameter>,
													  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>executorBlockKind</name></decl></parameter>,
													  <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>hasFirstRowNum</name></decl></parameter>,
													  <parameter><decl><type><name>int</name></type> <name>version</name></decl></parameter>,
													  <parameter><decl><type><name>int64</name> <modifier>*</modifier></type><name>firstRowNum</name></decl></parameter>,
													  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>rowCount</name></decl></parameter>,
													  <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isCompressed</name></decl></parameter>,
													  <parameter><decl><type><name>int32</name> <modifier>*</modifier></type><name>compressedLen</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AOBulkDenseContentHeader</name> <modifier>*</modifier></type><name>blockHeader</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>firstHeaderAndChecksumsLen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AOBulkDenseContentHeaderExt</name> <modifier>*</modifier></type><name>extHeader</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>int32</name></type>		<name>length</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>headerPtr</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>blockHeader</name> <operator>=</operator> <operator>(</operator><name>AOBulkDenseContentHeader</name> <operator>*</operator><operator>)</operator> <name>headerPtr</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>firstHeaderAndChecksumsLen</name> <operator>=</operator>
		<name>AoHeader_RegularSize</name> <operator>+</operator>
		<operator>(</operator><ternary><condition><expr><name>usingChecksums</name></expr> ?</condition><then> <expr><literal type="number">2</literal> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>pg_crc32</name></expr></argument>)</argument_list></sizeof></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>

	<comment type="block">/*
	 * The extension header is in the data portion with first row number.
	 */</comment>
	<expr_stmt><expr><name>extHeader</name> <operator>=</operator> <operator>(</operator><name>AOBulkDenseContentHeaderExt</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name>headerPtr</name> <operator>+</operator> <name>firstHeaderAndChecksumsLen</name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>offset</name> <operator>=</operator> <name>firstHeaderAndChecksumsLen</name> <operator>+</operator>
		<name>AoHeader_RegularSize</name></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>executorBlockKind</name> <operator>=</operator> <call><name>AOBulkDenseContentHeaderGet_executorBlockKind</name><argument_list>(<argument><expr><name>blockHeader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>hasFirstRowNum</name> <operator>=</operator> <call><name>AOBulkDenseContentHeaderGet_hasFirstRowNum</name><argument_list>(<argument><expr><name>blockHeader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>rowCount</name> <operator>=</operator> <call><name>AOBulkDenseContentHeaderExtGet_largeRowCount</name><argument_list>(<argument><expr><name>extHeader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>hasFirstRowNum</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int64</name>	   <modifier>*</modifier></type><name>firstRowNumPtr</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>firstRowNumPtr</name> <operator>=</operator> <operator>(</operator><name>int64</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>headerPtr</name><index>[<expr><operator>*</operator><name>offset</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>firstRowNum</name> <operator>=</operator> <operator>*</operator><name>firstRowNumPtr</name></expr>;</expr_stmt>

		<expr_stmt><expr><operator>(</operator><operator>*</operator><name>offset</name><operator>)</operator> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int64</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>firstRowNum</name> <operator>=</operator> <call><name>INT64CONST</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>offset</name> <operator>!=</operator> <name>headerLen</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Content offset %d doesn't equal header length parameter %d"</literal></expr></argument>,
			 <argument><expr><operator>*</operator><name>offset</name></expr></argument>,
			 <argument><expr><name>headerLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><operator>*</operator><name>uncompressedLen</name> <operator>=</operator> <call><name>AOBulkDenseContentHeaderGet_dataLength</name><argument_list>(<argument><expr><name>blockHeader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>compressedLen</name> <operator>=</operator> <call><name>AOBulkDenseContentHeaderGet_compressedLength</name><argument_list>(<argument><expr><name>blockHeader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>compressedLen</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>isCompressed</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>length</name> <operator>=</operator> <operator>*</operator><name>uncompressedLen</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>isCompressed</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>length</name> <operator>=</operator> <operator>*</operator><name>compressedLen</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * UNDONE: Fix doCompressAppend to supply slightly less output
		 * buffer... UNDONE: so we can make this comparison &gt;=.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>compressedLen</name> <operator>&gt;</operator> <operator>*</operator><name>uncompressedLen</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>AoHeaderCheckErrorStr</name></expr></argument>,
					 <argument><expr><name>MAX_AOHEADER_CHECK_ERROR_STR</name></expr></argument>,
					 <argument><expr><literal type="string">"Append-only storage header is invalid -- compressed length %d is &gt; uncompressed length %d "</literal>
					 <literal type="string">"(bulkdensecontent_bytes_0_3 0x%08x, bulkdensecontent_bytes_4_7 0x%08x, "</literal>
					 <literal type="string">"bulkdensecontent_ext_bytes_0_3 0x%08x, bulkdensecontent_ext_bytes_4_7 0x%08x)"</literal></expr></argument>,
					 <argument><expr><operator>*</operator><name>compressedLen</name></expr></argument>,
					 <argument><expr><operator>*</operator><name>uncompressedLen</name></expr></argument>,
					 <argument><expr><name><name>blockHeader</name><operator>-&gt;</operator><name>bulkdensecontent_bytes_0_3</name></name></expr></argument>, <argument><expr><name><name>blockHeader</name><operator>-&gt;</operator><name>bulkdensecontent_bytes_4_7</name></name></expr></argument>,
					 <argument><expr><name><name>extHeader</name><operator>-&gt;</operator><name>bulkdensecontent_ext_bytes_0_3</name></name></expr></argument>, <argument><expr><name><name>extHeader</name><operator>-&gt;</operator><name>bulkdensecontent_ext_bytes_4_7</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>AOHeaderCheckInvalidCompressedLen</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><operator>*</operator><name>overallBlockLen</name> <operator>=</operator> <operator>*</operator><name>offset</name> <operator>+</operator>
		<call><name>AOStorage_RoundUp</name><argument_list>(<argument><expr><name>length</name></expr></argument>, <argument><expr><name>version</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>overallBlockLen</name> <operator>&gt;</operator> <name>blockLimitLen</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>AoHeaderCheckErrorStr</name></expr></argument>,
				 <argument><expr><name>MAX_AOHEADER_CHECK_ERROR_STR</name></expr></argument>,
				 <argument><expr><literal type="string">"Append-only storage header is invalid -- overall block length %d is &gt; block limit length %d "</literal>
				 <literal type="string">"(bulkdensecontent_bytes_0_3 0x%08x, bulkdensecontent_bytes_4_7 0x%08x, "</literal>
				 <literal type="string">"bulkdensecontent_ext_bytes_0_3 0x%08x, bulkdensecontent_ext_bytes_4_7 0x%08x)"</literal></expr></argument>,
				 <argument><expr><operator>*</operator><name>overallBlockLen</name></expr></argument>,
				 <argument><expr><name>blockLimitLen</name></expr></argument>,
				 <argument><expr><name><name>blockHeader</name><operator>-&gt;</operator><name>bulkdensecontent_bytes_0_3</name></name></expr></argument>, <argument><expr><name><name>blockHeader</name><operator>-&gt;</operator><name>bulkdensecontent_bytes_4_7</name></name></expr></argument>,
				 <argument><expr><name><name>extHeader</name><operator>-&gt;</operator><name>bulkdensecontent_ext_bytes_0_3</name></name></expr></argument>, <argument><expr><name><name>extHeader</name><operator>-&gt;</operator><name>bulkdensecontent_ext_bytes_4_7</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>AOHeaderCheckInvalidOverallBlockLen</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>AOHeaderCheckOk</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>AppendOnlyStorageFormat_VerifyHeaderChecksum</name><parameter_list>(
											 <parameter><decl><type><name>uint8</name> <modifier>*</modifier></type><name>headerPtr</name></decl></parameter>,
											 <parameter><decl><type><name>pg_crc32</name> <modifier>*</modifier></type><name>storedChecksum</name></decl></parameter>,
											 <parameter><decl><type><name>pg_crc32</name> <modifier>*</modifier></type><name>computedChecksum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int32</name></type>		<name>firstHeaderLen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>firstHeaderAndBlockChecksumLen</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>pg_crc32</name>   <modifier>*</modifier></type><name>headerChecksumPtr</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>headerPtr</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>storedChecksum</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>computedChecksum</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>firstHeaderLen</name> <operator>=</operator> <name>AoHeader_RegularSize</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>firstHeaderAndBlockChecksumLen</name> <operator>=</operator> <name>firstHeaderLen</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>pg_crc32</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<comment type="block">/* Block checksum. */</comment>

	<comment type="block">/*
	 * CRC checksum is first 32 bits after the whole header.
	 */</comment>
	<expr_stmt><expr><name>headerChecksumPtr</name> <operator>=</operator> <operator>(</operator><name>pg_crc32</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>headerPtr</name><index>[<expr><name>firstHeaderAndBlockChecksumLen</name></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>storedChecksum</name> <operator>=</operator> <operator>*</operator><name>headerChecksumPtr</name></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>computedChecksum</name> <operator>=</operator> <call><name>AppendOnlyStorageFormat_ComputeHeaderChecksum</name><argument_list>(
																	  <argument><expr><name>headerPtr</name></expr></argument>,
																	  <argument><expr><name>firstHeaderAndBlockChecksumLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><operator>*</operator><name>storedChecksum</name> <operator>==</operator> <operator>*</operator><name>computedChecksum</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>AppendOnlyStorageFormat_VerifyBlockChecksum</name><parameter_list>(
											<parameter><decl><type><name>uint8</name> <modifier>*</modifier></type><name>headerPtr</name></decl></parameter>,
											<parameter><decl><type><name>int32</name></type> <name>overallBlockLen</name></decl></parameter>,
											<parameter><decl><type><name>pg_crc32</name> <modifier>*</modifier></type><name>storedChecksum</name></decl></parameter>,
											<parameter><decl><type><name>pg_crc32</name> <modifier>*</modifier></type><name>computedChecksum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int32</name></type>		<name>firstHeaderLen</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>pg_crc32</name>   <modifier>*</modifier></type><name>blockChecksumPtr</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>headerPtr</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>storedChecksum</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>computedChecksum</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>firstHeaderLen</name> <operator>=</operator> <name>AoHeader_RegularSize</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Block checksum is first 32 bits after header.
	 */</comment>
	<expr_stmt><expr><name>blockChecksumPtr</name> <operator>=</operator> <operator>(</operator><name>pg_crc32</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>headerPtr</name><index>[<expr><name>firstHeaderLen</name></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>storedChecksum</name> <operator>=</operator> <operator>*</operator><name>blockChecksumPtr</name></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>computedChecksum</name> <operator>=</operator> <call><name>AppendOnlyStorageFormat_ComputeBlockChecksum</name><argument_list>(
																	 <argument><expr><name>headerPtr</name></expr></argument>,
																	 <argument><expr><name>firstHeaderLen</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>pg_crc32</name></expr></argument>)</argument_list></sizeof></expr></argument>,
																	 <argument><expr><name>overallBlockLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><operator>*</operator><name>storedChecksum</name> <operator>==</operator> <operator>*</operator><name>computedChecksum</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>
</unit>
