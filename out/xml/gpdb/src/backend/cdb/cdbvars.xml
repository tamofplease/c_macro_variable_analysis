<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/backend/cdb/cdbvars.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * cdbvars.c
 *	  Provides storage areas and processing routines for Greenplum Database variables
 *	  managed by GUC.
 *
 * Portions Copyright (c) 2003-2010, Greenplum inc
 * Portions Copyright (c) 2012-Present VMware, Inc. or its affiliates.
 *
 *
 * IDENTIFICATION
 *	    src/backend/cdb/cdbvars.c
 *
 *
 * NOTES
 *	  See src/backend/utils/misc/guc.c for variable external specification.
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/guc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbvars.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq-fe.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq-int.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbfts.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbdisp.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbutil.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbdisp.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lib/stringinfo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq/libpq-be.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/backoff.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/resource_manager.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/proc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/procarray.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/memquota.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/fts.h"</cpp:file></cpp:include>

<comment type="block">/*
 * ----------------
 *		GUC/global variables
 *
 *	Initial values are set by guc.c function "InitializeGUCOptions" called
 *	*very* early during postmaster, postgres, or bootstrap initialization.
 * ----------------
 */</comment>



<decl_stmt><decl><type><name>GpRoleValue</name></type> <name>Gp_role</name></decl>;</decl_stmt>			<comment type="block">/* Role paid by this Greenplum Database
								 * backend */</comment>
<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>gp_role_string</name></decl>;</decl_stmt>		<comment type="block">/* Staging area for guc.c */</comment>

<decl_stmt><decl><type><name>bool</name></type>		<name>Gp_is_writer</name></decl>;</decl_stmt>		<comment type="block">/* is this qExec a "writer" process. */</comment>

<decl_stmt><decl><type><name>int</name></type>			<name>gp_session_id</name></decl>;</decl_stmt>		<comment type="block">/* global unique id for session. */</comment>

<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>qdHostname</name></decl>;</decl_stmt>			<comment type="block">/* QD hostname */</comment>
<decl_stmt><decl><type><name>int</name></type>			<name>qdPostmasterPort</name></decl>;</decl_stmt>	<comment type="block">/* Master Segment Postmaster port. */</comment>

<decl_stmt><decl><type><name>int</name></type>			<name>gp_command_count</name></decl>;</decl_stmt>	<comment type="block">/* num of commands from client */</comment>

<decl_stmt><decl><type><name>bool</name></type>		<name>gp_debug_pgproc</name></decl>;</decl_stmt>	<comment type="block">/* print debug info for PGPROC */</comment>
<decl_stmt><decl><type><name>bool</name></type>		<name>Debug_print_prelim_plan</name></decl>;</decl_stmt>	<comment type="block">/* Shall we log plan before adding
										 * Motions to subplans? */</comment>

<decl_stmt><decl><type><name>bool</name></type>		<name>Debug_print_slice_table</name></decl>;</decl_stmt>	<comment type="block">/* Shall we log the slice table? */</comment>

<decl_stmt><decl><type><name>bool</name></type>		<name>Debug_resource_group</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>	<comment type="block">/* Shall we log the resource group? */</comment>

<decl_stmt><decl><type><name>bool</name></type>		<name>Debug_burn_xids</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type>		<name>gp_external_enable_exec</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt> <comment type="block">/* allow ext tables with EXECUTE */</comment>

<decl_stmt><decl><type><name>bool</name></type>		<name>verify_gpfdists_cert</name></decl>;</decl_stmt> <comment type="block">/* verifies gpfdist's certificate */</comment>

<decl_stmt><decl><type><name>int</name></type>			<name>gp_external_max_segs</name></decl>;</decl_stmt>	<comment type="block">/* max segdbs per gpfdist/gpfdists URI */</comment>

<decl_stmt><decl><type><name>int</name></type>			<name>gp_safefswritesize</name></decl>;</decl_stmt> <comment type="block">/* set for safe AO writes in non-mature fs */</comment>

<decl_stmt><decl><type><name>int</name></type>			<name>gp_cached_gang_threshold</name></decl>;</decl_stmt>	<comment type="block">/* How many gangs to keep around from
										 * stmt to stmt. */</comment>

<decl_stmt><decl><type><name>bool</name></type>		<name>Gp_write_shared_snapshot</name></decl>;</decl_stmt>	<comment type="block">/* tell the writer QE to write the
										 * shared snapshot */</comment>

<decl_stmt><decl><type><name>bool</name></type>		<name>gp_reraise_signal</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>	<comment type="block">/* try to dump core when we get
										 * SIGABRT &amp; SIGSEGV */</comment>

<decl_stmt><decl><type><name>bool</name></type>		<name>gp_set_proc_affinity</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>	<comment type="block">/* set processor affinity (if
											 * platform supports it) */</comment>

<decl_stmt><decl><type><name>int</name></type>			<name>gp_reject_percent_threshold</name></decl>;</decl_stmt>	<comment type="block">/* SREH reject % kicks off only
											 * after * &lt;num&gt; records have been
											 * processed	*/</comment>

<decl_stmt><decl><type><name>bool</name></type>		<name>gp_select_invisible</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>	<comment type="block">/* debug mode to allow select to
											 * see "invisible" rows */</comment>

<decl_stmt><decl><type><name>int</name></type>         <name>gp_segment_connect_timeout</name> <init>= <expr><literal type="number">180</literal></expr></init></decl>;</decl_stmt>  <comment type="block">/* Maximum time (in seconds) allowed 
												* for a new worker process to start
												* or a mirror to respond.
												*/</comment>

<comment type="block">/*
 * Configurable timeout for snapshot add: exceptionally busy systems may take
 * longer than our old hard-coded version -- so here is a tuneable version.
 */</comment>
<decl_stmt><decl><type><name>int</name></type>			<name>gp_snapshotadd_timeout</name> <init>= <expr><literal type="number">10</literal></expr></init></decl>;</decl_stmt>


<comment type="block">/*
 * Probe retry count for fts prober.
 */</comment>
<decl_stmt><decl><type><name>int</name></type>			<name>gp_fts_probe_retries</name> <init>= <expr><literal type="number">5</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Probe timeout for fts prober.
 */</comment>
<decl_stmt><decl><type><name>int</name></type>			<name>gp_fts_probe_timeout</name> <init>= <expr><literal type="number">20</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Polling interval for the fts prober. A scan of the entire system starts
 * every time this expires.
 */</comment>
<decl_stmt><decl><type><name>int</name></type>			<name>gp_fts_probe_interval</name> <init>= <expr><literal type="number">60</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * If mirror disconnects and re-connects between this period, or just takes
 * this much time during initial connection of cluster start, it will not get
 * reported as down to FTS.
 */</comment>
<decl_stmt><decl><type><name>int</name></type> <name>gp_fts_mark_mirror_down_grace_period</name> <init>= <expr><literal type="number">30</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * If primary-mirror replication attempts to connect continuously and exceed
 * this count, mark the mirror down to prevent wal sync block.
 * More details please refer to FTSGetReplicationDisconnectTime.
 */</comment>
<decl_stmt><decl><type><name>int</name></type>			<name>gp_fts_replication_attempt_count</name> <init>= <expr><literal type="number">10</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Polling interval for the dtx recovery. Checking in dtx recovery starts every
 * time this expires.
 */</comment>
<decl_stmt><decl><type><name>int</name></type>			<name>gp_dtx_recovery_interval</name> <init>= <expr><literal type="number">60</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Gather prepared transactions that live longer than the time to find possible
 * orphaned prepared transactions.
 */</comment>
<decl_stmt><decl><type><name>int</name></type>			<name>gp_dtx_recovery_prepared_period</name> <init>= <expr><literal type="number">300</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * When we have certain types of failures during gang creation which indicate
 * that a segment is in recovery mode we may be able to retry.
 */</comment>
<decl_stmt><decl><type><name>int</name></type>			<name>gp_gang_creation_retry_count</name> <init>= <expr><literal type="number">5</literal></expr></init></decl>;</decl_stmt>	<comment type="block">/* disable by default */</comment>
<decl_stmt><decl><type><name>int</name></type>			<name>gp_gang_creation_retry_timer</name> <init>= <expr><literal type="number">2000</literal></expr></init></decl>;</decl_stmt>	<comment type="block">/* 2000ms */</comment>

<comment type="block">/*
 * These are GUCs to tune the TCP_KEEPALIVE parameters
 * for QD/QE libpq connections
 */</comment>
<decl_stmt><decl><type><name>int</name></type>			<name>gp_dispatch_keepalives_idle</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>			<name>gp_dispatch_keepalives_interval</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>			<name>gp_dispatch_keepalives_count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * gp_enable_slow_writer_testmode
 *
 * In order facilitate testing of reader-gang/writer-gang synchronization,
 * this inserts a pg_usleep call at the start of writer-gang processing.
 */</comment>
<decl_stmt><decl><type><name>bool</name></type>		<name>gp_enable_slow_writer_testmode</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * gp_enable_slow_cursor_testmode
 *
 * In order facilitate testing of reader-gang/writer-gang synchronization,
 * this inserts a pg_usleep call at the start of cursor-gang processing.
 */</comment>
<decl_stmt><decl><type><name>bool</name></type>		<name>gp_enable_slow_cursor_testmode</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * TCP port the Interconnect listens on for incoming connections from other
 * backends.  Assigned by initMotionLayerIPC() at process startup.  This port
 * is used for the duration of this process and should never change.
 */</comment>
<decl_stmt><decl><type><name>uint32</name></type>		<name>Gp_listener_port</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type>			<name>Gp_max_packet_size</name></decl>;</decl_stmt> <comment type="block">/* max Interconnect packet size */</comment>

<decl_stmt><decl><type><name>int</name></type>			<name>Gp_interconnect_queue_depth</name> <init>= <expr><literal type="number">4</literal></expr></init></decl>;</decl_stmt>	<comment type="block">/* max number of messages
												 * waiting in rx-queue before
												 * we drop. */</comment>
<decl_stmt><decl><type><name>int</name></type>			<name>Gp_interconnect_snd_queue_depth</name> <init>= <expr><literal type="number">2</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>			<name>Gp_interconnect_timer_period</name> <init>= <expr><literal type="number">5</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>			<name>Gp_interconnect_timer_checking_period</name> <init>= <expr><literal type="number">20</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>			<name>Gp_interconnect_default_rtt</name> <init>= <expr><literal type="number">20</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>			<name>Gp_interconnect_min_rto</name> <init>= <expr><literal type="number">20</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>			<name>Gp_interconnect_fc_method</name> <init>= <expr><name>INTERCONNECT_FC_METHOD_LOSS</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>			<name>Gp_interconnect_transmit_timeout</name> <init>= <expr><literal type="number">3600</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>			<name>Gp_interconnect_min_retries_before_timeout</name> <init>= <expr><literal type="number">100</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>			<name>Gp_interconnect_debug_retry_interval</name> <init>= <expr><literal type="number">10</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type>			<name>interconnect_setup_timeout</name> <init>= <expr><literal type="number">7200</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type>			<name>Gp_interconnect_type</name> <init>= <expr><name>INTERCONNECT_TYPE_UDPIFC</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> 		<name>Gp_interconnect_address_type</name> <init>= <expr><name>INTERCONNECT_ADDRESS_TYPE_UNICAST</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type>		<name>gp_interconnect_aggressive_retry</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>	<comment type="block">/* fast-track app-level
														 * retry */</comment>

<decl_stmt><decl><type><name>bool</name></type>		<name>gp_interconnect_full_crc</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>	<comment type="block">/* sanity check UDP data. */</comment>

<decl_stmt><decl><type><name>bool</name></type>		<name>gp_interconnect_log_stats</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>	<comment type="block">/* emit stats at log-level */</comment>

<decl_stmt><decl><type><name>bool</name></type>		<name>gp_interconnect_cache_future_packets</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * format: dbid:content:address:port,dbid:content:address:port ...
 * example: 1:-1:10.0.0.1:2000 2:0:10.0.0.2:2000 3:1:10.0.0.2:2001
 *
 * FIXME: at the moment:
 * - the address must be specified as IP;
 */</comment>
<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>gp_interconnect_proxy_addresses</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type>			<name>Gp_udp_bufsize_k</name></decl>;</decl_stmt>	<comment type="block">/* UPD recv buf size, in KB */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ASSERT_CHECKING</name></cpp:ifdef>
<comment type="block">/*
 * UDP-IC Test hooks (for fault injection).
 *
 * Dropseg: specifies which segment to apply the drop_percent to.
 */</comment>
<decl_stmt><decl><type><name>int</name></type>			<name>gp_udpic_dropseg</name> <init>= <expr><name>UNDEF_SEGMENT</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>			<name>gp_udpic_dropxmit_percent</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>			<name>gp_udpic_dropacks_percent</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>			<name>gp_udpic_fault_inject_percent</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>			<name>gp_udpic_fault_inject_bitmap</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>			<name>gp_udpic_network_disable_ipv6</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * Each slice table has a unique ID (certain commands like "vacuum analyze"
 * run many many slice-tables for each gp_command_id).
 */</comment>
<decl_stmt><decl><type><name>uint32</name></type>		<name>gp_interconnect_id</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/* --------------------------------------------------------------------------------------------------
 * Greenplum Optimizer GUCs
 */</comment>

<decl_stmt><decl><type><name>double</name></type>		<name>gp_motion_cost_per_row</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>			<name>gp_segments_for_planner</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type>			<name>gp_hashagg_default_nbatches</name> <init>= <expr><literal type="number">32</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type>		<name>gp_adjust_selectivity_for_outerjoins</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>		<name>gp_selectivity_damping_for_scans</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>		<name>gp_selectivity_damping_for_joins</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type>		<name>gp_selectivity_damping_factor</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>		<name>gp_selectivity_damping_sigsort</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type>			<name>gp_hashjoin_tuples_per_bucket</name> <init>= <expr><literal type="number">5</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>			<name>gp_hashagg_groups_per_bucket</name> <init>= <expr><literal type="number">5</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/* Analyzing aid */</comment>
<decl_stmt><decl><type><name>int</name></type>			<name>gp_motion_slice_noop</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/* Greenplum Database Experimental Feature GUCs */</comment>
<decl_stmt><decl><type><name>bool</name></type>		<name>gp_enable_explain_allstat</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>		<name>gp_enable_motion_deadlock_sanity</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>	<comment type="block">/* planning time sanity
														 * check */</comment>

<decl_stmt><decl><type><name>bool</name></type>		<name>gp_enable_tablespace_auto_mkdir</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* Enable check for compatibility of encoding and locale in createdb */</comment>
<decl_stmt><decl><type><name>bool</name></type>		<name>gp_encoding_check_locale_compatibility</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* Priority for the segworkers relative to the postmaster's priority */</comment>
<decl_stmt><decl><type><name>int</name></type>			<name>gp_segworker_relative_priority</name> <init>= <expr><name>PRIO_MAX</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* Max size of dispatched plans; 0 if no limit */</comment>
<decl_stmt><decl><type><name>int</name></type>			<name>gp_max_plan_size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/* Disable setting of tuple hints while reading */</comment>
<decl_stmt><decl><type><name>bool</name></type>		<name>gp_disable_tuple_hints</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type>			<name>gp_workfile_compress_algorithm</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>		<name>gp_workfile_checksumming</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>			<name>gp_workfile_caching_loglevel</name> <init>= <expr><name>DEBUG1</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>			<name>gp_sessionstate_loglevel</name> <init>= <expr><name>DEBUG1</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* Maximum disk space to use for workfiles on a segment, in kilobytes */</comment>
<decl_stmt><decl><type><name>int</name></type>			<name>gp_workfile_limit_per_segment</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/* Maximum disk space to use for workfiles per query on a segment, in kilobytes */</comment>
<decl_stmt><decl><type><name>int</name></type>			<name>gp_workfile_limit_per_query</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/* Maximum number of workfiles to be created by a query */</comment>
<decl_stmt><decl><type><name>int</name></type>			<name>gp_workfile_limit_files_per_query</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/* Enable single-slice single-row inserts ?*/</comment>
<decl_stmt><decl><type><name>bool</name></type>		<name>gp_enable_fast_sri</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* Enable single-mirror pair dispatch. */</comment>
<decl_stmt><decl><type><name>bool</name></type>		<name>gp_enable_direct_dispatch</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* Force core dump on memory context error */</comment>
<decl_stmt><decl><type><name>bool</name></type>		<name>coredump_on_memerror</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* Experimental feature for MPP-4082. Please read doc before setting this guc */</comment>
<decl_stmt><decl><type><name>int</name></type>			<name>gp_autostats_mode</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>gp_autostats_mode_string</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>			<name>gp_autostats_mode_in_functions</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>gp_autostats_mode_in_functions_string</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>			<name>gp_autostats_on_change_threshold</name> <init>= <expr><literal type="number">100000</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>		<name>gp_autostats_allow_nonowner</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>		<name>log_autostats</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* GUC to toggle JIT instrumentation output for EXPLAIN */</comment>
<decl_stmt><decl><type><name>bool</name></type>		<name>gp_explain_jit</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* --------------------------------------------------------------------------------------------------
 * Server debugging
 */</comment>

<comment type="block">/*
 * gp_debug_linger (integer)
 *
 * Upon an error with severity FATAL and error code ERRCODE_INTERNAL_ERROR,
 * errfinish() will sleep() for the specified number of seconds before
 * termination, to let the user attach a debugger.
 */</comment>
<decl_stmt><decl><type><name>int</name></type>			<name>gp_debug_linger</name> <init>= <expr><literal type="number">30</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/* ----------------
 * Non-GUC globals
 */</comment>

<decl_stmt><decl><type><name>int</name></type>			<name>currentSliceId</name> <init>= <expr><name>UNSET_SLICE_ID</name></expr></init></decl>;</decl_stmt>	<comment type="block">/* used by elog to show the
												 * current slice the process
												 * is executing. */</comment>

<decl_stmt><decl><type><name>bool</name></type>		<name>gp_cost_hashjoin_chainwalk</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* ----------------
 * This variable is initialized by the postmaster from command line arguments
 *
 * Any code needing the "numsegments"
 * can simply #include cdbvars.h, and use GpIdentity.numsegments
 */</comment>
<decl_stmt><decl><type><name>GpId</name></type>		<name>GpIdentity</name> <init>= <expr><block>{<expr><name>UNINITIALIZED_GP_IDENTITY_VALUE</name></expr>, <expr><name>UNINITIALIZED_GP_IDENTITY_VALUE</name></expr>}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Keep track of a few dispatch-related  statistics:
 */</comment>
<decl_stmt><decl><type><name>int</name></type>			<name>cdb_total_slices</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>			<name>cdb_total_plans</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>			<name>cdb_max_slices</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Local macro to provide string values of numeric defines.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CppNumericAsString</name><parameter_list>(<parameter><type><name>s</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>CppAsString(s)</cpp:value></cpp:define>

<comment type="block">/*
 *	Forward declarations of local function.
 */</comment>
<function_decl><type><specifier>static</specifier> <name>GpRoleValue</name></type> <name>string_to_role</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>string</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * Convert a Greenplum Database role string (as for gp_role) to an
 * enum value of type GpRoleValue. Return GP_ROLE_UNDEFINED in case the
 * string is unrecognized.
 */</comment>
<function><type><specifier>static</specifier> <name>GpRoleValue</name></type>
<name>string_to_role</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>string</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>GpRoleValue</name></type> <name>role</name> <init>= <expr><name>GP_ROLE_UNDEFINED</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>string</name></expr></argument>, <argument><expr><literal type="string">"dispatch"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>role</name> <operator>=</operator> <name>GP_ROLE_DISPATCH</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>string</name></expr></argument>, <argument><expr><literal type="string">"execute"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>role</name> <operator>=</operator> <name>GP_ROLE_EXECUTE</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>string</name></expr></argument>, <argument><expr><literal type="string">"utility"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>role</name> <operator>=</operator> <name>GP_ROLE_UTILITY</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>role</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Convert a GpRoleValue to a role string (as for gp_role).  Return eyecatcher
 * in the unexpected event that the value is unknown or undefined.
 */</comment>
<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>role_to_string</name><parameter_list>(<parameter><decl><type><name>GpRoleValue</name></type> <name>role</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name>role</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>GP_ROLE_DISPATCH</name></expr>:</case>
			<return>return <expr><literal type="string">"dispatch"</literal></expr>;</return>
		<case>case <expr><name>GP_ROLE_EXECUTE</name></expr>:</case>
			<return>return <expr><literal type="string">"execute"</literal></expr>;</return>
		<case>case <expr><name>GP_ROLE_UTILITY</name></expr>:</case>
			<return>return <expr><literal type="string">"utility"</literal></expr>;</return>
		<case>case <expr><name>GP_ROLE_UNDEFINED</name></expr>:</case>
		<default>default:</default>
			<return>return <expr><literal type="string">"undefined"</literal></expr>;</return>
	</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>check_gp_role</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>extra</name></decl></parameter>, <parameter><decl><type><name>GucSource</name></type> <name>source</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>GpRoleValue</name></type> <name>newrole</name> <init>= <expr><call><name>string_to_role</name><argument_list>(<argument><expr><operator>*</operator><name>newval</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Force utility mode in a stand-alone backend. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>IsPostmasterEnvironment</name> <operator>&amp;&amp;</operator> <name>newrole</name> <operator>!=</operator> <name>GP_ROLE_UTILITY</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"gp_role forced to 'utility' in single-user mode"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>newval</name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><literal type="string">"utility"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>source</name> <operator>==</operator> <name>PGC_S_DEFAULT</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_UNDEFINED</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>(</operator><name>newrole</name> <operator>!=</operator> <name>GP_ROLE_UNDEFINED</name><operator>)</operator></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content> <comment type="block">/* can only downgrade to utility. */</comment>
		<return>return <expr><operator>(</operator><name>newrole</name> <operator>==</operator> <name>GP_ROLE_UTILITY</name><operator>)</operator></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>assign_gp_role</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name>Gp_role</name> <operator>=</operator> <call><name>string_to_role</name><argument_list>(<argument><expr><name>newval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_UTILITY</name> <operator>&amp;&amp;</operator> <name>MyProc</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>MyProc</name><operator>-&gt;</operator><name>mppIsWriter</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Show hook routine for "gp_role" option.
 *
 * See src/backend/util/misc/guc.c for option definition.
 */</comment>
<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>show_gp_role</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>role_to_string</name><argument_list>(<argument><expr><name>Gp_role</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>



<comment type="block">/* --------------------------------------------------------------------------------------------------
 * Logging
 */</comment>


<comment type="block">/*
 * gp_log_gangs (string)
 *
 * Should creation, reallocation and cleanup of gangs of QE processes be logged?
 * "OFF"	 -&gt; only errors are logged
 * "TERSE"	 -&gt; terse logging of routine events, e.g. creation of new qExecs
 * "VERBOSE" -&gt; gang allocation per command is logged
 * "DEBUG"	 -&gt; additional events are logged at severity level DEBUG1 to DEBUG5
 *
 * The messages that are enabled by the TERSE and VERBOSE settings are
 * written with a severity level of LOG.
 */</comment>
<decl_stmt><decl><type><name>int</name></type> <name>gp_log_gang</name></decl>;</decl_stmt>

<comment type="block">/*
 * gp_log_fts (string)
 *
 * What kind of messages should the fault-prober log ?
 * "OFF"	 -&gt; only errors are logged
 * "TERSE"	 -&gt; terse logging of routine events
 * "VERBOSE" -&gt; gang allocation per command is logged
 * "DEBUG"	 -&gt; additional events are logged at severity level DEBUG1 to DEBUG5
 *
 * The messages that are enabled by the TERSE and VERBOSE settings are
 * written with a severity level of LOG.
 */</comment>
<decl_stmt><decl><type><name>int</name></type> <name>gp_log_fts</name></decl>;</decl_stmt>

<comment type="block">/*
 * gp_log_interconnect (string)
 *
 * Should connections between internal processes be logged?  (qDisp/qExec/etc)
 * "OFF"	 -&gt; connection errors are logged
 * "TERSE"	 -&gt; terse logging of routine events, e.g. successful connections
 * "VERBOSE" -&gt; most interconnect setup events are logged
 * "DEBUG"	 -&gt; additional events are logged at severity level DEBUG1 to DEBUG5.
 *
 * The messages that are enabled by the TERSE and VERBOSE settings are
 * written with a severity level of LOG.
 */</comment>
<decl_stmt><decl><type><name>int</name></type> <name>gp_log_interconnect</name></decl>;</decl_stmt>

<comment type="block">/*
 * gpvars_check_gp_resource_manager_policy
 * gpvars_assign_gp_resource_manager_policy
 * gpvars_show_gp_resource_manager_policy
 */</comment>
<function><type><name>bool</name></type>
<name>gpvars_check_gp_resource_manager_policy</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>extra</name></decl></parameter>, <parameter><decl><type><name>GucSource</name></type> <name>source</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>newval</name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
		<operator>*</operator><name><name>newval</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
		<operator>!</operator><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><literal type="string">"queue"</literal></expr></argument>, <argument><expr><operator>*</operator><name>newval</name></expr></argument>)</argument_list></call> <operator>||</operator>
		<operator>!</operator><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><literal type="string">"group"</literal></expr></argument>, <argument><expr><operator>*</operator><name>newval</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>GUC_check_errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid value for resource manager policy: \"%s\""</literal></expr></argument>, <argument><expr><operator>*</operator><name>newval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>gpvars_assign_gp_resource_manager_policy</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>newval</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>newval</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>Gp_resource_manager_policy</name> <operator>=</operator> <name>RESOURCE_MANAGER_POLICY_QUEUE</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><literal type="string">"queue"</literal></expr></argument>, <argument><expr><name>newval</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>Gp_resource_manager_policy</name> <operator>=</operator> <name>RESOURCE_MANAGER_POLICY_QUEUE</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><literal type="string">"group"</literal></expr></argument>, <argument><expr><name>newval</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>Gp_resource_manager_policy</name> <operator>=</operator> <name>RESOURCE_MANAGER_POLICY_GROUP</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>gp_enable_resqueue_priority</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/*
	 * No else should happen, since newval has been checked in check_hook.
	 */</comment>
</block_content>}</block></function>

<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>gpvars_show_gp_resource_manager_policy</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name>Gp_resource_manager_policy</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>RESOURCE_MANAGER_POLICY_QUEUE</name></expr>:</case>
			<return>return <expr><literal type="string">"queue"</literal></expr>;</return>
		<case>case <expr><name>RESOURCE_MANAGER_POLICY_GROUP</name></expr>:</case>
			<return>return <expr><literal type="string">"group"</literal></expr>;</return>
		<default>default:</default>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><literal type="string">"unexpected resource manager policy"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><literal type="string">"unknown"</literal></expr>;</return>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 * gpvars_assign_statement_mem
 */</comment>
<function><type><name>bool</name></type>
<name>gpvars_check_statement_mem</name><parameter_list>(<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>extra</name></decl></parameter>, <parameter><decl><type><name>GucSource</name></type> <name>source</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>newval</name> <operator>&gt;=</operator> <name>max_statement_mem</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>GUC_check_errmsg</name><argument_list>(<argument><expr><literal type="string">"Invalid input for statement_mem, must be less than max_statement_mem (%d kB)"</literal></expr></argument>,
						 <argument><expr><name>max_statement_mem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * increment_command_count
 *	  Increment gp_command_count. If the new command count is 0 or a negative number, reset it to 1.
 *	  And keep MyProc-&gt;queryCommandId synced with gp_command_count.
 */</comment>
<function><type><name>void</name></type>
<name>increment_command_count</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name>gp_command_count</name><operator>++</operator></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>gp_command_count</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>gp_command_count</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * No need to maintain MyProc-&gt;queryCommandId elsewhere, we guarantee
	 * they are always synced here.
	 */</comment>
	<expr_stmt><expr><name><name>MyProc</name><operator>-&gt;</operator><name>queryCommandId</name></name> <operator>=</operator> <name>gp_command_count</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function_decl><type><name>Datum</name></type> <name>mpp_execution_segment</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>Datum</name></type> <name>gp_execution_dbid</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * Implements the gp_execution_segment() function to return the contentid
 * of the current executing segment.
 */</comment>
<function><type><name>Datum</name></type>
<name>mpp_execution_segment</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>PG_RETURN_INT32</name><argument_list>(<argument><expr><name><name>GpIdentity</name><operator>.</operator><name>segindex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Implements the gp_execution_dbid() function to return the dbid of the
 * current executing segment.
 */</comment>
<function><type><name>Datum</name></type>
<name>gp_execution_dbid</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>PG_RETURN_INT32</name><argument_list>(<argument><expr><name><name>GpIdentity</name><operator>.</operator><name>dbid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
