<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/backend/cdb/cdbdtxrecovery.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * cdbdtxrecovery.c
 *	  Routine to recover distributed transactions
 *
 *
 * Copyright (c) 2018-Present VMware, Inc. or its affiliates.
 *
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>

<comment type="block">/* These are always necessary for a bgworker */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/guc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/ps_status.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/bgworker.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgstat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/ipc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/latch.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/lwlock.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/pmsignal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/proc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/shmem.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/procarray.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/faultinjector.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbgang.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbutil.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbvars.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbdispatchresult.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbdisp_query.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/postmaster.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tcop/tcopprot.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq-int.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_FREQ_CHECK_TIMES</name></cpp:macro> <cpp:value>12</cpp:value></cpp:define>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>frequent_check_times</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>volatile</specifier> <name>bool</name> <modifier>*</modifier></type><name>shmDtmStarted</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>volatile</specifier> <name>bool</name> <modifier>*</modifier></type><name>shmCleanupBackends</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>volatile</specifier> <name>pid_t</name> <modifier>*</modifier></type><name>shmDtxRecoveryPid</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>volatile</specifier> <name>DtxRecoveryEvent</name> <modifier>*</modifier></type><name>shmDtxRecoveryEvents</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>slock_t</name> <modifier>*</modifier></type><name>shmDtxRecoveryEventLock</name></decl>;</decl_stmt>

<comment type="block">/* transactions need recover */</comment>
<decl_stmt><decl><type><name>DistributedTransactionId</name> <modifier>*</modifier></type><name>shmCommittedGxidArray</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>volatile</specifier> <name>int</name> <modifier>*</modifier></type><name>shmNumCommittedGxacts</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>volatile</specifier> <name>sig_atomic_t</name></type> <name>got_SIGHUP</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<typedef>typedef <type><struct>struct <name>InDoubtDtx</name>
<block>{
	<decl_stmt><decl><type><name>char</name></type>		<name><name>gid</name><index>[<expr><name>TMGIDSIZE</name></expr>]</index></name></decl>;</decl_stmt>
}</block></struct></type> <name>InDoubtDtx</name>;</typedef>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>recoverTM</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>recoverInDoubtTransactions</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>TerminateMppBackends</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>HTAB</name> <modifier>*</modifier></type><name>gatherRMInDoubtTransactions</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>prepared_seconds</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>raiseError</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>abortRMInDoubtTransactions</name><parameter_list>(<parameter><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>htab</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>doAbortInDoubt</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>gid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>doNotifyCommittedInDoubt</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>gid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>AbortOrphanedPreparedTransactions</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>doNotifyCommittedInDoubt</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>gid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>succeeded</name></decl>;</decl_stmt>

	<comment type="block">/* UNDONE: Pass real gxid instead of InvalidDistributedTransactionId. */</comment>
	<expr_stmt><expr><name>succeeded</name> <operator>=</operator> <call><name>doDispatchDtxProtocolCommand</name><argument_list>(<argument><expr><name>DTX_PROTOCOL_COMMAND_RECOVERY_COMMIT_PREPARED</name></expr></argument>,
											 <argument><expr><name>gid</name></expr></argument>,
											 <comment type="block">/* raiseError */</comment> <argument><expr><name>false</name></expr></argument>,
											 <argument><expr><call><name>cdbcomponent_getCdbComponentsList</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>succeeded</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"Crash recovery broadcast of the distributed transaction "</literal>
			 		<literal type="string">"'Commit Prepared' broadcast failed to one or more segments for gid = %s."</literal></expr></argument>, <argument><expr><name>gid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Crash recovery broadcast of the distributed transaction "</literal>
			 	  <literal type="string">"'Commit Prepared' broadcast succeeded for gid = %s."</literal></expr></argument>, <argument><expr><name>gid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<return>return <expr><name>succeeded</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>doAbortInDoubt</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>gid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>succeeded</name></decl>;</decl_stmt>

	<comment type="block">/* UNDONE: Pass real gxid instead of InvalidDistributedTransactionId. */</comment>
	<expr_stmt><expr><name>succeeded</name> <operator>=</operator> <call><name>doDispatchDtxProtocolCommand</name><argument_list>(<argument><expr><name>DTX_PROTOCOL_COMMAND_RECOVERY_ABORT_PREPARED</name></expr></argument>,
											 <argument><expr><name>gid</name></expr></argument>,
											 <comment type="block">/* raiseError */</comment> <argument><expr><name>false</name></expr></argument>,
											 <argument><expr><call><name>cdbcomponent_getCdbComponentsList</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>succeeded</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ResetAllGangs</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Crash recovery retry of the distributed transaction "</literal>
			 		<literal type="string">"'Abort Prepared' broadcast failed to one or more segments "</literal>
					<literal type="string">"for gid = %s.  System will retry again later"</literal></expr></argument>, <argument><expr><name>gid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Crash recovery broadcast of the distributed transaction "</literal>
			 	  <literal type="string">"'Abort Prepared' broadcast succeeded for gid = %s"</literal></expr></argument>, <argument><expr><name>gid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * recoverTM:
 * perform TM recovery, this connects to all QE and resolve all in-doubt txn.
 *
 * This gets called when there is not any other DTM activity going on.
 *
 * First, we'll replay the dtm log and get our shmem as up to date as possible
 * in order to help resolve in-doubt transactions.	Then we'll go through and
 * try and resolve in-doubt transactions based on information in the DTM log.
 * The remaining in-doubt transactions that remain (ones the DTM doesn't know
 * about) are all ABORTed.
 *
 * If we're in read-only mode; we need to get started, but we can't run the
 * full recovery. So we go get the highest distributed-xid, but don't run
 * the recovery.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>recoverTM</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DTM_DEBUG3</name></expr></argument>, <argument><expr><literal type="string">"Starting to Recover DTM..."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We'd better terminate residual QE processes to avoid potential issues,
	 * e.g. shared snapshot collision, etc. We do soft-terminate here so it is
	 * still possible there are residual QE processes but it's better than doing
	 * nothing.
	 *
	 * We just do this when there was abnormal shutdown on master or standby
	 * promote, else mostly there should not have residual QE processes.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>shmCleanupBackends</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>TerminateMppBackends</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * attempt to recover all in-doubt transactions.
	 *
	 * first resolve all in-doubt transactions from the DTM's perspective and
	 * then resolve any remaining in-doubt transactions that the RMs have.
	 */</comment>
	<expr_stmt><expr><call><name>recoverInDoubtTransactions</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* finished recovery successfully. */</comment>
	<expr_stmt><expr><operator>*</operator><name>shmDtmStarted</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"DTM Started"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>SendPostmasterSignal</name><argument_list>(<argument><expr><name>PMSIGNAL_DTM_RECOVERED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * dtx recovery process won't exit, so signal postmaster to launch
	 * bg workers that depend on dtx recovery.
	 */</comment>
	<expr_stmt><expr><call><name>SendPostmasterSignal</name><argument_list>(<argument><expr><name>PMSIGNAL_BACKGROUND_WORKER_CHANGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* 
 * recoverInDoubtTransactions:
 * Go through all in-doubt transactions that the DTM knows about and
 * resolve them.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>recoverInDoubtTransactions</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HTAB</name>	   <modifier>*</modifier></type><name>htab</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DTM_DEBUG3</name></expr></argument>, <argument><expr><literal type="string">"recover in-doubt distributed transactions"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * For each committed transaction found in the redo pass that was not
	 * matched by a forget committed record, change its state indicating
	 * committed notification needed.  Attempt a notification.
	 */</comment>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DTM_DEBUG5</name></expr></argument>,
		 <argument><expr><literal type="string">"Going to retry commit notification for distributed transactions (count = %d)"</literal></expr></argument>,
		 <argument><expr><operator>*</operator><name>shmNumCommittedGxacts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <operator>*</operator><name>shmNumCommittedGxacts</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>DistributedTransactionId</name></type> <name>gxid</name> <init>= <expr><name><name>shmCommittedGxidArray</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name></type> <name><name>gid</name><index>[<expr><name>TMGIDSIZE</name></expr>]</index></name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>gxid</name> <operator>!=</operator> <name>InvalidDistributedTransactionId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>dtxFormGid</name><argument_list>(<argument><expr><name>gid</name></expr></argument>, <argument><expr><name>gxid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DTM_DEBUG5</name></expr></argument>,
			 <argument><expr><literal type="string">"Recovering committed distributed transaction gid = %s"</literal></expr></argument>, <argument><expr><name>gid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>doNotifyCommittedInDoubt</name><argument_list>(<argument><expr><name>gid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>RecordDistributedForgetCommitted</name><argument_list>(<argument><expr><name>gxid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><operator>*</operator><name>shmNumCommittedGxacts</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * Any in-doubt transctions found will be for aborted
	 * transactions. Gather in-doubt transactions and issue aborts.
	 */</comment>
	<expr_stmt><expr><name>htab</name> <operator>=</operator> <call><name>gatherRMInDoubtTransactions</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * go through and resolve any remaining in-doubt transactions that the
	 * RM's have AFTER recoverDTMInDoubtTransactions.  ALL of these in doubt
	 * transactions will be ABORT'd.  The fact that the DTM doesn't know about
	 * them means that something bad happened before everybody voted to
	 * COMMIT.
	 */</comment>
	<expr_stmt><expr><call><name>abortRMInDoubtTransactions</name><argument_list>(<argument><expr><name>htab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* get rid of the hashtable */</comment>
	<expr_stmt><expr><call><name>hash_destroy</name><argument_list>(<argument><expr><name>htab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * TerminateMppBackends:
 * Try to terminates all mpp backend processes.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>TerminateMppBackends</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CdbPgResults</name></type> <name>term_cdb_pgresults</name> <init>= <expr><block>{<expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>term_buf</name> <init>= <expr><literal type="string">"select * from gp_terminate_mpp_backends()"</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<expr_stmt><expr><call><name>CdbDispatchCommand</name><argument_list>(<argument><expr><name>term_buf</name></expr></argument>, <argument><expr><name>DF_NONE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>term_cdb_pgresults</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<expr_stmt><expr><call><name>FlushErrorState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>DisconnectAndDestroyAllGangs</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>cdbdisp_clearCdbPgResults</name><argument_list>(<argument><expr><operator>&amp;</operator><name>term_cdb_pgresults</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * gatherRMInDoubtTransactions:
 * Builds a hashtable of all of the in-doubt transactions that exist on the
 * segment databases.  The hashtable basically just serves as a single list
 * without duplicates of all the in-doubt transactions.  It does not keep track
 * of which seg db's have which transactions in-doubt.  It currently doesn't
 * need to due to the way we handle this information later.
 *
 * Parameter prepared_seconds: Gather prepared transactions which have
 * existed for at least prepared_seconds seconds.
 * Parameter raiseError: if true, rethrow the error else ignore it.
 */</comment>
<function><type><specifier>static</specifier> <name>HTAB</name> <modifier>*</modifier></type>
<name>gatherRMInDoubtTransactions</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>prepared_seconds</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>raiseError</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CdbPgResults</name></type> <name>cdb_pgresults</name> <init>= <expr><block>{<expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>rs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>cmdbuf</name><index>[<expr><literal type="number">256</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>InDoubtDtx</name> <modifier>*</modifier></type><name>lastDtx</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>HASHCTL</name></type>		<name>hctl</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HTAB</name>	   <modifier>*</modifier></type><name>htab</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
				<decl><type ref="prev"/><name>j</name></decl>,
				<decl><type ref="prev"/><name>rows</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>cmdbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>cmdbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"select gid from pg_prepared_xacts where "</literal>
			 <literal type="string">"prepared &lt; now() - interval'%d seconds'"</literal></expr></argument>,
			 <argument><expr><name>prepared_seconds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<expr_stmt><expr><call><name>CdbDispatchCommand</name><argument_list>(<argument><expr><name>cmdbuf</name></expr></argument>, <argument><expr><name>DF_NONE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cdb_pgresults</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<expr_stmt><expr><call><name>cdbdisp_clearCdbPgResults</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cdb_pgresults</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>raiseError</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>elog_demote</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"unable to demote an error"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>EmitErrorReport</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>FlushErrorState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>DisconnectAndDestroyAllGangs</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* if any result set is nonempty, there are in-doubt transactions. */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>cdb_pgresults</name><operator>.</operator><name>numResults</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>rs</name> <operator>=</operator> <name><name>cdb_pgresults</name><operator>.</operator><name>pg_results</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>rows</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>rs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>rows</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>gid</name></decl>;</decl_stmt>

			<comment type="block">/*
			 * we dont setup our hashtable until we know we have at least one
			 * in doubt transaction
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>htab</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* setup a hash table */</comment>
				<expr_stmt><expr><name><name>hctl</name><operator>.</operator><name>keysize</name></name> <operator>=</operator> <name>TMGIDSIZE</name></expr>;</expr_stmt>	<comment type="block">/* GID */</comment>
				<expr_stmt><expr><name><name>hctl</name><operator>.</operator><name>entrysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>InDoubtDtx</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

				<expr_stmt><expr><name>htab</name> <operator>=</operator> <call><name>hash_create</name><argument_list>(<argument><expr><literal type="string">"InDoubtDtxHash"</literal></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>hctl</name></expr></argument>, <argument><expr><name>HASH_ELEM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name>htab</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"DTM could not allocate hash table for InDoubtDtxList"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><name>gid</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>rs</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* now we can add entry to hash table */</comment>
			<expr_stmt><expr><name>lastDtx</name> <operator>=</operator> <operator>(</operator><name>InDoubtDtx</name> <operator>*</operator><operator>)</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>htab</name></expr></argument>, <argument><expr><name>gid</name></expr></argument>, <argument><expr><name>HASH_ENTER</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * only need to bother doing work if there isn't already an entry
			 * for our GID
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG3</name></expr></argument>, <argument><expr><literal type="string">"Found in-doubt transaction with GID: %s on remote RM"</literal></expr></argument>, <argument><expr><name>gid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name><name>lastDtx</name><operator>-&gt;</operator><name>gid</name></name></expr></argument>, <argument><expr><name>gid</name></expr></argument>, <argument><expr><name>TMGIDSIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>cdbdisp_clearCdbPgResults</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cdb_pgresults</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>htab</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * abortRMInDoubtTransactions:
 * Goes through all the InDoubtDtx's in the provided htab and ABORTs them
 * across all of the QEs by sending a ROLLBACK PREPARED.
 *
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>abortRMInDoubtTransactions</name><parameter_list>(<parameter><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>htab</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HASH_SEQ_STATUS</name></type> <name>status</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>InDoubtDtx</name> <modifier>*</modifier></type><name>entry</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>htab</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * now we have a nice hashtable full of in-doubt dtx's that we need to
	 * resolve.  so we'll use a nice big hammer to get this job done.  instead
	 * of keeping track of which QEs have a prepared txn to be aborted and
	 * which ones don't.  we just issue a ROLLBACK to all of them and ignore
	 * any pesky errors.  This is certainly not an elegant solution but is OK
	 * for now.
	 */</comment>
	<expr_stmt><expr><call><name>hash_seq_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>, <argument><expr><name>htab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><operator>(</operator><name>entry</name> <operator>=</operator> <operator>(</operator><name>InDoubtDtx</name> <operator>*</operator><operator>)</operator> <call><name>hash_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DTM_DEBUG3</name></expr></argument>, <argument><expr><literal type="string">"Aborting in-doubt transaction with gid = %s"</literal></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>gid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>doAbortInDoubt</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>gid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/*
 * abortOrphanedTransactions:
 * Goes through all the InDoubtDtx's in the provided htab and find orphaned
 * ones and then abort them.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>abortOrphanedTransactions</name><parameter_list>(<parameter><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>htab</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HASH_SEQ_STATUS</name></type> <name>status</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>InDoubtDtx</name> <modifier>*</modifier></type><name>entry</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DistributedTransactionId</name></type>	<name>gxid</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>htab</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>hash_seq_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>, <argument><expr><name>htab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><operator>(</operator><name>entry</name> <operator>=</operator> <operator>(</operator><name>InDoubtDtx</name> <operator>*</operator><operator>)</operator> <call><name>hash_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DTM_DEBUG3</name></expr></argument>, <argument><expr><literal type="string">"Finding orphaned transactions with gid = %s"</literal></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>gid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>dtxDeformGid</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>gid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>gxid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsDtxInProgress</name><argument_list>(<argument><expr><name>gxid</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Aborting orphaned transactions with gid = %s"</literal></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>gid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>doAbortInDoubt</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>gid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/*
 * Redo transaction commit log record.
 */</comment>
<function><type><name>void</name></type>
<name>redoDtxCheckPoint</name><parameter_list>(<parameter><decl><type><name>TMGXACT_CHECKPOINT</name> <modifier>*</modifier></type><name>gxact_checkpoint</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>committedCount</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * For checkpoint same as REDO, lets add entries to file in utility and
	 * in-memory if Dispatch.
	 */</comment>
	<expr_stmt><expr><name>committedCount</name> <operator>=</operator> <name><name>gxact_checkpoint</name><operator>-&gt;</operator><name>committedCount</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DTM_DEBUG5</name></expr></argument>, <argument><expr><literal type="string">"redoDtxCheckPoint has committedCount = %d"</literal></expr></argument>, <argument><expr><name>committedCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>committedCount</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>redoDistributedCommitRecord</name><argument_list>(<argument><expr><name><name>gxact_checkpoint</name><operator>-&gt;</operator><name>committedGxidArray</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></function>

<comment type="block">/*
 * Redo transaction commit log record.
 */</comment>
<function><type><name>void</name></type>
<name>redoDistributedCommitRecord</name><parameter_list>(<parameter><decl><type><name>DistributedTransactionId</name></type> <name>gxid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <operator>*</operator><name>shmNumCommittedGxacts</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>gxid</name> <operator>==</operator> <name><name>shmCommittedGxidArray</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return;</return></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <operator>*</operator><name>shmNumCommittedGxacts</name></expr>)</condition>
	<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FAULT_INJECTOR</name></cpp:ifdef>
		<if_stmt><if>if <condition>(<expr><call><name>SIMPLE_FAULT_INJECTOR</name><argument_list>(<argument><expr><literal type="string">"standby_gxacts_overflow"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>FaultInjectorTypeSkip</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>max_tm_gxacts</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Committed gid array length: %d"</literal></expr></argument>, <argument><expr><operator>*</operator><name>shmNumCommittedGxacts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

		<comment type="block">/*
		 * Transaction not found, this is the first log of this transaction.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>shmNumCommittedGxacts</name> <operator>&gt;=</operator> <name>max_tm_gxacts</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>StringInfoData</name></type> <name>gxact_array</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>gxact_array</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<for>for <control>(<init><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <operator>*</operator><name>shmNumCommittedGxacts</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>gxact_array</name></expr></argument>, <argument><expr><literal type="string">"shmCommittedGxactArray[%d]: "</literal><name>UINT64_FORMAT</name><literal type="string">"\n"</literal></expr></argument>,
					<argument><expr><name>j</name></expr></argument>, <argument><expr><name><name>shmCommittedGxidArray</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></for>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"the limit of %d distributed transactions has been reached "</literal>\
							<literal type="string">"while adding gid = "</literal><name>UINT64_FORMAT</name><literal type="string">". Committed gid array length: %d, dump:\n%s"</literal></expr></argument>,
							<argument><expr><name>max_tm_gxacts</name></expr></argument>, <argument><expr><name>gxid</name></expr></argument>, <argument><expr><operator>*</operator><name>shmNumCommittedGxacts</name></expr></argument>, <argument><expr><name><name>gxact_array</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"It should not happen. Temporarily increase "</literal>
							   <literal type="string">"max_connections (need postmaster reboot) on "</literal>
							   <literal type="string">"the postgres (master or standby) to work "</literal>
							   <literal type="string">"around this issue and then report a bug"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name><name>shmCommittedGxidArray</name><index>[<expr><operator>(</operator><operator>*</operator><name>shmNumCommittedGxacts</name><operator>)</operator><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>gxid</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><operator>(</operator><ternary><condition><expr><name>Debug_print_full_dtm</name></expr> ?</condition><then> <expr><name>LOG</name></expr> </then><else>: <expr><name>DEBUG5</name></expr></else></ternary><operator>)</operator></expr></argument>,
			 <argument><expr><literal type="string">"Crash recovery redo added committed distributed transaction gid = "</literal><name>UINT64_FORMAT</name></expr></argument>, <argument><expr><name>gxid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Redo transaction forget commit log record.
 */</comment>
<function><type><name>void</name></type>
<name>redoDistributedForgetCommitRecord</name><parameter_list>(<parameter><decl><type><name>DistributedTransactionId</name></type> <name>gxid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <operator>*</operator><name>shmNumCommittedGxacts</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>gxid</name> <operator>==</operator> <name><name>shmCommittedGxidArray</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* found an active global transaction */</comment>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><operator>(</operator><ternary><condition><expr><name>Debug_print_full_dtm</name></expr> ?</condition><then> <expr><name>INFO</name></expr> </then><else>: <expr><name>DEBUG5</name></expr></else></ternary><operator>)</operator></expr></argument>,
				 <argument><expr><literal type="string">"Crash recovery redo removed committed distributed transaction gid = "</literal><name>UINT64_FORMAT</name><literal type="string">" for forget"</literal></expr></argument>,
				 <argument><expr><name>gxid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * there's no concurrent access to shmCommittedGxidArray during
			 * recovery
			 */</comment>
			<expr_stmt><expr><operator>(</operator><operator>*</operator><name>shmNumCommittedGxacts</name><operator>)</operator><operator>--</operator></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>i</name> <operator>!=</operator> <operator>*</operator><name>shmNumCommittedGxacts</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>shmCommittedGxidArray</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>shmCommittedGxidArray</name><index>[<expr><operator>*</operator><name>shmNumCommittedGxacts</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<return>return;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><operator>(</operator><ternary><condition><expr><name>Debug_print_full_dtm</name></expr> ?</condition><then> <expr><name>WARNING</name></expr> </then><else>: <expr><name>DEBUG5</name></expr></else></ternary><operator>)</operator></expr></argument>,
		 <argument><expr><literal type="string">"Crash recovery redo did not find committed distributed transaction gid = "</literal><name>UINT64_FORMAT</name><literal type="string">" for forget"</literal></expr></argument>,
		 <argument><expr><name>gxid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>DtxRecoveryStartRule</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>main_arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><operator>(</operator><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>AbortOrphanedPreparedTransactions</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HTAB</name>	   <modifier>*</modifier></type><name>htab</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FAULT_INJECTOR</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><call><name>SIMPLE_FAULT_INJECTOR</name><argument_list>(<argument><expr><literal type="string">"before_orphaned_check"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>FaultInjectorTypeSkip</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><call><name>StartTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>htab</name> <operator>=</operator> <call><name>gatherRMInDoubtTransactions</name><argument_list>(<argument><expr><name>gp_dtx_recovery_prepared_period</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* in case an error happens somehow. */</comment>
	<if_stmt><if>if <condition>(<expr><name>htab</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>abortOrphanedTransactions</name><argument_list>(<argument><expr><name>htab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* get rid of the hashtable */</comment>
		<expr_stmt><expr><call><name>hash_destroy</name><argument_list>(<argument><expr><name>htab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>CommitTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>DisconnectAndDestroyAllGangs</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>SIMPLE_FAULT_INJECTOR</name><argument_list>(<argument><expr><literal type="string">"after_orphaned_check"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>sigIntHandler</name><parameter_list>(<parameter><decl><type><name>SIGNAL_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>frequent_check_times</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>frequent_check_times</name> <operator>=</operator> <name>MAX_FREQ_CHECK_TIMES</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>MyProc</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>SetLatch</name><argument_list>(<argument><expr><name>MyLatch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>sigHupHandler</name><parameter_list>(<parameter><decl><type><name>SIGNAL_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name>got_SIGHUP</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>MyProc</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>SetLatch</name><argument_list>(<argument><expr><name>MyLatch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>pid_t</name></type>
<name>DtxRecoveryPID</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><operator>*</operator><name>shmDtxRecoveryPid</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Note: Event functions may need lock shmDtxRecoveryEventLock. */</comment>

<function><type><name>void</name></type>
<name>SetDtxRecoveryEvent</name><parameter_list>(<parameter><decl><type><name>DtxRecoveryEvent</name></type> <name>event</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><operator>*</operator><name>shmDtxRecoveryEvents</name> <operator>|=</operator> <name>event</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>DtxRecoveryEvent</name></type>
<name>GetDtxRecoveryEvent</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><operator>*</operator><name>shmDtxRecoveryEvents</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ResetDtxRecoveryEvent</name><parameter_list>(<parameter><decl><type><name>DtxRecoveryEvent</name></type> <name>event</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><operator>*</operator><name>shmDtxRecoveryEvents</name> <operator>&amp;=</operator> <operator>~</operator><name>event</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * DtxRecoveryMain
 */</comment>
<function><type><name>void</name></type>
<name>DtxRecoveryMain</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>main_arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><operator>*</operator><name>shmDtxRecoveryPid</name> <operator>=</operator> <name>MyProcPid</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * reread postgresql.conf if requested
	 */</comment>
	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGHUP</name></expr></argument>, <argument><expr><name>sigHupHandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGINT</name></expr></argument>, <argument><expr><name>sigIntHandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* We're now ready to receive signals */</comment>
	<expr_stmt><expr><call><name>BackgroundWorkerUnblockSignals</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Connect to postgres */</comment>
	<expr_stmt><expr><call><name>BackgroundWorkerInitializeConnection</name><argument_list>(<argument><expr><name>DB_FOR_COMMON_ACCESS</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Do dtx recovery process.  It is possible that *shmDtmStarted is true
	 * here if we terminate after this code block, e.g. due to error and then
	 * postmaster restarts dtx recovery.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>*</operator><name>shmDtmStarted</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>set_ps_display</name><argument_list>(<argument><expr><literal type="string">"recovering"</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>StartTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>recoverTM</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CommitTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>DisconnectAndDestroyAllGangs</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>set_ps_display</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Fetch the gxid batch in advance. */</comment>
	<expr_stmt><expr><call><name>bumpGxid</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Normally we check with interval gp_dtx_recovery_interval, but sometimes
	 * we want to be more frequent in a period, e.g. just after master panic.
	 * We do not use a guc to control the period, instead hardcode 12 times
	 * with inteval 5 seconds simply.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>shmCleanupBackends</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>frequent_check_times</name> <operator>=</operator> <name>MAX_FREQ_CHECK_TIMES</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<while>while <condition>(<expr><name>true</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DtxRecoveryEvent</name></type> <name>event</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>got_SIGHUP</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>got_SIGHUP</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ProcessConfigFile</name><argument_list>(<argument><expr><name>PGC_SIGHUP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>event</name> <operator>=</operator> <call><name>GetDtxRecoveryEvent</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>event</name> <operator>&amp;</operator> <name>DTX_RECOVERY_EVENT_BUMP_GXID</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>bumpGxid</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><name>shmDtxRecoveryEventLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ResetDtxRecoveryEvent</name><argument_list>(<argument><expr><name>DTX_RECOVERY_EVENT_BUMP_GXID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><name>shmDtxRecoveryEventLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>event</name> <operator>&amp;</operator> <name>DTX_RECOVERY_EVENT_ABORT_PREPARED</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * We do not reset the event so far, but maybe do this later when
			 * we know there isn't distributed transaction to abort in normal
			 * cases so that it could respond promptly for gxid bumping given
			 * the abort operation might be time-consuming.
			 */</comment>
			<expr_stmt><expr><call><name>AbortOrphanedPreparedTransactions</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>WaitLatch</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>MyProc</name><operator>-&gt;</operator><name>procLatch</name></name></expr></argument>,
					   <argument><expr><name>WL_LATCH_SET</name> <operator>|</operator> <name>WL_TIMEOUT</name> <operator>|</operator> <name>WL_POSTMASTER_DEATH</name></expr></argument>,
					   <argument><expr><ternary><condition><expr><name>frequent_check_times</name> <operator>&gt;</operator> <literal type="number">0</literal></expr> ?</condition><then>
					   <expr><literal type="number">5</literal> <operator>*</operator> <literal type="number">1000L</literal></expr> </then><else>: <expr><name>gp_dtx_recovery_interval</name> <operator>*</operator> <literal type="number">1000L</literal></expr></else></ternary></expr></argument>,
					   <argument><expr><name>WAIT_EVENT_DTX_RECOVERY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ResetLatch</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>MyProc</name><operator>-&gt;</operator><name>procLatch</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* emergency bailout if postmaster has died */</comment>
		<if_stmt><if>if <condition>(<expr><name>rc</name> <operator>&amp;</operator> <name>WL_POSTMASTER_DEATH</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>proc_exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>frequent_check_times</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>frequent_check_times</name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></while>

	<comment type="block">/* One iteration done, go away */</comment>
	<expr_stmt><expr><call><name>proc_exit</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
