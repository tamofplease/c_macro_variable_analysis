<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/backend/cdb/dispatcher/cdbgang.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * cdbgang.c
 *	  Query Executor Factory for gangs of QEs
 *
 * Portions Copyright (c) 2005-2008, Greenplum inc
 * Portions Copyright (c) 2012-Present VMware, Inc. or its affiliates.
 *
 *
 * IDENTIFICATION
 *	    src/backend/cdb/dispatcher/cdbgang.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>			<comment type="block">/* MyProcPid */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgstat.h"</cpp:file></cpp:include>			<comment type="block">/* pgstat_report_sessionid() */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/namespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/variable.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/ip.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/execnodes.h"</cpp:file></cpp:include>	<comment type="block">/* CdbProcess, Slice, SliceTable */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/postmaster.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tcop/tcopprot.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/int8.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/sharedsnapshot.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tcop/pquery.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq-fe.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq-int.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbconn.h"</cpp:file></cpp:include>		<comment type="block">/* SegmentDatabaseDescriptor */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbfts.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbdisp.h"</cpp:file></cpp:include>		<comment type="block">/* me */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbdisp_query.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbgang.h"</cpp:file></cpp:include>		<comment type="block">/* me */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbgang_async.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbutil.h"</cpp:file></cpp:include>		<comment type="block">/* CdbComponentDatabaseInfo */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbvars.h"</cpp:file></cpp:include>		<comment type="block">/* Gp_role, etc. */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbconn.h"</cpp:file></cpp:include>		<comment type="block">/* cdbconn_* */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq/libpq-be.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/guc_tables.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"funcapi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>

<comment type="block">/*
 * All QEs are managed by cdb_component_dbs in QD, QD assigned
 * a unique identifier for each QE, when a QE is created, this
 * identifier is passed along with gpqeid params, see
 * cdbgang_parse_gpqeid_params()
 *
 * qe_identifier is use to go through slice table and find which slice
 * this QE should execute.
 */</comment>
<decl_stmt><decl><type><name>int</name></type>			<name>qe_identifier</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Number of primary segments on this host.
 * Note: This is only set on the segments and not on the coordinator. It is
 * used primarily by resource groups.
 */</comment>
<decl_stmt><decl><type><name>int</name></type>			<name>host_primary_segment_count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * size of hash table of interconnect connections
 * equals to 2 * (the number of total segments)
 */</comment>
<decl_stmt><decl><type><name>int</name></type>			<name>ic_htab_size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>Gang</name>      <modifier>*</modifier></type><name>CurrentGangCreating</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>CreateGangFunc</name></type> <name>pCreateGangFunc</name> <init>= <expr><name>cdbgang_createGang_async</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>NeedResetSession</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>Oid</name></type>	<name>OldTempNamespace</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * cdbgang_createGang:
 *
 * Creates a new gang by logging on a session to each segDB involved.
 *
 * call this function in GangContext memory context.
 * elog ERROR or return a non-NULL gang.
 */</comment>
<function><type><name>Gang</name> <modifier>*</modifier></type>
<name>cdbgang_createGang</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>segments</name></decl></parameter>, <parameter><decl><type><name>SegmentType</name></type> <name>segmentType</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>pCreateGangFunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>pCreateGangFunc</name><argument_list>(<argument><expr><name>segments</name></expr></argument>, <argument><expr><name>segmentType</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Creates a new gang by logging on a session to each segDB involved.
 *
 * elog ERROR or return a non-NULL gang.
 */</comment>
<function><type><name>Gang</name> <modifier>*</modifier></type>
<name>AllocateGang</name><parameter_list>(<parameter><decl><type><name>CdbDispatcherState</name> <modifier>*</modifier></type><name>ds</name></decl></parameter>, <parameter><decl><type><name>GangType</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>segments</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MemoryContext</name></type>	<name>oldContext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SegmentType</name></type> 	<name>segmentType</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Gang</name>			<modifier>*</modifier></type><name>newGang</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>				<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ELOG_DISPATCHER_DEBUG</name><argument_list>(<argument><expr><literal type="string">"AllocateGang begin."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>Gp_role</name> <operator>!=</operator> <name>GP_ROLE_DISPATCH</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"dispatch process called with role %d"</literal></expr></argument>, <argument><expr><name>Gp_role</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>segments</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>DispatcherContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>oldContext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>DispatcherContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>GANGTYPE_PRIMARY_WRITER</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>segmentType</name> <operator>=</operator> <name>SEGMENTTYPE_EXPLICT_WRITER</name></expr>;</expr_stmt></block_content></block></if>
	<comment type="block">/* for extended query like cursor, must specify a reader */</comment>
	<if type="elseif">else if <condition>(<expr><name><name>ds</name><operator>-&gt;</operator><name>isExtendedQuery</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>segmentType</name> <operator>=</operator> <name>SEGMENTTYPE_EXPLICT_READER</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>segmentType</name> <operator>=</operator> <name>SEGMENTTYPE_ANY</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name>newGang</name> <operator>=</operator> <call><name>cdbgang_createGang</name><argument_list>(<argument><expr><name>segments</name></expr></argument>, <argument><expr><name>segmentType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newGang</name><operator>-&gt;</operator><name>allocated</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newGang</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>type</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Push to the head of the allocated list, later in
	 * cdbdisp_destroyDispatcherState() we should recycle them from the head to
	 * restore the original order of the idle gangs.
	 */</comment>
	<expr_stmt><expr><name><name>ds</name><operator>-&gt;</operator><name>allocatedGangs</name></name> <operator>=</operator> <call><name>lcons</name><argument_list>(<argument><expr><name>newGang</name></expr></argument>, <argument><expr><name><name>ds</name><operator>-&gt;</operator><name>allocatedGangs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ds</name><operator>-&gt;</operator><name>largestGangSize</name></name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name><name>ds</name><operator>-&gt;</operator><name>largestGangSize</name></name></expr></argument>, <argument><expr><name><name>newGang</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ELOG_DISPATCHER_DEBUG</name><argument_list>(<argument><expr><literal type="string">"AllocateGang end."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>GANGTYPE_PRIMARY_WRITER</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * set "whoami" for utility statement. non-utility statement will
		 * overwrite it in function getCdbProcessList.
		 */</comment>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>newGang</name><operator>-&gt;</operator><name>size</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>cdbconn_setQEIdentifier</name><argument_list>(<argument><expr><name><name>newGang</name><operator>-&gt;</operator><name>db_descriptors</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>newGang</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Check the segment failure reason by comparing connection error message.
 */</comment>
<function><type><name>bool</name></type>
<name>segment_failure_due_to_recovery</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>error_message</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>fatal</name> <init>= <expr><name>NULL</name></expr></init></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>ptr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>fatal_len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>error_message</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>fatal</name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"FATAL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>fatal_len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>fatal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * it would be nice if we could check errcode for
	 * ERRCODE_CANNOT_CONNECT_NOW, instead we wind up looking for at the
	 * strings.
	 *
	 * And because if LC_MESSAGES gets set to something which changes the
	 * strings a lot we have to take extreme care with looking at the string.
	 */</comment>
	<expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name>strstr</name><argument_list>(<argument><expr><name>error_message</name></expr></argument>, <argument><expr><name>fatal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ptr</name> <operator>!=</operator> <name>NULL</name><operator>)</operator> <operator>&amp;&amp;</operator> <name><name>ptr</name><index>[<expr><name>fatal_len</name></expr>]</index></name> <operator>==</operator> <literal type="char">':'</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>strstr</name><argument_list>(<argument><expr><name>error_message</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><name>POSTMASTER_IN_RESET_MSG</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>strstr</name><argument_list>(<argument><expr><name>error_message</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><name>POSTMASTER_IN_STARTUP_MSG</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>strstr</name><argument_list>(<argument><expr><name>error_message</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><name>POSTMASTER_IN_RECOVERY_MSG</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* We could do retries for "sorry, too many clients already" here too */</comment>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Check if the segment failure is due to missing writer process on QE node. */</comment>
<function><type><name>bool</name></type>
<name>segment_failure_due_to_missing_writer</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>error_message</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>fatal</name> <init>= <expr><name>NULL</name></expr></init></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>ptr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>fatal_len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>error_message</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>fatal</name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"FATAL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>fatal_len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>fatal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name>strstr</name><argument_list>(<argument><expr><name>error_message</name></expr></argument>, <argument><expr><name>fatal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ptr</name> <operator>!=</operator> <name>NULL</name><operator>)</operator> <operator>&amp;&amp;</operator> <name><name>ptr</name><index>[<expr><name>fatal_len</name></expr>]</index></name> <operator>==</operator> <literal type="char">':'</literal> <operator>&amp;&amp;</operator>
		<call><name>strstr</name><argument_list>(<argument><expr><name>error_message</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><name>WRITER_IS_MISSING_MSG</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Reads the GP catalog tables and build a CdbComponentDatabases structure.
 * It then converts this to a Gang structure and initializes all the non-connection related fields.
 *
 * Call this function in GangContext.
 * Returns a not-null pointer.
 */</comment>
<function><type><name>Gang</name> <modifier>*</modifier></type>
<name>buildGangDefinition</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>segments</name></decl></parameter>, <parameter><decl><type><name>SegmentType</name></type> <name>segmentType</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Gang</name> <modifier>*</modifier></type><name>newGangDefinition</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>volatile</specifier> <name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>	<name>size</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>contentId</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>segments</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ELOG_DISPATCHER_DEBUG</name><argument_list>(<argument><expr><literal type="string">"buildGangDefinition:Starting %d qExec processes for gang"</literal></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name> <operator>==</operator> <name>DispatcherContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* allocate a gang */</comment>
	<expr_stmt><expr><name>newGangDefinition</name> <operator>=</operator> <operator>(</operator><name>Gang</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Gang</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newGangDefinition</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>GANGTYPE_UNALLOCATED</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newGangDefinition</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <name>size</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newGangDefinition</name><operator>-&gt;</operator><name>allocated</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newGangDefinition</name><operator>-&gt;</operator><name>db_descriptors</name></name> <operator>=</operator>
		<operator>(</operator><name>SegmentDatabaseDescriptor</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>size</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>SegmentDatabaseDescriptor</name><operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<comment type="block">/* initialize db_descriptors */</comment>
		<macro><name>foreach_with_count</name> <argument_list>(<argument>lc</argument>, <argument>segments</argument> , <argument>i</argument>)</argument_list></macro>
		<block>{<block_content>
			<expr_stmt><expr><name>contentId</name> <operator>=</operator> <call><name>lfirst_int</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>newGangDefinition</name><operator>-&gt;</operator><name>db_descriptors</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator>
						<call><name>cdbcomponent_allocateIdleQE</name><argument_list>(<argument><expr><name>contentId</name></expr></argument>, <argument><expr><name>segmentType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<expr_stmt><expr><name><name>newGangDefinition</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>RecycleGang</name><argument_list>(<argument><expr><name>newGangDefinition</name></expr></argument>, <argument><expr><name>true</name></expr></argument> <comment type="block">/* destroy */</comment>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ELOG_DISPATCHER_DEBUG</name><argument_list>(<argument><expr><literal type="string">"buildGangDefinition done"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>newGangDefinition</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Add one GUC to the option string.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>addOneOption</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>option</name></decl></parameter>, <parameter><decl><type><name>StringInfo</name></type> <name>diff</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>config_generic</name></name> <modifier>*</modifier></type><name>guc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>guc</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>guc</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>GUC_GPDB_NEED_SYNC</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<switch>switch <condition>(<expr><name><name>guc</name><operator>-&gt;</operator><name>vartype</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>PGC_BOOL</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name><name>struct</name> <name>config_bool</name></name> <modifier>*</modifier></type><name>bguc</name> <init>= <expr><operator>(</operator>struct <name>config_bool</name> <operator>*</operator><operator>)</operator> <name>guc</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>option</name></expr></argument>, <argument><expr><literal type="string">" -c %s=%s"</literal></expr></argument>, <argument><expr><name><name>guc</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><ternary><condition><expr><operator>(</operator><name><name>bguc</name><operator>-&gt;</operator><name>reset_val</name></name><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">"true"</literal></expr> </then><else>: <expr><literal type="string">"false"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>bguc</name><operator>-&gt;</operator><name>reset_val</name></name> <operator>!=</operator> <operator>*</operator><name><name>bguc</name><operator>-&gt;</operator><name>variable</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>diff</name></expr></argument>, <argument><expr><literal type="string">" %s=%s"</literal></expr></argument>, <argument><expr><name><name>guc</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><ternary><condition><expr><operator>*</operator><operator>(</operator><name><name>bguc</name><operator>-&gt;</operator><name>variable</name></name><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">"true"</literal></expr> </then><else>: <expr><literal type="string">"false"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<break>break;</break>
			</block_content>}</block>
		<case>case <expr><name>PGC_INT</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name><name>struct</name> <name>config_int</name></name> <modifier>*</modifier></type><name>iguc</name> <init>= <expr><operator>(</operator>struct <name>config_int</name> <operator>*</operator><operator>)</operator> <name>guc</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>option</name></expr></argument>, <argument><expr><literal type="string">" -c %s=%d"</literal></expr></argument>, <argument><expr><name><name>guc</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>iguc</name><operator>-&gt;</operator><name>reset_val</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>iguc</name><operator>-&gt;</operator><name>reset_val</name></name> <operator>!=</operator> <operator>*</operator><name><name>iguc</name><operator>-&gt;</operator><name>variable</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>diff</name></expr></argument>, <argument><expr><literal type="string">" %s=%d"</literal></expr></argument>, <argument><expr><name><name>guc</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><operator>*</operator><name><name>iguc</name><operator>-&gt;</operator><name>variable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<break>break;</break>
			</block_content>}</block>
		<case>case <expr><name>PGC_REAL</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name><name>struct</name> <name>config_real</name></name> <modifier>*</modifier></type><name>rguc</name> <init>= <expr><operator>(</operator>struct <name>config_real</name> <operator>*</operator><operator>)</operator> <name>guc</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>option</name></expr></argument>, <argument><expr><literal type="string">" -c %s=%f"</literal></expr></argument>, <argument><expr><name><name>guc</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>rguc</name><operator>-&gt;</operator><name>reset_val</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>rguc</name><operator>-&gt;</operator><name>reset_val</name></name> <operator>!=</operator> <operator>*</operator><name><name>rguc</name><operator>-&gt;</operator><name>variable</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>diff</name></expr></argument>, <argument><expr><literal type="string">" %s=%f"</literal></expr></argument>, <argument><expr><name><name>guc</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><operator>*</operator><name><name>rguc</name><operator>-&gt;</operator><name>variable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<break>break;</break>
			</block_content>}</block>
		<case>case <expr><name>PGC_STRING</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name><name>struct</name> <name>config_string</name></name> <modifier>*</modifier></type><name>sguc</name> <init>= <expr><operator>(</operator>struct <name>config_string</name> <operator>*</operator><operator>)</operator> <name>guc</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name> <init>= <expr><name><name>sguc</name><operator>-&gt;</operator><name>reset_val</name></name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>option</name></expr></argument>, <argument><expr><literal type="string">" -c %s="</literal></expr></argument>, <argument><expr><name><name>guc</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * All whitespace characters must be escaped. See
				 * pg_split_opts() in the backend.
				 */</comment>
				<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>str</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><call><name>isspace</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <name><name>str</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>option</name></expr></argument>, <argument><expr><literal type="char">'\\'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

					<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>option</name></expr></argument>, <argument><expr><name><name>str</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></for>
				<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>*</operator><name><name>sguc</name><operator>-&gt;</operator><name>variable</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>*</operator><name><name>sguc</name><operator>-&gt;</operator><name>variable</name></name></expr></init></decl>;</decl_stmt>
					<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>diff</name></expr></argument>, <argument><expr><literal type="string">" %s="</literal></expr></argument>, <argument><expr><name><name>guc</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>p</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><call><name>isspace</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <name><name>p</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>diff</name></expr></argument>, <argument><expr><literal type="char">'\\'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

						<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>diff</name></expr></argument>, <argument><expr><name><name>p</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></for>
				</block_content>}</block></if></if_stmt>
				<break>break;</break>
			</block_content>}</block>
		<case>case <expr><name>PGC_ENUM</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name><name>struct</name> <name>config_enum</name></name> <modifier>*</modifier></type><name>eguc</name> <init>= <expr><operator>(</operator>struct <name>config_enum</name> <operator>*</operator><operator>)</operator> <name>guc</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int</name></type>			<name>value</name> <init>= <expr><name><name>eguc</name><operator>-&gt;</operator><name>reset_val</name></name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name> <init>= <expr><call><name>config_enum_lookup_by_value</name><argument_list>(<argument><expr><name>eguc</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>option</name></expr></argument>, <argument><expr><literal type="string">" -c %s="</literal></expr></argument>, <argument><expr><name><name>guc</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * All whitespace characters must be escaped. See
				 * pg_split_opts() in the backend. (Not sure if an enum value
				 * can have whitespace, but let's be prepared.)
				 */</comment>
				<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>str</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><call><name>isspace</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <name><name>str</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>option</name></expr></argument>, <argument><expr><literal type="char">'\\'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

					<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>option</name></expr></argument>, <argument><expr><name><name>str</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></for>
				<if_stmt><if>if <condition>(<expr><name>value</name> <operator>!=</operator> <operator>*</operator><name><name>eguc</name><operator>-&gt;</operator><name>variable</name></name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>config_enum_lookup_by_value</name><argument_list>(<argument><expr><name>eguc</name></expr></argument>, <argument><expr><operator>*</operator><name><name>eguc</name><operator>-&gt;</operator><name>variable</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>diff</name></expr></argument>, <argument><expr><literal type="string">" %s="</literal></expr></argument>, <argument><expr><name><name>guc</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>p</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><call><name>isspace</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <name><name>p</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>diff</name></expr></argument>, <argument><expr><literal type="char">'\\'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

						<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>diff</name></expr></argument>, <argument><expr><name><name>p</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></for>
				</block_content>}</block></if></if_stmt>
				<break>break;</break>
			</block_content>}</block>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 * Add GUCs to option/diff_options string.
 *
 * `options` is a list of reset_val of the GUCs, not the GUC's current value.
 * `diff_options` is a list of the GUCs' current value. If the GUC is unchanged,
 * `diff_options` will omit it.
 *
 * In process_startup_options(), `options` is used to set the GUCs with
 * PGC_S_CLIENT as its guc source. Then, `diff_options` is used to set the GUCs
 * with PGC_S_SESSION as its guc source.
 *
 * With PGC_S_CLIENT, SetConfigOption() will set the GUC's reset_val
 * when processing `options`, so the reset_val of the involved GUCs on all QD
 * and QEs are the same.
 *
 * After applying `diff_options`, the GUCs' current value is set to the same
 * value as the QD and the reset_val of the GUC will not change.
 *
 * At last, both the reset_val and current value of the GUC are consistent,
 * even after RESET.
 *
 * See addOneOption() and process_startup_options() for more details.
 */</comment>
<function><type><name>void</name></type>
<name>makeOptions</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>options</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>diff_options</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>config_generic</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>gucs</name> <init>= <expr><call><name>get_guc_variables</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ngucs</name> <init>= <expr><call><name>get_num_guc_variables</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CdbComponentDatabaseInfo</name> <modifier>*</modifier></type><name>qdinfo</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>optionsStr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>diffStr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>optionsStr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>diffStr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>qdinfo</name> <operator>=</operator> <call><name>cdbcomponent_getComponentInfo</name><argument_list>(<argument><expr><name>MASTER_CONTENT_ID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>optionsStr</name></expr></argument>, <argument><expr><literal type="string">" -c gp_qd_hostname=%s"</literal></expr></argument>, <argument><expr><name><name>qdinfo</name><operator>-&gt;</operator><name>config</name><operator>-&gt;</operator><name>hostip</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>optionsStr</name></expr></argument>, <argument><expr><literal type="string">" -c gp_qd_port=%d"</literal></expr></argument>, <argument><expr><name><name>qdinfo</name><operator>-&gt;</operator><name>config</name><operator>-&gt;</operator><name>port</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ngucs</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name><name>struct</name> <name>config_generic</name></name> <modifier>*</modifier></type><name>guc</name> <init>= <expr><name><name>gucs</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>guc</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>GUC_GPDB_NEED_SYNC</name><operator>)</operator> <operator>&amp;&amp;</operator>
			<operator>(</operator><name><name>guc</name><operator>-&gt;</operator><name>context</name></name> <operator>==</operator> <name>PGC_USERSET</name> <operator>||</operator>
			 <name><name>guc</name><operator>-&gt;</operator><name>context</name></name> <operator>==</operator> <name>PGC_BACKEND</name> <operator>||</operator>
			 <call><name>IsAuthenticatedUserSuperUser</name><argument_list>()</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>addOneOption</name><argument_list>(<argument><expr><operator>&amp;</operator><name>optionsStr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>diffStr</name></expr></argument>, <argument><expr><name>guc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><operator>*</operator><name>options</name> <operator>=</operator> <name><name>optionsStr</name><operator>.</operator><name>data</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>diff_options</name> <operator>=</operator> <name><name>diffStr</name><operator>.</operator><name>data</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * build_gpqeid_param
 *
 * Called from the qDisp process to create the "gpqeid" parameter string
 * to be passed to a qExec that is being started.  NB: Can be called in a
 * thread, so mustn't use palloc/elog/ereport/etc.
 */</comment>
<function><type><name>bool</name></type>
<name>build_gpqeid_param</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>bufsz</name></decl></parameter>,
				   <parameter><decl><type><name>bool</name></type> <name>is_writer</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>identifier</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>hostSegs</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>icHtabSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>		<name>len</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_INT64_TIMESTAMP</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TIMESTAMP_FORMAT</name></cpp:macro> <cpp:value>INT64_FORMAT</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>_WIN32</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TIMESTAMP_FORMAT</name></cpp:macro> <cpp:value>"%.14a"</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TIMESTAMP_FORMAT</name></cpp:macro> <cpp:value>"%g"</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>bufsz</name></expr></argument>, <argument><expr><literal type="string">"%d;"</literal> <name>TIMESTAMP_FORMAT</name> <literal type="string">";%s;%d;%d;%d"</literal></expr></argument>,
				   <argument><expr><name>gp_session_id</name></expr></argument>, <argument><expr><name>PgStartTime</name></expr></argument>,
				   <argument><expr><operator>(</operator><ternary><condition><expr><name>is_writer</name></expr> ?</condition><then> <expr><literal type="string">"true"</literal></expr> </then><else>: <expr><literal type="string">"false"</literal></expr></else></ternary><operator>)</operator></expr></argument>, <argument><expr><name>identifier</name></expr></argument>, <argument><expr><name>hostSegs</name></expr></argument>, <argument><expr><name>icHtabSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>len</name> <operator>&lt;</operator> <name>bufsz</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>gpqeid_next_param</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>cpp</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>npp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><operator>*</operator><name>cpp</name> <operator>=</operator> <operator>*</operator><name>npp</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>*</operator><name>cpp</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><operator>*</operator><name>npp</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><operator>*</operator><name>npp</name></expr></argument>, <argument><expr><literal type="char">';'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>npp</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><operator>*</operator><name>npp</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
		<expr_stmt><expr><operator>++</operator><operator>*</operator><name>npp</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * cdbgang_parse_gpqeid_params
 *
 * Called very early in backend initialization, to interpret the "gpqeid"
 * parameter value that a qExec receives from its qDisp.
 *
 * At this point, client authentication has not been done; the backend
 * command line options have not been processed; GUCs have the settings
 * inherited from the postmaster; etc; so don't try to do too much in here.
 */</comment>
<decl_stmt><decl><type><name>void</name></type>
<name>cdbgang_parse_gpqeid_params</name><argument_list>(<argument><expr>struct <name>Port</name> <operator>*</operator><name>port</name> <call><name>pg_attribute_unused</name><argument_list>()</argument_list></call></expr></argument>,
							<argument><expr><specifier>const</specifier> <name>char</name> <operator>*</operator><name>gpqeid_value</name></expr></argument>)</argument_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>gpqeid</name> <init>= <expr><call><name>pstrdup</name><argument_list>(<argument><expr><name>gpqeid_value</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>cp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>np</name> <init>= <expr><name>gpqeid</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* gp_session_id */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>gpqeid_next_param</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>np</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><literal type="string">"gp_session_id"</literal></expr></argument>, <argument><expr><name>cp</name></expr></argument>, <argument><expr><name>PGC_POSTMASTER</name></expr></argument>, <argument><expr><name>PGC_S_OVERRIDE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* PgStartTime */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>gpqeid_next_param</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>np</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_INT64_TIMESTAMP</name></cpp:ifdef>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>scanint8</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>PgStartTime</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>bad</name>;</goto></block_content></block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		<expr_stmt><expr><name>PgStartTime</name> <operator>=</operator> <call><name>strtod</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Gp_is_writer */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>gpqeid_next_param</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>np</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><literal type="string">"gp_is_writer"</literal></expr></argument>, <argument><expr><name>cp</name></expr></argument>, <argument><expr><name>PGC_POSTMASTER</name></expr></argument>, <argument><expr><name>PGC_S_OVERRIDE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* qe_identifier */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>gpqeid_next_param</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>np</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>qe_identifier</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <call><name>strtol</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>gpqeid_next_param</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>np</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>host_primary_segment_count</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <call><name>strtol</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>gpqeid_next_param</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>np</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>ic_htab_size</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <call><name>strtol</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Too few items, or too many? */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>cp</name> <operator>||</operator> <name>np</name></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>bad</name>;</goto></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>gp_session_id</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <name>PgStartTime</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <name>qe_identifier</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator>
		<name>host_primary_segment_count</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <name>ic_htab_size</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>bad</name>;</goto></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>gpqeid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return;</return>

<label><name>bad</name>:</label>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"Segment dispatched with invalid option: 'gpqeid=%s'"</literal></expr></argument>, <argument><expr><name>gpqeid_value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt>

<function><type><name><name>struct</name> <name>SegmentDatabaseDescriptor</name></name> <modifier>*</modifier></type>
<name>getSegmentDescriptorFromGang</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Gang</name> <modifier>*</modifier></type><name>gp</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>seg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>gp</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>gp</name><operator>-&gt;</operator><name>size</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>gp</name><operator>-&gt;</operator><name>db_descriptors</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>segindex</name> <operator>==</operator> <name>seg</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name><name>gp</name><operator>-&gt;</operator><name>db_descriptors</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>CdbProcess</name> <modifier>*</modifier></type>
<name>makeCdbProcess</name><parameter_list>(<parameter><decl><type><name>SegmentDatabaseDescriptor</name> <modifier>*</modifier></type><name>segdbDesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CdbProcess</name> <modifier>*</modifier></type><name>process</name> <init>= <expr><operator>(</operator><name>CdbProcess</name> <operator>*</operator><operator>)</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>CdbProcess</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CdbComponentDatabaseInfo</name> <modifier>*</modifier></type><name>qeinfo</name> <init>= <expr><name><name>segdbDesc</name><operator>-&gt;</operator><name>segment_database_info</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>qeinfo</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"required segment is unavailable"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>qeinfo</name><operator>-&gt;</operator><name>config</name><operator>-&gt;</operator><name>hostip</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"required segment IP is unavailable"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>process</name><operator>-&gt;</operator><name>listenerAddr</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name><name>qeinfo</name><operator>-&gt;</operator><name>config</name><operator>-&gt;</operator><name>hostip</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>Gp_interconnect_type</name> <operator>==</operator> <name>INTERCONNECT_TYPE_UDPIFC</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>process</name><operator>-&gt;</operator><name>listenerPort</name></name> <operator>=</operator> <operator>(</operator><name><name>segdbDesc</name><operator>-&gt;</operator><name>motionListener</name></name> <operator>&gt;&gt;</operator> <literal type="number">16</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x0ffff</literal></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>Gp_interconnect_type</name> <operator>==</operator> <name>INTERCONNECT_TYPE_TCP</name> <operator>||</operator>
			 <name>Gp_interconnect_type</name> <operator>==</operator> <name>INTERCONNECT_TYPE_PROXY</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>process</name><operator>-&gt;</operator><name>listenerPort</name></name> <operator>=</operator> <operator>(</operator><name><name>segdbDesc</name><operator>-&gt;</operator><name>motionListener</name></name> <operator>&amp;</operator> <literal type="number">0x0ffff</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>process</name><operator>-&gt;</operator><name>pid</name></name> <operator>=</operator> <name><name>segdbDesc</name><operator>-&gt;</operator><name>backendPid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>process</name><operator>-&gt;</operator><name>contentid</name></name> <operator>=</operator> <name><name>segdbDesc</name><operator>-&gt;</operator><name>segindex</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>process</name><operator>-&gt;</operator><name>dbid</name></name> <operator>=</operator> <name><name>qeinfo</name><operator>-&gt;</operator><name>config</name><operator>-&gt;</operator><name>dbid</name></name></expr>;</expr_stmt>
	<return>return <expr><name>process</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Create a list of CdbProcess and initialize with Gang information.
 *
 * 1) For primary reader gang and primary writer gang, the elements
 * in this list is order by segment index.
 * 2) For entry DB gang and singleton gang, the list length is 1.
 *
 * @directDispatch: might be null
 */</comment>
<function><type><name>void</name></type>
<name>setupCdbProcessList</name><parameter_list>(<parameter><decl><type><name>ExecSlice</name> <modifier>*</modifier></type><name>slice</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Gang</name>		<modifier>*</modifier></type><name>gang</name> <init>= <expr><name><name>slice</name><operator>-&gt;</operator><name>primaryGang</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ELOG_DISPATCHER_DEBUG</name><argument_list>(<argument><expr><literal type="string">"getCdbProcessList slice%d gangtype=%d gangsize=%d"</literal></expr></argument>,
						  <argument><expr><name><name>slice</name><operator>-&gt;</operator><name>sliceIndex</name></name></expr></argument>, <argument><expr><name><name>gang</name><operator>-&gt;</operator><name>type</name></name></expr></argument>, <argument><expr><name><name>gang</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>gang</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>gang</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>GANGTYPE_PRIMARY_WRITER</name> <operator>||</operator>
		   <name><name>gang</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>GANGTYPE_PRIMARY_READER</name> <operator>||</operator>
		   <operator>(</operator><name><name>gang</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>GANGTYPE_ENTRYDB_READER</name> <operator>&amp;&amp;</operator> <name><name>gang</name><operator>-&gt;</operator><name>size</name></name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator> <operator>||</operator>
		   <operator>(</operator><name><name>gang</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>GANGTYPE_SINGLETON_READER</name> <operator>&amp;&amp;</operator> <name><name>gang</name><operator>-&gt;</operator><name>size</name></name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>


	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>gang</name><operator>-&gt;</operator><name>size</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SegmentDatabaseDescriptor</name> <modifier>*</modifier></type><name>segdbDesc</name> <init>= <expr><name><name>gang</name><operator>-&gt;</operator><name>db_descriptors</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>CdbProcess</name> <modifier>*</modifier></type><name>process</name> <init>= <expr><call><name>makeCdbProcess</name><argument_list>(<argument><expr><name>segdbDesc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>cdbconn_setQEIdentifier</name><argument_list>(<argument><expr><name>segdbDesc</name></expr></argument>, <argument><expr><name><name>slice</name><operator>-&gt;</operator><name>sliceIndex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>slice</name><operator>-&gt;</operator><name>primaryProcesses</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>slice</name><operator>-&gt;</operator><name>primaryProcesses</name></name></expr></argument>, <argument><expr><name>process</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>slice</name><operator>-&gt;</operator><name>processesMap</name></name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name><name>slice</name><operator>-&gt;</operator><name>processesMap</name></name></expr></argument>, <argument><expr><name><name>segdbDesc</name><operator>-&gt;</operator><name>identifier</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ELOG_DISPATCHER_DEBUG</name><argument_list>(<argument><expr><literal type="string">"Gang assignment: slice%d seg%d %s:%d pid=%d"</literal></expr></argument>,
							  <argument><expr><name><name>slice</name><operator>-&gt;</operator><name>sliceIndex</name></name></expr></argument>, <argument><expr><name><name>process</name><operator>-&gt;</operator><name>contentid</name></name></expr></argument>,
							  <argument><expr><name><name>process</name><operator>-&gt;</operator><name>listenerAddr</name></name></expr></argument>, <argument><expr><name><name>process</name><operator>-&gt;</operator><name>listenerPort</name></name></expr></argument>,
							  <argument><expr><name><name>process</name><operator>-&gt;</operator><name>pid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * getCdbProcessForQD:	Manufacture a CdbProcess representing the QD,
 * as if it were a worker from the executor factory.
 *
 * NOTE: Does not support multiple (mirrored) QDs.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>getCdbProcessesForQD</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>isPrimary</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>list</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>CdbComponentDatabaseInfo</name> <modifier>*</modifier></type><name>qdinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CdbProcess</name> <modifier>*</modifier></type><name>proc</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isPrimary</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"getCdbProcessesForQD: unsupported request for master mirror process"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>qdinfo</name> <operator>=</operator> <call><name>cdbcomponent_getComponentInfo</name><argument_list>(<argument><expr><name>MASTER_CONTENT_ID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>qdinfo</name><operator>-&gt;</operator><name>config</name><operator>-&gt;</operator><name>segindex</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>SEGMENT_IS_ACTIVE_PRIMARY</name><argument_list>(<argument><expr><name>qdinfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>qdinfo</name><operator>-&gt;</operator><name>config</name><operator>-&gt;</operator><name>hostip</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>proc</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>CdbProcess</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Set QD listener address to the ADDRESS of the master, so the motions that connect to
	 * the master knows what the interconnect address of the peer is.
	 */</comment>
	<expr_stmt><expr><name><name>proc</name><operator>-&gt;</operator><name>listenerAddr</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name><name>qdinfo</name><operator>-&gt;</operator><name>config</name><operator>-&gt;</operator><name>hostip</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>Gp_interconnect_type</name> <operator>==</operator> <name>INTERCONNECT_TYPE_UDPIFC</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>proc</name><operator>-&gt;</operator><name>listenerPort</name></name> <operator>=</operator> <operator>(</operator><name>Gp_listener_port</name> <operator>&gt;&gt;</operator> <literal type="number">16</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x0ffff</literal></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>Gp_interconnect_type</name> <operator>==</operator> <name>INTERCONNECT_TYPE_TCP</name> <operator>||</operator>
			 <name>Gp_interconnect_type</name> <operator>==</operator> <name>INTERCONNECT_TYPE_PROXY</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>proc</name><operator>-&gt;</operator><name>listenerPort</name></name> <operator>=</operator> <operator>(</operator><name>Gp_listener_port</name> <operator>&amp;</operator> <literal type="number">0x0ffff</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>proc</name><operator>-&gt;</operator><name>pid</name></name> <operator>=</operator> <name>MyProcPid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>proc</name><operator>-&gt;</operator><name>contentid</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>proc</name><operator>-&gt;</operator><name>dbid</name></name> <operator>=</operator> <name><name>qdinfo</name><operator>-&gt;</operator><name>config</name><operator>-&gt;</operator><name>dbid</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name>list</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>proc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>list</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * This function should not be used in the context of named portals
 * as it destroys the CdbComponentsContext, which is accessed later
 * during named portal cleanup.
 */</comment>
<function><type><name>void</name></type>
<name>DisconnectAndDestroyAllGangs</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>resetSession</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_UTILITY</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>ELOG_DISPATCHER_DEBUG</name><argument_list>(<argument><expr><literal type="string">"DisconnectAndDestroyAllGangs"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Destroy CurrentGangCreating before GangContext is reset */</comment>
    <if_stmt><if>if <condition>(<expr><name>CurrentGangCreating</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>RecycleGang</name><argument_list>(<argument><expr><name>CurrentGangCreating</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>CurrentGangCreating</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

	<comment type="block">/* cleanup all out bound dispatcher state */</comment>
	<expr_stmt><expr><call><name>CdbResourceOwnerWalker</name><argument_list>(<argument><expr><name>CurrentResourceOwner</name></expr></argument>, <argument><expr><name>cdbdisp_cleanupDispatcherHandle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	
	<comment type="block">/* destroy cdb_component_dbs, disconnect all connections with QEs */</comment>
	<expr_stmt><expr><call><name>cdbcomponent_destroyCdbComponents</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>resetSession</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>resetSessionForPrimaryGangLoss</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>ELOG_DISPATCHER_DEBUG</name><argument_list>(<argument><expr><literal type="string">"DisconnectAndDestroyAllGangs done"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Destroy all idle (i.e available) QEs.
 * It is always safe to get rid of the reader QEs.
 *
 * call only from an idle session.
 */</comment>
<function><type><name>void</name></type> <name>DisconnectAndDestroyUnusedQEs</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Only release reader gangs, never writer gang. This helps to avoid the
	 * shared snapshot collision error on next gang creation from hitting if
	 * QE processes are slow to exit due to this cleanup.
	 *
	 * If we are in a transaction, we can't release the writer gang also, as
	 * this will abort the transaction.
	 *
	 * If we have a TempNameSpace, we can't release the writer gang also, as
	 * this would drop any temp tables we own.
	 *
	 * Since we are idle, any reader gangs will be available but not
	 * allocated.
	 */</comment>
	<expr_stmt><expr><call><name>cdbcomponent_cleanupIdleQEs</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Drop any temporary tables associated with the current session and
 * use a new session id since we have effectively reset the session.
 */</comment>
<function><type><name>void</name></type>
<name>GpDropTempTables</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>oldSessionId</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>newSessionId</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>dropTempNamespaceOid</name></decl>;</decl_stmt>

	<comment type="block">/* No need to reset session or drop temp tables */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>NeedResetSession</name> <operator>&amp;&amp;</operator> <name>OldTempNamespace</name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Do the session id change early. */</comment>
	<if_stmt><if>if <condition>(<expr><name>NeedResetSession</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* If we have gangs, we can't change our session ID. */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>cdbcomponent_qesExist</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>oldSessionId</name> <operator>=</operator> <name>gp_session_id</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ProcNewMppSessionId</name><argument_list>(<argument><expr><operator>&amp;</operator><name>newSessionId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>gp_session_id</name> <operator>=</operator> <name>newSessionId</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>gp_command_count</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pgstat_report_sessionid</name><argument_list>(<argument><expr><name>newSessionId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Update the slotid for our singleton reader. */</comment>
		<if_stmt><if>if <condition>(<expr><name>SharedLocalSnapshotSlot</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name><name>SharedLocalSnapshotSlot</name><operator>-&gt;</operator><name>slotLock</name></name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>SharedLocalSnapshotSlot</name><operator>-&gt;</operator><name>slotid</name></name> <operator>=</operator> <name>gp_session_id</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name><name>SharedLocalSnapshotSlot</name><operator>-&gt;</operator><name>slotLock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"The previous session was reset because its gang was disconnected (session id = %d). "</literal>
			 <literal type="string">"The new session id = %d"</literal></expr></argument>, <argument><expr><name>oldSessionId</name></expr></argument>, <argument><expr><name>newSessionId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * When it's in transaction block, need to bump the session id, e.g. retry COMMIT PREPARED,
	 * but defer drop temp table to the main loop in PostgresMain().
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsTransactionOrTransactionBlock</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>NeedResetSession</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>dropTempNamespaceOid</name> <operator>=</operator> <name>OldTempNamespace</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>OldTempNamespace</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>NeedResetSession</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>dropTempNamespaceOid</name> <operator>!=</operator> <name>InvalidOid</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<block>{<block_content>
			<expr_stmt><expr><call><name>DropTempTableNamespaceForResetSession</name><argument_list>(<argument><expr><name>dropTempNamespaceOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block> <expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<block>{<block_content>
			<comment type="block">/*
			 * But first demote the error to something much less scary.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>elog_demote</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"unable to demote error"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>EmitErrorReport</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>FlushErrorState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block> <expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>resetSessionForPrimaryGangLoss</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>ProcCanSetMppSessionId</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Not too early.
		 */</comment>
		<expr_stmt><expr><name>NeedResetSession</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Keep this check away from transaction/catalog access, as we are
		 * possibly just after releasing ResourceOwner at the end of Tx. It's
		 * ok to remember uncommitted temporary namespace because
		 * DropTempTableNamespaceForResetSession will simply do nothing if the
		 * namespace is not visible.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>TempNamespaceOidIsValid</name><argument_list>()</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Here we indicate we don't have a temporary table namespace
			 * anymore so all temporary tables of the previous session will be
			 * inaccessible.  Later, when we can start a new transaction, we
			 * will attempt to actually drop the old session tables to release
			 * the disk space.
			 */</comment>
			<expr_stmt><expr><name>OldTempNamespace</name> <operator>=</operator> <call><name>ResetTempNamespace</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
				 <argument><expr><literal type="string">"Any temporary tables for this session have been dropped "</literal>
				 <literal type="string">"because the gang was disconnected (session id = %d)"</literal></expr></argument>,
				 <argument><expr><name>gp_session_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>OldTempNamespace</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Helper functions
 */</comment>

<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>gangTypeToString</name><parameter_list>(<parameter><decl><type><name>GangType</name></type> <name>type</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ret</name> <init>= <expr><literal type="string">""</literal></expr></init></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><name>type</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>GANGTYPE_PRIMARY_WRITER</name></expr>:</case>
			<expr_stmt><expr><name>ret</name> <operator>=</operator> <literal type="string">"primary writer"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>GANGTYPE_PRIMARY_READER</name></expr>:</case>
			<expr_stmt><expr><name>ret</name> <operator>=</operator> <literal type="string">"primary reader"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>GANGTYPE_SINGLETON_READER</name></expr>:</case>
			<expr_stmt><expr><name>ret</name> <operator>=</operator> <literal type="string">"singleton reader"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>GANGTYPE_ENTRYDB_READER</name></expr>:</case>
			<expr_stmt><expr><name>ret</name> <operator>=</operator> <literal type="string">"entry DB reader"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>GANGTYPE_UNALLOCATED</name></expr>:</case>
			<expr_stmt><expr><name>ret</name> <operator>=</operator> <literal type="string">"unallocated"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>
	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>RecycleGang</name><parameter_list>(<parameter><decl><type><name>Gang</name> <modifier>*</modifier></type><name>gp</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>forceDestroy</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>gp</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>
	<comment type="block">/*
	 *
	 * Callers of RecycleGang should not throw ERRORs by design. This is
	 * because RecycleGang is not re-entrant: For example, an ERROR could be
	 * thrown whilst the gang's segdbDesc is already freed. This would cause
	 * RecycleGang to be called again during abort processing, giving rise to
	 * potential double freeing of the gang's segdbDesc.
	 *
	 * Thus, we hold off interrupts until the gang is fully cleaned here to prevent
	 * throwing an ERROR here.
	 *
	 * details See github issue: https://github.com/greenplum-db/gpdb/issues/13393
	 */</comment>
	<expr_stmt><expr><call><name>HOLD_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/*
	 * Loop through the segment_database_descriptors array and, for each
	 * SegmentDatabaseDescriptor: 1) discard the query results (if any), 2)
	 * disconnect the session, and 3) discard any connection error message.
	 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FAULT_INJECTOR</name></cpp:ifdef>
	<comment type="block">/*
	 * select * from gp_segment_configuration a, t13393,
	 * gp_segment_configuration b where a.dbid = t13393.tc1 limit 0;
	 *
	 * above sql has 3 gangs, the first and second gangtype is ENTRYDB_READER
	 * and the third gang is PRIMARY_READER, the second gang will be destroyed.
	 * inject an interrupt fault during RecycleGang PRIMARY_READER gang.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>gp</name><operator>-&gt;</operator><name>size</name></name> <operator>&gt;=</operator> <literal type="number">3</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>SIMPLE_FAULT_INJECTOR</name><argument_list>(<argument><expr><literal type="string">"cdbcomponent_recycle_idle_qe_error"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>gp</name><operator>-&gt;</operator><name>size</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SegmentDatabaseDescriptor</name> <modifier>*</modifier></type><name>segdbDesc</name> <init>= <expr><name><name>gp</name><operator>-&gt;</operator><name>db_descriptors</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>segdbDesc</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>cdbcomponent_recycleIdleQE</name><argument_list>(<argument><expr><name>segdbDesc</name></expr></argument>, <argument><expr><name>forceDestroy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>RESUME_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ResetAllGangs</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>DisconnectAndDestroyAllGangs</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>GpDropTempTables</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Used by gp_backend_info() to find a single character that represents a
 * backend type.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name></type>
<name>backend_type</name><parameter_list>(<parameter><decl><type><name>SegmentDatabaseDescriptor</name> <modifier>*</modifier></type><name>segdb</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>segdb</name><operator>-&gt;</operator><name>identifier</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* QD backend */</comment>
		<return>return <expr><literal type="char">'Q'</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>segdb</name><operator>-&gt;</operator><name>segindex</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Entry singleton reader. */</comment>
		<return>return <expr><literal type="char">'R'</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><operator>(</operator><ternary><condition><expr><name><name>segdb</name><operator>-&gt;</operator><name>isWriter</name></name></expr> ?</condition><then> <expr><literal type="char">'w'</literal></expr> </then><else>: <expr><literal type="char">'r'</literal></expr></else></ternary><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * qsort comparator for SegmentDatabaseDescriptors. Sorts by descriptor ID.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>compare_segdb_id</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>v1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>v2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SegmentDatabaseDescriptor</name> <modifier>*</modifier></type><name>d1</name> <init>= <expr><operator>(</operator><name>SegmentDatabaseDescriptor</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><operator>*</operator><operator>(</operator><name>ListCell</name> <operator>*</operator><operator>*</operator><operator>)</operator> <name>v1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SegmentDatabaseDescriptor</name> <modifier>*</modifier></type><name>d2</name> <init>= <expr><operator>(</operator><name>SegmentDatabaseDescriptor</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><operator>*</operator><operator>(</operator><name>ListCell</name> <operator>*</operator><operator>*</operator><operator>)</operator> <name>v2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><name><name>d1</name><operator>-&gt;</operator><name>identifier</name></name> <operator>-</operator> <name><name>d2</name><operator>-&gt;</operator><name>identifier</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Returns a list of rows, each corresponding to a connected segment backend and
 * containing information on the role and definition of that backend (e.g. host,
 * port, PID).
 *
 * SELECT * from gp_backend_info();
 */</comment>
<function><type><name>Datum</name></type>
<name>gp_backend_info</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>Gp_role</name> <operator>!=</operator> <name>GP_ROLE_DISPATCH</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_GP_COMMAND_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
			<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"gp_backend_info() could only be called on QD"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Our struct for funcctx-&gt;user_fctx. */</comment>
	<struct>struct <name>func_ctx</name>
	<block>{
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>segdbs</name></decl>;</decl_stmt>		<comment type="block">/* the SegmentDatabaseDescriptor entries we will output */</comment>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>curpos</name></decl>;</decl_stmt>		<comment type="block">/* pointer to our current position in .segdbs */</comment>
	}</block>;</struct>

	<decl_stmt><decl><type><name>FuncCallContext</name> <modifier>*</modifier></type><name>funcctx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>func_ctx</name></name> <modifier>*</modifier></type><name>user_fctx</name></decl>;</decl_stmt>

	<comment type="block">/* Number of attributes we'll return per row. Must match the catalog. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BACKENDINFO_NATTR</name></cpp:macro>    <cpp:value>6</cpp:value></cpp:define>

	<if_stmt><if>if <condition>(<expr><call><name>SRF_IS_FIRSTCALL</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Standard first-call setup. */</comment>
		<decl_stmt><decl><type><name>MemoryContext</name></type>         <name>oldcontext</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TupleDesc</name></type>             <name>tupdesc</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>CdbComponentDatabases</name> <modifier>*</modifier></type><name>cdbs</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>                   <name>i</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>funcctx</name>    <operator>=</operator> <call><name>SRF_FIRSTCALL_INIT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>funcctx</name><operator>-&gt;</operator><name>multi_call_memory_ctx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>funcctx</name><operator>-&gt;</operator><name>user_fctx</name></name> <operator>=</operator> <name>user_fctx</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>user_fctx</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Construct the list of all known segment DB descriptors. */</comment>
		<expr_stmt><expr><name>cdbs</name> <operator>=</operator> <call><name>cdbcomponent_getCdbComponents</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>cdbs</name><operator>-&gt;</operator><name>total_entry_dbs</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>CdbComponentDatabaseInfo</name> <modifier>*</modifier></type><name>cdbinfo</name> <init>= <expr><operator>&amp;</operator><name><name>cdbs</name><operator>-&gt;</operator><name>entry_db_info</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>user_fctx</name><operator>-&gt;</operator><name>segdbs</name></name> <operator>=</operator>
				<call><name>list_concat_unique_ptr</name><argument_list>(<argument><expr><name><name>user_fctx</name><operator>-&gt;</operator><name>segdbs</name></name></expr></argument>, <argument><expr><name><name>cdbinfo</name><operator>-&gt;</operator><name>activelist</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>user_fctx</name><operator>-&gt;</operator><name>segdbs</name></name> <operator>=</operator>
				<call><name>list_concat_unique_ptr</name><argument_list>(<argument><expr><name><name>user_fctx</name><operator>-&gt;</operator><name>segdbs</name></name></expr></argument>, <argument><expr><name><name>cdbinfo</name><operator>-&gt;</operator><name>freelist</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>cdbs</name><operator>-&gt;</operator><name>total_segment_dbs</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>CdbComponentDatabaseInfo</name> <modifier>*</modifier></type><name>cdbinfo</name> <init>= <expr><operator>&amp;</operator><name><name>cdbs</name><operator>-&gt;</operator><name>segment_db_info</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>user_fctx</name><operator>-&gt;</operator><name>segdbs</name></name> <operator>=</operator>
				<call><name>list_concat_unique_ptr</name><argument_list>(<argument><expr><name><name>user_fctx</name><operator>-&gt;</operator><name>segdbs</name></name></expr></argument>, <argument><expr><name><name>cdbinfo</name><operator>-&gt;</operator><name>activelist</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>user_fctx</name><operator>-&gt;</operator><name>segdbs</name></name> <operator>=</operator>
				<call><name>list_concat_unique_ptr</name><argument_list>(<argument><expr><name><name>user_fctx</name><operator>-&gt;</operator><name>segdbs</name></name></expr></argument>, <argument><expr><name><name>cdbinfo</name><operator>-&gt;</operator><name>freelist</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
		<comment type="block">/* Fake a segment descriptor to represent the current QD backend */</comment>
		<decl_stmt><decl><type><name>SegmentDatabaseDescriptor</name> <modifier>*</modifier></type><name>qddesc</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SegmentDatabaseDescriptor</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>qddesc</name><operator>-&gt;</operator><name>segment_database_info</name></name> <operator>=</operator> <call><name>cdbcomponent_getComponentInfo</name><argument_list>(<argument><expr><name>MASTER_CONTENT_ID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>qddesc</name><operator>-&gt;</operator><name>segindex</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>qddesc</name><operator>-&gt;</operator><name>conn</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>qddesc</name><operator>-&gt;</operator><name>motionListener</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>qddesc</name><operator>-&gt;</operator><name>backendPid</name></name> <operator>=</operator> <name>MyProcPid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>qddesc</name><operator>-&gt;</operator><name>whoami</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>qddesc</name><operator>-&gt;</operator><name>isWriter</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>qddesc</name><operator>-&gt;</operator><name>identifier</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>user_fctx</name><operator>-&gt;</operator><name>segdbs</name></name> <operator>=</operator> <call><name>lcons</name><argument_list>(<argument><expr><name>qddesc</name></expr></argument>, <argument><expr><name><name>user_fctx</name><operator>-&gt;</operator><name>segdbs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/*
		 * For a slightly better default user experience, sort by descriptor ID.
		 * Users may of course specify their own ORDER BY if they don't like it.
		 */</comment>
		<expr_stmt><expr><name><name>user_fctx</name><operator>-&gt;</operator><name>segdbs</name></name> <operator>=</operator> <call><name>list_qsort</name><argument_list>(<argument><expr><name><name>user_fctx</name><operator>-&gt;</operator><name>segdbs</name></name></expr></argument>, <argument><expr><name>compare_segdb_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>user_fctx</name><operator>-&gt;</operator><name>curpos</name></name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name><name>user_fctx</name><operator>-&gt;</operator><name>segdbs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Create a descriptor for the records we'll be returning. */</comment>
		<expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <call><name>CreateTemplateTupleDesc</name><argument_list>(<argument><expr><name>BACKENDINFO_NATTR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"id"</literal></expr></argument>, <argument><expr><name>INT4OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="string">"type"</literal></expr></argument>, <argument><expr><name>CHAROID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><literal type="string">"content"</literal></expr></argument>, <argument><expr><name>INT4OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">"host"</literal></expr></argument>, <argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"port"</literal></expr></argument>, <argument><expr><name>INT4OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>, <argument><expr><literal type="string">"pid"</literal></expr></argument>, <argument><expr><name>INT4OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>funcctx</name><operator>-&gt;</operator><name>tuple_desc</name></name> <operator>=</operator> <call><name>BlessTupleDesc</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Tell the caller how many rows we'll return. */</comment>
		<expr_stmt><expr><name><name>funcctx</name><operator>-&gt;</operator><name>max_calls</name></name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>user_fctx</name><operator>-&gt;</operator><name>segdbs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>funcctx</name> <operator>=</operator> <call><name>SRF_PERCALL_SETUP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Construct and return a row for every entry. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>funcctx</name><operator>-&gt;</operator><name>call_cntr</name></name> <operator>&lt;</operator> <name><name>funcctx</name><operator>-&gt;</operator><name>max_calls</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Datum</name></type>                     <name><name>values</name><index>[<expr><name>BACKENDINFO_NATTR</name></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name><name>nulls</name><index>[<expr><name>BACKENDINFO_NATTR</name></expr>]</index></name>                       <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTuple</name></type>                 <name>tuple</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>SegmentDatabaseDescriptor</name> <modifier>*</modifier></type><name>dbdesc</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>CdbComponentDatabaseInfo</name>  <modifier>*</modifier></type><name>dbinfo</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>user_fctx</name> <operator>=</operator> <name><name>funcctx</name><operator>-&gt;</operator><name>user_fctx</name></name></expr>;</expr_stmt>

		<comment type="block">/* Get the next descriptor. */</comment>
		<expr_stmt><expr><name>dbdesc</name> <operator>=</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name><name>user_fctx</name><operator>-&gt;</operator><name>curpos</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>user_fctx</name><operator>-&gt;</operator><name>curpos</name></name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name><name>user_fctx</name><operator>-&gt;</operator><name>curpos</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Fill in the row attributes. */</comment>
		<expr_stmt><expr><name>dbinfo</name> <operator>=</operator> <name><name>dbdesc</name><operator>-&gt;</operator><name>segment_database_info</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name><name>dbdesc</name><operator>-&gt;</operator><name>identifier</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>			<comment type="block">/* id */</comment>
		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>CharGetDatum</name><argument_list>(<argument><expr><call><name>backend_type</name><argument_list>(<argument><expr><name>dbdesc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* type */</comment>
		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name><name>dbdesc</name><operator>-&gt;</operator><name>segindex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>			<comment type="block">/* content */</comment>

		<if_stmt><if>if <condition>(<expr><name><name>dbinfo</name><operator>-&gt;</operator><name>config</name><operator>-&gt;</operator><name>hostname</name></name></expr>)</condition><block type="pseudo"><block_content>								<comment type="block">/* host */</comment>
			<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name><name>dbinfo</name><operator>-&gt;</operator><name>config</name><operator>-&gt;</operator><name>hostname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name><name>dbinfo</name><operator>-&gt;</operator><name>config</name><operator>-&gt;</operator><name>port</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>          <comment type="block">/* port */</comment>
		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name><name>dbdesc</name><operator>-&gt;</operator><name>backendPid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>            <comment type="block">/* pid */</comment>

		<comment type="block">/* Form the new tuple using our attributes and return it. */</comment>
		<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>heap_form_tuple</name><argument_list>(<argument><expr><name><name>funcctx</name><operator>-&gt;</operator><name>tuple_desc</name></name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>SRF_RETURN_NEXT</name><argument_list>(<argument><expr><name>funcctx</name></expr></argument>, <argument><expr><call><name>HeapTupleGetDatum</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Clean up. */</comment>
		<expr_stmt><expr><name>user_fctx</name> <operator>=</operator> <name><name>funcctx</name><operator>-&gt;</operator><name>user_fctx</name></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>user_fctx</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name><name>user_fctx</name><operator>-&gt;</operator><name>segdbs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>user_fctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>funcctx</name><operator>-&gt;</operator><name>user_fctx</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>SRF_RETURN_DONE</name><argument_list>(<argument><expr><name>funcctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>BACKENDINFO_NATTR</name></cpp:undef>
</block_content>}</block></function>

<comment type="block">/*
 * Print the time of create a gang.
 * if all segDescs of the gang are cached, we regard the gang as reused.
 * else we print the shortest time and the longest time of estabishing connection to the segDesc.
 */</comment>
<function><type><name>void</name></type>
<name>printCreateGangTime</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>sliceId</name></decl></parameter>, <parameter><decl><type><name>Gang</name> <modifier>*</modifier></type><name>gang</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>double</name></type>	<name>shortestTime</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>, <decl><type ref="prev"/><name>longestTime</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>		<name>shortestSegIndex</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>, <decl><type ref="prev"/><name>longestSegIndex</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>		<name>size</name> <init>= <expr><name><name>gang</name><operator>-&gt;</operator><name>size</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SegmentDatabaseDescriptor</name> <modifier>*</modifier></type><name>segdbDesc</name></decl>;</decl_stmt>
	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>size</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>segdbDesc</name> <operator>=</operator> <name><name>gang</name><operator>-&gt;</operator><name>db_descriptors</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		<comment type="block">/* the connection of segdbDesc is not cached */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>segdbDesc</name><operator>-&gt;</operator><name>establishConnTime</name></name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>longestTime</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal> <operator>||</operator> <name><name>segdbDesc</name><operator>-&gt;</operator><name>establishConnTime</name></name> <operator>&gt;</operator> <name>longestTime</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>longestTime</name> <operator>=</operator> <name><name>segdbDesc</name><operator>-&gt;</operator><name>establishConnTime</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name>longestSegIndex</name> <operator>=</operator> <name><name>segdbDesc</name><operator>-&gt;</operator><name>segindex</name></name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>shortestTime</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal> <operator>||</operator> <name><name>segdbDesc</name><operator>-&gt;</operator><name>establishConnTime</name></name> <operator>&lt;</operator> <name>shortestTime</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>shortestTime</name> <operator>=</operator> <name><name>segdbDesc</name><operator>-&gt;</operator><name>establishConnTime</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name>shortestSegIndex</name> <operator>=</operator> <name><name>segdbDesc</name><operator>-&gt;</operator><name>segindex</name></name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* All the segDescs are cached, and we regard this gang as reused gang. */</comment>
	<if_stmt><if>if <condition>(<expr><name>longestTime</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>sliceId</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>INFO</name></expr></argument>, <argument><expr><literal type="string">"(Gang) is reused"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>INFO</name></expr></argument>, <argument><expr><literal type="string">"(Slice%d) is reused"</literal></expr></argument>, <argument><expr><name>sliceId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>sliceId</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>INFO</name></expr></argument>, <argument><expr><literal type="string">"The shortest establish conn time: %.2f ms, segindex: %d,\n"</literal>
				<literal type="string">"       The longest  establish conn time: %.2f ms, segindex: %d"</literal></expr></argument>,
				<argument><expr><name>shortestTime</name></expr></argument>, <argument><expr><name>shortestSegIndex</name></expr></argument>, <argument><expr><name>longestTime</name></expr></argument>, <argument><expr><name>longestSegIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>INFO</name></expr></argument>, <argument><expr><literal type="string">"(Slice%d) The shortest establish conn time: %.2f ms, segindex: %d,\n"</literal>
				 <literal type="string">"                The longest  establish conn time: %.2f ms, segindex: %d"</literal></expr></argument>,
				<argument><expr><name>sliceId</name></expr></argument>, <argument><expr><name>shortestTime</name></expr></argument>, <argument><expr><name>shortestSegIndex</name></expr></argument>, <argument><expr><name>longestTime</name></expr></argument>, <argument><expr><name>longestSegIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>
</unit>
