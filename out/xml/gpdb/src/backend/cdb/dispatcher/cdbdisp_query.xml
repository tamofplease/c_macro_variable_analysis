<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/backend/cdb/dispatcher/cdbdisp_query.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * cdbdisp_query.c
 *	  Functions to dispatch command string or plan to QExecutors.
 *
 *
 * Portions Copyright (c) 2005-2008, Greenplum inc
 * Portions Copyright (c) 2012-Present VMware, Inc. or its affiliates.
 *
 *
 * IDENTIFICATION
 *	    src/backend/cdb/dispatcher/cdbdisp_query.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq-fe.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq-int.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbconn.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbgang.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbutil.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbvars.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbmutate.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbsrlz.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/tupleremap.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/namespace.h"</cpp:file></cpp:include> <comment type="block">/* for GetTempNamespaceState() */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/execnodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgstat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tcop/tcopprot.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/datum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/guc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/faultinjector.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/resgroup.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/resource_manager.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/cgroup.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/session_state.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/typcache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"mb/pg_wchar.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbdisp.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbdisp_query.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbdisp_dtx.h"</cpp:file></cpp:include>	<comment type="block">/* for qdSerializeDtxContextInfo() */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbdispatchresult.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbcopy.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/execUtils.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>QUERY_STRING_TRUNCATE_SIZE</name></cpp:macro> <cpp:value>(1024)</cpp:value></cpp:define>

<decl_stmt><decl><type><specifier>extern</specifier> <name>bool</name></type> <name>Test_print_direct_dispatch_info</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>extern</specifier> <name>bool</name></type> <name>gp_print_create_gang_time</name></decl>;</decl_stmt>
<typedef>typedef <type><struct>struct <name>ParamWalkerContext</name>
<block>{
	<decl_stmt><decl><type><name>plan_tree_base_prefix</name></type> <name>base</name></decl>;</decl_stmt> <comment type="block">/* Required prefix for
								 * plan_tree_walker/mutator */</comment>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>params</name></decl>;</decl_stmt>
}</block></struct></type> <name>ParamWalkerContext</name>;</typedef>

<comment type="block">/*
 * We need an array describing the relationship between a slice and
 * the number of "child" slices which depend on it.
 */</comment>
<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>int</name></type>			<name>sliceIndex</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>children</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExecSlice</name>  <modifier>*</modifier></type><name>slice</name></decl>;</decl_stmt>
}</block></struct></type> <name>SliceVec</name>;</typedef>

<comment type="block">/*
 * Parameter structure for Greenplum Database Queries
 */</comment>
<typedef>typedef <type><struct>struct <name>DispatchCommandQueryParms</name>
<block>{
	<comment type="block">/*
	 * The SQL command
	 */</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>strCommand</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>strCommandlen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>serializedPlantree</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>serializedPlantreelen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>serializedQueryDispatchDesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>serializedQueryDispatchDesclen</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Additional information.
	 */</comment>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>serializedOidAssignments</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>serializedOidAssignmentslen</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * serialized DTX context string
	 */</comment>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>serializedDtxContextInfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>serializedDtxContextInfolen</name></decl>;</decl_stmt>
}</block></struct></type> <name>DispatchCommandQueryParms</name>;</typedef>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>fillSliceVector</name><parameter_list>(<parameter><decl><type><name>SliceTable</name> <modifier>*</modifier></type><name>sliceTable</name></decl></parameter>,
				<parameter><decl><type><name>int</name></type> <name>sliceIndex</name></decl></parameter>,
				<parameter><decl><type><name>SliceVec</name> <modifier>*</modifier></type><name>sliceVector</name></decl></parameter>,
				<parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>buildGpQueryString</name><parameter_list>(<parameter><decl><type><name>DispatchCommandQueryParms</name> <modifier>*</modifier></type><name>pQueryParms</name></decl></parameter>,
				   <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>finalLen</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>DispatchCommandQueryParms</name> <modifier>*</modifier></type><name>cdbdisp_buildPlanQueryParms</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>QueryDesc</name></name> <modifier>*</modifier></type><name>queryDesc</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>planRequiresTxn</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>DispatchCommandQueryParms</name> <modifier>*</modifier></type><name>cdbdisp_buildUtilityQueryParms</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>Node</name></name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>oid_assignments</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>DispatchCommandQueryParms</name> <modifier>*</modifier></type><name>cdbdisp_buildCommandQueryParms</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>strCommand</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>cdbdisp_dispatchCommandInternal</name><parameter_list>(<parameter><decl><type><name>DispatchCommandQueryParms</name> <modifier>*</modifier></type><name>pQueryParms</name></decl></parameter>,
											<parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>segments</name></decl></parameter>,
											<parameter><decl><type><name>CdbPgResults</name> <modifier>*</modifier></type><name>cdb_pgresults</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type>
<name>cdbdisp_dispatchX</name><parameter_list>(<parameter><decl><type><name>QueryDesc</name> <modifier>*</modifier></type><name>queryDesc</name></decl></parameter>,
			<parameter><decl><type><name>bool</name></type> <name>planRequiresTxn</name></decl></parameter>,
			<parameter><decl><type><name>bool</name></type> <name>cancelOnError</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>formIdleSegmentIdList</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>param_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>ParamWalkerContext</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Oid</name></type>	<name>findParamType</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>params</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>paramid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Bitmapset</name> <modifier>*</modifier></type><name>getExecParamsToDispatch</name><parameter_list>(<parameter><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>, <parameter><decl><type><name>ParamExecData</name> <modifier>*</modifier></type><name>intPrm</name></decl></parameter>,
										  <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>paramExecTypes</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>SerializedParams</name> <modifier>*</modifier></type><name>serializeParamsForDispatch</name><parameter_list>(<parameter><decl><type><name>QueryDesc</name> <modifier>*</modifier></type><name>queryDesc</name></decl></parameter>,
													<parameter><decl><type><name>ParamListInfo</name></type> <name>externParams</name></decl></parameter>,
													<parameter><decl><type><name>ParamExecData</name> <modifier>*</modifier></type><name>execParams</name></decl></parameter>,
													<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>paramExecTypes</name></decl></parameter>,
													<parameter><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>sendParams</name></decl></parameter>)</parameter_list>;</function_decl>



<comment type="block">/*
 * Compose and dispatch the MPPEXEC commands corresponding to a plan tree
 * within a complete parallel plan. (A plan tree will correspond either
 * to an initPlan or to the main plan.)
 *
 * 'execParams', 'paramExecTypes' and 'sendParams' describe executor
 * parameters (PARAM_EXEC) that should be sent with the query.
 * 'sendParams' indicates which parameters are included and 'execParams'
 * contains their values. 'paramExecTypes' is a list indexed by paramid,
 * containing the datatype OID of each parameter.
 * GPDB_11_MERGE_FIXME: In PostgreSQL v11, we have paramExecTypes in
 * PlannedStmt, so it will no longer be necessary to pass it as a param.
 *
 * If cancelOnError is true, then any dispatching error, a cancellation
 * request from the client, or an error from any of the associated QEs,
 * may cause the unfinished portion of the plan to be abandoned or canceled;
 * and in the event this occurs before all gangs have been dispatched, this
 * function does not return, but waits for all QEs to stop and exits to
 * the caller's error catcher via ereport(ERROR,...). Otherwise this
 * function returns normally and errors are not reported until later.
 *
 * If cancelOnError is false, the plan is to be dispatched as fully as
 * possible and the QEs allowed to proceed regardless of cancellation
 * requests, errors or connection failures from other QEs, etc.
 *
 * The CdbDispatchResults objects allocated for the plan are returned
 * in *pPrimaryResults. The caller, after calling
 * CdbCheckDispatchResult(), can examine the CdbDispatchResults
 * objects, can keep them as long as needed, and ultimately must free
 * them with cdbdisp_destroyDispatcherState() prior to deallocation of
 * the caller's memory context. Callers should use PG_TRY/PG_CATCH to
 * ensure proper cleanup.
 *
 * To wait for completion, check for errors, and clean up, it is
 * suggested that the caller use cdbdisp_finishCommand().
 *
 * Note that the slice tree dispatched is the one specified in the EState
 * of the argument QueryDesc as es_cur__slice.
 *
 * Each QE receives its assignment as a message of type 'M' in PostgresMain().
 * The message is deserialized and processed by exec_mpp_query() in postgres.c.
 */</comment>
<function><type><name>void</name></type>
<name>CdbDispatchPlan</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>QueryDesc</name></name> <modifier>*</modifier></type><name>queryDesc</name></decl></parameter>,
				<parameter><decl><type><name>ParamExecData</name> <modifier>*</modifier></type><name>execParams</name></decl></parameter>,
				<parameter><decl><type><name>bool</name></type> <name>planRequiresTxn</name></decl></parameter>,
				<parameter><decl><type><name>bool</name></type> <name>cancelOnError</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>stmt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>is_SRI</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>paramExecTypes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>sendParams</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>queryDesc</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>queryDesc</name><operator>-&gt;</operator><name>estate</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * This function is called only for planned statements.
	 */</comment>
	<expr_stmt><expr><name>stmt</name> <operator>=</operator> <name><name>queryDesc</name><operator>-&gt;</operator><name>plannedstmt</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Let's evaluate STABLE functions now, so we get consistent values on the
	 * QEs
	 *
	 * Also, if this is a single-row INSERT statement, let's evaluate
	 * nextval() and currval() now, so that we get the QD's values, and a
	 * consistent value for everyone
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>queryDesc</name><operator>-&gt;</operator><name>operation</name></name> <operator>==</operator> <name>CMD_INSERT</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_INSERT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * We might look for constant input relation (instead of SRI), but I'm
		 * afraid that wouldn't scale.
		 */</comment>
		<expr_stmt><expr><name>is_SRI</name> <operator>=</operator> <call><name>IsA</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>planTree</name></name></expr></argument>, <argument><expr><name>Result</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator><name><name>stmt</name><operator>-&gt;</operator><name>planTree</name><operator>-&gt;</operator><name>lefttree</name></name> <operator>==</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>queryDesc</name><operator>-&gt;</operator><name>operation</name></name> <operator>==</operator> <name>CMD_INSERT</name> <operator>||</operator>
		<name><name>queryDesc</name><operator>-&gt;</operator><name>operation</name></name> <operator>==</operator> <name>CMD_SELECT</name> <operator>||</operator>
		<name><name>queryDesc</name><operator>-&gt;</operator><name>operation</name></name> <operator>==</operator> <name>CMD_UPDATE</name> <operator>||</operator>
		<name><name>queryDesc</name><operator>-&gt;</operator><name>operation</name></name> <operator>==</operator> <name>CMD_DELETE</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>cursors</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Need to be careful not to modify the original PlannedStmt, because
		 * it might be a cached plan. So make a copy. A shallow copy of the
		 * fields we don't modify should be enough.
		 */</comment>
		<expr_stmt><expr><name>stmt</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PlannedStmt</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>plannedstmt</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PlannedStmt</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>subplans</name></name> <operator>=</operator> <call><name>list_copy</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>subplans</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>planTree</name></name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>exec_make_plan_constant</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>estate</name></name></expr></argument>, <argument><expr><name>is_SRI</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cursors</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>plannedstmt</name></name> <operator>=</operator> <name>stmt</name></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>ddesc</name><operator>-&gt;</operator><name>cursorPositions</name></name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>cursors</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Fill in parameter info.
	 *
	 * First, figure out which executor parameters (PARAM_EXEC) have valid
	 * values that need to be included with the query. Then serialize them,
	 * and also any PARAM_EXTERN parameters.
	 */</comment>
	<expr_stmt><expr><name>sendParams</name> <operator>=</operator> <call><name>getExecParamsToDispatch</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>execParams</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>paramExecTypes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>ddesc</name><operator>-&gt;</operator><name>paramInfo</name></name> <operator>=</operator>
		<call><name>serializeParamsForDispatch</name><argument_list>(<argument><expr><name>queryDesc</name></expr></argument>,
								   <argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>params</name></name></expr></argument>,
								   <argument><expr><name>execParams</name></expr></argument>, <argument><expr><name>paramExecTypes</name></expr></argument>, <argument><expr><name>sendParams</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Cursor queries and bind/execute path queries don't run on the
	 * writer-gang QEs; but they require snapshot-synchronization to get
	 * started.
	 *
	 * initPlans, and other work (see the function pre-evaluation above) may
	 * advance the snapshot "segmateSync" value, so we're best off setting the
	 * shared-snapshot-ready value here. This will dispatch to the writer gang
	 * and force it to set its snapshot; we'll then be able to serialize the
	 * same snapshot version (see qdSerializeDtxContextInfo() below).
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>queryDesc</name><operator>-&gt;</operator><name>extended_query</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>verify_shared_snapshot_ready</name><argument_list>(<argument><expr><name>gp_command_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* In the final stage, add the resource information needed for QE by the resource group */</comment>
	<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>total_memory_coordinator</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>nsegments_coordinator</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsResGroupEnabled</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <name>gp_resource_group_enable_recalculate_query_mem</name> <operator>&amp;&amp;</operator>
		<name>memory_spill_ratio</name> <operator>!=</operator> <name>RESGROUP_FALLBACK_MEMORY_SPILL_RATIO</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We enable resource group re-calculate the query_mem on QE, and we are not in
		 * fall back mode (use statement_mem).
		 */</comment>
		<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>total_memory_coordinator</name></name> <operator>=</operator> <call><name><name>cgroupOpsRoutine</name><operator>-&gt;</operator><name>gettotalmemory</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>nsegments_coordinator</name></name> <operator>=</operator> <call><name>ResGroupGetHostPrimaryCount</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>cdbdisp_dispatchX</name><argument_list>(<argument><expr><name>queryDesc</name></expr></argument>, <argument><expr><name>planRequiresTxn</name></expr></argument>, <argument><expr><name>cancelOnError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * SET command can not be dispatched to named portal (like CURSOR). On the one
 * hand, named portal might be busy and also it should not be affected by
 * the SET command. Then when a dispatcher state of named portal is destroyed,
 * its gang should not be recycled because its guc was not set, so need to mark
 * those gangs as not recyclable.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>cdbdisp_markNamedPortalGangsDestroyed</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>dispatcher_handle_t</name> <modifier>*</modifier></type><name>head</name> <init>= <expr><name>open_dispatcher_handles</name></expr></init></decl>;</decl_stmt>
	<while>while <condition>(<expr><name>head</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>head</name><operator>-&gt;</operator><name>dispatcherState</name><operator>-&gt;</operator><name>isExtendedQuery</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>head</name><operator>-&gt;</operator><name>dispatcherState</name><operator>-&gt;</operator><name>forceDestroyGang</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>head</name> <operator>=</operator> <name><name>head</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
	</block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/*
 * Special for sending SET commands that change GUC variables, so they go to all
 * gangs, both reader and writer
 *
 * Can not dispatch SET commands to busy reader gangs (allocated by cursors) directly because another
 * command is already in progress.
 * Cursors only allocate reader gangs, so primary writer and idle reader gangs can be dispatched to.
 */</comment>
<function><type><name>void</name></type>
<name>CdbDispatchSetCommand</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>strCommand</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>cancelOnError</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CdbDispatcherState</name> <modifier>*</modifier></type><name>ds</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DispatchCommandQueryParms</name> <modifier>*</modifier></type><name>pQueryParms</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Gang</name> <modifier>*</modifier></type><name>primaryGang</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>queryText</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>		<name>queryTextLength</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>le</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ErrorData</name> <modifier>*</modifier></type><name>qeError</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><operator>(</operator><ternary><condition><expr><name>Debug_print_full_dtm</name></expr> ?</condition><then> <expr><name>LOG</name></expr> </then><else>: <expr><name>DEBUG5</name></expr></else></ternary><operator>)</operator></expr></argument>,
		 <argument><expr><literal type="string">"CdbDispatchSetCommand for command = '%s'"</literal></expr></argument>,
		 <argument><expr><name>strCommand</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>pQueryParms</name> <operator>=</operator> <call><name>cdbdisp_buildCommandQueryParms</name><argument_list>(<argument><expr><name>strCommand</name></expr></argument>, <argument><expr><name>DF_NONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ds</name> <operator>=</operator> <call><name>cdbdisp_makeDispatcherState</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>queryText</name> <operator>=</operator> <call><name>buildGpQueryString</name><argument_list>(<argument><expr><name>pQueryParms</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>queryTextLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>primaryGang</name> <operator>=</operator> <call><name>AllocateGang</name><argument_list>(<argument><expr><name>ds</name></expr></argument>, <argument><expr><name>GANGTYPE_PRIMARY_WRITER</name></expr></argument>, <argument><expr><call><name>cdbcomponent_getCdbComponentsList</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>gp_print_create_gang_time</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>printCreateGangTime</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>primaryGang</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* put all idle segment to a gang so QD can send SET command to them */</comment>
	<expr_stmt><expr><call><name>AllocateGang</name><argument_list>(<argument><expr><name>ds</name></expr></argument>, <argument><expr><name>GANGTYPE_PRIMARY_READER</name></expr></argument>, <argument><expr><call><name>formIdleSegmentIdList</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	
	<expr_stmt><expr><call><name>cdbdisp_makeDispatchResults</name><argument_list>(<argument><expr><name>ds</name></expr></argument>, <argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>ds</name><operator>-&gt;</operator><name>allocatedGangs</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>cancelOnError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>cdbdisp_makeDispatchParams</name> <argument_list>(<argument><expr><name>ds</name></expr></argument>, <argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>ds</name><operator>-&gt;</operator><name>allocatedGangs</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>queryText</name></expr></argument>, <argument><expr><name>queryTextLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>le</argument>, <argument>ds-&gt;allocatedGangs</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Gang</name>	   <modifier>*</modifier></type><name>rg</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>le</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>cdbdisp_dispatchToGang</name><argument_list>(<argument><expr><name>ds</name></expr></argument>, <argument><expr><name>rg</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>addToGxactDtxSegments</name><argument_list>(<argument><expr><name>primaryGang</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * No need for two-phase commit, so no need to call
	 * addToGxactDtxSegments.
	 */</comment>

	<expr_stmt><expr><call><name>cdbdisp_waitDispatchFinish</name><argument_list>(<argument><expr><name>ds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>cdbdisp_checkDispatchResult</name><argument_list>(<argument><expr><name>ds</name></expr></argument>, <argument><expr><name>DISPATCH_WAIT_NONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>cdbdisp_getDispatchResults</name><argument_list>(<argument><expr><name>ds</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>qeError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * For named portal (like CURSOR), SET command will not be
	 * dispatched. Meanwhile such gang should not be reused because
	 * it's guc was not set.
	 */</comment>
	<expr_stmt><expr><call><name>cdbdisp_markNamedPortalGangsDestroyed</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>qeError</name></expr>)</condition>
	<block>{<block_content>

		<expr_stmt><expr><call><name>FlushErrorState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ReThrowError</name><argument_list>(<argument><expr><name>qeError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>cdbdisp_destroyDispatcherState</name><argument_list>(<argument><expr><name>ds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * CdbDispatchCommand:
 *
 * Execute plain command on all primary writer QEs.
 * If one or more QEs got error, throw a Error.
 *
 * -flags:
 *  Is the combination of DF_NEED_TWO_PHASE, DF_WITH_SNAPSHOT,DF_CANCEL_ON_ERROR
 */</comment>
<function><type><name>void</name></type>
<name>CdbDispatchCommand</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>strCommand</name></decl></parameter>,
				   <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>,
				   <parameter><decl><type><name>CdbPgResults</name> <modifier>*</modifier></type><name>cdb_pgresults</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>CdbDispatchCommandToSegments</name><argument_list>(<argument><expr><name>strCommand</name></expr></argument>,
										<argument><expr><name>flags</name></expr></argument>,
										<argument><expr><call><name>cdbcomponent_getCdbComponentsList</name><argument_list>()</argument_list></call></expr></argument>,
										<argument><expr><name>cdb_pgresults</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Like CdbDispatchCommand, but sends the command only to the
 * specified segments.
 */</comment>
<function><type><name>void</name></type>
<name>CdbDispatchCommandToSegments</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>strCommand</name></decl></parameter>,
							 <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>,
							 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>segments</name></decl></parameter>,
							 <parameter><decl><type><name>CdbPgResults</name> <modifier>*</modifier></type><name>cdb_pgresults</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DispatchCommandQueryParms</name> <modifier>*</modifier></type><name>pQueryParms</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>needTwoPhase</name> <init>= <expr><name>flags</name> <operator>&amp;</operator> <name>DF_NEED_TWO_PHASE</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>needTwoPhase</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>setupDtxTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>elogif</name><argument_list>(<argument><expr><operator>(</operator><name>Debug_print_full_dtm</name> <operator>||</operator> <name>log_min_messages</name> <operator>&lt;=</operator> <name>DEBUG5</name><operator>)</operator></expr></argument>, <argument><expr><name>LOG</name></expr></argument>,
		   <argument><expr><literal type="string">"CdbDispatchCommand: %s (needTwoPhase = %s)"</literal></expr></argument>,
		   <argument><expr><name>strCommand</name></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><name>needTwoPhase</name></expr> ?</condition><then> <expr><literal type="string">"true"</literal></expr> </then><else>: <expr><literal type="string">"false"</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>pQueryParms</name> <operator>=</operator> <call><name>cdbdisp_buildCommandQueryParms</name><argument_list>(<argument><expr><name>strCommand</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>cdbdisp_dispatchCommandInternal</name><argument_list>(<argument><expr><name>pQueryParms</name></expr></argument>,
										   <argument><expr><name>flags</name></expr></argument>,
										   <argument><expr><name>segments</name></expr></argument>,
										   <argument><expr><name>cdb_pgresults</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * CdbDispatchUtilityStatement
 *
 * Dispatch an already parsed statement to all primary writer QEs, wait until
 * all QEs finished successfully. If one or more QEs got error,
 * throw an Error.
 *
 * -flags:
 *      Is the combination of DF_NEED_TWO_PHASE, DF_WITH_SNAPSHOT,DF_CANCEL_ON_ERROR
 *
 * -cdb_pgresults:
 *      Indicate whether return the pg_result for each QE connection.
 *
 */</comment>
<function><type><name>void</name></type>
<name>CdbDispatchUtilityStatement</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>Node</name></name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>,
							<parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>,
							<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>oid_assignments</name></decl></parameter>,
							<parameter><decl><type><name>CdbPgResults</name> <modifier>*</modifier></type><name>cdb_pgresults</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DispatchCommandQueryParms</name> <modifier>*</modifier></type><name>pQueryParms</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>needTwoPhase</name> <init>= <expr><name>flags</name> <operator>&amp;</operator> <name>DF_NEED_TWO_PHASE</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>needTwoPhase</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>setupDtxTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>elogif</name><argument_list>(<argument><expr><operator>(</operator><name>Debug_print_full_dtm</name> <operator>||</operator> <name>log_min_messages</name> <operator>&lt;=</operator> <name>DEBUG5</name><operator>)</operator></expr></argument>, <argument><expr><name>LOG</name></expr></argument>,
		   <argument><expr><literal type="string">"CdbDispatchUtilityStatement: %s (needTwoPhase = %s)"</literal></expr></argument>,
		   <argument><expr><operator>(</operator><ternary><condition><expr><call><name>PointerIsValid</name><argument_list>(<argument><expr><name>debug_query_string</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>debug_query_string</name></expr> </then><else>: <expr><literal type="string">"\"\""</literal></expr></else></ternary><operator>)</operator></expr></argument>,
		   <argument><expr><operator>(</operator><ternary><condition><expr><name>needTwoPhase</name></expr> ?</condition><then> <expr><literal type="string">"true"</literal></expr> </then><else>: <expr><literal type="string">"false"</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>pQueryParms</name> <operator>=</operator> <call><name>cdbdisp_buildUtilityQueryParms</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>oid_assignments</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>cdbdisp_dispatchCommandInternal</name><argument_list>(<argument><expr><name>pQueryParms</name></expr></argument>,
										   <argument><expr><name>flags</name></expr></argument>,
										   <argument><expr><call><name>cdbcomponent_getCdbComponentsList</name><argument_list>()</argument_list></call></expr></argument>,
										   <argument><expr><name>cdb_pgresults</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>cdbdisp_dispatchCommandInternal</name><parameter_list>(<parameter><decl><type><name>DispatchCommandQueryParms</name> <modifier>*</modifier></type><name>pQueryParms</name></decl></parameter>,
                                <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>,
								<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>segments</name></decl></parameter>,
                                <parameter><decl><type><name>CdbPgResults</name> <modifier>*</modifier></type><name>cdb_pgresults</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CdbDispatcherState</name> <modifier>*</modifier></type><name>ds</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Gang</name> <modifier>*</modifier></type><name>primaryGang</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CdbDispatchResults</name> <modifier>*</modifier></type><name>pr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ErrorData</name> <modifier>*</modifier></type><name>qeError</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>queryText</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>queryTextLength</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Dispatch the command.
	 */</comment>
	<expr_stmt><expr><name>ds</name> <operator>=</operator> <call><name>cdbdisp_makeDispatcherState</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Reader gangs use local snapshot to access catalog, as a result, it will
	 * not synchronize with the global snapshot from write gang which will lead
	 * to inconsistent visibilty of catalog table. Considering the case:
	 * 
	 * select * from t, t t1; -- create a reader gang.
	 * begin;
	 * create role r1;
	 * set role r1;  -- set command will also dispatched to idle reader gang
	 *
	 * When set role command dispatched to reader gang, reader gang cannot see
	 * the new tuple t1 in catalog table pg_auth.
	 * To fix this issue, we should drop the idle reader gangs after each
	 * utility statement which may modify the catalog table.
	 */</comment>
	<expr_stmt><expr><name><name>ds</name><operator>-&gt;</operator><name>destroyIdleReaderGang</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>queryText</name> <operator>=</operator> <call><name>buildGpQueryString</name><argument_list>(<argument><expr><name>pQueryParms</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>queryTextLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Allocate a primary QE for every available segDB in the system.
	 */</comment>
	<expr_stmt><expr><name>primaryGang</name> <operator>=</operator> <call><name>AllocateGang</name><argument_list>(<argument><expr><name>ds</name></expr></argument>, <argument><expr><name>GANGTYPE_PRIMARY_WRITER</name></expr></argument>, <argument><expr><name>segments</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>gp_print_create_gang_time</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>printCreateGangTime</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>primaryGang</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>primaryGang</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>cdbdisp_makeDispatchResults</name><argument_list>(<argument><expr><name>ds</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>flags</name> <operator>&amp;</operator> <name>DF_CANCEL_ON_ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>cdbdisp_makeDispatchParams</name> <argument_list>(<argument><expr><name>ds</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>queryText</name></expr></argument>, <argument><expr><name>queryTextLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>cdbdisp_dispatchToGang</name><argument_list>(<argument><expr><name>ds</name></expr></argument>, <argument><expr><name>primaryGang</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>DF_NEED_TWO_PHASE</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>isDtxExplicitBegin</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>addToGxactDtxSegments</name><argument_list>(<argument><expr><name>primaryGang</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>cdbdisp_waitDispatchFinish</name><argument_list>(<argument><expr><name>ds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>cdbdisp_checkDispatchResult</name><argument_list>(<argument><expr><name>ds</name></expr></argument>, <argument><expr><name>DISPATCH_WAIT_NONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>pr</name> <operator>=</operator> <call><name>cdbdisp_getDispatchResults</name><argument_list>(<argument><expr><name>ds</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>qeError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>qeError</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>FlushErrorState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ReThrowError</name><argument_list>(<argument><expr><name>qeError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* collect pgstat from QEs for current transaction level */</comment>
	<expr_stmt><expr><call><name>pgstat_combine_from_qe</name><argument_list>(<argument><expr><name>pr</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>cdbdisp_returnResults</name><argument_list>(<argument><expr><name>pr</name></expr></argument>, <argument><expr><name>cdb_pgresults</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>cdbdisp_destroyDispatcherState</name><argument_list>(<argument><expr><name>ds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>DispatchCommandQueryParms</name> <modifier>*</modifier></type>
<name>cdbdisp_buildCommandQueryParms</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>strCommand</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>needTwoPhase</name> <init>= <expr><name>flags</name> <operator>&amp;</operator> <name>DF_NEED_TWO_PHASE</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>withSnapshot</name> <init>= <expr><name>flags</name> <operator>&amp;</operator> <name>DF_WITH_SNAPSHOT</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DispatchCommandQueryParms</name> <modifier>*</modifier></type><name>pQueryParms</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>pQueryParms</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pQueryParms</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pQueryParms</name><operator>-&gt;</operator><name>strCommand</name></name> <operator>=</operator> <name>strCommand</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pQueryParms</name><operator>-&gt;</operator><name>serializedQueryDispatchDesc</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pQueryParms</name><operator>-&gt;</operator><name>serializedQueryDispatchDesclen</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * Serialize a version of our DTX Context Info
	 */</comment>
	<expr_stmt><expr><name><name>pQueryParms</name><operator>-&gt;</operator><name>serializedDtxContextInfo</name></name> <operator>=</operator>
		<call><name>qdSerializeDtxContextInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pQueryParms</name><operator>-&gt;</operator><name>serializedDtxContextInfolen</name></name></expr></argument>,
								  <argument><expr><name>withSnapshot</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
								  <argument><expr><call><name>mppTxnOptions</name><argument_list>(<argument><expr><name>needTwoPhase</name></expr></argument>)</argument_list></call></expr></argument>,
								  <argument><expr><literal type="string">"cdbdisp_dispatchCommandInternal"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>pQueryParms</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>DispatchCommandQueryParms</name> <modifier>*</modifier></type>
<name>cdbdisp_buildUtilityQueryParms</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>Node</name></name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>,
				<parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>,
				<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>oid_assignments</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>serializedPlantree</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>serializedQueryDispatchDesc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>serializedPlantree_len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>serializedQueryDispatchDesc_len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>needTwoPhase</name> <init>= <expr><name>flags</name> <operator>&amp;</operator> <name>DF_NEED_TWO_PHASE</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>withSnapshot</name> <init>= <expr><name>flags</name> <operator>&amp;</operator> <name>DF_WITH_SNAPSHOT</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>QueryDispatchDesc</name> <modifier>*</modifier></type><name>qddesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>pstmt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DispatchCommandQueryParms</name> <modifier>*</modifier></type><name>pQueryParms</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>	<name>save_userid</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>stmt</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>type</name></name> <operator>&lt;</operator> <literal type="number">1000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>type</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Wrap it in a PlannedStmt */</comment>
	<expr_stmt><expr><name>pstmt</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>PlannedStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pstmt</name><operator>-&gt;</operator><name>commandType</name></name> <operator>=</operator> <name>CMD_UTILITY</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * We must set q-&gt;canSetTag = true.  False would be used to hide a command
	 * introduced by rule expansion which is not allowed to return its
	 * completion status in the command tag (PQcmdStatus/PQcmdTuples). For
	 * example, if the original unexpanded command was SELECT, the status
	 * should come back as "SELECT n" and should not reflect other commands
	 * inserted by rewrite rules.  True means we want the status.
	 */</comment>
	<expr_stmt><expr><name><name>pstmt</name><operator>-&gt;</operator><name>canSetTag</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pstmt</name><operator>-&gt;</operator><name>utilityStmt</name></name> <operator>=</operator> <name>stmt</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pstmt</name><operator>-&gt;</operator><name>stmt_location</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pstmt</name><operator>-&gt;</operator><name>stmt_len</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * serialized the stmt tree, and create the sql statement: mppexec ....
	 */</comment>
	<expr_stmt><expr><name>serializedPlantree</name> <operator>=</operator> <call><name>serializeNode</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>pstmt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>serializedPlantree_len</name></expr></argument>,
									   <argument><expr><name>NULL</name></expr></argument> <comment type="block">/* uncompressed_size */</comment> )</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>serializedPlantree</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>oid_assignments</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>qddesc</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>QueryDispatchDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>qddesc</name><operator>-&gt;</operator><name>oidAssignments</name></name> <operator>=</operator> <name>oid_assignments</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>GetUserIdAndSecContext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>save_userid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>qddesc</name><operator>-&gt;</operator><name>secContext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>serializedQueryDispatchDesc</name> <operator>=</operator> <call><name>serializeNode</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>qddesc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>serializedQueryDispatchDesc_len</name></expr></argument>,
													<argument><expr><name>NULL</name></expr></argument> <comment type="block">/* uncompressed_size */</comment> )</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>pQueryParms</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pQueryParms</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pQueryParms</name><operator>-&gt;</operator><name>strCommand</name></name> <operator>=</operator> <ternary><condition><expr><call><name>PointerIsValid</name><argument_list>(<argument><expr><name>debug_query_string</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>debug_query_string</name></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pQueryParms</name><operator>-&gt;</operator><name>serializedPlantree</name></name> <operator>=</operator> <name>serializedPlantree</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pQueryParms</name><operator>-&gt;</operator><name>serializedPlantreelen</name></name> <operator>=</operator> <name>serializedPlantree_len</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pQueryParms</name><operator>-&gt;</operator><name>serializedQueryDispatchDesc</name></name> <operator>=</operator> <name>serializedQueryDispatchDesc</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pQueryParms</name><operator>-&gt;</operator><name>serializedQueryDispatchDesclen</name></name> <operator>=</operator> <name>serializedQueryDispatchDesc_len</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Serialize a version of our DTX Context Info
	 */</comment>
	<expr_stmt><expr><name><name>pQueryParms</name><operator>-&gt;</operator><name>serializedDtxContextInfo</name></name> <operator>=</operator>
		<call><name>qdSerializeDtxContextInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pQueryParms</name><operator>-&gt;</operator><name>serializedDtxContextInfolen</name></name></expr></argument>,
								  <argument><expr><name>withSnapshot</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
								  <argument><expr><call><name>mppTxnOptions</name><argument_list>(<argument><expr><name>needTwoPhase</name></expr></argument>)</argument_list></call></expr></argument>,
								  <argument><expr><literal type="string">"cdbdisp_dispatchCommandInternal"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>pQueryParms</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>DispatchCommandQueryParms</name> <modifier>*</modifier></type>
<name>cdbdisp_buildPlanQueryParms</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>QueryDesc</name></name> <modifier>*</modifier></type><name>queryDesc</name></decl></parameter>,
							<parameter><decl><type><name>bool</name></type> <name>planRequiresTxn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>splan</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>sddesc</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>int</name></type>			<name>splan_len</name></decl>,
				<decl><type ref="prev"/><name>splan_len_uncompressed</name></decl>,
				<decl><type ref="prev"/><name>sddesc_len</name></decl>,
				<decl><type ref="prev"/><name>rootIdx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>save_userid</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>rootIdx</name> <operator>=</operator> <call><name>RootSliceIndex</name><argument_list>(<argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>estate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>DispatchCommandQueryParms</name> <modifier>*</modifier></type><name>pQueryParms</name> <init>= <expr><operator>(</operator><name>DispatchCommandQueryParms</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pQueryParms</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * serialized plan tree. Note that we're called for a single slice tree
	 * (corresponding to an initPlan or the main plan), so the parameters are
	 * fixed and we can include them in the prefix.
	 */</comment>
	<expr_stmt><expr><name>splan</name> <operator>=</operator> <call><name>serializeNode</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>queryDesc</name><operator>-&gt;</operator><name>plannedstmt</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>splan_len</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>splan_len_uncompressed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>uint64</name></type>		<name>plan_size_in_kb</name> <init>= <expr><operator>(</operator><operator>(</operator><name>uint64</name><operator>)</operator> <name>splan_len_uncompressed</name><operator>)</operator> <operator>/</operator> <operator>(</operator><name>uint64</name><operator>)</operator> <literal type="number">1024</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><operator>(</operator><ternary><condition><expr><operator>(</operator><name>gp_log_gang</name> <operator>&gt;=</operator> <name>GPVARS_VERBOSITY_TERSE</name><operator>)</operator></expr> ?</condition><then> <expr><name>LOG</name></expr> </then><else>: <expr><name>DEBUG1</name></expr></else></ternary><operator>)</operator></expr></argument>,
		 <argument><expr><literal type="string">"Query plan size to dispatch: "</literal> <name>UINT64_FORMAT</name> <literal type="string">"KB"</literal></expr></argument>, <argument><expr><name>plan_size_in_kb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>&lt;</operator> <name>gp_max_plan_size</name> <operator>&amp;&amp;</operator> <name>plan_size_in_kb</name> <operator>&gt;</operator> <name>gp_max_plan_size</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_STATEMENT_TOO_COMPLEX</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Query plan size limit exceeded, current size: "</literal>
						 <name>UINT64_FORMAT</name> <literal type="string">"KB, max allowed size: %dKB"</literal></expr></argument>,
						 <argument><expr><name>plan_size_in_kb</name></expr></argument>, <argument><expr><name>gp_max_plan_size</name></expr></argument>)</argument_list></call><operator>,</operator>
				  <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Size controlled by gp_max_plan_size"</literal></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>splan</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>splan_len</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>splan_len_uncompressed</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>GetUserIdAndSecContext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>save_userid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>queryDesc</name><operator>-&gt;</operator><name>ddesc</name><operator>-&gt;</operator><name>secContext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>sddesc</name> <operator>=</operator> <call><name>serializeNode</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>queryDesc</name><operator>-&gt;</operator><name>ddesc</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sddesc_len</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument> <comment type="block">/* uncompressed_size */</comment> )</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>pQueryParms</name><operator>-&gt;</operator><name>strCommand</name></name> <operator>=</operator> <name><name>queryDesc</name><operator>-&gt;</operator><name>sourceText</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pQueryParms</name><operator>-&gt;</operator><name>serializedPlantree</name></name> <operator>=</operator> <name>splan</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pQueryParms</name><operator>-&gt;</operator><name>serializedPlantreelen</name></name> <operator>=</operator> <name>splan_len</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pQueryParms</name><operator>-&gt;</operator><name>serializedQueryDispatchDesc</name></name> <operator>=</operator> <name>sddesc</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pQueryParms</name><operator>-&gt;</operator><name>serializedQueryDispatchDesclen</name></name> <operator>=</operator> <name>sddesc_len</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Serialize a version of our snapshot, and generate our transction
	 * isolations. We generally want Plan based dispatch to be in a global
	 * transaction. The executor gets to decide if the special circumstances
	 * exist which allow us to dispatch without starting a global xact.
	 */</comment>
	<expr_stmt><expr><name><name>pQueryParms</name><operator>-&gt;</operator><name>serializedDtxContextInfo</name></name> <operator>=</operator>
		<call><name>qdSerializeDtxContextInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pQueryParms</name><operator>-&gt;</operator><name>serializedDtxContextInfolen</name></name></expr></argument>,
								  <argument><expr><name>true</name></expr></argument> <comment type="block">/* wantSnapshot */</comment> ,
								  <argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>extended_query</name></name></expr></argument>,
								  <argument><expr><call><name>mppTxnOptions</name><argument_list>(<argument><expr><name>planRequiresTxn</name></expr></argument>)</argument_list></call></expr></argument>,
								  <argument><expr><literal type="string">"cdbdisp_buildPlanQueryParms"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>pQueryParms</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Three Helper functions for cdbdisp_dispatchX:
 *
 * Used to figure out the dispatch order for the sliceTable by
 * counting the number of dependent child slices for each slice; and
 * then sorting based on the count (all indepenedent slices get
 * dispatched first, then the slice above them and so on).
 *
 * fillSliceVector: figure out the number of slices we're dispatching,
 * and order them.
 *
 * count_dependent_children(): walk tree counting up children.
 *
 * compare_slice_order(): comparison function for qsort(): order the
 * slices by the number of dependent children. Empty slices are
 * sorted last (to make this work with initPlans).
 *
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>compare_slice_order</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>aa</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>bb</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SliceVec</name>   <modifier>*</modifier></type><name>a</name> <init>= <expr><operator>(</operator><name>SliceVec</name> <operator>*</operator><operator>)</operator> <name>aa</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SliceVec</name>   <modifier>*</modifier></type><name>b</name> <init>= <expr><operator>(</operator><name>SliceVec</name> <operator>*</operator><operator>)</operator> <name>bb</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>slice</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>b</name><operator>-&gt;</operator><name>slice</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Put the slice not going to dispatch in the last
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>slice</name><operator>-&gt;</operator><name>primaryGang</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>a</name><operator>-&gt;</operator><name>slice</name><operator>-&gt;</operator><name>gangType</name></name> <operator>==</operator> <name>GANGTYPE_UNALLOCATED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>b</name><operator>-&gt;</operator><name>slice</name><operator>-&gt;</operator><name>primaryGang</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>b</name><operator>-&gt;</operator><name>slice</name><operator>-&gt;</operator><name>gangType</name></name> <operator>==</operator> <name>GANGTYPE_UNALLOCATED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* sort slice with larger size first because it has a bigger chance to contain writers */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>slice</name><operator>-&gt;</operator><name>primaryGang</name><operator>-&gt;</operator><name>size</name></name> <operator>&gt;</operator> <name><name>b</name><operator>-&gt;</operator><name>slice</name><operator>-&gt;</operator><name>primaryGang</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>slice</name><operator>-&gt;</operator><name>primaryGang</name><operator>-&gt;</operator><name>size</name></name> <operator>&lt;</operator> <name><name>b</name><operator>-&gt;</operator><name>slice</name><operator>-&gt;</operator><name>primaryGang</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>children</name></name> <operator>==</operator> <name><name>b</name><operator>-&gt;</operator><name>children</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>children</name></name> <operator>&gt;</operator> <name><name>b</name><operator>-&gt;</operator><name>children</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Quick and dirty bit mask operations
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>mark_bit</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>bits</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nth</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>nthbyte</name> <init>= <expr><name>nth</name> <operator>&gt;&gt;</operator> <literal type="number">3</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>nthbit</name> <init>= <expr><literal type="number">1</literal> <operator>&lt;&lt;</operator> <operator>(</operator><name>nth</name> <operator>&amp;</operator> <literal type="number">7</literal><operator>)</operator></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>bits</name><index>[<expr><name>nthbyte</name></expr>]</index></name> <operator>|=</operator> <name>nthbit</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>or_bits</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>src</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>dest</name><index>[<expr><name>i</name></expr>]</index></name> <operator>|=</operator> <name><name>src</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>count_bits</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>bits</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nbyte</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nbit</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>int</name></type>			<name><name>bitcount</name><index>[]</index></name> <init>=
	<expr><block>{
		<expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><literal type="number">4</literal></expr>
	}</block></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nbyte</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>nbit</name> <operator>+=</operator> <name><name>bitcount</name><index>[<expr><name><name>bits</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0x0F</literal></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>nbit</name> <operator>+=</operator> <name><name>bitcount</name><index>[<expr><operator>(</operator><name><name>bits</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;&gt;</operator> <literal type="number">4</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x0F</literal></expr>]</index></name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>nbit</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * We use a bitmask to count the dep. childrens.
 * Because of input sharing, the slices now are DAG. We cannot simply go down the
 * tree and add up number of children, which will return too big number.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>markbit_dep_children</name><parameter_list>(<parameter><decl><type><name>SliceTable</name> <modifier>*</modifier></type><name>sliceTable</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sliceIdx</name></decl></parameter>,
					 <parameter><decl><type><name>SliceVec</name> <modifier>*</modifier></type><name>sliceVec</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>bitmasklen</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>bits</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>sublist</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExecSlice</name>  <modifier>*</modifier></type><name>slice</name> <init>= <expr><operator>&amp;</operator><name><name>sliceTable</name><operator>-&gt;</operator><name>slices</name><index>[<expr><name>sliceIdx</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>sublist</argument>, <argument>slice-&gt;children</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>childIndex</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>sublist</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>newbits</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><name>bitmasklen</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>markbit_dep_children</name><argument_list>(<argument><expr><name>sliceTable</name></expr></argument>, <argument><expr><name>childIndex</name></expr></argument>,
							 <argument><expr><name>sliceVec</name></expr></argument>, <argument><expr><name>bitmasklen</name></expr></argument>, <argument><expr><name>newbits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>or_bits</name><argument_list>(<argument><expr><name>bits</name></expr></argument>, <argument><expr><name>newbits</name></expr></argument>, <argument><expr><name>bitmasklen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>mark_bit</name><argument_list>(<argument><expr><name>bits</name></expr></argument>, <argument><expr><name>childIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>newbits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><name><name>sliceVec</name><index>[<expr><name>sliceIdx</name></expr>]</index></name><operator>.</operator><name>sliceIndex</name> <operator>=</operator> <name>sliceIdx</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sliceVec</name><index>[<expr><name>sliceIdx</name></expr>]</index></name><operator>.</operator><name>children</name> <operator>=</operator> <call><name>count_bits</name><argument_list>(<argument><expr><name>bits</name></expr></argument>, <argument><expr><name>bitmasklen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sliceVec</name><index>[<expr><name>sliceIdx</name></expr>]</index></name><operator>.</operator><name>slice</name> <operator>=</operator> <name>slice</name></expr>;</expr_stmt>

	<return>return <expr><name><name>sliceVec</name><index>[<expr><name>sliceIdx</name></expr>]</index></name><operator>.</operator><name>children</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Count how many dependent childrens and fill in the sliceVector of dependent childrens.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>count_dependent_children</name><parameter_list>(<parameter><decl><type><name>SliceTable</name> <modifier>*</modifier></type><name>sliceTable</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sliceIndex</name></decl></parameter>,
						 <parameter><decl><type><name>SliceVec</name> <modifier>*</modifier></type><name>sliceVector</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>ret</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>bitmasklen</name> <init>= <expr><operator>(</operator><name>len</name> <operator>+</operator> <literal type="number">7</literal><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">3</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>bitmask</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><name>bitmasklen</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>markbit_dep_children</name><argument_list>(<argument><expr><name>sliceTable</name></expr></argument>, <argument><expr><name>sliceIndex</name></expr></argument>, <argument><expr><name>sliceVector</name></expr></argument>, <argument><expr><name>bitmasklen</name></expr></argument>, <argument><expr><name>bitmask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>bitmask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>fillSliceVector</name><parameter_list>(<parameter><decl><type><name>SliceTable</name> <modifier>*</modifier></type><name>sliceTbl</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>rootIdx</name></decl></parameter>,
				<parameter><decl><type><name>SliceVec</name> <modifier>*</modifier></type><name>sliceVector</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nTotalSlices</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>top_count</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * count doesn't include top slice add 1, note that sliceVector would be
	 * modified in place by count_dependent_children.
	 */</comment>
	<expr_stmt><expr><name>top_count</name> <operator>=</operator> <literal type="number">1</literal> <operator>+</operator> <call><name>count_dependent_children</name><argument_list>(<argument><expr><name>sliceTbl</name></expr></argument>, <argument><expr><name>rootIdx</name></expr></argument>, <argument><expr><name>sliceVector</name></expr></argument>, <argument><expr><name>nTotalSlices</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><name>sliceVector</name></expr></argument>, <argument><expr><name>nTotalSlices</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SliceVec</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>compare_slice_order</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>top_count</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Build a query string to be dispatched to QE.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>buildGpQueryString</name><parameter_list>(<parameter><decl><type><name>DispatchCommandQueryParms</name> <modifier>*</modifier></type><name>pQueryParms</name></decl></parameter>,
				   <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>finalLen</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>command</name> <init>= <expr><name><name>pQueryParms</name><operator>-&gt;</operator><name>strCommand</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>command_len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>plantree</name> <init>= <expr><name><name>pQueryParms</name><operator>-&gt;</operator><name>serializedPlantree</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>plantree_len</name> <init>= <expr><name><name>pQueryParms</name><operator>-&gt;</operator><name>serializedPlantreelen</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sddesc</name> <init>= <expr><name><name>pQueryParms</name><operator>-&gt;</operator><name>serializedQueryDispatchDesc</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>sddesc_len</name> <init>= <expr><name><name>pQueryParms</name><operator>-&gt;</operator><name>serializedQueryDispatchDesclen</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dtxContextInfo</name> <init>= <expr><name><name>pQueryParms</name><operator>-&gt;</operator><name>serializedDtxContextInfo</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>dtxContextInfo_len</name> <init>= <expr><name><name>pQueryParms</name><operator>-&gt;</operator><name>serializedDtxContextInfolen</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type>		<name>currentStatementStartTimestamp</name> <init>= <expr><call><name>GetCurrentStatementStartTimestamp</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>sessionUserId</name> <init>= <expr><call><name>GetSessionUserId</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>outerUserId</name> <init>= <expr><call><name>GetOuterUserId</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>currentUserId</name> <init>= <expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>numsegments</name> <init>= <expr><call><name>getgpsegmentCount</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>resgroupInfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>tempNamespaceId</name></decl>, <decl><type ref="prev"/><name>tempToastNamespaceId</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>int</name></type>			<name>tmp</name></decl>,
				<decl><type ref="prev"/><name>len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>n32</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>total_query_len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>shared_query</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>pos</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldContext</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Must allocate query text within DispatcherContext,
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>DispatcherContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>oldContext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>DispatcherContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If plantree is set then the query string is not so
	 * important, dispatch a truncated version to increase the performance.
	 *
	 * Here we only need to determine the truncated size, the actual work is
	 * done later when copying it to the result buffer.
	 *
	 * The +1 and -1 below are adjustments to accommodate terminating null
	 * character.
	 */</comment>
	<expr_stmt><expr><name>command_len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>command</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>plantree</name> <operator>&amp;&amp;</operator> <name>command_len</name> <operator>&gt;</operator> <name>QUERY_STRING_TRUNCATE_SIZE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>command_len</name> <operator>=</operator> <call><name>pg_mbcliplen</name><argument_list>(<argument><expr><name>command</name></expr></argument>, <argument><expr><name>command_len</name></expr></argument>,
								   <argument><expr><name>QUERY_STRING_TRUNCATE_SIZE</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>resgroupInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsResGroupActivated</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>SerializeResGroupInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>resgroupInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>total_query_len</name> <operator>=</operator> <literal type="number">1</literal> <comment type="block">/* 'M' */</comment> <operator>+</operator>
		<sizeof>sizeof<argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></sizeof> <comment type="block">/* message length */</comment> <operator>+</operator>
		<sizeof>sizeof<argument_list>(<argument><expr><name>gp_command_count</name></expr></argument>)</argument_list></sizeof> <operator>+</operator>
		<sizeof>sizeof<argument_list>(<argument><expr><name>sessionUserId</name></expr></argument>)</argument_list></sizeof> <comment type="block">/* sessionUserIsSuper */</comment> <operator>+</operator>
		<sizeof>sizeof<argument_list>(<argument><expr><name>outerUserId</name></expr></argument>)</argument_list></sizeof> <comment type="block">/* outerUserIsSuper */</comment> <operator>+</operator>
		<sizeof>sizeof<argument_list>(<argument><expr><name>currentUserId</name></expr></argument>)</argument_list></sizeof> <operator>+</operator>
		<sizeof>sizeof<argument_list>(<argument><expr><name>n32</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <literal type="number">2</literal> <comment type="block">/* currentStatementStartTimestamp */</comment> <operator>+</operator>
		<sizeof>sizeof<argument_list>(<argument><expr><name>command_len</name></expr></argument>)</argument_list></sizeof> <operator>+</operator>
		<sizeof>sizeof<argument_list>(<argument><expr><name>plantree_len</name></expr></argument>)</argument_list></sizeof> <operator>+</operator>
		<sizeof>sizeof<argument_list>(<argument><expr><name>sddesc_len</name></expr></argument>)</argument_list></sizeof> <operator>+</operator>
		<sizeof>sizeof<argument_list>(<argument><expr><name>dtxContextInfo_len</name></expr></argument>)</argument_list></sizeof> <operator>+</operator>
		<name>dtxContextInfo_len</name> <operator>+</operator>
		<name>command_len</name> <operator>+</operator>
		<name>plantree_len</name> <operator>+</operator>
		<name>sddesc_len</name> <operator>+</operator>
		<sizeof>sizeof<argument_list>(<argument><expr><name>numsegments</name></expr></argument>)</argument_list></sizeof> <operator>+</operator>
		<sizeof>sizeof<argument_list>(<argument><expr><name><name>resgroupInfo</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></sizeof> <operator>+</operator>
		<name><name>resgroupInfo</name><operator>.</operator><name>len</name></name> <operator>+</operator>
		<sizeof>sizeof<argument_list>(<argument><expr><name>tempNamespaceId</name></expr></argument>)</argument_list></sizeof> <operator>+</operator>
		<sizeof>sizeof<argument_list>(<argument><expr><name>tempToastNamespaceId</name></expr></argument>)</argument_list></sizeof> <operator>+</operator>
		<literal type="number">0</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name>shared_query</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>total_query_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>pos</name> <operator>=</operator> <name>shared_query</name></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>pos</name><operator>++</operator> <operator>=</operator> <literal type="char">'M'</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name>pos</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>					<comment type="block">/* placeholder for message length */</comment>

	<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>htonl</name><argument_list>(<argument><expr><name>gp_command_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pos</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmp</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>gp_command_count</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>pos</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>gp_command_count</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

	<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>htonl</name><argument_list>(<argument><expr><name>sessionUserId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pos</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmp</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sessionUserId</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>pos</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>sessionUserId</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

	<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>htonl</name><argument_list>(<argument><expr><name>outerUserId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pos</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmp</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>outerUserId</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>pos</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>outerUserId</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

	<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>htonl</name><argument_list>(<argument><expr><name>currentUserId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pos</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmp</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>currentUserId</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>pos</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>currentUserId</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

	<comment type="block">/*
	 * High order half first, since we're doing MSB-first
	 */</comment>
	<expr_stmt><expr><name>n32</name> <operator>=</operator> <operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>currentStatementStartTimestamp</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>n32</name> <operator>=</operator> <call><name>htonl</name><argument_list>(<argument><expr><name>n32</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pos</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>n32</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>n32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>pos</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>n32</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

	<comment type="block">/*
	 * Now the low order half
	 */</comment>
	<expr_stmt><expr><name>n32</name> <operator>=</operator> <operator>(</operator><name>uint32</name><operator>)</operator> <name>currentStatementStartTimestamp</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>n32</name> <operator>=</operator> <call><name>htonl</name><argument_list>(<argument><expr><name>n32</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pos</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>n32</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>n32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>pos</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>n32</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

	<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>htonl</name><argument_list>(<argument><expr><name>command_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pos</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmp</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>command_len</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>pos</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>command_len</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

	<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>htonl</name><argument_list>(<argument><expr><name>plantree_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pos</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmp</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>plantree_len</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>pos</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>plantree_len</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

	<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>htonl</name><argument_list>(<argument><expr><name>sddesc_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pos</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmp</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>pos</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

	<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>htonl</name><argument_list>(<argument><expr><name>dtxContextInfo_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pos</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmp</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>pos</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>dtxContextInfo_len</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pos</name></expr></argument>, <argument><expr><name>dtxContextInfo</name></expr></argument>, <argument><expr><name>dtxContextInfo_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>pos</name> <operator>+=</operator> <name>dtxContextInfo_len</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pos</name></expr></argument>, <argument><expr><name>command</name></expr></argument>, <argument><expr><name>command_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* If command is truncated we need to set the terminating '\0' manually */</comment>
	<expr_stmt><expr><name><name>pos</name><index>[<expr><name>command_len</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>pos</name> <operator>+=</operator> <name>command_len</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>plantree_len</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pos</name></expr></argument>, <argument><expr><name>plantree</name></expr></argument>, <argument><expr><name>plantree_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>pos</name> <operator>+=</operator> <name>plantree_len</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>sddesc_len</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pos</name></expr></argument>, <argument><expr><name>sddesc</name></expr></argument>, <argument><expr><name>sddesc_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>pos</name> <operator>+=</operator> <name>sddesc_len</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>htonl</name><argument_list>(<argument><expr><name>numsegments</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pos</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmp</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>numsegments</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>pos</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>numsegments</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

	<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>htonl</name><argument_list>(<argument><expr><name><name>resgroupInfo</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pos</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmp</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>resgroupInfo</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>pos</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>resgroupInfo</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>resgroupInfo</name><operator>.</operator><name>len</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pos</name></expr></argument>, <argument><expr><name><name>resgroupInfo</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>resgroupInfo</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>pos</name> <operator>+=</operator> <name><name>resgroupInfo</name><operator>.</operator><name>len</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* pass process local variables to QEs */</comment>
	<expr_stmt><expr><call><name>GetTempNamespaceState</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tempNamespaceId</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tempToastNamespaceId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tempNamespaceId</name> <operator>=</operator> <call><name>htonl</name><argument_list>(<argument><expr><name>tempNamespaceId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tempToastNamespaceId</name> <operator>=</operator> <call><name>htonl</name><argument_list>(<argument><expr><name>tempToastNamespaceId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pos</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tempNamespaceId</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>tempNamespaceId</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>pos</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>tempNamespaceId</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pos</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tempToastNamespaceId</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>tempToastNamespaceId</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>pos</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>tempToastNamespaceId</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

	<comment type="block">/*
	 * fill in length placeholder
	 */</comment>
	<expr_stmt><expr><name>len</name> <operator>=</operator> <name>pos</name> <operator>-</operator> <name>shared_query</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>htonl</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>shared_query</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmp</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>len</name> <operator>+</operator> <literal type="number">1</literal> <operator>==</operator> <name>total_query_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>finalLen</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>finalLen</name> <operator>=</operator> <name>len</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>shared_query</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * This function is used for dispatching sliced plans
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>cdbdisp_dispatchX</name><parameter_list>(<parameter><decl><type><name>QueryDesc</name><modifier>*</modifier></type> <name>queryDesc</name></decl></parameter>,
					<parameter><decl><type><name>bool</name></type> <name>planRequiresTxn</name></decl></parameter>,
					<parameter><decl><type><name>bool</name></type> <name>cancelOnError</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SliceVec</name>   <modifier>*</modifier></type><name>sliceVector</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nSlices</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>	<comment type="block">/* slices this dispatch cares about */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>nTotalSlices</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>	<comment type="block">/* total slices in sliceTbl */</comment>

	<decl_stmt><decl><type><name>int</name></type>			<name>iSlice</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>rootIdx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>queryText</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>queryTextLength</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>SliceTable</name></name> <modifier>*</modifier></type><name>sliceTbl</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>EState</name></name> <modifier>*</modifier></type><name>estate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CdbDispatcherState</name> <modifier>*</modifier></type><name>ds</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ErrorData</name> <modifier>*</modifier></type><name>qeError</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DispatchCommandQueryParms</name> <modifier>*</modifier></type><name>pQueryParms</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>log_dispatch_stats</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ResetUsage</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>estate</name> <operator>=</operator> <name><name>queryDesc</name><operator>-&gt;</operator><name>estate</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>sliceTbl</name> <operator>=</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_sliceTable</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>sliceTbl</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>rootIdx</name> <operator>=</operator> <call><name>RootSliceIndex</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ds</name> <operator>=</operator> <call><name>cdbdisp_makeDispatcherState</name><argument_list>(<argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>extended_query</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Since we intend to execute the plan, inventory the slice tree,
	 * allocate gangs, and associate them with slices.
	 *
	 * On return, gangs have been allocated and CDBProcess lists have
	 * been filled in the slice table.)
	 * 
	 * Notice: This must be done before cdbdisp_buildPlanQueryParms
	 */</comment>
	<expr_stmt><expr><call><name>AssignGangs</name><argument_list>(<argument><expr><name>ds</name></expr></argument>, <argument><expr><name>queryDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Traverse the slice tree in sliceTbl rooted at rootIdx and build a
	 * vector of slice indexes specifying the order of [potential] dispatch.
	 */</comment>
	<expr_stmt><expr><name>nTotalSlices</name> <operator>=</operator> <name><name>sliceTbl</name><operator>-&gt;</operator><name>numSlices</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>sliceVector</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>nTotalSlices</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>SliceVec</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>nSlices</name> <operator>=</operator> <call><name>fillSliceVector</name><argument_list>(<argument><expr><name>sliceTbl</name></expr></argument>, <argument><expr><name>rootIdx</name></expr></argument>, <argument><expr><name>sliceVector</name></expr></argument>, <argument><expr><name>nTotalSlices</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Each slice table has a unique-id. */</comment>
	<expr_stmt><expr><name><name>sliceTbl</name><operator>-&gt;</operator><name>ic_instance_id</name></name> <operator>=</operator> <operator>++</operator><name>gp_interconnect_id</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>pQueryParms</name> <operator>=</operator> <call><name>cdbdisp_buildPlanQueryParms</name><argument_list>(<argument><expr><name>queryDesc</name></expr></argument>, <argument><expr><name>planRequiresTxn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>queryText</name> <operator>=</operator> <call><name>buildGpQueryString</name><argument_list>(<argument><expr><name>pQueryParms</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>queryTextLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Allocate result array with enough slots for QEs of primary gangs.
	 */</comment>
	<expr_stmt><expr><call><name>cdbdisp_makeDispatchResults</name><argument_list>(<argument><expr><name>ds</name></expr></argument>, <argument><expr><name>nTotalSlices</name></expr></argument>, <argument><expr><name>cancelOnError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>cdbdisp_makeDispatchParams</name><argument_list>(<argument><expr><name>ds</name></expr></argument>, <argument><expr><name>nTotalSlices</name></expr></argument>, <argument><expr><name>queryText</name></expr></argument>, <argument><expr><name>queryTextLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>cdb_total_plans</name><operator>++</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>cdb_total_slices</name> <operator>+=</operator> <name>nSlices</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>nSlices</name> <operator>&gt;</operator> <name>cdb_max_slices</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>cdb_max_slices</name> <operator>=</operator> <name>nSlices</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>DEBUG1</name> <operator>&gt;=</operator> <name>log_min_messages</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>msec_str</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>

		<switch>switch <condition>(<expr><call><name>check_log_duration</name><argument_list>(<argument><expr><name>msec_str</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><literal type="number">1</literal></expr>:</case>
			<case>case <expr><literal type="number">2</literal></expr>:</case>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"duration to start of dispatch send (root %d): %s ms"</literal></expr></argument>,
								<argument><expr><name>rootIdx</name></expr></argument>, <argument><expr><name>msec_str</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
		</block_content>}</block></switch>
	</block_content>}</block></if></if_stmt>

	<for>for <control>(<init><expr><name>iSlice</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>iSlice</name> <operator>&lt;</operator> <name>nSlices</name></expr>;</condition> <incr><expr><name>iSlice</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Gang</name>	   <modifier>*</modifier></type><name>primaryGang</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ExecSlice</name>  <modifier>*</modifier></type><name>slice</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>si</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>sliceVector</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>slice</name> <operator>=</operator> <name><name>sliceVector</name><index>[<expr><name>iSlice</name></expr>]</index></name><operator>.</operator><name>slice</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>si</name> <operator>=</operator> <name><name>slice</name><operator>-&gt;</operator><name>sliceIndex</name></name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Is this a slice we should dispatch?
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>slice</name> <operator>&amp;&amp;</operator> <name><name>slice</name><operator>-&gt;</operator><name>gangType</name></name> <operator>==</operator> <name>GANGTYPE_UNALLOCATED</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>slice</name><operator>-&gt;</operator><name>primaryGang</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Most slices are dispatched, however, in many cases the root
			 * runs only on the QD and is not dispatched to the QEs.
			 */</comment>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>primaryGang</name> <operator>=</operator> <name><name>slice</name><operator>-&gt;</operator><name>primaryGang</name></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>gp_print_create_gang_time</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>printCreateGangTime</name><argument_list>(<argument><expr><name>si</name></expr></argument>, <argument><expr><name>primaryGang</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>primaryGang</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>AssertImply</name><argument_list>(<argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>extended_query</name></name></expr></argument>,
					<argument><expr><name><name>primaryGang</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>GANGTYPE_PRIMARY_READER</name> <operator>||</operator>
					<name><name>primaryGang</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>GANGTYPE_SINGLETON_READER</name> <operator>||</operator>
					<name><name>primaryGang</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>GANGTYPE_ENTRYDB_READER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>si</name> <operator>==</operator> <name><name>slice</name><operator>-&gt;</operator><name>rootIndex</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>ds</name><operator>-&gt;</operator><name>rootGangSize</name></name> <operator>=</operator> <name><name>primaryGang</name><operator>-&gt;</operator><name>size</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>Test_print_direct_dispatch_info</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>INFO</name></expr></argument>, <argument><expr><literal type="string">"(slice %d) Dispatch command to %s"</literal></expr></argument>, <argument><expr><name><name>slice</name><operator>-&gt;</operator><name>sliceIndex</name></name></expr></argument>,
						<argument><expr><call><name>segmentsToContentStr</name><argument_list>(<argument><expr><name><name>slice</name><operator>-&gt;</operator><name>segments</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Bail out if already got an error or cancellation request.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>cancelOnError</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>ds</name><operator>-&gt;</operator><name>primaryResults</name><operator>-&gt;</operator><name>errcode</name></name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>CancelRequested</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>SIMPLE_FAULT_INJECTOR</name><argument_list>(<argument><expr><literal type="string">"before_one_slice_dispatched"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>cdbdisp_dispatchToGang</name><argument_list>(<argument><expr><name>ds</name></expr></argument>, <argument><expr><name>primaryGang</name></expr></argument>, <argument><expr><name>si</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>planRequiresTxn</name> <operator>||</operator> <call><name>isDtxExplicitBegin</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>addToGxactDtxSegments</name><argument_list>(<argument><expr><name>primaryGang</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>SIMPLE_FAULT_INJECTOR</name><argument_list>(<argument><expr><literal type="string">"after_one_slice_dispatched"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>sliceVector</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>cdbdisp_waitDispatchFinish</name><argument_list>(<argument><expr><name>ds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If bailed before completely dispatched, stop QEs and throw error.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>iSlice</name> <operator>&lt;</operator> <name>nSlices</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><ternary><condition><expr><name>Debug_cancel_print</name></expr> ?</condition><then> <expr><name>LOG</name></expr> </then><else>: <expr><name>DEBUG2</name></expr></else></ternary></expr></argument>,
			 <argument><expr><literal type="string">"Plan dispatch canceled; dispatched %d of %d slices"</literal></expr></argument>,
			 <argument><expr><name>iSlice</name></expr></argument>, <argument><expr><name>nSlices</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Cancel any QEs still running, and wait for them to terminate.
		 */</comment>
		<expr_stmt><expr><call><name>cdbdisp_cancelDispatch</name><argument_list>(<argument><expr><name>ds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Check and free the results of all gangs. If any QE had an error,
		 * report it and exit via PG_THROW.
		 */</comment>
		<expr_stmt><expr><call><name>cdbdisp_getDispatchResults</name><argument_list>(<argument><expr><name>ds</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>qeError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>qeError</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>FlushErrorState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ReThrowError</name><argument_list>(<argument><expr><name>qeError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Wasn't an error, must have been an interrupt.
		 */</comment>
		<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Strange! Not an interrupt either.
		 */</comment>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"unable to dispatch plan"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>DEBUG1</name> <operator>&gt;=</operator> <name>log_min_messages</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>msec_str</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>

		<switch>switch <condition>(<expr><call><name>check_log_duration</name><argument_list>(<argument><expr><name>msec_str</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><literal type="number">1</literal></expr>:</case>
			<case>case <expr><literal type="number">2</literal></expr>:</case>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"duration to dispatch out (root %d): %s ms"</literal></expr></argument>,
								<argument><expr><name>rootIdx</name></expr></argument>, <argument><expr><name>msec_str</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
		</block_content>}</block></switch>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>dispatcherState</name></name> <operator>=</operator> <name>ds</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Copy external query parameters from serialized form into a ParamListInfo.
 */</comment>
<function><type><name>ParamListInfo</name></type>
<name>deserializeExternParams</name><parameter_list>(<parameter><decl><type><name>SerializedParams</name> <modifier>*</modifier></type><name>sparams</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TupleRemapper</name> <modifier>*</modifier></type><name>remapper</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ParamListInfo</name></type> <name>paramLI</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>sparams</name><operator>-&gt;</operator><name>nExternParams</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If a transient record type cache was included, load it into
	 * a TupleRemapper.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>sparams</name><operator>-&gt;</operator><name>transientTypes</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>remapper</name> <operator>=</operator> <call><name>CreateTupleRemapper</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TRHandleTypeLists</name><argument_list>(<argument><expr><name>remapper</name></expr></argument>, <argument><expr><name><name>sparams</name><operator>-&gt;</operator><name>transientTypes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>remapper</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * Build a new ParamListInfo.
	 */</comment>
	<expr_stmt><expr><name>paramLI</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>ParamListInfoData</name></expr></argument>, <argument><expr><name>params</name></expr></argument>)</argument_list></call> <operator>+</operator>
					 <name><name>sparams</name><operator>-&gt;</operator><name>nExternParams</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ParamExternData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* this clears the callback fields, among others */</comment>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>paramLI</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>ParamListInfoData</name></expr></argument>, <argument><expr><name>params</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>paramLI</name><operator>-&gt;</operator><name>numParams</name></name> <operator>=</operator> <name><name>sparams</name><operator>-&gt;</operator><name>nExternParams</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Read the ParamExternDatas
	 */</comment>
	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>sparams</name><operator>-&gt;</operator><name>nExternParams</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SerializedParamExternData</name> <modifier>*</modifier></type><name>sprm</name> <init>= <expr><operator>&amp;</operator><name><name>sparams</name><operator>-&gt;</operator><name>externParams</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ParamExternData</name> <modifier>*</modifier></type><name>prm</name> <init>= <expr><operator>&amp;</operator><name><name>paramLI</name><operator>-&gt;</operator><name>params</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>prm</name><operator>-&gt;</operator><name>ptype</name></name> <operator>=</operator> <name><name>sprm</name><operator>-&gt;</operator><name>ptype</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>prm</name><operator>-&gt;</operator><name>isnull</name></name> <operator>=</operator> <name><name>sprm</name><operator>-&gt;</operator><name>isnull</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>prm</name><operator>-&gt;</operator><name>pflags</name></name> <operator>=</operator> <name><name>sprm</name><operator>-&gt;</operator><name>pflags</name></name></expr>;</expr_stmt>

		<comment type="block">/* If remapping record types is needed, do it. */</comment>
		<if_stmt><if>if <condition>(<expr><name>remapper</name> <operator>&amp;&amp;</operator> <name><name>prm</name><operator>-&gt;</operator><name>ptype</name></name> <operator>!=</operator> <name>InvalidOid</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>prm</name><operator>-&gt;</operator><name>value</name></name> <operator>=</operator> <call><name>TRRemapDatum</name><argument_list>(<argument><expr><name>remapper</name></expr></argument>, <argument><expr><name><name>sprm</name><operator>-&gt;</operator><name>ptype</name></name></expr></argument>, <argument><expr><name><name>sprm</name><operator>-&gt;</operator><name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>prm</name><operator>-&gt;</operator><name>value</name></name> <operator>=</operator> <name><name>sprm</name><operator>-&gt;</operator><name>value</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>paramLI</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * CdbDispatchCopyStart allocate a writer gang and
 * dispatch the COPY command to segments.
 *
 * In COPY protocol, after a COPY command is dispatched, a response
 * to this will be a PGresult object bearing a status code of
 * PGRES_COPY_OUT or PGRES_COPY_IN, then client can use APIs like
 * PQputCopyData/PQgetCopyData to copy in/out data.
 *
 * cdbdisp_checkDispatchResult() will block until all connections
 * has issued a PGRES_COPY_OUT/PGRES_COPY_IN PGresult response.
 */</comment>
<function><type><name>void</name></type>
<name>CdbDispatchCopyStart</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>CdbCopy</name></name> <modifier>*</modifier></type><name>cdbCopy</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DispatchCommandQueryParms</name> <modifier>*</modifier></type><name>pQueryParms</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>queryText</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>queryTextLength</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CdbDispatcherState</name> <modifier>*</modifier></type><name>ds</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Gang</name> <modifier>*</modifier></type><name>primaryGang</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ErrorData</name> <modifier>*</modifier></type><name>error</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>needTwoPhase</name> <init>= <expr><name>flags</name> <operator>&amp;</operator> <name>DF_NEED_TWO_PHASE</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>needTwoPhase</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>setupDtxTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>elogif</name><argument_list>(<argument><expr><operator>(</operator><name>Debug_print_full_dtm</name> <operator>||</operator> <name>log_min_messages</name> <operator>&lt;=</operator> <name>DEBUG5</name><operator>)</operator></expr></argument>, <argument><expr><name>LOG</name></expr></argument>,
		   <argument><expr><literal type="string">"CdbDispatchCopyStart: %s (needTwoPhase = %s)"</literal></expr></argument>,
		   <argument><expr><operator>(</operator><ternary><condition><expr><call><name>PointerIsValid</name><argument_list>(<argument><expr><name>debug_query_string</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>debug_query_string</name></expr> </then><else>: <expr><literal type="string">"\"\""</literal></expr></else></ternary><operator>)</operator></expr></argument>,
		   <argument><expr><operator>(</operator><ternary><condition><expr><name>needTwoPhase</name></expr> ?</condition><then> <expr><literal type="string">"true"</literal></expr> </then><else>: <expr><literal type="string">"false"</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>pQueryParms</name> <operator>=</operator> <call><name>cdbdisp_buildUtilityQueryParms</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Dispatch the command.
	 */</comment>
	<expr_stmt><expr><name>ds</name> <operator>=</operator> <call><name>cdbdisp_makeDispatcherState</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>queryText</name> <operator>=</operator> <call><name>buildGpQueryString</name><argument_list>(<argument><expr><name>pQueryParms</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>queryTextLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Allocate a primary QE for every available segDB in the system.
	 */</comment>
	<expr_stmt><expr><name>primaryGang</name> <operator>=</operator> <call><name>AllocateGang</name><argument_list>(<argument><expr><name>ds</name></expr></argument>, <argument><expr><name>GANGTYPE_PRIMARY_WRITER</name></expr></argument>, <argument><expr><name><name>cdbCopy</name><operator>-&gt;</operator><name>seglist</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>gp_print_create_gang_time</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>printCreateGangTime</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>primaryGang</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>primaryGang</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>cdbdisp_makeDispatchResults</name><argument_list>(<argument><expr><name>ds</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>flags</name> <operator>&amp;</operator> <name>DF_CANCEL_ON_ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>cdbdisp_makeDispatchParams</name> <argument_list>(<argument><expr><name>ds</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>queryText</name></expr></argument>, <argument><expr><name>queryTextLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>cdbdisp_dispatchToGang</name><argument_list>(<argument><expr><name>ds</name></expr></argument>, <argument><expr><name>primaryGang</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>DF_NEED_TWO_PHASE</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>isDtxExplicitBegin</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>addToGxactDtxSegments</name><argument_list>(<argument><expr><name>primaryGang</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>cdbdisp_waitDispatchFinish</name><argument_list>(<argument><expr><name>ds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>cdbdisp_checkDispatchResult</name><argument_list>(<argument><expr><name>ds</name></expr></argument>, <argument><expr><name>DISPATCH_WAIT_NONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>cdbdisp_getDispatchResults</name><argument_list>(<argument><expr><name>ds</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>error</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>FlushErrorState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ReThrowError</name><argument_list>(<argument><expr><name>error</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Notice: Do not call cdbdisp_finishCommand to destroy dispatcher state,
	 * following PQputCopyData/PQgetCopyData will be called on those connections
	 */</comment>
	<expr_stmt><expr><name><name>cdbCopy</name><operator>-&gt;</operator><name>dispatcherState</name></name> <operator>=</operator> <name>ds</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>CdbDispatchCopyEnd</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>CdbCopy</name></name> <modifier>*</modifier></type><name>cdbCopy</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CdbDispatcherState</name> <modifier>*</modifier></type><name>ds</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>ds</name> <operator>=</operator> <name><name>cdbCopy</name><operator>-&gt;</operator><name>dispatcherState</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cdbCopy</name><operator>-&gt;</operator><name>dispatcherState</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>cdbdisp_destroyDispatcherState</name><argument_list>(<argument><expr><name>ds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Helper function only used by CdbDispatchSetCommand()
 *
 * Return a List of segment id who has idle segment dbs, the list
 * may contain duplicated segment id. eg, if segment 0 has two
 * idle segment dbs in freelist, the list looks like 0 -&gt; 0.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>formIdleSegmentIdList</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CdbComponentDatabases</name>	<modifier>*</modifier></type><name>cdbs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>					<modifier>*</modifier></type><name>segments</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>						<name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>cdbs</name> <operator>=</operator> <call><name>cdbcomponent_getCdbComponents</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>cdbs</name><operator>-&gt;</operator><name>segment_db_info</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>cdbs</name><operator>-&gt;</operator><name>total_segment_dbs</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>CdbComponentDatabaseInfo</name> <modifier>*</modifier></type><name>cdi</name> <init>= <expr><operator>&amp;</operator><name><name>cdbs</name><operator>-&gt;</operator><name>segment_db_info</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
			<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>cdi</name><operator>-&gt;</operator><name>numIdleQEs</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
				<expr_stmt><expr><name>segments</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>segments</name></expr></argument>, <argument><expr><name><name>cdi</name><operator>-&gt;</operator><name>config</name><operator>-&gt;</operator><name>segindex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>cdbs</name><operator>-&gt;</operator><name>entry_db_info</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>cdbs</name><operator>-&gt;</operator><name>total_entry_dbs</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>CdbComponentDatabaseInfo</name> <modifier>*</modifier></type><name>cdi</name> <init>= <expr><operator>&amp;</operator><name><name>cdbs</name><operator>-&gt;</operator><name>entry_db_info</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
			<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>cdi</name><operator>-&gt;</operator><name>numIdleQEs</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
				<expr_stmt><expr><name>segments</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>segments</name></expr></argument>, <argument><expr><name><name>cdi</name><operator>-&gt;</operator><name>config</name><operator>-&gt;</operator><name>segindex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>segments</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Serialization of query parameters (ParamListInfos and executor params)
 *
 * When a query is dispatched from QD to QE, we also need to dispatch any
 * query parameters (contained in the ParamListInfo struct), and executor
 * parameters that have already been evaluated in the QD. We need to
 * serialize ParamListInfo, but there are a few complications:
 *
 * - ParamListInfo is not a Node type, so we cannot use the usual
 * nodeToStringBinary() function directly. We turn the array of
 * ParamExternDatas into a List of SerializedParamExternData nodes,
 * which we can then pass to nodeToStringBinary().
 *
 * - The paramFetch callback, which could be used in this process to fetch
 * parameter values on-demand, cannot be used in a different process.
 * Therefore, fetch all parameters before serializing them. When
 * deserializing, leave the callbacks NULL.
 *
 * - In order to deserialize correctly, the receiver needs the typlen and
 * typbyval information for each datatype. The receiver has access to the
 * catalogs, so it could look them up, but for the sake of simplicity and
 * robustness in the receiver, we include that information in
 * SerializedParamExternData.
 *
 * - RECORD types. Type information of transient record is kept only in
 * backend private memory, indexed by typmod. The recipient will not know
 * what a record type's typmod means. And record types can also be nested.
 * Because of that, if there are any RECORD, we include a copy of the whole
 * transient record type cache.
 *
 * We form a SerializedParams struct, which contains enough information
 * to reconstruct in the QEs.
 *
 * XXX: Sending *all* record types can be quite bulky, but ATM there is no
 * easy way to extract just the needed record types.
 */</comment>
<function><type><specifier>static</specifier> <name>SerializedParams</name> <modifier>*</modifier></type>
<name>serializeParamsForDispatch</name><parameter_list>(<parameter><decl><type><name>QueryDesc</name> <modifier>*</modifier></type><name>queryDesc</name></decl></parameter>,
						   <parameter><decl><type><name>ParamListInfo</name></type> <name>externParams</name></decl></parameter>,
						   <parameter><decl><type><name>ParamExecData</name> <modifier>*</modifier></type><name>execParams</name></decl></parameter>,
						   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>paramExecTypes</name></decl></parameter>,
						   <parameter><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>sendParams</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SerializedParams</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>SerializedParams</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found_records</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* materialize Extern params */</comment>
	<if_stmt><if>if <condition>(<expr><name>externParams</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>nExternParams</name></name> <operator>=</operator> <name><name>externParams</name><operator>-&gt;</operator><name>numParams</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>externParams</name></name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name><name>externParams</name><operator>-&gt;</operator><name>numParams</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>SerializedParamExternData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>externParams</name><operator>-&gt;</operator><name>numParams</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ParamExternData</name> <modifier>*</modifier></type><name>prm</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>SerializedParamExternData</name> <modifier>*</modifier></type><name>sprm</name> <init>= <expr><operator>&amp;</operator><name><name>result</name><operator>-&gt;</operator><name>externParams</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ParamExternData</name></type> <name>prmdata</name></decl>;</decl_stmt>

			<comment type="block">/*
			 * First, use paramFetch to fetch any "lazy" parameters. (The callback
			 * function is of no use in the QE.)
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>externParams</name><operator>-&gt;</operator><name>paramFetch</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>prm</name> <operator>=</operator> <call><name><name>externParams</name><operator>-&gt;</operator><name>paramFetch</name></name><argument_list>(<argument><expr><name>externParams</name></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>prmdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>prm</name> <operator>=</operator> <operator>&amp;</operator><name><name>externParams</name><operator>-&gt;</operator><name>params</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<expr_stmt><expr><name><name>sprm</name><operator>-&gt;</operator><name>value</name></name> <operator>=</operator> <name><name>prm</name><operator>-&gt;</operator><name>value</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>sprm</name><operator>-&gt;</operator><name>isnull</name></name> <operator>=</operator> <name><name>prm</name><operator>-&gt;</operator><name>isnull</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>sprm</name><operator>-&gt;</operator><name>pflags</name></name> <operator>=</operator> <name><name>prm</name><operator>-&gt;</operator><name>pflags</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>sprm</name><operator>-&gt;</operator><name>ptype</name></name> <operator>=</operator> <name><name>prm</name><operator>-&gt;</operator><name>ptype</name></name></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>prm</name><operator>-&gt;</operator><name>ptype</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>get_typlenbyval</name><argument_list>(<argument><expr><name><name>prm</name><operator>-&gt;</operator><name>ptype</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>sprm</name><operator>-&gt;</operator><name>plen</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>sprm</name><operator>-&gt;</operator><name>pbyval</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>prm</name><operator>-&gt;</operator><name>ptype</name></name> <operator>==</operator> <name>RECORDOID</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>prm</name><operator>-&gt;</operator><name>isnull</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>found_records</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><name><name>sprm</name><operator>-&gt;</operator><name>plen</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>sprm</name><operator>-&gt;</operator><name>pbyval</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* materialize Exec params */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>bms_is_empty</name><argument_list>(<argument><expr><name>sendParams</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>numExecParams</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name>paramExecTypes</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>x</name></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>nExecParams</name></name> <operator>=</operator> <name>numExecParams</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>execParams</name></name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>numExecParams</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>SerializedParamExecData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>x</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
		<while>while <condition>(<expr><operator>(</operator><name>x</name> <operator>=</operator> <call><name>bms_next_member</name><argument_list>(<argument><expr><name>sendParams</name></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ParamExecData</name> <modifier>*</modifier></type><name>prm</name> <init>= <expr><operator>&amp;</operator><name><name>execParams</name><index>[<expr><name>x</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>SerializedParamExecData</name> <modifier>*</modifier></type><name>sprm</name> <init>= <expr><operator>&amp;</operator><name><name>result</name><operator>-&gt;</operator><name>execParams</name><index>[<expr><name>x</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>ptype</name> <init>= <expr><call><name>list_nth_oid</name><argument_list>(<argument><expr><name>paramExecTypes</name></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>sprm</name><operator>-&gt;</operator><name>value</name></name> <operator>=</operator> <name><name>prm</name><operator>-&gt;</operator><name>value</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>sprm</name><operator>-&gt;</operator><name>isnull</name></name> <operator>=</operator> <name><name>prm</name><operator>-&gt;</operator><name>isnull</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>sprm</name><operator>-&gt;</operator><name>isvalid</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>get_typlenbyval</name><argument_list>(<argument><expr><name>ptype</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>sprm</name><operator>-&gt;</operator><name>plen</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>sprm</name><operator>-&gt;</operator><name>pbyval</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>ptype</name> <operator>==</operator> <name>RECORDOID</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>prm</name><operator>-&gt;</operator><name>isnull</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>found_records</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></while>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If there were any record types, include the transient record type cache.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>found_records</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>transientTypes</name></name> <operator>=</operator> <call><name>build_tuple_node_list</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Function: getExecParamsToDispatch()
 *
 * Determine which PARAM_EXEC values are valid, and should be included
 * when the query is dispatched to the QEs.
 *
 * When the query eventually runs (on the QD or a QE), it will have access
 * to these PARAM_EXEC values (locally or through serialization).

 * Then, rather than lazily-evaluating the SubPlan to get its value (as for
 * an internal parameter), the plan will just use the value that's already
 * in the EState-&gt;es_param_exec_vals array.
 */</comment>
<function><type><specifier>static</specifier> <name>Bitmapset</name> <modifier>*</modifier></type>
<name>getExecParamsToDispatch</name><parameter_list>(<parameter><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>, <parameter><decl><type><name>ParamExecData</name> <modifier>*</modifier></type><name>intPrm</name></decl></parameter>,
						<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>paramExecTypes</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ParamWalkerContext</name></type> <name>context</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>plan</name> <init>= <expr><name><name>stmt</name><operator>-&gt;</operator><name>planTree</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nIntPrm</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>paramExecTypes</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>sendParams</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>nIntPrm</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>paramExecTypes</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>intPrm</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>		<comment type="block">/* So there must be some internal parameters. */</comment>

	<comment type="block">/*
	 * Walk the plan, looking for Param nodes of kind PARAM_EXEC, i.e.,
	 * executor internal parameters.
	 *
	 * We need these for their paramtype field, which isn't available in
	 * either the ParamExecData struct or the SubPlan struct.
	 */</comment>

	<expr_stmt><expr><call><name>exec_init_plan_tree_base</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>context</name><operator>.</operator><name>base</name></name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>params</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>param_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>plan</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * mpp-25490: subplanX may is within subplan Y, try to param_walker the
	 * subplans list
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>context</name><operator>.</operator><name>params</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>nIntPrm</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>sb</name></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>sb</argument>, <argument>stmt-&gt;subplans</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>subplan</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>sb</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>param_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>subplan</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Now set the bit corresponding to each init plan param. Use the datatype
	 * info harvested above.
	 */</comment>
	<expr_stmt><expr><operator>*</operator><name>paramExecTypes</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nIntPrm</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>paramType</name> <init>= <expr><call><name>findParamType</name><argument_list>(<argument><expr><name><name>context</name><operator>.</operator><name>params</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><operator>*</operator><name>paramExecTypes</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><operator>*</operator><name>paramExecTypes</name></expr></argument>, <argument><expr><name>paramType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>paramType</name> <operator>!=</operator> <name>InvalidOid</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>sendParams</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name>sendParams</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * Param of id i not found. Likely has been removed by constant
			 * folding.
			 */</comment>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name><name>context</name><operator>.</operator><name>params</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>sendParams</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Helper function param_walker() walks a plan and adds any Param nodes
 * to a list in the ParamWalkerContext.
 *
 * This list is input to the function findParamType(), which loops over the
 * list looking for a specific paramid, and returns its type.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>param_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>ParamWalkerContext</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>T_Param</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Param</name>	   <modifier>*</modifier></type><name>param</name> <init>= <expr><operator>(</operator><name>Param</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>param</name><operator>-&gt;</operator><name>paramkind</name></name> <operator>==</operator> <name>PARAM_EXEC</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>params</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>params</name></name></expr></argument>, <argument><expr><name>param</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><call><name>plan_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>param_walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Helper function findParamType() iterates over a list of Param nodes,
 * trying to match on the passed-in paramid. Returns the paramtype of a
 * match, else error.
 */</comment>
<function><type><specifier>static</specifier> <name>Oid</name></type>
<name>findParamType</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>params</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>paramid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>params</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Param</name>	   <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>paramid</name></name> <operator>==</operator> <name>paramid</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name><name>p</name><operator>-&gt;</operator><name>paramtype</name></name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>InvalidOid</name></expr>;</return>
</block_content>}</block></function>
</unit>
