<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/backend/cdb/dispatcher/cdbdisp_async.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * cdbdisp_async.c
 *	  Functions for asynchronous implementation of dispatching
 *	  commands to QExecutors.
 *
 * Portions Copyright (c) 2005-2008, Greenplum inc
 * Portions Copyright (c) 2012-Present VMware, Inc. or its affiliates.
 *
 *
 * IDENTIFICATION
 *	    src/backend/cdb/dispatcher/cdbdisp_async.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_POLL_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;poll.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_SYS_POLL_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/poll.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgstat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/ipc.h"</cpp:file></cpp:include>		<comment type="block">/* For proc_exit_inprogress  */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tcop/tcopprot.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbdisp.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbdisp_async.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbdispatchresult.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq-fe.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq-int.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbfts.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbgang.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbvars.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbpq.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/sequence.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/timestamp.h"</cpp:file></cpp:include>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DISPATCH_WAIT_TIMEOUT_MSEC</name></cpp:macro> <cpp:value>2000</cpp:value></cpp:define>

<comment type="block">/*
 * Ideally, we should set timeout to zero to cancel QEs as soon as possible,
 * but considering the cost of sending cancel signal is high, we want to process
 * as many finishing QEs as possible before cancelling
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DISPATCH_WAIT_CANCEL_TIMEOUT_MSEC</name></cpp:macro> <cpp:value>100</cpp:value></cpp:define>

<comment type="block">/*
 * DISPATCH_NO_WAIT means return immediate when there's no more data,
 * DISPATCH_WAIT_UNTIL_FINISH means wait until all dispatch works are completed.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DISPATCH_NO_WAIT</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DISPATCH_WAIT_UNTIL_FINISH</name></cpp:macro> <cpp:value>-1</cpp:value></cpp:define>

<typedef>typedef <type><struct>struct <name>CdbDispatchCmdAsync</name>
<block>{

	<comment type="block">/*
	 * dispatchResultPtrArray: Array[0..dispatchCount-1] of CdbDispatchResult*
	 * Each CdbDispatchResult object points to a SegmentDatabaseDescriptor
	 * that dispatcher will send the command to.
	 */</comment>
	<decl_stmt><decl><type><name><name>struct</name> <name>CdbDispatchResult</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>dispatchResultPtrArray</name></decl>;</decl_stmt>

	<comment type="block">/* Number of segment DBs dispatched */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>dispatchCount</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Depending on this mode, we may send query cancel or query finish
	 * message to QE while we are waiting it to complete.  NONE means we
	 * expect QE to complete without any instruction.
	 */</comment>
	<decl_stmt><decl><type><specifier>volatile</specifier> <name>DispatchWaitMode</name></type> <name>waitMode</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * When waitMode is set to DISPATCH_WAIT_ACK_ROOT,
	 * the expected acknowledge message from QE should be specified.
	 * This field stores the expected acknowledge message.
	 */</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name>	<modifier>*</modifier></type><name>ackMessage</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Text information to dispatch: The format is type(1 byte) + length(size
	 * of int) + content(n bytes)
	 *
	 * For DTX command, type is 'T', it's built by function
	 * buildGpDtxProtocolCommand. For query, type is 'M', it's built by
	 * function buildGpQueryString.
	 */</comment>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>query_text</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>query_text_len</name></decl>;</decl_stmt>

}</block></struct></type> <name>CdbDispatchCmdAsync</name>;</typedef>

<function_decl><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type><name>cdbdisp_makeDispatchParams_async</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>maxSlices</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>largestGangSize</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>queryText</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>cdbdisp_checkAckMessage_async</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>CdbDispatcherState</name></name> <modifier>*</modifier></type><name>ds</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>message</name></decl></parameter>,
									<parameter><decl><type><name>int</name></type> <name>timeout_sec</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>cdbdisp_checkDispatchResult_async</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>CdbDispatcherState</name></name> <modifier>*</modifier></type><name>ds</name></decl></parameter>,
								  <parameter><decl><type><name>DispatchWaitMode</name></type> <name>waitMode</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>cdbdisp_dispatchToGang_async</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>CdbDispatcherState</name></name> <modifier>*</modifier></type><name>ds</name></decl></parameter>,
							 <parameter><decl><type><name><name>struct</name> <name>Gang</name></name> <modifier>*</modifier></type><name>gp</name></decl></parameter>,
							 <parameter><decl><type><name>int</name></type> <name>sliceIndex</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type>	<name>cdbdisp_waitDispatchFinish_async</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>CdbDispatcherState</name></name> <modifier>*</modifier></type><name>ds</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>bool</name></type>	<name>cdbdisp_checkForCancel_async</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>CdbDispatcherState</name></name> <modifier>*</modifier></type><name>ds</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name> <modifier>*</modifier></type><name>cdbdisp_getWaitSocketFds_async</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>CdbDispatcherState</name></name> <modifier>*</modifier></type><name>ds</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>nsocks</name></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><name>DispatcherInternalFuncs</name></type> <name>DispatcherAsyncFuncs</name> <init>=
<expr><block>{
	<expr><name>cdbdisp_checkForCancel_async</name></expr>,
	<expr><name>cdbdisp_getWaitSocketFds_async</name></expr>,
	<expr><name>cdbdisp_makeDispatchParams_async</name></expr>,
	<expr><name>cdbdisp_checkAckMessage_async</name></expr>,
	<expr><name>cdbdisp_checkDispatchResult_async</name></expr>,
	<expr><name>cdbdisp_dispatchToGang_async</name></expr>,
	<expr><name>cdbdisp_waitDispatchFinish_async</name></expr>
}</block></expr></init></decl>;</decl_stmt>


<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dispatchCommand</name><parameter_list>(<parameter><decl><type><name>CdbDispatchResult</name> <modifier>*</modifier></type><name>dispatchResult</name></decl></parameter>,
				<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>query_text</name></decl></parameter>,
				<parameter><decl><type><name>int</name></type> <name>query_text_len</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>checkDispatchResult</name><parameter_list>(<parameter><decl><type><name>CdbDispatcherState</name> <modifier>*</modifier></type><name>ds</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>timeout_sec</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>checkDispatchResultLoop</name><parameter_list>(<parameter><decl><type><name>CdbDispatcherState</name> <modifier>*</modifier></type><name>ds</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>timeout_sec</name></decl></parameter>, <parameter><decl><type><name>WaitEventSet</name> <modifier>*</modifier></type><name>waitset</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>cdbdisp_waitDispatchFinishLoop_async</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>CdbDispatcherState</name></name> <modifier>*</modifier></type><name>ds</name></decl></parameter>, <parameter><decl><type><name>WaitEventSet</name> <modifier>*</modifier></type><name>waitset</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>processResults</name><parameter_list>(<parameter><decl><type><name>CdbDispatchResult</name> <modifier>*</modifier></type><name>dispatchResult</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type>
			<name>signalQEs</name><parameter_list>(<parameter><decl><type><name>CdbDispatchCmdAsync</name> <modifier>*</modifier></type><name>pParms</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type>
			<name>checkSegmentAlive</name><parameter_list>(<parameter><decl><type><name>CdbDispatchCmdAsync</name> <modifier>*</modifier></type><name>pParms</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type>
			<name>handlePollError</name><parameter_list>(<parameter><decl><type><name>CdbDispatchCmdAsync</name> <modifier>*</modifier></type><name>pParms</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type>
			<name>handlePollSuccess</name><parameter_list>(<parameter><decl><type><name>CdbDispatchCmdAsync</name> <modifier>*</modifier></type><name>pParms</name></decl></parameter>, <parameter><decl><type><name>WaitEvent</name> <modifier>*</modifier></type><name>revents</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nready</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>bool</name></type>
			<name>checkAckMessage</name><parameter_list>(<parameter><decl><type><name>CdbDispatchResult</name> <modifier>*</modifier></type><name>dispatchResult</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>message</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * Check dispatch result.
 * Don't wait all dispatch commands to complete.
 *
 * Return true if any connection received error.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>cdbdisp_checkForCancel_async</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>CdbDispatcherState</name></name> <modifier>*</modifier></type><name>ds</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>checkDispatchResult</name><argument_list>(<argument><expr><name>ds</name></expr></argument>, <argument><expr><name>DISPATCH_NO_WAIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>cdbdisp_checkResultsErrcode</name><argument_list>(<argument><expr><name><name>ds</name><operator>-&gt;</operator><name>primaryResults</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Return all FDs to wait for, after dispatching.
 *
 * nsocks is the returned socket fds number (as an output param):
 *
 * Return value is the array of waiting socket fds.
 * It's be palloced in this function, so caller need to pfree it.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name> <modifier>*</modifier></type>
<name>cdbdisp_getWaitSocketFds_async</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>CdbDispatcherState</name></name> <modifier>*</modifier></type><name>ds</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>nsocks</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CdbDispatchCmdAsync</name> <modifier>*</modifier></type><name>pParms</name> <init>= <expr><operator>(</operator><name>CdbDispatchCmdAsync</name> <operator>*</operator><operator>)</operator> <name><name>ds</name><operator>-&gt;</operator><name>dispatchParams</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name>			<modifier>*</modifier></type><name>fds</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>nsocks</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>proc_exit_inprogress</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>fds</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>pParms</name><operator>-&gt;</operator><name>dispatchCount</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * This should match the logic in cdbdisp_checkForCancel_async(). In
	 * particular, when cdbdisp_checkForCancel_async() is called, it must
	 * process any incoming data from the socket we return here, or we
	 * will busy wait.
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>pParms</name><operator>-&gt;</operator><name>dispatchCount</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>CdbDispatchResult</name> <modifier>*</modifier></type><name>dispatchResult</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>SegmentDatabaseDescriptor</name> <modifier>*</modifier></type><name>segdbDesc</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>dispatchResult</name> <operator>=</operator> <name><name>pParms</name><operator>-&gt;</operator><name>dispatchResultPtrArray</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>segdbDesc</name> <operator>=</operator> <name><name>dispatchResult</name><operator>-&gt;</operator><name>segdbDesc</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>cdbconn_isBadConnection</name><argument_list>(<argument><expr><name>segdbDesc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><operator>(</operator><name>fds</name><operator>)</operator><index>[<expr><operator>(</operator><operator>*</operator><name>nsocks</name><operator>)</operator><operator>++</operator></expr>]</index> <operator>=</operator> <call><name>PQsocket</name><argument_list>(<argument><expr><name><name>segdbDesc</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>fds</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Block until all data are dispatched.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>cdbdisp_waitDispatchFinish_async</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>CdbDispatcherState</name></name> <modifier>*</modifier></type><name>ds</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CdbDispatchCmdAsync</name> <modifier>*</modifier></type><name>pParms</name> <init>= <expr><operator>(</operator><name>CdbDispatchCmdAsync</name> <operator>*</operator><operator>)</operator> <name><name>ds</name><operator>-&gt;</operator><name>dispatchParams</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>				<name>dispatchCount</name> <init>= <expr><name><name>pParms</name><operator>-&gt;</operator><name>dispatchCount</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>WaitEventSet</name> 	<modifier>*</modifier><specifier>volatile</specifier></type> <name>waitset</name> <init>= <expr><call><name>CreateWaitEventSet</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>, <argument><expr><name>dispatchCount</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Use PG_TRY() - PG_CATCH() to make sure destroy the waiteventset (close the epoll fd) */</comment>
	<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<expr_stmt><expr><call><name>cdbdisp_waitDispatchFinishLoop_async</name><argument_list>(<argument><expr><name>ds</name></expr></argument>, <argument><expr><name>waitset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<expr_stmt><expr><call><name>FreeWaitEventSet</name><argument_list>(<argument><expr><name>waitset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>FreeWaitEventSet</name><argument_list>(<argument><expr><name>waitset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>cdbdisp_waitDispatchFinishLoop_async</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>CdbDispatcherState</name></name> <modifier>*</modifier></type><name>ds</name></decl></parameter>, <parameter><decl><type><name>WaitEventSet</name> <modifier>*</modifier></type><name>waitset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <specifier>static</specifier> <name>int</name></type> <name>DISPATCH_POLL_TIMEOUT</name> <init>= <expr><literal type="number">500</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CdbDispatchCmdAsync</name> <modifier>*</modifier></type><name>pParms</name> <init>= <expr><operator>(</operator><name>CdbDispatchCmdAsync</name> <operator>*</operator><operator>)</operator> <name><name>ds</name><operator>-&gt;</operator><name>dispatchParams</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>dispatchCount</name> <init>= <expr><name><name>pParms</name><operator>-&gt;</operator><name>dispatchCount</name></name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>WaitEvent</name> 		<modifier>*</modifier></type><name>revents</name> <init>= <expr><call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>WaitEvent</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>dispatchCount</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name> 			<modifier>*</modifier></type><name>added</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>dispatchCount</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<while>while <condition>(<expr><name>true</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>pollRet</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>allFlushed</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>dispatchCount</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>CdbDispatchResult</name> <modifier>*</modifier></type><name>qeResult</name> <init>= <expr><name><name>pParms</name><operator>-&gt;</operator><name>dispatchResultPtrArray</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>SegmentDatabaseDescriptor</name> <modifier>*</modifier></type><name>segdbDesc</name> <init>= <expr><name><name>qeResult</name><operator>-&gt;</operator><name>segdbDesc</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>PGconn</name>	   <modifier>*</modifier></type><name>conn</name> <init>= <expr><name><name>segdbDesc</name><operator>-&gt;</operator><name>conn</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>ret</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

			<comment type="block">/* skip already completed connections */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>outCount</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * call send for this connection regardless of its POLLOUT status,
			 * because it may be writable NOW
			 */</comment>
			<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>pqFlushNonBlocking</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><name>ret</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* add segment sock to the waitset */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>added</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>int</name></type> 	<name>sock</name> <init>= <expr><call><name>PQsocket</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>sock</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>AddWaitEventToSet</name><argument_list>(<argument><expr><name>waitset</name></expr></argument>, <argument><expr><name>WL_SOCKET_WRITEABLE</name></expr></argument>, <argument><expr><name>sock</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>added</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<expr_stmt><expr><name>allFlushed</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* error message should be set up already */</comment>
				<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>msg</name> <init>= <expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name><name>qeResult</name><operator>-&gt;</operator><name>stillRunning</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_GP_INTERCONNECTION_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Command could not be dispatch to segment %s: %s"</literal></expr></argument>, <argument><expr><name><name>qeResult</name><operator>-&gt;</operator><name>segdbDesc</name><operator>-&gt;</operator><name>whoami</name></name></expr></argument>, <argument><expr><ternary><condition><expr><name>msg</name></expr> ?</condition><then> <expr><name>msg</name></expr> </then><else>: <expr><literal type="string">"unknown error"</literal></expr></else></ternary></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>

		<if_stmt><if>if <condition>(<expr><name>allFlushed</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<comment type="block">/* guarantee poll() is interruptible */</comment>
		<do>do
		<block>{<block_content>
			<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>pollRet</name> <operator>=</operator> <call><name>WaitEventSetWait</name><argument_list>(<argument><expr><name>waitset</name></expr></argument>, <argument><expr><name>DISPATCH_POLL_TIMEOUT</name></expr></argument>, <argument><expr><name>revents</name></expr></argument>, <argument><expr><name>dispatchCount</name></expr></argument>, <argument><expr><name>WAIT_EVENT_DISP_FINISH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>pollRet</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>pollRet</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ELOG_DISPATCHER_DEBUG</name><argument_list>(<argument><expr><literal type="string">"cdbdisp_waitDispatchFinish_async(): Dispatch poll timeout after %d ms"</literal></expr></argument>, <argument><expr><name>DISPATCH_POLL_TIMEOUT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block>
		while <condition>(<expr><name>pollRet</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>;</do>
	</block_content>}</block></while>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>revents</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>added</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Dispatch command to gang.
 *
 * Throw out error to upper try-catch block if anything goes wrong. This function only kicks off dispatching,
 * call cdbdisp_waitDispatchFinish_async to ensure the completion
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>cdbdisp_dispatchToGang_async</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>CdbDispatcherState</name></name> <modifier>*</modifier></type><name>ds</name></decl></parameter>,
							 <parameter><decl><type><name><name>struct</name> <name>Gang</name></name> <modifier>*</modifier></type><name>gp</name></decl></parameter>,
							 <parameter><decl><type><name>int</name></type> <name>sliceIndex</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>CdbDispatchCmdAsync</name> <modifier>*</modifier></type><name>pParms</name> <init>= <expr><operator>(</operator><name>CdbDispatchCmdAsync</name> <operator>*</operator><operator>)</operator> <name><name>ds</name><operator>-&gt;</operator><name>dispatchParams</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Start the dispatching
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>gp</name><operator>-&gt;</operator><name>size</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>CdbDispatchResult</name> <modifier>*</modifier></type><name>qeResult</name></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>SegmentDatabaseDescriptor</name> <modifier>*</modifier></type><name>segdbDesc</name> <init>= <expr><name><name>gp</name><operator>-&gt;</operator><name>db_descriptors</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>segdbDesc</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Initialize the QE's CdbDispatchResult object.
		 */</comment>
		<expr_stmt><expr><name>qeResult</name> <operator>=</operator> <call><name>cdbdisp_makeResult</name><argument_list>(<argument><expr><name><name>ds</name><operator>-&gt;</operator><name>primaryResults</name></name></expr></argument>, <argument><expr><name>segdbDesc</name></expr></argument>, <argument><expr><name>sliceIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>qeResult</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"could not allocate resources for segworker communication"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name><name>pParms</name><operator>-&gt;</operator><name>dispatchResultPtrArray</name><index>[<expr><name><name>pParms</name><operator>-&gt;</operator><name>dispatchCount</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>qeResult</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>dispatchCommand</name><argument_list>(<argument><expr><name>qeResult</name></expr></argument>, <argument><expr><name><name>pParms</name><operator>-&gt;</operator><name>query_text</name></name></expr></argument>, <argument><expr><name><name>pParms</name><operator>-&gt;</operator><name>query_text_len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * Check the specified acknowledge messages from QEs.
 *
 * Check all dispatch connections to get expected acknowledge message.
 * Return true if all required QEs' acknowledge messages have been received.
 *
 * message: specifies the expected ACK message to check.
 * timeout_sec: the second that the dispatcher waits for the ack messages at most.
 *              0 means checking immediately, and -1 means waiting until all ack
 *              messages are received.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>cdbdisp_checkAckMessage_async</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>CdbDispatcherState</name></name> <modifier>*</modifier></type><name>ds</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>message</name></decl></parameter>,
							  <parameter><decl><type><name>int</name></type> <name>timeout_sec</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DispatchWaitMode</name></type> <name>prevWaitMode</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CdbDispatchCmdAsync</name> <modifier>*</modifier></type><name>pParms</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>receivedAll</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>pParms</name> <operator>=</operator> <operator>(</operator><name>CdbDispatchCmdAsync</name> <operator>*</operator><operator>)</operator> <name><name>ds</name><operator>-&gt;</operator><name>dispatchParams</name></name></expr>;</expr_stmt>
	<comment type="block">/* If cdbdisp_destroyDispatcherState is called */</comment>
	<if_stmt><if>if <condition>(<expr><name>pParms</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>message</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>pParms</name><operator>-&gt;</operator><name>ackMessage</name></name> <operator>=</operator> <name>message</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>prevWaitMode</name> <operator>=</operator> <name><name>pParms</name><operator>-&gt;</operator><name>waitMode</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pParms</name><operator>-&gt;</operator><name>waitMode</name></name> <operator>=</operator> <name>DISPATCH_WAIT_ACK_ROOT</name></expr>;</expr_stmt>

	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>pParms</name><operator>-&gt;</operator><name>dispatchCount</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>pParms</name><operator>-&gt;</operator><name>dispatchResultPtrArray</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>receivedAckMsg</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></for>

	<expr_stmt><expr><call><name>checkDispatchResult</name><argument_list>(<argument><expr><name>ds</name></expr></argument>, <argument><expr><name>timeout_sec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>pParms</name><operator>-&gt;</operator><name>dispatchCount</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>pParms</name><operator>-&gt;</operator><name>dispatchResultPtrArray</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>receivedAckMsg</name> <operator>&amp;&amp;</operator>
			<name><name>pParms</name><operator>-&gt;</operator><name>dispatchResultPtrArray</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>stillRunning</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>receivedAll</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><name><name>pParms</name><operator>-&gt;</operator><name>waitMode</name></name> <operator>=</operator> <name>prevWaitMode</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pParms</name><operator>-&gt;</operator><name>ackMessage</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<return>return <expr><name>receivedAll</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Check dispatch result.
 *
 * Wait all dispatch work to complete, either success or fail.
 * (Set stillRunning to true when one dispatch work is completed)
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>cdbdisp_checkDispatchResult_async</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>CdbDispatcherState</name></name> <modifier>*</modifier></type><name>ds</name></decl></parameter>,
								  <parameter><decl><type><name>DispatchWaitMode</name></type> <name>waitMode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ds</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>CdbDispatchCmdAsync</name> <modifier>*</modifier></type><name>pParms</name> <init>= <expr><operator>(</operator><name>CdbDispatchCmdAsync</name> <operator>*</operator><operator>)</operator> <name><name>ds</name><operator>-&gt;</operator><name>dispatchParams</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* cdbdisp_destroyDispatcherState is called */</comment>
	<if_stmt><if>if <condition>(<expr><name>pParms</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Don't overwrite DISPATCH_WAIT_CANCEL or DISPATCH_WAIT_FINISH with
	 * DISPATCH_WAIT_NONE
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>waitMode</name> <operator>!=</operator> <name>DISPATCH_WAIT_NONE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>pParms</name><operator>-&gt;</operator><name>waitMode</name></name> <operator>=</operator> <name>waitMode</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>checkDispatchResult</name><argument_list>(<argument><expr><name>ds</name></expr></argument>, <argument><expr><name>DISPATCH_WAIT_UNTIL_FINISH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Allocates memory for a CdbDispatchCmdAsync structure and do the initialization.
 *
 * Memory will be freed in function cdbdisp_destroyDispatcherState by deleting the
 * memory context.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type>
<name>cdbdisp_makeDispatchParams_async</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>maxSlices</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>largestGangSize</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>queryText</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>maxResults</name> <init>= <expr><name>maxSlices</name> <operator>*</operator> <name>largestGangSize</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>CdbDispatchCmdAsync</name> <modifier>*</modifier></type><name>pParms</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>CdbDispatchCmdAsync</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>size</name> <operator>=</operator> <name>maxResults</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>CdbDispatchResult</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pParms</name><operator>-&gt;</operator><name>dispatchResultPtrArray</name></name> <operator>=</operator> <operator>(</operator><name>CdbDispatchResult</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pParms</name><operator>-&gt;</operator><name>dispatchCount</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pParms</name><operator>-&gt;</operator><name>waitMode</name></name> <operator>=</operator> <name>DISPATCH_WAIT_NONE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pParms</name><operator>-&gt;</operator><name>ackMessage</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pParms</name><operator>-&gt;</operator><name>query_text</name></name> <operator>=</operator> <name>queryText</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pParms</name><operator>-&gt;</operator><name>query_text_len</name></name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>pParms</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Receive and process results from all running QEs.
 * timeout_sec: the second that the dispatcher waits for the ack messages at most.
 *              DISPATCH_NO_WAIT(0): return immediate when there's no more data.
 *              DISPATCH_WAIT_UNTIL_FINISH(-1): wait until all dispatch works are completed.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>checkDispatchResult</name><parameter_list>(<parameter><decl><type><name>CdbDispatcherState</name> <modifier>*</modifier></type><name>ds</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>timeout_sec</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CdbDispatchCmdAsync</name> <modifier>*</modifier></type><name>pParms</name> <init>= <expr><operator>(</operator><name>CdbDispatchCmdAsync</name> <operator>*</operator><operator>)</operator> <name><name>ds</name><operator>-&gt;</operator><name>dispatchParams</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>WaitEventSet</name> <modifier>*</modifier><specifier>volatile</specifier></type> <name>waitset</name> <init>= <expr><call><name>CreateWaitEventSet</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>, <argument><expr><name><name>pParms</name><operator>-&gt;</operator><name>dispatchCount</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Use PG_TRY() - PG_CATCH() to make sure destroy the waiteventset (close the epoll fd) */</comment>
	<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<expr_stmt><expr><call><name>checkDispatchResultLoop</name><argument_list>(<argument><expr><name>ds</name></expr></argument>, <argument><expr><name>timeout_sec</name></expr></argument>, <argument><expr><name>waitset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<expr_stmt><expr><call><name>FreeWaitEventSet</name><argument_list>(<argument><expr><name>waitset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>FreeWaitEventSet</name><argument_list>(<argument><expr><name>waitset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>checkDispatchResultLoop</name><parameter_list>(<parameter><decl><type><name>CdbDispatcherState</name> <modifier>*</modifier></type><name>ds</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>timeout_sec</name></decl></parameter>, <parameter><decl><type><name>WaitEventSet</name> <modifier>*</modifier></type><name>waitset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>timeout</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>sentSignal</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint8</name></type> <name>ftsVersion</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>start_ts</name></decl>, <decl><type ref="prev"/><name>now</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type>		<name>diff_us</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>CdbDispatchCmdAsync</name> <modifier>*</modifier></type><name>pParms</name> <init>= <expr><operator>(</operator><name>CdbDispatchCmdAsync</name> <operator>*</operator><operator>)</operator> <name><name>ds</name><operator>-&gt;</operator><name>dispatchParams</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CdbDispatchResults</name> <modifier>*</modifier></type><name>meleeResults</name> <init>= <expr><name><name>ds</name><operator>-&gt;</operator><name>primaryResults</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SegmentDatabaseDescriptor</name> <modifier>*</modifier></type><name>segdbDesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CdbDispatchResult</name> <modifier>*</modifier></type><name>dispatchResult</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>int</name></type> 	<name>db_count</name> <init>= <expr><name><name>pParms</name><operator>-&gt;</operator><name>dispatchCount</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name> 	<modifier>*</modifier></type><name>added</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><name>db_count</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>WaitEvent</name> <modifier>*</modifier></type><name>revents</name> <init>= <expr><call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>WaitEvent</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>db_count</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * OK, we are finished submitting the command to the segdbs. Now, we have
	 * to wait for them to finish.
	 */</comment>
	<expr_stmt><expr><call><name>gettimeofday</name><argument_list>(<argument><expr><operator>&amp;</operator><name>start_ts</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>n</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>nfds</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>ack_count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PGconn</name>		<modifier>*</modifier></type><name>conn</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * bail-out if we are dying. Once QD dies, QE will recognize it
		 * shortly anyway.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>proc_exit_inprogress</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Current loop might last for the long time so check on interrupts.
		 */</comment>
		<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * escalate waitMode to cancel if:
		 * - user cancel request has occurred,
		 * - or an error has been reported by any QE,
		 * - in case the caller wants cancelOnError
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>CancelRequested</name><argument_list>()</argument_list></call> <operator>||</operator> <name><name>meleeResults</name><operator>-&gt;</operator><name>errcode</name></name><operator>)</operator> <operator>&amp;&amp;</operator> <name><name>meleeResults</name><operator>-&gt;</operator><name>cancelOnError</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>pParms</name><operator>-&gt;</operator><name>waitMode</name></name> <operator>=</operator> <name>DISPATCH_WAIT_CANCEL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Which QEs are still running and could send results to us?
		 */</comment>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>db_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name>dispatchResult</name> <operator>=</operator> <name><name>pParms</name><operator>-&gt;</operator><name>dispatchResultPtrArray</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>segdbDesc</name> <operator>=</operator> <name><name>dispatchResult</name><operator>-&gt;</operator><name>segdbDesc</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>conn</name> <operator>=</operator> <name><name>segdbDesc</name><operator>-&gt;</operator><name>conn</name></name></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>pParms</name><operator>-&gt;</operator><name>waitMode</name></name> <operator>==</operator> <name>DISPATCH_WAIT_ACK_ROOT</name> <operator>&amp;&amp;</operator>
				<call><name>checkAckMessage</name><argument_list>(<argument><expr><name>dispatchResult</name></expr></argument>, <argument><expr><name><name>pParms</name><operator>-&gt;</operator><name>ackMessage</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>ack_count</name><operator>++</operator></expr>;</expr_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * Already finished with this QE?
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>dispatchResult</name><operator>-&gt;</operator><name>stillRunning</name></name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>cdbconn_isBadConnection</name><argument_list>(<argument><expr><name>segdbDesc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Flush out buffer in case some commands are not fully
			 * dispatched to QEs, this can prevent QD from polling
			 * on such QEs forever.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>outCount</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * Don't error out here, let following poll() routine to
				 * handle it.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>pqFlush</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Failed flushing outbound data to %s:%s"</literal></expr></argument>,
						 <argument><expr><name><name>segdbDesc</name><operator>-&gt;</operator><name>whoami</name></name></expr></argument>, <argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FAULT_INJECTOR</name></cpp:ifdef>
			<comment type="block">/* inject invalid sock to simulate an pqFlush() error */</comment>
			<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>saved_sock</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>FaultInjector_InjectFaultIfSet</name><argument_list>(<argument><expr><literal type="string">"inject_invalid_sock_for_checkDispatchResult"</literal></expr></argument>,
						<argument><expr><name>DDLNotSpecified</name></expr></argument>,
						<argument><expr><literal type="string">""</literal></expr></argument> <comment type="block">/* databaseName */</comment>,
						<argument><expr><literal type="string">""</literal></expr></argument> <comment type="block">/* tableName */</comment>)</argument_list></call> <operator>==</operator> <name>FaultInjectorTypeSkip</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>saved_sock</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>saved_sock</name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>sock</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>sock</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><literal type="string">"inject invalid sock\n"</literal></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name><operator>.</operator><name>maxlen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name><operator>.</operator><name>len</name></name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>i</name><operator>--</operator></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

			<comment type="block">/*
			 * When the connection was broken, the previous pqFlush() set:
			 * 			sock = -1 and status = CONNECTION_BAD
			 * it will cause an infinite hang when poll() it later, so need to skip it here
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>cdbconn_isBadConnection</name><argument_list>(<argument><expr><name>segdbDesc</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"Connection (%s) is broken, PQerrorMessage:%s"</literal></expr></argument>,
					<argument><expr><name><name>segdbDesc</name><operator>-&gt;</operator><name>whoami</name></name></expr></argument>, <argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>stillRunning</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FAULT_INJECTOR</name></cpp:ifdef>
				<comment type="block">/* restore the saved sock */</comment>
				<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>sock</name></name> <operator>=</operator> <name>saved_sock</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name><operator>.</operator><name>data</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>errorMessage</name><operator>.</operator><name>len</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>stillRunning</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* add segment sock to the waitset */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>added</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>int</name></type> 	<name>sock</name> <init>= <expr><call><name>PQsocket</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>long</name></type> 	<name>ev_userdata</name> <init>= <expr><name>i</name></expr></init></decl>;</decl_stmt> <comment type="block">/* the index "i" as the event's userdata */</comment>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>sock</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>AddWaitEventToSet</name><argument_list>(<argument><expr><name>waitset</name></expr></argument>, <argument><expr><name>WL_SOCKET_READABLE</name></expr></argument>, <argument><expr><name>sock</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>ev_userdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>added</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>nfds</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></for>

		<comment type="block">/*
		 * Break out when no QEs still running or required QEs acked.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>nfds</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator>
			<operator>(</operator><name><name>pParms</name><operator>-&gt;</operator><name>waitMode</name></name> <operator>==</operator> <name>DISPATCH_WAIT_ACK_ROOT</name> <operator>&amp;&amp;</operator> <name>ack_count</name> <operator>==</operator> <name><name>ds</name><operator>-&gt;</operator><name>rootGangSize</name></name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Wait for results from QEs
		 *
		 * Don't wait if: - this is called from interconnect to check if
		 * there's any error.
		 *
		 * Lower the timeout if: - we need send signal to QEs.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>timeout_sec</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>timeout</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name><name>pParms</name><operator>-&gt;</operator><name>waitMode</name></name> <operator>==</operator> <name>DISPATCH_WAIT_NONE</name> <operator>||</operator>
				 <name><name>pParms</name><operator>-&gt;</operator><name>waitMode</name></name> <operator>==</operator> <name>DISPATCH_WAIT_ACK_ROOT</name> <operator>||</operator>
				 <name>sentSignal</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>timeout</name> <operator>=</operator> <name>DISPATCH_WAIT_TIMEOUT_MSEC</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>timeout</name> <operator>=</operator> <name>DISPATCH_WAIT_CANCEL_TIMEOUT_MSEC</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>WaitEventSetWait</name><argument_list>(<argument><expr><name>waitset</name></expr></argument>, <argument><expr><name>timeout</name></expr></argument>, <argument><expr><name>revents</name></expr></argument>, <argument><expr><name>db_count</name></expr></argument>, <argument><expr><name>WAIT_EVENT_DISP_RESULT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * poll returns with an error, including one due to an interrupted
		 * call
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>sock_errno</name> <init>= <expr><name>SOCK_ERRNO</name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>sock_errno</name> <operator>==</operator> <name>EINTR</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"handlePollError poll() failed; errno=%d"</literal></expr></argument>, <argument><expr><name>sock_errno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>handlePollError</name><argument_list>(<argument><expr><name>pParms</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Since an error was detected for the segment, request
			 * FTS to perform a probe before checking the segment
			 * state.
			 */</comment>
			<expr_stmt><expr><call><name>FtsNotifyProber</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>checkSegmentAlive</name><argument_list>(<argument><expr><name>pParms</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>pParms</name><operator>-&gt;</operator><name>waitMode</name></name> <operator>!=</operator> <name>DISPATCH_WAIT_NONE</name> <operator>&amp;&amp;</operator>
				<name><name>pParms</name><operator>-&gt;</operator><name>waitMode</name></name> <operator>!=</operator> <name>DISPATCH_WAIT_ACK_ROOT</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>signalQEs</name><argument_list>(<argument><expr><name>pParms</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>sentSignal</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>gettimeofday</name><argument_list>(<argument><expr><operator>&amp;</operator><name>now</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>diff_us</name> <operator>=</operator> <operator>(</operator><name><name>now</name><operator>.</operator><name>tv_sec</name></name> <operator>-</operator> <name><name>start_ts</name><operator>.</operator><name>tv_sec</name></name><operator>)</operator> <operator>*</operator> <literal type="number">1000000</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>diff_us</name> <operator>+=</operator> <operator>(</operator><name>int</name><operator>)</operator> <name><name>now</name><operator>.</operator><name>tv_usec</name></name> <operator>-</operator> <operator>(</operator><name>int</name><operator>)</operator> <name><name>start_ts</name><operator>.</operator><name>tv_usec</name></name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>timeout_sec</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>diff_us</name> <operator>&gt;=</operator> <name>timeout_sec</name> <operator>*</operator> <literal type="number">1000000L</literal></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<comment type="block">/* If the time limit expires, poll() returns 0 */</comment>
		<if type="elseif">else if <condition>(<expr><name>n</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>pParms</name><operator>-&gt;</operator><name>waitMode</name></name> <operator>!=</operator> <name>DISPATCH_WAIT_NONE</name> <operator>&amp;&amp;</operator>
				<name><name>pParms</name><operator>-&gt;</operator><name>waitMode</name></name> <operator>!=</operator> <name>DISPATCH_WAIT_ACK_ROOT</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>signalQEs</name><argument_list>(<argument><expr><name>pParms</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>sentSignal</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * This code relies on FTS being triggered at regular
			 * intervals. Iff FTS detects change in configuration
			 * then check segment state. FTS probe is not triggered
			 * explicitly in this case because this happens every
			 * DISPATCH_WAIT_TIMEOUT_MSEC.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>ftsVersion</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>ftsVersion</name> <operator>!=</operator> <call><name>getFtsVersion</name><argument_list>()</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>ftsVersion</name> <operator>=</operator> <call><name>getFtsVersion</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>checkSegmentAlive</name><argument_list>(<argument><expr><name>pParms</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>gettimeofday</name><argument_list>(<argument><expr><operator>&amp;</operator><name>now</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>diff_us</name> <operator>=</operator> <operator>(</operator><name><name>now</name><operator>.</operator><name>tv_sec</name></name> <operator>-</operator> <name><name>start_ts</name><operator>.</operator><name>tv_sec</name></name><operator>)</operator> <operator>*</operator> <literal type="number">1000000</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>diff_us</name> <operator>+=</operator> <operator>(</operator><name>int</name><operator>)</operator> <name><name>now</name><operator>.</operator><name>tv_usec</name></name> <operator>-</operator> <operator>(</operator><name>int</name><operator>)</operator> <name><name>start_ts</name><operator>.</operator><name>tv_usec</name></name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>timeout_sec</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>diff_us</name> <operator>&gt;=</operator> <name>timeout_sec</name> <operator>*</operator> <literal type="number">1000000L</literal></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<comment type="block">/* We have data waiting on one or more of the connections. */</comment>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>handlePollSuccess</name><argument_list>(<argument><expr><name>pParms</name></expr></argument>, <argument><expr><name>revents</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></for> <comment type="block">/* for (;;) */</comment>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>revents</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>added</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Helper function that actually kicks off the command on the libpq connection.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dispatchCommand</name><parameter_list>(<parameter><decl><type><name>CdbDispatchResult</name> <modifier>*</modifier></type><name>dispatchResult</name></decl></parameter>,
				<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>query_text</name></decl></parameter>,
				<parameter><decl><type><name>int</name></type> <name>query_text_len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>beforeSend</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>long</name></type>		<name>secs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>usecs</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>DEBUG1</name> <operator>&gt;=</operator> <name>log_min_messages</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>beforeSend</name> <operator>=</operator> <call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Submit the command asynchronously.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>PQsendGpQuery_shared</name><argument_list>(<argument><expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>segdbDesc</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>query_text</name></expr></argument>, <argument><expr><name>query_text_len</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>msg</name> <init>= <expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>segdbDesc</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>stillRunning</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_GP_INTERCONNECTION_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Command could not be dispatch to segment %s: %s"</literal></expr></argument>,
						<argument><expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>segdbDesc</name><operator>-&gt;</operator><name>whoami</name></name></expr></argument>, <argument><expr><ternary><condition><expr><name>msg</name></expr> ?</condition><then> <expr><name>msg</name></expr> </then><else>: <expr><literal type="string">"unknown error"</literal></expr></else></ternary></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>forwardQENotices</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>DEBUG1</name> <operator>&gt;=</operator> <name>log_min_messages</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>TimestampDifference</name><argument_list>(<argument><expr><name>beforeSend</name></expr></argument>, <argument><expr><call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>secs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>usecs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>secs</name> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator> <name>usecs</name> <operator>&gt;</operator> <literal type="number">1000</literal></expr>)</condition><block type="pseudo"><block_content>	<comment type="block">/* Time &gt; 1ms? */</comment>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"time for PQsendGpQuery_shared %ld.%06d"</literal></expr></argument>, <argument><expr><name>secs</name></expr></argument>, <argument><expr><name>usecs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * We'll keep monitoring this QE -- whether or not the command was
	 * dispatched -- in order to check for a lost connection or any other
	 * errors that libpq might have in store for us.
	 */</comment>
	<expr_stmt><expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>stillRunning</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>hasDispatched</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ELOG_DISPATCHER_DEBUG</name><argument_list>(<argument><expr><literal type="string">"Command dispatched to QE (%s)"</literal></expr></argument>, <argument><expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>segdbDesc</name><operator>-&gt;</operator><name>whoami</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Helper function to check whether specified acknowledge message has been
 * received.
 *
 * Check whether the current required acknowledge message is already received
 * in the ackPGNotifies queue.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>checkAckMessage</name><parameter_list>(<parameter><decl><type><name>CdbDispatchResult</name> <modifier>*</modifier></type><name>dispatchResult</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>message</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>received</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGnotify</name><modifier>*</modifier></type> <name>ackNotifies</name> <init>= <expr><operator>(</operator><name>PGnotify</name> <operator>*</operator><operator>)</operator> <name><name>dispatchResult</name><operator>-&gt;</operator><name>ackPGNotifies</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>message</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Notify ACK message is required."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>receivedAckMsg</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<while>while <condition>(<expr><name>ackNotifies</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>ackNotifies</name><operator>-&gt;</operator><name>extra</name></name></expr></argument>, <argument><expr><name>message</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>received</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>receivedAckMsg</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>ackNotifies</name> <operator>=</operator> <name><name>ackNotifies</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
	</block_content>}</block></while>
	<return>return <expr><name>received</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Helper function to checkDispatchResult that handles errors that occur
 * during the poll() call.
 *
 * NOTE: The cleanup of the connections will be performed by handlePollTimeout().
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>handlePollError</name><parameter_list>(<parameter><decl><type><name>CdbDispatchCmdAsync</name> <modifier>*</modifier></type><name>pParms</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>pParms</name><operator>-&gt;</operator><name>dispatchCount</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>CdbDispatchResult</name> <modifier>*</modifier></type><name>dispatchResult</name> <init>= <expr><name><name>pParms</name><operator>-&gt;</operator><name>dispatchResultPtrArray</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>SegmentDatabaseDescriptor</name> <modifier>*</modifier></type><name>segdbDesc</name> <init>= <expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>segdbDesc</name></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Skip if already finished or didn't dispatch. */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>dispatchResult</name><operator>-&gt;</operator><name>stillRunning</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>pParms</name><operator>-&gt;</operator><name>waitMode</name></name> <operator>==</operator> <name>DISPATCH_WAIT_ACK_ROOT</name> <operator>&amp;&amp;</operator>
				 <name><name>dispatchResult</name><operator>-&gt;</operator><name>receivedAckMsg</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* We're done with this QE, sadly. */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>PQstatus</name><argument_list>(<argument><expr><name><name>segdbDesc</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>CONNECTION_BAD</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>msg</name> <init>= <expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name><name>segdbDesc</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>msg</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Dispatcher encountered connection error on %s: %s"</literal></expr></argument>, <argument><expr><name><name>segdbDesc</name><operator>-&gt;</operator><name>whoami</name></name></expr></argument>, <argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Dispatcher noticed bad connection in handlePollError()"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Save error info for later. */</comment>
			<expr_stmt><expr><call><name>cdbdisp_appendMessageNonThread</name><argument_list>(<argument><expr><name>dispatchResult</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>,
										   <argument><expr><literal type="string">"Error after dispatch from %s: %s"</literal></expr></argument>,
										   <argument><expr><name><name>segdbDesc</name><operator>-&gt;</operator><name>whoami</name></name></expr></argument>,
										   <argument><expr><ternary><condition><expr><name>msg</name></expr> ?</condition><then> <expr><name>msg</name></expr> </then><else>: <expr><literal type="string">"unknown error"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>PQfinish</name><argument_list>(<argument><expr><name><name>segdbDesc</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>segdbDesc</name><operator>-&gt;</operator><name>conn</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>stillRunning</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>forwardQENotices</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<return>return;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Receive and process results from QEs.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>handlePollSuccess</name><parameter_list>(<parameter><decl><type><name>CdbDispatchCmdAsync</name> <modifier>*</modifier></type><name>pParms</name></decl></parameter>,
				  <parameter><decl><type><name>WaitEvent</name> <modifier>*</modifier></type><name>revents</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nready</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * We have data waiting on one or more of the connections.
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nready</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>long</name></type> <name>pos</name> <init>= <expr><operator>(</operator><name>long</name><operator>)</operator><operator>(</operator><name><name>revents</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>user_data</name><operator>)</operator></expr></init></decl>;</decl_stmt> <comment type="block">/* original position */</comment>
		<decl_stmt><decl><type><name>bool</name></type>		<name>finished</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>sock</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>CdbDispatchResult</name> <modifier>*</modifier></type><name>dispatchResult</name> <init>= <expr><name><name>pParms</name><operator>-&gt;</operator><name>dispatchResultPtrArray</name><index>[<expr><name>pos</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>SegmentDatabaseDescriptor</name> <modifier>*</modifier></type><name>segdbDesc</name> <init>= <expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>segdbDesc</name></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * Skip if already finished or didn't dispatch.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>dispatchResult</name><operator>-&gt;</operator><name>stillRunning</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>pParms</name><operator>-&gt;</operator><name>waitMode</name></name> <operator>==</operator> <name>DISPATCH_WAIT_ACK_ROOT</name> <operator>&amp;&amp;</operator>
				 <name><name>dispatchResult</name><operator>-&gt;</operator><name>receivedAckMsg</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>ELOG_DISPATCHER_DEBUG</name><argument_list>(<argument><expr><literal type="string">"looking for results from %ld of %d (%s)"</literal></expr></argument>,
							  <argument><expr><name>pos</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name><name>pParms</name><operator>-&gt;</operator><name>dispatchCount</name></name></expr></argument>, <argument><expr><name><name>segdbDesc</name><operator>-&gt;</operator><name>whoami</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>sock</name> <operator>=</operator> <call><name>PQsocket</name><argument_list>(<argument><expr><name><name>segdbDesc</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>sock</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>sock</name> <operator>==</operator> <name><name>revents</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Skip this connection if it has no input available.
		if (!(fds[currentFdNumber++].revents &amp; POLLIN))
			continue;
		 */</comment>

		<expr_stmt><expr><call><name>ELOG_DISPATCHER_DEBUG</name><argument_list>(<argument><expr><literal type="string">"PQsocket says there are results from %ld of %d (%s)"</literal></expr></argument>,
							  <argument><expr><name>pos</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name><name>pParms</name><operator>-&gt;</operator><name>dispatchCount</name></name></expr></argument>, <argument><expr><name><name>segdbDesc</name><operator>-&gt;</operator><name>whoami</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Receive and process results from this QE.
		 */</comment>
		<expr_stmt><expr><name>finished</name> <operator>=</operator> <call><name>processResults</name><argument_list>(<argument><expr><name>dispatchResult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Are we through with this QE now?
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>finished</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>stillRunning</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>ELOG_DISPATCHER_DEBUG</name><argument_list>(<argument><expr><literal type="string">"processResults says we are finished with %ld of %d (%s)"</literal></expr></argument>,
								  <argument><expr><name>pos</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name><name>pParms</name><operator>-&gt;</operator><name>dispatchCount</name></name></expr></argument>, <argument><expr><name><name>segdbDesc</name><operator>-&gt;</operator><name>whoami</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>DEBUG1</name> <operator>&gt;=</operator> <name>log_min_messages</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>char</name></type>		<name><name>msec_str</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>

				<switch>switch <condition>(<expr><call><name>check_log_duration</name><argument_list>(<argument><expr><name>msec_str</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<case>case <expr><literal type="number">1</literal></expr>:</case>
					<case>case <expr><literal type="number">2</literal></expr>:</case>
						<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"duration to dispatch result received from %ld (seg %d): %s ms"</literal></expr></argument>,
							 <argument><expr><name>pos</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>segdbDesc</name><operator>-&gt;</operator><name>segindex</name></name></expr></argument>, <argument><expr><name>msec_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
				</block_content>}</block></switch>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>PQisBusy</name><argument_list>(<argument><expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>segdbDesc</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"did not receive query results on libpq connection %s"</literal></expr></argument>,
					 <argument><expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>segdbDesc</name><operator>-&gt;</operator><name>whoami</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ELOG_DISPATCHER_DEBUG</name><argument_list>(<argument><expr><literal type="string">"processResults says we have more to do with %ld of %d (%s)"</literal></expr></argument>,
								  <argument><expr><name>pos</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name><name>pParms</name><operator>-&gt;</operator><name>dispatchCount</name></name></expr></argument>, <argument><expr><name><name>segdbDesc</name><operator>-&gt;</operator><name>whoami</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * Send finish or cancel signal to QEs if needed.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>signalQEs</name><parameter_list>(<parameter><decl><type><name>CdbDispatchCmdAsync</name> <modifier>*</modifier></type><name>pParms</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DispatchWaitMode</name></type> <name>waitMode</name> <init>= <expr><name><name>pParms</name><operator>-&gt;</operator><name>waitMode</name></name></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>pParms</name><operator>-&gt;</operator><name>dispatchCount</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>errbuf</name><index>[<expr><literal type="number">256</literal></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>sent</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>CdbDispatchResult</name> <modifier>*</modifier></type><name>dispatchResult</name> <init>= <expr><name><name>pParms</name><operator>-&gt;</operator><name>dispatchResultPtrArray</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>dispatchResult</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<decl_stmt><decl><type><name>SegmentDatabaseDescriptor</name> <modifier>*</modifier></type><name>segdbDesc</name> <init>= <expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>segdbDesc</name></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * Don't send the signal if - QE is finished or canceled - the signal
		 * was already sent - connection is dead
		 */</comment>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>dispatchResult</name><operator>-&gt;</operator><name>stillRunning</name></name> <operator>||</operator>
			<name><name>dispatchResult</name><operator>-&gt;</operator><name>wasCanceled</name></name> <operator>||</operator>
			<operator>(</operator><name><name>pParms</name><operator>-&gt;</operator><name>waitMode</name></name> <operator>==</operator> <name>DISPATCH_WAIT_ACK_ROOT</name> <operator>&amp;&amp;</operator>
			 <name><name>dispatchResult</name><operator>-&gt;</operator><name>receivedAckMsg</name></name><operator>)</operator> <operator>||</operator>
			<call><name>cdbconn_isBadConnection</name><argument_list>(<argument><expr><name>segdbDesc</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>errbuf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>errbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>sent</name> <operator>=</operator> <call><name>cdbconn_signalQE</name><argument_list>(<argument><expr><name>segdbDesc</name></expr></argument>, <argument><expr><name>errbuf</name></expr></argument>, <argument><expr><name>waitMode</name> <operator>==</operator> <name>DISPATCH_WAIT_CANCEL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>sent</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>sentSignal</name></name> <operator>=</operator> <name>waitMode</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Unable to cancel: %s"</literal></expr></argument>,
				 <argument><expr><ternary><condition><expr><call><name>strlen</name><argument_list>(<argument><expr><name>errbuf</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="string">"cannot allocate PGCancel"</literal></expr> </then><else>: <expr><name>errbuf</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * Check if any segment DB down is detected by FTS.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>checkSegmentAlive</name><parameter_list>(<parameter><decl><type><name>CdbDispatchCmdAsync</name> <modifier>*</modifier></type><name>pParms</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * check the connection still valid
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>pParms</name><operator>-&gt;</operator><name>dispatchCount</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>CdbDispatchResult</name> <modifier>*</modifier></type><name>dispatchResult</name> <init>= <expr><name><name>pParms</name><operator>-&gt;</operator><name>dispatchResultPtrArray</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>SegmentDatabaseDescriptor</name> <modifier>*</modifier></type><name>segdbDesc</name> <init>= <expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>segdbDesc</name></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * Skip if already finished or didn't dispatch.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>dispatchResult</name><operator>-&gt;</operator><name>stillRunning</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Skip the entry db.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>segdbDesc</name><operator>-&gt;</operator><name>segindex</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>ELOG_DISPATCHER_DEBUG</name><argument_list>(<argument><expr><literal type="string">"FTS testing connection %d of %d (%s)"</literal></expr></argument>,
							  <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name><name>pParms</name><operator>-&gt;</operator><name>dispatchCount</name></name></expr></argument>, <argument><expr><name><name>segdbDesc</name><operator>-&gt;</operator><name>whoami</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>FtsIsSegmentDown</name><argument_list>(<argument><expr><name><name>segdbDesc</name><operator>-&gt;</operator><name>segment_database_info</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>msg</name> <init>= <expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name><name>segdbDesc</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>stillRunning</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>cdbdisp_appendMessageNonThread</name><argument_list>(<argument><expr><name>dispatchResult</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>,
										   <argument><expr><literal type="string">"FTS detected connection lost during dispatch to %s: %s"</literal></expr></argument>,
										   <argument><expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>segdbDesc</name><operator>-&gt;</operator><name>whoami</name></name></expr></argument>, <argument><expr><ternary><condition><expr><name>msg</name></expr> ?</condition><then> <expr><name>msg</name></expr> </then><else>: <expr><literal type="string">"unknown error"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Not a good idea to store into the PGconn object. Instead, just
			 * close it.
			 */</comment>
			<expr_stmt><expr><call><name>PQfinish</name><argument_list>(<argument><expr><name><name>segdbDesc</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>segdbDesc</name><operator>-&gt;</operator><name>conn</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>send_sequence_response</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>oid</name></decl></parameter>, <parameter><decl><type><name>int64</name></type> <name>last</name></decl></parameter>, <parameter><decl><type><name>int64</name></type> <name>cached</name></decl></parameter>, <parameter><decl><type><name>int64</name></type> <name>increment</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>overflow</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>error</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>pqPutMsgStart</name><argument_list>(<argument><expr><name>SEQ_NEXTVAL_QUERY_RESPONSE</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Failed to send sequence response: %s"</literal></expr></argument>, <argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>pqPutInt</name><argument_list>(<argument><expr><name>oid</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pqPutInt</name><argument_list>(<argument><expr><name>last</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pqPutInt</name><argument_list>(<argument><expr><name>last</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pqPutInt</name><argument_list>(<argument><expr><name>cached</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pqPutInt</name><argument_list>(<argument><expr><name>cached</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pqPutInt</name><argument_list>(<argument><expr><name>increment</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pqPutInt</name><argument_list>(<argument><expr><name>increment</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pqPutc</name><argument_list>(<argument><expr><ternary><condition><expr><name>overflow</name></expr> ?</condition><then> <expr><name>SEQ_NEXTVAL_TRUE</name></expr> </then><else>: <expr><name>SEQ_NEXTVAL_FALSE</name></expr></else></ternary></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pqPutc</name><argument_list>(<argument><expr><ternary><condition><expr><name>error</name></expr> ?</condition><then> <expr><name>SEQ_NEXTVAL_TRUE</name></expr> </then><else>: <expr><name>SEQ_NEXTVAL_FALSE</name></expr></else></ternary></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>pqPutMsgEnd</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Failed to send sequence response: %s"</literal></expr></argument>, <argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>pqFlush</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Failed to send sequence response: %s"</literal></expr></argument>, <argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Receive and process input from one QE.
 *
 * Return true if all input are consumed or the connection went wrong.
 * Return false if there'er still more data expected.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>processResults</name><parameter_list>(<parameter><decl><type><name>CdbDispatchResult</name> <modifier>*</modifier></type><name>dispatchResult</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SegmentDatabaseDescriptor</name> <modifier>*</modifier></type><name>segdbDesc</name> <init>= <expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>segdbDesc</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>msg</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Receive input from QE.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>PQconsumeInput</name><argument_list>(<argument><expr><name><name>segdbDesc</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>PQerrorMessage</name><argument_list>(<argument><expr><name><name>segdbDesc</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>cdbdisp_appendMessageNonThread</name><argument_list>(<argument><expr><name>dispatchResult</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>,
									   <argument><expr><literal type="string">"Error on receive from %s: %s"</literal></expr></argument>,
									   <argument><expr><name><name>segdbDesc</name><operator>-&gt;</operator><name>whoami</name></name></expr></argument>, <argument><expr><ternary><condition><expr><name>msg</name></expr> ?</condition><then> <expr><name>msg</name></expr> </then><else>: <expr><literal type="string">"unknown error"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>forwardQENotices</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If we have received one or more complete messages, process them.
	 */</comment>
	<while>while <condition>(<expr><operator>!</operator><call><name>PQisBusy</name><argument_list>(<argument><expr><name><name>segdbDesc</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* loop to call PQgetResult; won't block */</comment>
		<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>pRes</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ExecStatusType</name></type> <name>resultStatus</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>resultIndex</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>forwardQENotices</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * PQisBusy() does some error handling, which can cause the connection
		 * to die -- we can't just continue on as if the connection is happy
		 * without checking first.
		 *
		 * For example, cdbdisp_numPGresult() will return a completely bogus
		 * value!
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>cdbconn_isBadConnection</name><argument_list>(<argument><expr><name>segdbDesc</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>PQerrorMessage</name><argument_list>(<argument><expr><name><name>segdbDesc</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>cdbdisp_appendMessageNonThread</name><argument_list>(<argument><expr><name>dispatchResult</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>,
										   <argument><expr><literal type="string">"Connection lost when receiving from %s: %s"</literal></expr></argument>,
										   <argument><expr><name><name>segdbDesc</name><operator>-&gt;</operator><name>whoami</name></name></expr></argument>, <argument><expr><ternary><condition><expr><name>msg</name></expr> ?</condition><then> <expr><name>msg</name></expr> </then><else>: <expr><literal type="string">"unknown error"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Get one message.
		 */</comment>
		<expr_stmt><expr><call><name>ELOG_DISPATCHER_DEBUG</name><argument_list>(<argument><expr><literal type="string">"PQgetResult"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>pRes</name> <operator>=</operator> <call><name>PQgetResult</name><argument_list>(<argument><expr><name><name>segdbDesc</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Command is complete when PGgetResult() returns NULL. It is critical
		 * that for any connection that had an asynchronous command sent thru
		 * it, we call PQgetResult until it returns NULL. Otherwise, the next
		 * time a command is sent to that connection, it will return an error
		 * that there's a command pending.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>pRes</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ELOG_DISPATCHER_DEBUG</name><argument_list>(<argument><expr><literal type="string">"%s -&gt; idle"</literal></expr></argument>, <argument><expr><name><name>segdbDesc</name><operator>-&gt;</operator><name>whoami</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* this is normal end of command */</comment>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>segdbDesc</name><operator>-&gt;</operator><name>conn</name><operator>-&gt;</operator><name>wrote_xlog</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>MarkTopTransactionWriteXLogOnExecutor</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Reset the worte_xlog here. Since if the received pgresult not process
			 * the xlog write message('x' message sends from QE in ReadyForQuery),
			 * the value may still refer to previous dispatch statement. Which may
			 * always mark current top transaction has wrote xlog on executor.
			 */</comment>
			<expr_stmt><expr><name><name>segdbDesc</name><operator>-&gt;</operator><name>conn</name><operator>-&gt;</operator><name>wrote_xlog</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Attach the PGresult object to the CdbDispatchResult object.
		 */</comment>
		<expr_stmt><expr><name>resultIndex</name> <operator>=</operator> <call><name>cdbdisp_numPGresult</name><argument_list>(<argument><expr><name>dispatchResult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>cdbdisp_appendResult</name><argument_list>(<argument><expr><name>dispatchResult</name></expr></argument>, <argument><expr><name>pRes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Did a command complete successfully?
		 */</comment>
		<expr_stmt><expr><name>resultStatus</name> <operator>=</operator> <call><name>PQresultStatus</name><argument_list>(<argument><expr><name>pRes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>resultStatus</name> <operator>==</operator> <name>PGRES_COMMAND_OK</name> <operator>||</operator>
			<name>resultStatus</name> <operator>==</operator> <name>PGRES_TUPLES_OK</name> <operator>||</operator>
			<name>resultStatus</name> <operator>==</operator> <name>PGRES_COPY_IN</name> <operator>||</operator>
			<name>resultStatus</name> <operator>==</operator> <name>PGRES_COPY_OUT</name> <operator>||</operator>
			<name>resultStatus</name> <operator>==</operator> <name>PGRES_EMPTY_QUERY</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ELOG_DISPATCHER_DEBUG</name><argument_list>(<argument><expr><literal type="string">"%s -&gt; ok %s"</literal></expr></argument>,
								  <argument><expr><name><name>segdbDesc</name><operator>-&gt;</operator><name>whoami</name></name></expr></argument>,
								  <argument><expr><ternary><condition><expr><call><name>PQcmdStatus</name><argument_list>(<argument><expr><name>pRes</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><call><name>PQcmdStatus</name><argument_list>(<argument><expr><name>pRes</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="string">"(no cmdStatus)"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>resultStatus</name> <operator>==</operator> <name>PGRES_EMPTY_QUERY</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ELOG_DISPATCHER_DEBUG</name><argument_list>(<argument><expr><literal type="string">"QE received empty query."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * Save the index of the last successful PGresult. Can be given to
			 * cdbdisp_getPGresult() to get tuple count, etc.
			 */</comment>
			<expr_stmt><expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>okindex</name></name> <operator>=</operator> <name>resultIndex</name></expr>;</expr_stmt>

			<comment type="block">/*
			 * SREH - get number of rows rejected from QE if any
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>pRes</name><operator>-&gt;</operator><name>numRejected</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>numrowsrejected</name></name> <operator>+=</operator> <name><name>pRes</name><operator>-&gt;</operator><name>numRejected</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * COPY FROM - get the number of rows completed by QE
			 * if any
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>pRes</name><operator>-&gt;</operator><name>numCompleted</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>numrowscompleted</name></name> <operator>+=</operator> <name><name>pRes</name><operator>-&gt;</operator><name>numCompleted</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>resultStatus</name> <operator>==</operator> <name>PGRES_COPY_IN</name> <operator>||</operator>
				<name>resultStatus</name> <operator>==</operator> <name>PGRES_COPY_OUT</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block></if>

		<comment type="block">/*
		 * Note QE error. Cancel the whole statement if requested.
		 */</comment>
		<else>else
		<block>{<block_content>
			<comment type="block">/* QE reported an error */</comment>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>sqlstate</name> <init>= <expr><call><name>PQresultErrorField</name><argument_list>(<argument><expr><name>pRes</name></expr></argument>, <argument><expr><name>PG_DIAG_SQLSTATE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>errcode</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>PQresultErrorMessage</name><argument_list>(<argument><expr><name>pRes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>ELOG_DISPATCHER_DEBUG</name><argument_list>(<argument><expr><literal type="string">"%s -&gt; %s %s  %s"</literal></expr></argument>,
								  <argument><expr><name><name>segdbDesc</name><operator>-&gt;</operator><name>whoami</name></name></expr></argument>,
								  <argument><expr><call><name>PQresStatus</name><argument_list>(<argument><expr><name>resultStatus</name></expr></argument>)</argument_list></call></expr></argument>,
								  <argument><expr><ternary><condition><expr><name>sqlstate</name></expr> ?</condition><then> <expr><name>sqlstate</name></expr> </then><else>: <expr><literal type="string">"(no SQLSTATE)"</literal></expr></else></ternary></expr></argument>,
								  <argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Convert SQLSTATE to an error code (ERRCODE_xxx). Use a generic
			 * nonzero error code if no SQLSTATE.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>sqlstate</name> <operator>&amp;&amp;</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>sqlstate</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">5</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>errcode</name> <operator>=</operator> <call><name>sqlstate_to_errcode</name><argument_list>(<argument><expr><name>sqlstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * Save first error code and the index of its PGresult buffer
			 * entry.
			 */</comment>
			<expr_stmt><expr><call><name>cdbdisp_seterrcode</name><argument_list>(<argument><expr><name>errcode</name></expr></argument>, <argument><expr><name>resultIndex</name></expr></argument>, <argument><expr><name>dispatchResult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>forwardQENotices</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>PGnotify</name> <modifier>*</modifier></type><name>qnotifies</name> <init>= <expr><call><name>PQnotifies</name><argument_list>(<argument><expr><name><name>segdbDesc</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<while>while<condition>(<expr><name>qnotifies</name> <operator>&amp;&amp;</operator> <call><name>elog_geterrcode</name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>qnotifies</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>, <argument><expr><name>CDB_NOTIFY_NEXTVAL</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * If there was nextval request then respond back on this libpq
			 * connection with the next value. Check and process nextval
			 * message only if QD has not already hit the error. Since QD could
			 * have hit the error while processing the previous nextval_qd()
			 * request itself and since full error handling is not complete yet
			 * (ex: releasing all the locks, etc.), shouldn't attempt to call
			 * nextval_qd() again.
			 */</comment>

			<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

			<decl_stmt><decl><type><name>int64</name></type> <name>last</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int64</name></type> <name>cached</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int64</name></type> <name>increment</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type> <name>overflow</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type> <name>dbid</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type> <name>seq_oid</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>sscanf</name><argument_list>(<argument><expr><name><name>qnotifies</name><operator>-&gt;</operator><name>extra</name></name></expr></argument>, <argument><expr><literal type="string">"%u:%u"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>dbid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>seq_oid</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid nextval message"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>dbid</name> <operator>!=</operator> <name>MyDatabaseId</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"nextval message database id:%u doesn't match my database id:%u"</literal></expr></argument>,
					 <argument><expr><name>dbid</name></expr></argument>, <argument><expr><name>MyDatabaseId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<block>{<block_content>
				<expr_stmt><expr><call><name>nextval_qd</name><argument_list>(<argument><expr><name>seq_oid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>last</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cached</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>increment</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>overflow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<block>{<block_content>
				<expr_stmt><expr><call><name>send_sequence_response</name><argument_list>(<argument><expr><name><name>segdbDesc</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>, <argument><expr><name>seq_oid</name></expr></argument>, <argument><expr><name>last</name></expr></argument>, <argument><expr><name>cached</name></expr></argument>, <argument><expr><name>increment</name></expr></argument>, <argument><expr><name>overflow</name></expr></argument>, <argument><expr><name>true</name></expr></argument> <comment type="block">/* error */</comment>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* respond back on this libpq connection with the next value */</comment>
			<expr_stmt><expr><call><name>send_sequence_response</name><argument_list>(<argument><expr><name><name>segdbDesc</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>, <argument><expr><name>seq_oid</name></expr></argument>, <argument><expr><name>last</name></expr></argument>, <argument><expr><name>cached</name></expr></argument>, <argument><expr><name>increment</name></expr></argument>, <argument><expr><name>overflow</name></expr></argument>, <argument><expr><name>false</name></expr></argument> <comment type="block">/* error */</comment>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>qnotifies</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>, <argument><expr><name>CDB_NOTIFY_ENDPOINT_ACK</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>qnotifies</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <operator>(</operator>struct <name>pgNotify</name> <operator>*</operator><operator>)</operator> <name><name>dispatchResult</name><operator>-&gt;</operator><name>ackPGNotifies</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>ackPGNotifies</name></name> <operator>=</operator> <operator>(</operator>struct <name>PGnotify</name> <operator>*</operator><operator>)</operator> <name>qnotifies</name></expr>;</expr_stmt>

			<comment type="block">/* Don't free the notify here since it in queue now */</comment>
			<expr_stmt><expr><name>qnotifies</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* Got an unknown PGnotify, just record it in log */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>qnotifies</name><operator>-&gt;</operator><name>relname</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"got an unknown notify message : %s"</literal></expr></argument>, <argument><expr><name><name>qnotifies</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>qnotifies</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>PQfreemem</name><argument_list>(<argument><expr><name>qnotifies</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>qnotifies</name> <operator>=</operator> <call><name>PQnotifies</name><argument_list>(<argument><expr><name><name>segdbDesc</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>forwardQENotices</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>false</name></expr>;</return>				<comment type="block">/* we must keep on monitoring this socket */</comment>
</block_content>}</block></function>
</unit>
