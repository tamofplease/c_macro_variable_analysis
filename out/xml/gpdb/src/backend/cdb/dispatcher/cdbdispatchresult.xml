<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/backend/cdb/dispatcher/cdbdispatchresult.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * cdbdispatchresult.c
 *	  Functions for handling dispatch results
 *
 *
 * Portions Copyright (c) 2005-2008, Greenplum inc
 * Portions Copyright (c) 2012-Present VMware, Inc. or its affiliates.
 *
 *
 * IDENTIFICATION
 *	    src/backend/cdb/dispatcher/cdbdispatchresult.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq-fe.h"</cpp:file></cpp:include>		<comment type="block">/* prerequisite for libpq-int.h */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq-int.h"</cpp:file></cpp:include>		<comment type="block">/* PQExpBufferData */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/guc.h"</cpp:file></cpp:include>			<comment type="block">/* log_min_messages */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbconn.h"</cpp:file></cpp:include>		<comment type="block">/* SegmentDatabaseDescriptor */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbvars.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbsreh.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbdispatchresult.h"</cpp:file></cpp:include>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>cdbdisp_snatchPGresults</name><parameter_list>(<parameter><decl><type><name>CdbDispatchResult</name> <modifier>*</modifier></type><name>dispatchResult</name></decl></parameter>,
						<parameter><decl><type><name><name>struct</name> <name>pg_result</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>pgresultptrs</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>maxresults</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>noTrailingNewlinePQ</name><parameter_list>(<parameter><decl><type><name>PQExpBuffer</name></type> <name>buf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<while>while <condition>(<expr><name><name>buf</name><operator>-&gt;</operator><name>len</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>buf</name><operator>-&gt;</operator><name>data</name><index>[<expr><name><name>buf</name><operator>-&gt;</operator><name>len</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>&lt;=</operator> <literal type="char">' '</literal> <operator>&amp;&amp;</operator> <name><name>buf</name><operator>-&gt;</operator><name>data</name><index>[<expr><name><name>buf</name><operator>-&gt;</operator><name>len</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>&gt;</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>data</name><index>[<expr><operator>--</operator><name><name>buf</name><operator>-&gt;</operator><name>len</name></name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt></block_content></block></while>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>oneTrailingNewlinePQ</name><parameter_list>(<parameter><decl><type><name>PQExpBuffer</name></type> <name>buf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>noTrailingNewlinePQ</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>buf</name><operator>-&gt;</operator><name>len</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Create a CdbDispatchResult object, appending it to the
 * resultArray of a given CdbDispatchResults object.
 */</comment>
<function><type><name>CdbDispatchResult</name> <modifier>*</modifier></type>
<name>cdbdisp_makeResult</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>CdbDispatchResults</name></name> <modifier>*</modifier></type><name>meleeResults</name></decl></parameter>,
				   <parameter><decl><type><name><name>struct</name> <name>SegmentDatabaseDescriptor</name></name> <modifier>*</modifier></type><name>segdbDesc</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sliceIndex</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CdbDispatchResult</name> <modifier>*</modifier></type><name>dispatchResult</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>meleeIndex</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>meleeResults</name> <operator>&amp;&amp;</operator>
		   <name><name>meleeResults</name><operator>-&gt;</operator><name>resultArray</name></name> <operator>&amp;&amp;</operator>
		   <name><name>meleeResults</name><operator>-&gt;</operator><name>resultCount</name></name> <operator>&lt;</operator> <name><name>meleeResults</name><operator>-&gt;</operator><name>resultCapacity</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Allocate a slot for the new CdbDispatchResult object.
	 */</comment>
	<expr_stmt><expr><name>meleeIndex</name> <operator>=</operator> <name><name>meleeResults</name><operator>-&gt;</operator><name>resultCount</name></name><operator>++</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>dispatchResult</name> <operator>=</operator> <operator>&amp;</operator><name><name>meleeResults</name><operator>-&gt;</operator><name>resultArray</name><index>[<expr><name>meleeIndex</name></expr>]</index></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Initialize CdbDispatchResult.
	 */</comment>
	<expr_stmt><expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>meleeResults</name></name> <operator>=</operator> <name>meleeResults</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>meleeIndex</name></name> <operator>=</operator> <name>meleeIndex</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>segdbDesc</name></name> <operator>=</operator> <name>segdbDesc</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>resultbuf</name></name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>error_message</name></name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>numrowsrejected</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>numrowscompleted</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>ackPGNotifies</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FAULT_INJECTOR</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><call><name>SIMPLE_FAULT_INJECTOR</name><argument_list>(<argument><expr><literal type="string">"make_dispatch_result_error"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>FaultInjectorTypeSkip</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Inject a fault to simulate the createPQExpBuffer return NULL (maybe because of
		 * malloc failure, this will lead to enter the below if block and return NULL in
		 * this function. We need to test this code path to verify the gang clean up code
		 * is correct.
		 */</comment>
		<expr_stmt><expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>resultbuf</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<if_stmt><if>if <condition>(<expr><call><name>PQExpBufferBroken</name><argument_list>(<argument><expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>resultbuf</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
		<call><name>PQExpBufferBroken</name><argument_list>(<argument><expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>error_message</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>resultbuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>resultbuf</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>error_message</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>error_message</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * caller is responsible for cleanup -- can't elog(ERROR, ...) from
		 * here.
		 */</comment>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Reset summary indicators.
	 */</comment>
	<expr_stmt><expr><call><name>cdbdisp_resetResult</name><argument_list>(<argument><expr><name>dispatchResult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Update slice map entry.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>sliceIndex</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>sliceIndex</name> <operator>&lt;</operator> <name><name>meleeResults</name><operator>-&gt;</operator><name>sliceCapacity</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>CdbDispatchResults_SliceInfo</name> <modifier>*</modifier></type><name>si</name> <init>= <expr><operator>&amp;</operator><name><name>meleeResults</name><operator>-&gt;</operator><name>sliceMap</name><index>[<expr><name>sliceIndex</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>si</name><operator>-&gt;</operator><name>resultBegin</name></name> <operator>==</operator> <name><name>si</name><operator>-&gt;</operator><name>resultEnd</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>si</name><operator>-&gt;</operator><name>resultBegin</name></name> <operator>=</operator> <name>meleeIndex</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>si</name><operator>-&gt;</operator><name>resultEnd</name></name> <operator>=</operator> <name>meleeIndex</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>si</name><operator>-&gt;</operator><name>resultBegin</name></name> <operator>&gt;</operator> <name>meleeIndex</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>si</name><operator>-&gt;</operator><name>resultBegin</name></name> <operator>=</operator> <name>meleeIndex</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>si</name><operator>-&gt;</operator><name>resultEnd</name></name> <operator>&lt;=</operator> <name>meleeIndex</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>si</name><operator>-&gt;</operator><name>resultEnd</name></name> <operator>=</operator> <name>meleeIndex</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>dispatchResult</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Destroy a CdbDispatchResult object.
 */</comment>
<function><type><name>void</name></type>
<name>cdbdisp_termResult</name><parameter_list>(<parameter><decl><type><name>CdbDispatchResult</name> <modifier>*</modifier></type><name>dispatchResult</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>trash</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>segdbDesc</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Free the PGresult objects.
	 */</comment>
	<expr_stmt><expr><call><name>cdbdisp_resetResult</name><argument_list>(<argument><expr><name>dispatchResult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Free the error message buffer and result buffer.
	 */</comment>
	<expr_stmt><expr><name>trash</name> <operator>=</operator> <name><name>dispatchResult</name><operator>-&gt;</operator><name>resultbuf</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>resultbuf</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>trash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>trash</name> <operator>=</operator> <name><name>dispatchResult</name><operator>-&gt;</operator><name>error_message</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>error_message</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>trash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Reset a CdbDispatchResult object for possible reuse.
 */</comment>
<function><type><name>void</name></type>
<name>cdbdisp_resetResult</name><parameter_list>(<parameter><decl><type><name>CdbDispatchResult</name> <modifier>*</modifier></type><name>dispatchResult</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>buf</name> <init>= <expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>resultbuf</name></name></expr></init></decl>;</decl_stmt>
	<comment type="block">/*
	* the resultbuf may be empty due to oom, set in cdbdisp_makeResult()
 	* Related to issue: https://github.com/greenplum-db/gpdb/issues/12399
	*/</comment>
	<if_stmt><if>if <condition>(<expr><name>buf</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PGresult</name>  <modifier>*</modifier><modifier>*</modifier></type><name>begp</name> <init>= <expr><operator>(</operator><name>PGresult</name> <operator>*</operator><operator>*</operator><operator>)</operator> <name><name>buf</name><operator>-&gt;</operator><name>data</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PGresult</name>  <modifier>*</modifier><modifier>*</modifier></type><name>endp</name> <init>= <expr><operator>(</operator><name>PGresult</name> <operator>*</operator><operator>*</operator><operator>)</operator> <operator>(</operator><name><name>buf</name><operator>-&gt;</operator><name>data</name></name> <operator>+</operator> <name><name>buf</name><operator>-&gt;</operator><name>len</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PGresult</name>  <modifier>*</modifier><modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Free the PGresult objects.
		 */</comment>
		<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name>begp</name></expr>;</init> <condition><expr><name>p</name> <operator>&lt;</operator> <name>endp</name></expr>;</condition> <incr><expr><operator>++</operator><name>p</name></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>*</operator><name>p</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>PGnotify</name><modifier>*</modifier></type> <name>pgnotify</name> <init>= <expr><operator>(</operator><name>PGnotify</name> <operator>*</operator><operator>)</operator> <name><name>dispatchResult</name><operator>-&gt;</operator><name>ackPGNotifies</name></name></expr></init></decl>;</decl_stmt>
	<while>while <condition>(<expr><name>pgnotify</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PGnotify</name><modifier>*</modifier></type> <name>temp</name> <init>= <expr><name>pgnotify</name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>pgnotify</name> <operator>=</operator> <name><name>temp</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PQfreemem</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>
	<expr_stmt><expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>ackPGNotifies</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Reset summary indicators.
	 */</comment>
	<expr_stmt><expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>errcode</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>okindex</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * Reset progress indicators.
	 */</comment>
	<expr_stmt><expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>hasDispatched</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>stillRunning</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>receivedAckMsg</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>sentSignal</name></name> <operator>=</operator> <name>DISPATCH_WAIT_NONE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>wasCanceled</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Empty (but don't free) the error message buffer and result buffer.
	 */</comment>
	<expr_stmt><expr><call><name>resetPQExpBuffer</name><argument_list>(<argument><expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>resultbuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>resetPQExpBuffer</name><argument_list>(<argument><expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>error_message</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Take note of an error.
 * 'errcode' is the ERRCODE_xxx value for setting the client's SQLSTATE.
 */</comment>
<function><type><name>void</name></type>
<name>cdbdisp_seterrcode</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>errcode</name></decl></parameter>, <comment type="block">/* ERRCODE_xxx or 0 */</comment>
				   <parameter><decl><type><name>int</name></type> <name>resultIndex</name></decl></parameter>, <comment type="block">/* -1 if no PGresult */</comment>
				   <parameter><decl><type><name>CdbDispatchResult</name> <modifier>*</modifier></type><name>dispatchResult</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CdbDispatchResults</name> <modifier>*</modifier></type><name>meleeResults</name> <init>= <expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>meleeResults</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * We must ensure a nonzero errcode.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>errcode</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>errcode</name> <operator>=</operator> <name>ERRCODE_INTERNAL_ERROR</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Was the command canceled?
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>errcode</name> <operator>==</operator> <name>ERRCODE_GP_OPERATION_CANCELED</name> <operator>||</operator>
		<name>errcode</name> <operator>==</operator> <name>ERRCODE_QUERY_CANCELED</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>wasCanceled</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If this is the first error from this QE, save the error code and the
	 * index of the PGresult buffer entry. We assume the caller has not yet
	 * added the item to the PGresult buffer.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>dispatchResult</name><operator>-&gt;</operator><name>errcode</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>errcode</name></name> <operator>=</operator> <name>errcode</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>meleeResults</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Remember which QE reported an error first among the gangs, but keep
	 * quiet about cancellation done at our request.
	 *
	 * Interconnection errors are given lower precedence because often they
	 * are secondary to an earlier and more interesting error.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>errcode</name> <operator>==</operator> <name>ERRCODE_GP_OPERATION_CANCELED</name> <operator>&amp;&amp;</operator>
		<name><name>dispatchResult</name><operator>-&gt;</operator><name>sentSignal</name></name> <operator>==</operator> <name>DISPATCH_WAIT_CANCEL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* nop */</comment>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>meleeResults</name><operator>-&gt;</operator><name>errcode</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
			 <operator>(</operator><name><name>meleeResults</name><operator>-&gt;</operator><name>errcode</name></name> <operator>==</operator> <name>ERRCODE_GP_INTERCONNECTION_ERROR</name> <operator>&amp;&amp;</operator>
			  <name>errcode</name> <operator>!=</operator> <name>ERRCODE_GP_INTERCONNECTION_ERROR</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>meleeResults</name><operator>-&gt;</operator><name>errcode</name></name> <operator>=</operator> <name>errcode</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>meleeResults</name><operator>-&gt;</operator><name>iFirstError</name></name> <operator>=</operator> <name><name>dispatchResult</name><operator>-&gt;</operator><name>meleeIndex</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * NonThread version of cdbdisp_appendMessage.
 *
 * It's safe to use palloc/pfree or elog/ereport.
 */</comment>
<function><type><name>void</name></type>
<name>cdbdisp_appendMessageNonThread</name><parameter_list>(<parameter><decl><type><name>CdbDispatchResult</name> <modifier>*</modifier></type><name>dispatchResult</name></decl></parameter>,
							   <parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>,<parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>va_list</name></type>		<name>args</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>msgoff</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Remember first error.
	 */</comment>
	<expr_stmt><expr><call><name>cdbdisp_seterrcode</name><argument_list>(<argument><expr><name>ERRCODE_GP_INTERCONNECTION_ERROR</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>dispatchResult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Allocate buffer if first message. Insert newline between previous
	 * message and new one.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>error_message</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>oneTrailingNewlinePQ</name><argument_list>(<argument><expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>error_message</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>msgoff</name> <operator>=</operator> <name><name>dispatchResult</name><operator>-&gt;</operator><name>error_message</name><operator>-&gt;</operator><name>len</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Format the message and append it to the buffer.
	 */</comment>
	<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendPQExpBufferVA</name><argument_list>(<argument><expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>error_message</name></name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Display the message on stderr for debugging, if requested. This helps
	 * to clarify the actual timing of threaded events.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>elevel</name> <operator>&gt;=</operator> <name>log_min_messages</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>oneTrailingNewlinePQ</name><argument_list>(<argument><expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>error_message</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>error_message</name><operator>-&gt;</operator><name>data</name></name> <operator>+</operator> <name>msgoff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * In case the caller wants to hand the buffer to ereport(), follow the
	 * ereport() convention of not ending with a newline.
	 */</comment>
	<expr_stmt><expr><call><name>noTrailingNewlinePQ</name><argument_list>(<argument><expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>error_message</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Store a PGresult object ptr in the result buffer.
 * NB: Caller must not PQclear() the PGresult object.
 */</comment>
<function><type><name>void</name></type>
<name>cdbdisp_appendResult</name><parameter_list>(<parameter><decl><type><name>CdbDispatchResult</name> <modifier>*</modifier></type><name>dispatchResult</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>pg_result</name></name> <modifier>*</modifier></type><name>res</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>dispatchResult</name> <operator>&amp;&amp;</operator> <name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Attach the QE identification string to the PGresult
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>segdbDesc</name></name> <operator>&amp;&amp;</operator> <name><name>dispatchResult</name><operator>-&gt;</operator><name>segdbDesc</name><operator>-&gt;</operator><name>whoami</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pqSaveMessageField</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>PG_DIAG_GP_PROCESS_TAG</name></expr></argument>, <argument><expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>segdbDesc</name><operator>-&gt;</operator><name>whoami</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>appendBinaryPQExpBuffer</name><argument_list>(<argument><expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>resultbuf</name></name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>res</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Return the i'th PGresult object ptr (if i &gt;= 0), or
 * the n+i'th one (if i &lt; 0), or NULL (if i out of bounds).
 * NB: Caller must not PQclear() the PGresult object.
 */</comment>
<function><type><name><name>struct</name> <name>pg_result</name></name> <modifier>*</modifier></type>
<name>cdbdisp_getPGresult</name><parameter_list>(<parameter><decl><type><name>CdbDispatchResult</name> <modifier>*</modifier></type><name>dispatchResult</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>dispatchResult</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>buf</name> <init>= <expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>resultbuf</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PGresult</name>  <modifier>*</modifier><modifier>*</modifier></type><name>begp</name> <init>= <expr><operator>(</operator><name>PGresult</name> <operator>*</operator><operator>*</operator><operator>)</operator> <name><name>buf</name><operator>-&gt;</operator><name>data</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PGresult</name>  <modifier>*</modifier><modifier>*</modifier></type><name>endp</name> <init>= <expr><operator>(</operator><name>PGresult</name> <operator>*</operator><operator>*</operator><operator>)</operator> <operator>(</operator><name><name>buf</name><operator>-&gt;</operator><name>data</name></name> <operator>+</operator> <name><name>buf</name><operator>-&gt;</operator><name>len</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PGresult</name>  <modifier>*</modifier><modifier>*</modifier></type><name>p</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><operator>&amp;</operator><name><name>begp</name><index>[<expr><name>i</name></expr>]</index></name></expr> </then><else>: <expr><operator>&amp;</operator><name><name>endp</name><index>[<expr><name>i</name></expr>]</index></name></expr></else></ternary></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>p</name> <operator>&gt;=</operator> <name>begp</name> <operator>&amp;&amp;</operator> <name>p</name> <operator>&lt;</operator> <name>endp</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>*</operator><name>p</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><operator>*</operator><name>p</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Return the number of PGresult objects in the result buffer.
 */</comment>
<function><type><name>int</name></type>
<name>cdbdisp_numPGresult</name><parameter_list>(<parameter><decl><type><name>CdbDispatchResult</name> <modifier>*</modifier></type><name>dispatchResult</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><ternary><condition><expr><name>dispatchResult</name></expr> ?</condition><then> <expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>resultbuf</name><operator>-&gt;</operator><name>len</name></name> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PGresult</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Display a CdbDispatchResult in the log for debugging.
 * Call only from main thread, during or after cdbdisp_checkDispatchResults.
 */</comment>
<function><type><name>void</name></type>
<name>cdbdisp_debugDispatchResult</name><parameter_list>(<parameter><decl><type><name>CdbDispatchResult</name> <modifier>*</modifier></type><name>dispatchResult</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>ires</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nres</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>dispatchResult</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * PGresult messages
	 */</comment>
	<expr_stmt><expr><name>nres</name> <operator>=</operator> <call><name>cdbdisp_numPGresult</name><argument_list>(<argument><expr><name>dispatchResult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>ires</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>ires</name> <operator>&lt;</operator> <name>nres</name></expr>;</condition> <incr><expr><operator>++</operator><name>ires</name></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>pgresult</name> <init>= <expr><call><name>cdbdisp_getPGresult</name><argument_list>(<argument><expr><name>dispatchResult</name></expr></argument>, <argument><expr><name>ires</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ExecStatusType</name></type> <name>resultStatus</name> <init>= <expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>pgresult</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>whoami</name> <init>= <expr><call><name>PQresultErrorField</name><argument_list>(<argument><expr><name>pgresult</name></expr></argument>, <argument><expr><name>PG_DIAG_GP_PROCESS_TAG</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>whoami</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>whoami</name> <operator>=</operator> <literal type="string">"no process id"</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>resultStatus</name> <operator>==</operator> <name>PGRES_COMMAND_OK</name> <operator>||</operator>
			<name>resultStatus</name> <operator>==</operator> <name>PGRES_TUPLES_OK</name> <operator>||</operator>
			<name>resultStatus</name> <operator>==</operator> <name>PGRES_COPY_IN</name> <operator>||</operator>
			<name>resultStatus</name> <operator>==</operator> <name>PGRES_COPY_OUT</name> <operator>||</operator>
			<name>resultStatus</name> <operator>==</operator> <name>PGRES_EMPTY_QUERY</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>cmdStatus</name> <init>= <expr><call><name>PQcmdStatus</name><argument_list>(<argument><expr><name>pgresult</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"DispatchResult from %s: ok %s (%s)"</literal></expr></argument>,
				 <argument><expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>segdbDesc</name><operator>-&gt;</operator><name>whoami</name></name></expr></argument>,
				 <argument><expr><ternary><condition><expr><name>cmdStatus</name></expr> ?</condition><then> <expr><name>cmdStatus</name></expr> </then><else>: <expr><literal type="string">"(no cmdStatus)"</literal></expr></else></ternary></expr></argument>, <argument><expr><name>whoami</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>sqlstate</name> <init>= <expr><call><name>PQresultErrorField</name><argument_list>(<argument><expr><name>pgresult</name></expr></argument>, <argument><expr><name>PG_DIAG_SQLSTATE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>pri</name> <init>= <expr><call><name>PQresultErrorField</name><argument_list>(<argument><expr><name>pgresult</name></expr></argument>, <argument><expr><name>PG_DIAG_MESSAGE_PRIMARY</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>dtl</name> <init>= <expr><call><name>PQresultErrorField</name><argument_list>(<argument><expr><name>pgresult</name></expr></argument>, <argument><expr><name>PG_DIAG_MESSAGE_DETAIL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>sourceFile</name> <init>= <expr><call><name>PQresultErrorField</name><argument_list>(<argument><expr><name>pgresult</name></expr></argument>, <argument><expr><name>PG_DIAG_SOURCE_FILE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>sourceLine</name> <init>= <expr><call><name>PQresultErrorField</name><argument_list>(<argument><expr><name>pgresult</name></expr></argument>, <argument><expr><name>PG_DIAG_SOURCE_LINE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>lenpri</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>pri</name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><call><name>strlen</name><argument_list>(<argument><expr><name>pri</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>sqlstate</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>sqlstate</name> <operator>=</operator> <literal type="string">"no SQLSTATE"</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<while>while <condition>(<expr><name>lenpri</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pri</name><index>[<expr><name>lenpri</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>&lt;=</operator> <literal type="char">' '</literal> <operator>&amp;&amp;</operator> <name><name>pri</name><index>[<expr><name>lenpri</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>&gt;</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>lenpri</name><operator>--</operator></expr>;</expr_stmt></block_content></block></while>

			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"DispatchResult from %s: error (%s) %s %.*s (%s)"</literal></expr></argument>,
							<argument><expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>segdbDesc</name><operator>-&gt;</operator><name>whoami</name></name></expr></argument>,
							<argument><expr><name>sqlstate</name></expr></argument>,
							<argument><expr><call><name>PQresStatus</name><argument_list>(<argument><expr><name>resultStatus</name></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><name>lenpri</name></expr></argument>,
							<argument><expr><ternary><condition><expr><name>pri</name></expr> ?</condition><then> <expr><name>pri</name></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>, <argument><expr><name>whoami</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"(%s:%s) %s"</literal></expr></argument>,
							   <argument><expr><ternary><condition><expr><name>sourceFile</name></expr> ?</condition><then> <expr><name>sourceFile</name></expr> </then><else>: <expr><literal type="string">"unknown file"</literal></expr></else></ternary></expr></argument>,
							   <argument><expr><ternary><condition><expr><name>sourceLine</name></expr> ?</condition><then> <expr><name>sourceLine</name></expr> </then><else>: <expr><literal type="string">"unknown line"</literal></expr></else></ternary></expr></argument>,
							   <argument><expr><ternary><condition><expr><name>dtl</name></expr> ?</condition><then> <expr><name>dtl</name></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Error found on our side of the libpq interface?
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>error_message</name></name> <operator>&amp;&amp;</operator>
		<name><name>dispatchResult</name><operator>-&gt;</operator><name>error_message</name><operator>-&gt;</operator><name>len</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>esqlstate</name><index>[<expr><literal type="number">6</literal></expr>]</index></name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>errcode_to_sqlstate</name><argument_list>(<argument><expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>errcode</name></name></expr></argument>, <argument><expr><name>esqlstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"DispatchResult from %s: connect error (%s) %s"</literal></expr></argument>,
			 <argument><expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>segdbDesc</name><operator>-&gt;</operator><name>whoami</name></name></expr></argument>,
			 <argument><expr><name>esqlstate</name></expr></argument>, <argument><expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>error_message</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Should have either an error code or an ok result.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>errcode</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>dispatchResult</name><operator>-&gt;</operator><name>okindex</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"DispatchResult from %s: No ending status."</literal></expr></argument>,
			 <argument><expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>segdbDesc</name><operator>-&gt;</operator><name>whoami</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Construct an ErrorData from the dispatch results.
 */</comment>
<function><type><name>ErrorData</name> <modifier>*</modifier></type>
<name>cdbdisp_dumpDispatchResult</name><parameter_list>(<parameter><decl><type><name>CdbDispatchResult</name> <modifier>*</modifier></type><name>dispatchResult</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>ires</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nres</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ErrorData</name>  <modifier>*</modifier></type><name>errdata</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>dispatchResult</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Format PGresult messages
	 */</comment>
	<expr_stmt><expr><name>nres</name> <operator>=</operator> <call><name>cdbdisp_numPGresult</name><argument_list>(<argument><expr><name>dispatchResult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>ires</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>ires</name> <operator>&lt;</operator> <name>nres</name></expr>;</condition> <incr><expr><operator>++</operator><name>ires</name></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>pgresult</name> <init>= <expr><call><name>cdbdisp_getPGresult</name><argument_list>(<argument><expr><name>dispatchResult</name></expr></argument>, <argument><expr><name>ires</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>errdata</name> <operator>=</operator> <call><name>cdbdisp_get_PQerror</name><argument_list>(<argument><expr><name>pgresult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>errdata</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>errdata</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Error found on our side of the libpq interface?
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>error_message</name></name> <operator>&amp;&amp;</operator>
		<name><name>dispatchResult</name><operator>-&gt;</operator><name>error_message</name><operator>-&gt;</operator><name>len</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>errstart</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><name>TEXTDOMAIN</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_GP_INTERCONNECTION_ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>error_message</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>errdata</name> <operator>=</operator> <call><name>errfinish_and_return</name><argument_list>(<argument><expr><name>__FILE__</name></expr></argument>, <argument><expr><name>__LINE__</name></expr></argument>, <argument><expr><name>PG_FUNCNAME_MACRO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pg_unreachable</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<return>return <expr><name>errdata</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * The returned error object is allocated in TopTransactionContext.
 * 
 * Caution: do not use the returned object across transaction boundary.
 * Current usages of this API are such that the returned object is either
 * logged using elog() or rethrown, both within a transaction context, at the
 * time of finishing a dispatched command.  The caution applies to future uses
 * of this function.
 */</comment>
<function><type><name>ErrorData</name> <modifier>*</modifier></type>
<name>cdbdisp_get_PQerror</name><parameter_list>(<parameter><decl><type><name>PGresult</name> <modifier>*</modifier></type><name>pgresult</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExecStatusType</name></type> <name>resultStatus</name> <init>= <expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>pgresult</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * QE success
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>resultStatus</name> <operator>==</operator> <name>PGRES_COMMAND_OK</name> <operator>||</operator>
		<name>resultStatus</name> <operator>==</operator> <name>PGRES_TUPLES_OK</name> <operator>||</operator>
		<name>resultStatus</name> <operator>==</operator> <name>PGRES_COPY_IN</name> <operator>||</operator>
		<name>resultStatus</name> <operator>==</operator> <name>PGRES_COPY_OUT</name> <operator>||</operator>
		<name>resultStatus</name> <operator>==</operator> <name>PGRES_EMPTY_QUERY</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * QE error or libpq error
	 */</comment>

	<comment type="block">/* These will be overwritten below with the values from QE, if the QE sent them. */</comment>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>filename</name> <init>= <expr><name>__FILE__</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>lineno</name> <init>= <expr><name>__LINE__</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>funcname</name> <init>= <expr><name>PG_FUNCNAME_MACRO</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>qe_errcode</name> <init>= <expr><name>ERRCODE_GP_INTERCONNECTION_ERROR</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>whoami</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>fld</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * errstart need a const filename and funcname, make sure they
	 * are at least const in this transaction.
	 */</comment>
	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>TopTransactionContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>fld</name> <operator>=</operator> <call><name>PQresultErrorField</name><argument_list>(<argument><expr><name>pgresult</name></expr></argument>, <argument><expr><name>PG_DIAG_SOURCE_FILE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>fld</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>filename</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>fld</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>fld</name> <operator>=</operator> <call><name>PQresultErrorField</name><argument_list>(<argument><expr><name>pgresult</name></expr></argument>, <argument><expr><name>PG_DIAG_SOURCE_LINE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>fld</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>lineno</name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><name>fld</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>fld</name> <operator>=</operator> <call><name>PQresultErrorField</name><argument_list>(<argument><expr><name>pgresult</name></expr></argument>, <argument><expr><name>PG_DIAG_SOURCE_FUNCTION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>fld</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>funcname</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>fld</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We should only get errors with ERROR level or above, if the
	 * command failed. And if a QE disconnected with FATAL, or PANICed,
	 * we don't want to do the same in the QD. So, always an ERROR.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>errstart</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><name>TEXTDOMAIN</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pg_unreachable</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt> <comment type="block">/* unexpected path. */</comment>

	<expr_stmt><expr><name>fld</name> <operator>=</operator> <call><name>PQresultErrorField</name><argument_list>(<argument><expr><name>pgresult</name></expr></argument>, <argument><expr><name>PG_DIAG_SQLSTATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>fld</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>qe_errcode</name> <operator>=</operator> <call><name>sqlstate_to_errcode</name><argument_list>(<argument><expr><name>fld</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>errcode</name><argument_list>(<argument><expr><name>qe_errcode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>whoami</name> <operator>=</operator> <call><name>PQresultErrorField</name><argument_list>(<argument><expr><name>pgresult</name></expr></argument>, <argument><expr><name>PG_DIAG_GP_PROCESS_TAG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>fld</name> <operator>=</operator> <call><name>PQresultErrorField</name><argument_list>(<argument><expr><name>pgresult</name></expr></argument>, <argument><expr><name>PG_DIAG_MESSAGE_PRIMARY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>fld</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>fld</name> <operator>=</operator> <literal type="string">"no primary message received"</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>whoami</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s  (%s)"</literal></expr></argument>, <argument><expr><name>fld</name></expr></argument>, <argument><expr><name>whoami</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>fld</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name>fld</name> <operator>=</operator> <call><name>PQresultErrorField</name><argument_list>(<argument><expr><name>pgresult</name></expr></argument>, <argument><expr><name>PG_DIAG_MESSAGE_DETAIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>fld</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>fld</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>fld</name> <operator>=</operator> <call><name>PQresultErrorField</name><argument_list>(<argument><expr><name>pgresult</name></expr></argument>, <argument><expr><name>PG_DIAG_MESSAGE_HINT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>fld</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>fld</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>fld</name> <operator>=</operator> <call><name>PQresultErrorField</name><argument_list>(<argument><expr><name>pgresult</name></expr></argument>, <argument><expr><name>PG_DIAG_CONTEXT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>fld</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>errcontext</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>fld</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>fld</name> <operator>=</operator> <call><name>PQresultErrorField</name><argument_list>(<argument><expr><name>pgresult</name></expr></argument>, <argument><expr><name>PG_DIAG_SCHEMA_NAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>fld</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>err_generic_string</name><argument_list>(<argument><expr><name>PG_DIAG_SCHEMA_NAME</name></expr></argument>, <argument><expr><name>fld</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>fld</name> <operator>=</operator> <call><name>PQresultErrorField</name><argument_list>(<argument><expr><name>pgresult</name></expr></argument>, <argument><expr><name>PG_DIAG_TABLE_NAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>fld</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>err_generic_string</name><argument_list>(<argument><expr><name>PG_DIAG_TABLE_NAME</name></expr></argument>, <argument><expr><name>fld</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>fld</name> <operator>=</operator> <call><name>PQresultErrorField</name><argument_list>(<argument><expr><name>pgresult</name></expr></argument>, <argument><expr><name>PG_DIAG_COLUMN_NAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>fld</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>err_generic_string</name><argument_list>(<argument><expr><name>PG_DIAG_COLUMN_NAME</name></expr></argument>, <argument><expr><name>fld</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>fld</name> <operator>=</operator> <call><name>PQresultErrorField</name><argument_list>(<argument><expr><name>pgresult</name></expr></argument>, <argument><expr><name>PG_DIAG_DATATYPE_NAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>fld</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>err_generic_string</name><argument_list>(<argument><expr><name>PG_DIAG_DATATYPE_NAME</name></expr></argument>, <argument><expr><name>fld</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>fld</name> <operator>=</operator> <call><name>PQresultErrorField</name><argument_list>(<argument><expr><name>pgresult</name></expr></argument>, <argument><expr><name>PG_DIAG_CONSTRAINT_NAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>fld</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>err_generic_string</name><argument_list>(<argument><expr><name>PG_DIAG_CONSTRAINT_NAME</name></expr></argument>, <argument><expr><name>fld</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>TopTransactionContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>TopTransactionContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>ErrorData</name> <modifier>*</modifier></type><name>edata</name> <init>= <expr><call><name>errfinish_and_return</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><name>lineno</name></expr></argument>, <argument><expr><name>funcname</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>edata</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Format a CdbDispatchResults object.
 * Returns an ErrorData object in *qeError if some error was found, or NIL if no errors.
 * Before calling this function, you must call CdbCheckDispatchResult().
 */</comment>
<function><type><name>void</name></type>
<name>cdbdisp_dumpDispatchResults</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>CdbDispatchResults</name></name> <modifier>*</modifier></type><name>meleeResults</name></decl></parameter>,
							<parameter><decl><type><name>ErrorData</name> <modifier>*</modifier><modifier>*</modifier></type><name>qeError</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CdbDispatchResult</name> <modifier>*</modifier></type><name>dispatchResult</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Quick exit if no error (not counting ERRCODE_GP_OPERATION_CANCELED).
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>meleeResults</name> <operator>||</operator> <operator>!</operator><name><name>meleeResults</name><operator>-&gt;</operator><name>errcode</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>qeError</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Find the CdbDispatchResult of the first QE that got an error.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>meleeResults</name><operator>-&gt;</operator><name>iFirstError</name></name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
		   <name><name>meleeResults</name><operator>-&gt;</operator><name>iFirstError</name></name> <operator>&lt;</operator> <name><name>meleeResults</name><operator>-&gt;</operator><name>resultCount</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>dispatchResult</name> <operator>=</operator> <operator>&amp;</operator><name><name>meleeResults</name><operator>-&gt;</operator><name>resultArray</name><index>[<expr><name><name>meleeResults</name><operator>-&gt;</operator><name>iFirstError</name></name></expr>]</index></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>meleeResults</name></name> <operator>==</operator> <name>meleeResults</name> <operator>&amp;&amp;</operator>
		   <name><name>dispatchResult</name><operator>-&gt;</operator><name>errcode</name></name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Format one QE's result.
	 */</comment>
	<expr_stmt><expr><operator>*</operator><name>qeError</name> <operator>=</operator> <call><name>cdbdisp_dumpDispatchResult</name><argument_list>(<argument><expr><name>dispatchResult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Return sum of the cmdTuples values from CdbDispatchResult
 * entries that have a successful PGresult. If sliceIndex &gt;= 0,
 * uses only the results belonging to the specified slice.
 */</comment>
<function><type><name>int64</name></type>
<name>cdbdisp_sumCmdTuples</name><parameter_list>(<parameter><decl><type><name>CdbDispatchResults</name> <modifier>*</modifier></type><name>results</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sliceIndex</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CdbDispatchResult</name> <modifier>*</modifier></type><name>dispatchResult</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CdbDispatchResult</name> <modifier>*</modifier></type><name>resultEnd</name> <init>= <expr><call><name>cdbdisp_resultEnd</name><argument_list>(<argument><expr><name>results</name></expr></argument>, <argument><expr><name>sliceIndex</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>pgresult</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type>		<name>sum</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>dispatchResult</name> <operator>=</operator> <call><name>cdbdisp_resultBegin</name><argument_list>(<argument><expr><name>results</name></expr></argument>, <argument><expr><name>sliceIndex</name></expr></argument>)</argument_list></call></expr>;</init>
		 <condition><expr><name>dispatchResult</name> <operator>&lt;</operator> <name>resultEnd</name></expr>;</condition> <incr><expr><operator>++</operator><name>dispatchResult</name></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>pgresult</name> <operator>=</operator> <call><name>cdbdisp_getPGresult</name><argument_list>(<argument><expr><name>dispatchResult</name></expr></argument>, <argument><expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>okindex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>pgresult</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>dispatchResult</name><operator>-&gt;</operator><name>errcode</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>cmdTuples</name> <init>= <expr><call><name>PQcmdTuples</name><argument_list>(<argument><expr><name>pgresult</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>cmdTuples</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>sum</name> <operator>+=</operator> <call><name>atoll</name><argument_list>(<argument><expr><name>cmdTuples</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
	<return>return <expr><name>sum</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * If several tuples were eliminated/rejected from the result because of
 * bad data formatting (this is currenly only possible in external tables
 * with single row error handling) - sum up the total rows rejected from
 * all QE's and notify the client.
 */</comment>
<function><type><name>void</name></type>
<name>cdbdisp_sumRejectedRows</name><parameter_list>(<parameter><decl><type><name>CdbDispatchResults</name> <modifier>*</modifier></type><name>results</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CdbDispatchResult</name> <modifier>*</modifier></type><name>dispatchResult</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CdbDispatchResult</name> <modifier>*</modifier></type><name>resultEnd</name> <init>= <expr><call><name>cdbdisp_resultEnd</name><argument_list>(<argument><expr><name>results</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>pgresult</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>totalRejected</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>dispatchResult</name> <operator>=</operator> <call><name>cdbdisp_resultBegin</name><argument_list>(<argument><expr><name>results</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</init>
		 <condition><expr><name>dispatchResult</name> <operator>&lt;</operator> <name>resultEnd</name></expr>;</condition> <incr><expr><operator>++</operator><name>dispatchResult</name></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>pgresult</name> <operator>=</operator> <call><name>cdbdisp_getPGresult</name><argument_list>(<argument><expr><name>dispatchResult</name></expr></argument>, <argument><expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>okindex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>pgresult</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>dispatchResult</name><operator>-&gt;</operator><name>errcode</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * add num rows rejected from this QE to the total
			 */</comment>
			<expr_stmt><expr><name>totalRejected</name> <operator>+=</operator> <name><name>dispatchResult</name><operator>-&gt;</operator><name>numrowsrejected</name></name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><name>totalRejected</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ReportSrehResults</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>totalRejected</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></function>

<comment type="block">/*
 * Return ptr to first resultArray entry for a given sliceIndex.
 */</comment>
<function><type><name>CdbDispatchResult</name> <modifier>*</modifier></type>
<name>cdbdisp_resultBegin</name><parameter_list>(<parameter><decl><type><name>CdbDispatchResults</name> <modifier>*</modifier></type><name>results</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sliceIndex</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CdbDispatchResults_SliceInfo</name> <modifier>*</modifier></type><name>si</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>results</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>sliceIndex</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>&amp;</operator><name><name>results</name><operator>-&gt;</operator><name>resultArray</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>sliceIndex</name> <operator>&lt;</operator> <name><name>results</name><operator>-&gt;</operator><name>sliceCapacity</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>si</name> <operator>=</operator> <operator>&amp;</operator><name><name>results</name><operator>-&gt;</operator><name>sliceMap</name><index>[<expr><name>sliceIndex</name></expr>]</index></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>si</name><operator>-&gt;</operator><name>resultBegin</name></name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
		   <name><name>si</name><operator>-&gt;</operator><name>resultBegin</name></name> <operator>&lt;=</operator> <name><name>si</name><operator>-&gt;</operator><name>resultEnd</name></name> <operator>&amp;&amp;</operator>
		   <name><name>si</name><operator>-&gt;</operator><name>resultEnd</name></name> <operator>&lt;=</operator> <name><name>results</name><operator>-&gt;</operator><name>resultCount</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><operator>&amp;</operator><name><name>results</name><operator>-&gt;</operator><name>resultArray</name><index>[<expr><name><name>si</name><operator>-&gt;</operator><name>resultBegin</name></name></expr>]</index></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Return ptr to last+1 resultArray entry for a given sliceIndex.
 */</comment>
<function><type><name>CdbDispatchResult</name> <modifier>*</modifier></type>
<name>cdbdisp_resultEnd</name><parameter_list>(<parameter><decl><type><name>CdbDispatchResults</name> <modifier>*</modifier></type><name>results</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sliceIndex</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CdbDispatchResults_SliceInfo</name> <modifier>*</modifier></type><name>si</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>results</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>sliceIndex</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>&amp;</operator><name><name>results</name><operator>-&gt;</operator><name>resultArray</name><index>[<expr><name><name>results</name><operator>-&gt;</operator><name>resultCount</name></name></expr>]</index></name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>si</name> <operator>=</operator> <operator>&amp;</operator><name><name>results</name><operator>-&gt;</operator><name>sliceMap</name><index>[<expr><name>sliceIndex</name></expr>]</index></name></expr>;</expr_stmt>

	<return>return <expr><operator>&amp;</operator><name><name>results</name><operator>-&gt;</operator><name>resultArray</name><index>[<expr><name><name>si</name><operator>-&gt;</operator><name>resultEnd</name></name></expr>]</index></name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>cdbdisp_returnResults</name><parameter_list>(<parameter><decl><type><name>CdbDispatchResults</name> <modifier>*</modifier></type><name>primaryResults</name></decl></parameter>, <parameter><decl><type><name>CdbPgResults</name> <modifier>*</modifier></type><name>cdb_pgresults</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CdbDispatchResult</name> <modifier>*</modifier></type><name>dispatchResult</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nslots</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nresults</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>primaryResults</name> <operator>||</operator> <operator>!</operator><name>cdb_pgresults</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Allocate result set ptr array. The caller must PQclear() each PGresult
	 * and free() the array.
	 */</comment>
	<expr_stmt><expr><name>nslots</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>primaryResults</name><operator>-&gt;</operator><name>resultCount</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name>nslots</name> <operator>+=</operator> <call><name>cdbdisp_numPGresult</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>primaryResults</name><operator>-&gt;</operator><name>resultArray</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

	<expr_stmt><expr><name><name>cdb_pgresults</name><operator>-&gt;</operator><name>pg_results</name></name> <operator>=</operator> <operator>(</operator>struct <name>pg_result</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>nslots</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr>struct <name>pg_result</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Collect results from primary gang.
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>primaryResults</name><operator>-&gt;</operator><name>resultCount</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>dispatchResult</name> <operator>=</operator> <operator>&amp;</operator><name><name>primaryResults</name><operator>-&gt;</operator><name>resultArray</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Take ownership of this QE's PGresult object(s).
		 */</comment>
		<expr_stmt><expr><name>nresults</name> <operator>+=</operator> <call><name>cdbdisp_snatchPGresults</name><argument_list>(<argument><expr><name>dispatchResult</name></expr></argument>,
											<argument><expr><name><name>cdb_pgresults</name><operator>-&gt;</operator><name>pg_results</name></name> <operator>+</operator> <name>nresults</name></expr></argument>,
											<argument><expr><name>nslots</name> <operator>-</operator> <name>nresults</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nresults</name> <operator>==</operator> <name>nslots</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* tell the caller how many sets we're returning. */</comment>
	<expr_stmt><expr><name><name>cdb_pgresults</name><operator>-&gt;</operator><name>numResults</name></name> <operator>=</operator> <name>nresults</name></expr>;</expr_stmt>
	<comment type="block">/* set the number of dispatched QE */</comment>
	<expr_stmt><expr><name><name>cdb_pgresults</name><operator>-&gt;</operator><name>numDispatches</name></name> <operator>=</operator> <name><name>primaryResults</name><operator>-&gt;</operator><name>resultCount</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * used in the interconnect on the dispatcher to avoid error-cleanup deadlocks.
 */</comment>
<function><type><name>bool</name></type>
<name>cdbdisp_checkResultsErrcode</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>CdbDispatchResults</name></name> <modifier>*</modifier></type><name>meleeResults</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>meleeResults</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>meleeResults</name><operator>-&gt;</operator><name>errcode</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * cdbdisp_makeDispatchResults:
 * Allocates a CdbDispatchResults object in the current memory context.
 * Will be freed in function cdbdisp_destroyDispatcherState by deleting the
 * memory context.
 */</comment>
<function><type><name>void</name></type>
<name>cdbdisp_makeDispatchResults</name><parameter_list>(<parameter><decl><type><name>CdbDispatcherState</name> <modifier>*</modifier></type><name>ds</name></decl></parameter>,
							<parameter><decl><type><name>int</name></type> <name>sliceCapacity</name></decl></parameter>,
							<parameter><decl><type><name>bool</name></type> <name>cancelOnError</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CdbDispatchResults</name> <modifier>*</modifier></type><name>results</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldContext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>	<name>resultCapacity</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>nbytes</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>DispatcherContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>oldContext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>DispatcherContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>resultCapacity</name> <operator>=</operator> <name><name>ds</name><operator>-&gt;</operator><name>largestGangSize</name></name> <operator>*</operator> <name>sliceCapacity</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>nbytes</name> <operator>=</operator> <name>resultCapacity</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>results</name><operator>-&gt;</operator><name>resultArray</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

	<expr_stmt><expr><name>results</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>results</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>results</name><operator>-&gt;</operator><name>resultArray</name></name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>nbytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>results</name><operator>-&gt;</operator><name>resultCapacity</name></name> <operator>=</operator> <name>resultCapacity</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>results</name><operator>-&gt;</operator><name>resultCount</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>results</name><operator>-&gt;</operator><name>iFirstError</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>results</name><operator>-&gt;</operator><name>errcode</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>results</name><operator>-&gt;</operator><name>cancelOnError</name></name> <operator>=</operator> <name>cancelOnError</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>results</name><operator>-&gt;</operator><name>sliceMap</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>results</name><operator>-&gt;</operator><name>sliceCapacity</name></name> <operator>=</operator> <name>sliceCapacity</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>sliceCapacity</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>nbytes</name> <operator>=</operator> <name>sliceCapacity</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>results</name><operator>-&gt;</operator><name>sliceMap</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>results</name><operator>-&gt;</operator><name>sliceMap</name></name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>nbytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>ds</name><operator>-&gt;</operator><name>primaryResults</name></name> <operator>=</operator> <name>results</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>cdbdisp_clearCdbPgResults</name><parameter_list>(<parameter><decl><type><name>CdbPgResults</name> <modifier>*</modifier></type><name>cdb_pgresults</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>cdb_pgresults</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>cdb_pgresults</name><operator>-&gt;</operator><name>numResults</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name><name>cdb_pgresults</name><operator>-&gt;</operator><name>pg_results</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

	<if_stmt><if>if <condition>(<expr><name><name>cdb_pgresults</name><operator>-&gt;</operator><name>pg_results</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>cdb_pgresults</name><operator>-&gt;</operator><name>pg_results</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cdb_pgresults</name><operator>-&gt;</operator><name>pg_results</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>cdb_pgresults</name><operator>-&gt;</operator><name>numResults</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Remove all of the PGresult ptrs from a CdbDispatchResult object
 * and place them into an array provided by the caller. The caller
 * becomes responsible for PQclear()ing them. Returns the number of
 * PGresult ptrs placed in the array.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>cdbdisp_snatchPGresults</name><parameter_list>(<parameter><decl><type><name>CdbDispatchResult</name> <modifier>*</modifier></type><name>dispatchResult</name></decl></parameter>,
						<parameter><decl><type><name><name>struct</name> <name>pg_result</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>pgresultptrs</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>maxresults</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>buf</name> <init>= <expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>resultbuf</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>  <modifier>*</modifier><modifier>*</modifier></type><name>begp</name> <init>= <expr><operator>(</operator><name>PGresult</name> <operator>*</operator><operator>*</operator><operator>)</operator> <name><name>buf</name><operator>-&gt;</operator><name>data</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>  <modifier>*</modifier><modifier>*</modifier></type><name>endp</name> <init>= <expr><operator>(</operator><name>PGresult</name> <operator>*</operator><operator>*</operator><operator>)</operator> <operator>(</operator><name><name>buf</name><operator>-&gt;</operator><name>data</name></name> <operator>+</operator> <name><name>buf</name><operator>-&gt;</operator><name>len</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>  <modifier>*</modifier><modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nresults</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Snatch the PGresult objects.
	 */</comment>
	<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name>begp</name></expr>;</init> <condition><expr><name>p</name> <operator>&lt;</operator> <name>endp</name></expr>;</condition> <incr><expr><operator>++</operator><name>p</name></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>*</operator><name>p</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nresults</name> <operator>&lt;</operator> <name>maxresults</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pgresultptrs</name><index>[<expr><name>nresults</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>*</operator><name>p</name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Empty our PGresult array.
	 */</comment>
	<expr_stmt><expr><call><name>resetPQExpBuffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>okindex</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

	<return>return <expr><name>nresults</name></expr>;</return>
</block_content>}</block></function>
</unit>
