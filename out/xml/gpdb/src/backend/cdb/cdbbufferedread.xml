<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/backend/cdb/cdbbufferedread.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * cdbbufferedread.c
 *	  Read buffers sequentially from a file efficiently.
 *
 * (See .h file for usage comments)
 *
 * Portions Copyright (c) 2007, greenplum inc
 * Portions Copyright (c) 2012-Present VMware, Inc. or its affiliates.
 *
 *
 * IDENTIFICATION
 *	    src/backend/cdb/cdbbufferedread.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbbufferedread.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgstat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/guc.h"</cpp:file></cpp:include>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>BufferedReadIo</name><parameter_list>(
			   <parameter><decl><type><name>BufferedRead</name> <modifier>*</modifier></type><name>bufferedRead</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>uint8</name> <modifier>*</modifier></type><name>BufferedReadUseBeforeBuffer</name><parameter_list>(
							<parameter><decl><type><name>BufferedRead</name> <modifier>*</modifier></type><name>bufferedRead</name></decl></parameter>,
							<parameter><decl><type><name>int32</name></type> <name>maxReadAheadLen</name></decl></parameter>,
							<parameter><decl><type><name>int32</name> <modifier>*</modifier></type><name>nextBufferLen</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * Determines the amount of memory to supply for
 * BufferedRead given the desired buffer and
 * large write lengths.
 */</comment>
<function><type><name>int32</name></type>
<name>BufferedReadMemoryLen</name><parameter_list>(
					  <parameter><decl><type><name>int32</name></type> <name>maxBufferLen</name></decl></parameter>,
					  <parameter><decl><type><name>int32</name></type> <name>maxLargeReadLen</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>maxBufferLen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>maxLargeReadLen</name> <operator>&gt;=</operator> <name>maxBufferLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Adjacent before memory for 1 buffer and large read memory. */</comment>
	<return>return <expr><operator>(</operator><name>maxBufferLen</name> <operator>+</operator> <name>maxLargeReadLen</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Initialize BufferedRead.
 *
 * Use the BufferedReadMemoryLen procedure to
 * determine the amount of memory to supply.
 */</comment>
<function><type><name>void</name></type>
<name>BufferedReadInit</name><parameter_list>(
				 <parameter><decl><type><name>BufferedRead</name> <modifier>*</modifier></type><name>bufferedRead</name></decl></parameter>,
				 <parameter><decl><type><name>uint8</name> <modifier>*</modifier></type><name>memory</name></decl></parameter>,
				 <parameter><decl><type><name>int32</name></type> <name>memoryLen</name></decl></parameter>,
				 <parameter><decl><type><name>int32</name></type> <name>maxBufferLen</name></decl></parameter>,
				 <parameter><decl><type><name>int32</name></type> <name>maxLargeReadLen</name></decl></parameter>,
				 <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>relationName</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>bufferedRead</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>memory</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>maxBufferLen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>maxLargeReadLen</name> <operator>&gt;=</operator> <name>maxBufferLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>memoryLen</name> <operator>&gt;=</operator> <call><name>BufferedReadMemoryLen</name><argument_list>(<argument><expr><name>maxBufferLen</name></expr></argument>, <argument><expr><name>maxLargeReadLen</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>bufferedRead</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BufferedRead</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Init level.
	 */</comment>
	<expr_stmt><expr><name><name>bufferedRead</name><operator>-&gt;</operator><name>relationName</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>relationName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Large-read memory level members.
	 */</comment>
	<expr_stmt><expr><name><name>bufferedRead</name><operator>-&gt;</operator><name>maxBufferLen</name></name> <operator>=</operator> <name>maxBufferLen</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>bufferedRead</name><operator>-&gt;</operator><name>maxLargeReadLen</name></name> <operator>=</operator> <name>maxLargeReadLen</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>bufferedRead</name><operator>-&gt;</operator><name>memory</name></name> <operator>=</operator> <name>memory</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>bufferedRead</name><operator>-&gt;</operator><name>memoryLen</name></name> <operator>=</operator> <name>memoryLen</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>bufferedRead</name><operator>-&gt;</operator><name>beforeBufferMemory</name></name> <operator>=</operator> <name>memory</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>bufferedRead</name><operator>-&gt;</operator><name>largeReadMemory</name></name> <operator>=</operator>
		<operator>&amp;</operator><name><name>memory</name><index>[<expr><name>maxBufferLen</name></expr>]</index></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>bufferedRead</name><operator>-&gt;</operator><name>largeReadPosition</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>bufferedRead</name><operator>-&gt;</operator><name>largeReadLen</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * Buffer level members.
	 */</comment>
	<expr_stmt><expr><name><name>bufferedRead</name><operator>-&gt;</operator><name>bufferOffset</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>bufferedRead</name><operator>-&gt;</operator><name>bufferLen</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * File level members.
	 */</comment>
	<expr_stmt><expr><name><name>bufferedRead</name><operator>-&gt;</operator><name>file</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>bufferedRead</name><operator>-&gt;</operator><name>fileLen</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<comment type="block">/* start reading from beginning of file */</comment>
	<expr_stmt><expr><name><name>bufferedRead</name><operator>-&gt;</operator><name>fileOff</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * Temporary limit support for random reading.
	 */</comment>
	<expr_stmt><expr><name><name>bufferedRead</name><operator>-&gt;</operator><name>haveTemporaryLimitInEffect</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>bufferedRead</name><operator>-&gt;</operator><name>temporaryLimitFileLen</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Takes an open file handle for the next file.
 */</comment>
<function><type><name>void</name></type>
<name>BufferedReadSetFile</name><parameter_list>(
					<parameter><decl><type><name>BufferedRead</name> <modifier>*</modifier></type><name>bufferedRead</name></decl></parameter>,
					<parameter><decl><type><name>File</name></type> <name>file</name></decl></parameter>,
					<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>filePathName</name></decl></parameter>,
					<parameter><decl><type><name>int64</name></type> <name>fileLen</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>bufferedRead</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>bufferedRead</name><operator>-&gt;</operator><name>file</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>bufferedRead</name><operator>-&gt;</operator><name>fileLen</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>bufferedRead</name><operator>-&gt;</operator><name>largeReadPosition</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>bufferedRead</name><operator>-&gt;</operator><name>largeReadLen</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>bufferedRead</name><operator>-&gt;</operator><name>bufferOffset</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>bufferedRead</name><operator>-&gt;</operator><name>bufferLen</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>file</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>fileLen</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>bufferedRead</name><operator>-&gt;</operator><name>file</name></name> <operator>=</operator> <name>file</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>bufferedRead</name><operator>-&gt;</operator><name>filePathName</name></name> <operator>=</operator> <name>filePathName</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>bufferedRead</name><operator>-&gt;</operator><name>fileLen</name></name> <operator>=</operator> <name>fileLen</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>bufferedRead</name><operator>-&gt;</operator><name>haveTemporaryLimitInEffect</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>bufferedRead</name><operator>-&gt;</operator><name>temporaryLimitFileLen</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>bufferedRead</name><operator>-&gt;</operator><name>fileOff</name></name> <operator>=</operator><literal type="number">0</literal></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>fileLen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Do the first read.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>fileLen</name> <operator>&gt;</operator> <name><name>bufferedRead</name><operator>-&gt;</operator><name>maxLargeReadLen</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>bufferedRead</name><operator>-&gt;</operator><name>largeReadLen</name></name> <operator>=</operator> <name><name>bufferedRead</name><operator>-&gt;</operator><name>maxLargeReadLen</name></name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>bufferedRead</name><operator>-&gt;</operator><name>largeReadLen</name></name> <operator>=</operator> <operator>(</operator><name>int32</name><operator>)</operator> <name>fileLen</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<expr_stmt><expr><call><name>BufferedReadIo</name><argument_list>(<argument><expr><name>bufferedRead</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Perform a large read i/o.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>BufferedReadIo</name><parameter_list>(
			   <parameter><decl><type><name>BufferedRead</name> <modifier>*</modifier></type><name>bufferedRead</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int32</name></type>		<name>largeReadLen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint8</name>	   <modifier>*</modifier></type><name>largeReadMemory</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>offset</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>largeReadLen</name> <operator>=</operator> <name><name>bufferedRead</name><operator>-&gt;</operator><name>largeReadLen</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>bufferedRead</name><operator>-&gt;</operator><name>largeReadLen</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>largeReadMemory</name> <operator>=</operator> <name><name>bufferedRead</name><operator>-&gt;</operator><name>largeReadMemory</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name>offset</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>largeReadLen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>actualLen</name> <init>= <expr><call><name>FileRead</name><argument_list>(<argument><expr><name><name>bufferedRead</name><operator>-&gt;</operator><name>file</name></name></expr></argument>,
										 <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>largeReadMemory</name></expr></argument>,
										 <argument><expr><name>largeReadLen</name></expr></argument>,
										 <argument><expr><name><name>bufferedRead</name><operator>-&gt;</operator><name>fileOff</name></name></expr></argument>,
										 <argument><expr><name>WAIT_EVENT_DATA_FILE_READ</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>actualLen</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
							<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"read beyond eof in table \"%s\" file \"%s\", "</literal>
								   <literal type="string">"read position "</literal> <name>INT64_FORMAT</name> <literal type="string">" (small offset %d), "</literal>
								   <literal type="string">"actual read length %d (large read length %d)"</literal></expr></argument>,
								   <argument><expr><name><name>bufferedRead</name><operator>-&gt;</operator><name>relationName</name></name></expr></argument>,
								   <argument><expr><name><name>bufferedRead</name><operator>-&gt;</operator><name>filePathName</name></name></expr></argument>,
								   <argument><expr><name><name>bufferedRead</name><operator>-&gt;</operator><name>largeReadPosition</name></name></expr></argument>,
								   <argument><expr><name>offset</name></expr></argument>,
								   <argument><expr><name>actualLen</name></expr></argument>,
								   <argument><expr><name><name>bufferedRead</name><operator>-&gt;</operator><name>largeReadLen</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name>actualLen</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
							<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unable to read table \"%s\" file \"%s\", "</literal>
								   <literal type="string">"read position "</literal> <name>INT64_FORMAT</name> <literal type="string">" (small offset %d), "</literal>
								   <literal type="string">"actual read length %d (large read length %d): %m"</literal></expr></argument>,
								   <argument><expr><name><name>bufferedRead</name><operator>-&gt;</operator><name>relationName</name></name></expr></argument>,
								   <argument><expr><name><name>bufferedRead</name><operator>-&gt;</operator><name>filePathName</name></name></expr></argument>,
								   <argument><expr><name><name>bufferedRead</name><operator>-&gt;</operator><name>largeReadPosition</name></name></expr></argument>,
								   <argument><expr><name>offset</name></expr></argument>,
								   <argument><expr><name>actualLen</name></expr></argument>,
								   <argument><expr><name><name>bufferedRead</name><operator>-&gt;</operator><name>largeReadLen</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>bufferedRead</name><operator>-&gt;</operator><name>fileOff</name></name> <operator>+=</operator> <name>actualLen</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>elogif</name><argument_list>(<argument><expr><name>Debug_appendonly_print_read_block</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>,
			   <argument><expr><literal type="string">"Append-Only storage read: table \"%s\", segment file \"%s\", read position "</literal> <name>INT64_FORMAT</name> <literal type="string">" (small offset %d), "</literal>
			   <literal type="string">"actual read length %d (equals large read length %d is %s)"</literal></expr></argument>,
			   <argument><expr><name><name>bufferedRead</name><operator>-&gt;</operator><name>relationName</name></name></expr></argument>,
			   <argument><expr><name><name>bufferedRead</name><operator>-&gt;</operator><name>filePathName</name></name></expr></argument>,
			   <argument><expr><name><name>bufferedRead</name><operator>-&gt;</operator><name>largeReadPosition</name></name></expr></argument>,
			   <argument><expr><name>offset</name></expr></argument>,
			   <argument><expr><name>actualLen</name></expr></argument>,
			   <argument><expr><name><name>bufferedRead</name><operator>-&gt;</operator><name>largeReadLen</name></name></expr></argument>,
			   <argument><expr><operator>(</operator><ternary><condition><expr><name>actualLen</name> <operator>==</operator> <name><name>bufferedRead</name><operator>-&gt;</operator><name>largeReadLen</name></name></expr> ?</condition><then> <expr><literal type="string">"true"</literal></expr> </then><else>: <expr><literal type="string">"false"</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>largeReadLen</name> <operator>-=</operator> <name>actualLen</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>largeReadMemory</name> <operator>+=</operator> <name>actualLen</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>offset</name> <operator>+=</operator> <name>actualLen</name></expr>;</expr_stmt>
	</block_content>}</block></while>

	<if_stmt><if>if <condition>(<expr><name>VacuumCostActive</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>VacuumCostBalance</name> <operator>+=</operator> <name>VacuumCostPageMiss</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>uint8</name> <modifier>*</modifier></type>
<name>BufferedReadUseBeforeBuffer</name><parameter_list>(
							<parameter><decl><type><name>BufferedRead</name> <modifier>*</modifier></type><name>bufferedRead</name></decl></parameter>,
							<parameter><decl><type><name>int32</name></type> <name>maxReadAheadLen</name></decl></parameter>,
							<parameter><decl><type><name>int32</name> <modifier>*</modifier></type><name>nextBufferLen</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int64</name></type>		<name>inEffectFileLen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type>		<name>nextPosition</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type>		<name>remainingFileLen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>nextReadLen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>beforeLen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>beforeOffset</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>extraLen</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>bufferedRead</name><operator>-&gt;</operator><name>largeReadLen</name></name> <operator>-</operator> <name><name>bufferedRead</name><operator>-&gt;</operator><name>bufferOffset</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>bufferedRead</name><operator>-&gt;</operator><name>haveTemporaryLimitInEffect</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>inEffectFileLen</name> <operator>=</operator> <name><name>bufferedRead</name><operator>-&gt;</operator><name>temporaryLimitFileLen</name></name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>inEffectFileLen</name> <operator>=</operator> <name><name>bufferedRead</name><operator>-&gt;</operator><name>fileLen</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * Requesting more data than in the current read.
	 */</comment>
	<expr_stmt><expr><name>nextPosition</name> <operator>=</operator> <name><name>bufferedRead</name><operator>-&gt;</operator><name>largeReadPosition</name></name> <operator>+</operator> <name><name>bufferedRead</name><operator>-&gt;</operator><name>largeReadLen</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>nextPosition</name> <operator>==</operator> <name>inEffectFileLen</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * No more file to read.
		 */</comment>
		<expr_stmt><expr><name><name>bufferedRead</name><operator>-&gt;</operator><name>bufferLen</name></name> <operator>=</operator> <name><name>bufferedRead</name><operator>-&gt;</operator><name>largeReadLen</name></name> <operator>-</operator>
			<name><name>bufferedRead</name><operator>-&gt;</operator><name>bufferOffset</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>bufferedRead</name><operator>-&gt;</operator><name>bufferLen</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><operator>*</operator><name>nextBufferLen</name> <operator>=</operator> <name><name>bufferedRead</name><operator>-&gt;</operator><name>bufferLen</name></name></expr>;</expr_stmt>
		<return>return <expr><operator>&amp;</operator><name><name>bufferedRead</name><operator>-&gt;</operator><name>largeReadMemory</name><index>[<expr><name><name>bufferedRead</name><operator>-&gt;</operator><name>bufferOffset</name></name></expr>]</index></name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>remainingFileLen</name> <operator>=</operator> <name>inEffectFileLen</name> <operator>-</operator>
		<name>nextPosition</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>remainingFileLen</name> <operator>&gt;</operator> <name><name>bufferedRead</name><operator>-&gt;</operator><name>maxLargeReadLen</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>nextReadLen</name> <operator>=</operator> <name><name>bufferedRead</name><operator>-&gt;</operator><name>maxLargeReadLen</name></name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>nextReadLen</name> <operator>=</operator> <operator>(</operator><name>int32</name><operator>)</operator> <name>remainingFileLen</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nextReadLen</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>beforeLen</name> <operator>=</operator> <name><name>bufferedRead</name><operator>-&gt;</operator><name>maxLargeReadLen</name></name> <operator>-</operator> <name><name>bufferedRead</name><operator>-&gt;</operator><name>bufferOffset</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>beforeOffset</name> <operator>=</operator> <name><name>bufferedRead</name><operator>-&gt;</operator><name>maxBufferLen</name></name> <operator>-</operator> <name>beforeLen</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Copy data from the current large-read buffer into the before memory.
	 */</comment>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>bufferedRead</name><operator>-&gt;</operator><name>beforeBufferMemory</name><index>[<expr><name>beforeOffset</name></expr>]</index></name></expr></argument>,
		   <argument><expr><operator>&amp;</operator><name><name>bufferedRead</name><operator>-&gt;</operator><name>largeReadMemory</name><index>[<expr><name><name>bufferedRead</name><operator>-&gt;</operator><name>bufferOffset</name></name></expr>]</index></name></expr></argument>,
		   <argument><expr><name>beforeLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Do the next read.
	 */</comment>
	<expr_stmt><expr><name><name>bufferedRead</name><operator>-&gt;</operator><name>largeReadPosition</name></name> <operator>=</operator> <name>nextPosition</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>bufferedRead</name><operator>-&gt;</operator><name>largeReadLen</name></name> <operator>=</operator> <name>nextReadLen</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * MPP-17061: nextReadLen should never be 0, since the code will return
	 * above if inEffectFileLen is equal to nextPosition.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>nextReadLen</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Unexpected internal error,"</literal>
							   <literal type="string">" largeReadLen is set to 0 before calling BufferedReadIo."</literal>
							   <literal type="string">" remainingFileLen is "</literal> <name>INT64_FORMAT</name>
							   <literal type="string">" inEffectFileLen is "</literal> <name>INT64_FORMAT</name>
							   <literal type="string">" nextPosition is "</literal> <name>INT64_FORMAT</name></expr></argument>,
							   <argument><expr><name>remainingFileLen</name></expr></argument>, <argument><expr><name>inEffectFileLen</name></expr></argument>, <argument><expr><name>nextPosition</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>BufferedReadIo</name><argument_list>(<argument><expr><name>bufferedRead</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>extraLen</name> <operator>=</operator> <name>maxReadAheadLen</name> <operator>-</operator> <name>beforeLen</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>extraLen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>extraLen</name> <operator>&gt;</operator> <name>nextReadLen</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>extraLen</name> <operator>=</operator> <operator>(</operator><name>int32</name><operator>)</operator> <name>nextReadLen</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Return a buffer using a negative offset that starts in the before
	 * memory and goes into the large-read memory.
	 */</comment>
	<expr_stmt><expr><name><name>bufferedRead</name><operator>-&gt;</operator><name>bufferOffset</name></name> <operator>=</operator> <operator>-</operator><name>beforeLen</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>bufferedRead</name><operator>-&gt;</operator><name>bufferLen</name></name> <operator>=</operator> <name>beforeLen</name> <operator>+</operator> <name>extraLen</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>bufferedRead</name><operator>-&gt;</operator><name>bufferLen</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>nextBufferLen</name> <operator>=</operator> <name><name>bufferedRead</name><operator>-&gt;</operator><name>bufferLen</name></name></expr>;</expr_stmt>

	<return>return <expr><operator>&amp;</operator><name><name>bufferedRead</name><operator>-&gt;</operator><name>beforeBufferMemory</name><index>[<expr><name>beforeOffset</name></expr>]</index></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Set a temporary read range in the current open segment file.
 *
 * The beginFileOffset must be to the beginning of an Append-Only Storage block.
 *
 * The afterFileOffset serves as the temporary EOF.  It will cause reads to return
 * false (no more blocks) when reached.  It must be at the end of an Append-Only Storage
 * block.
 *
 * When a read returns false (no more blocks), the temporary read range is forgotten.
 */</comment>
<function><type><name>void</name></type>
<name>BufferedReadSetTemporaryRange</name><parameter_list>(
							  <parameter><decl><type><name>BufferedRead</name> <modifier>*</modifier></type><name>bufferedRead</name></decl></parameter>,
							  <parameter><decl><type><name>int64</name></type> <name>beginFileOffset</name></decl></parameter>,
							  <parameter><decl><type><name>int64</name></type> <name>afterFileOffset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>newReadNeeded</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type>		<name>largeReadAfterPos</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>bufferedRead</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>bufferedRead</name><operator>-&gt;</operator><name>file</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Forget any current read buffer length (but not the offset!).
	 */</comment>
	<expr_stmt><expr><name><name>bufferedRead</name><operator>-&gt;</operator><name>bufferLen</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name>newReadNeeded</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>largeReadAfterPos</name> <operator>=</operator> <name><name>bufferedRead</name><operator>-&gt;</operator><name>largeReadPosition</name></name> <operator>+</operator>
		<name><name>bufferedRead</name><operator>-&gt;</operator><name>largeReadLen</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>bufferedRead</name><operator>-&gt;</operator><name>bufferOffset</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int64</name></type>		<name>virtualLargeReadBeginPos</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>virtualLargeReadBeginPos</name> <operator>=</operator> <name><name>bufferedRead</name><operator>-&gt;</operator><name>largeReadPosition</name></name> <operator>+</operator>
			<name><name>bufferedRead</name><operator>-&gt;</operator><name>bufferOffset</name></name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>beginFileOffset</name> <operator>&gt;=</operator> <name>virtualLargeReadBeginPos</name> <operator>&amp;&amp;</operator>
			<name>beginFileOffset</name> <operator>&lt;</operator> <name>largeReadAfterPos</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Our temporary read begin position is within our before buffer
			 * and current read.
			 */</comment>
			<expr_stmt><expr><name><name>bufferedRead</name><operator>-&gt;</operator><name>bufferOffset</name></name> <operator>=</operator>
				<operator>(</operator><name>int32</name><operator>)</operator> <operator>(</operator><name>beginFileOffset</name> <operator>-</operator>
						 <name><name>bufferedRead</name><operator>-&gt;</operator><name>largeReadPosition</name></name><operator>)</operator></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>newReadNeeded</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>beginFileOffset</name> <operator>&gt;=</operator> <name><name>bufferedRead</name><operator>-&gt;</operator><name>largeReadPosition</name></name> <operator>&amp;&amp;</operator>
			<name>beginFileOffset</name> <operator>&lt;</operator> <name>largeReadAfterPos</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Our temporary read begin position is within our current read.
			 */</comment>
			<expr_stmt><expr><name><name>bufferedRead</name><operator>-&gt;</operator><name>bufferOffset</name></name> <operator>=</operator>
				<operator>(</operator><name>int32</name><operator>)</operator> <operator>(</operator><name>beginFileOffset</name> <operator>-</operator>
						 <name><name>bufferedRead</name><operator>-&gt;</operator><name>largeReadPosition</name></name><operator>)</operator></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>newReadNeeded</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>newReadNeeded</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int64</name></type>		<name>remainingFileLen</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Seek to the requested beginning position. MPP-17061: allow seeking
		 * backward (negative offset) in file, this could happen during index
		 * scan, if we do lookup for a block directory entry at the end of the
		 * segment file, followed by a lookup for a block directory entry at
		 * the beginning of file.
		 */</comment>
		<expr_stmt><expr><name><name>bufferedRead</name><operator>-&gt;</operator><name>fileOff</name></name> <operator>=</operator> <name>beginFileOffset</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>bufferedRead</name><operator>-&gt;</operator><name>bufferOffset</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

		<expr_stmt><expr><name>remainingFileLen</name> <operator>=</operator> <name>afterFileOffset</name> <operator>-</operator> <name>beginFileOffset</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>remainingFileLen</name> <operator>&gt;</operator> <name><name>bufferedRead</name><operator>-&gt;</operator><name>maxLargeReadLen</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>bufferedRead</name><operator>-&gt;</operator><name>largeReadLen</name></name> <operator>=</operator> <name><name>bufferedRead</name><operator>-&gt;</operator><name>maxLargeReadLen</name></name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>bufferedRead</name><operator>-&gt;</operator><name>largeReadLen</name></name> <operator>=</operator> <operator>(</operator><name>int32</name><operator>)</operator> <name>remainingFileLen</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><name><name>bufferedRead</name><operator>-&gt;</operator><name>largeReadPosition</name></name> <operator>=</operator> <name>beginFileOffset</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>bufferedRead</name><operator>-&gt;</operator><name>largeReadLen</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>BufferedReadIo</name><argument_list>(<argument><expr><name>bufferedRead</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>bufferedRead</name><operator>-&gt;</operator><name>haveTemporaryLimitInEffect</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>bufferedRead</name><operator>-&gt;</operator><name>temporaryLimitFileLen</name></name> <operator>=</operator> <name>afterFileOffset</name></expr>;</expr_stmt>

</block_content>}</block></function>

<comment type="block">/*
 * Return the position of the next read in bytes.
 */</comment>
<function><type><name>int64</name></type>
<name>BufferedReadNextBufferPosition</name><parameter_list>(
							   <parameter><decl><type><name>BufferedRead</name> <modifier>*</modifier></type><name>bufferedRead</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>bufferedRead</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>bufferedRead</name><operator>-&gt;</operator><name>file</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Note that the bufferOffset can be negative when we are using the before
	 * buffer, but that is ok.  We should get an accurate next position.
	 */</comment>
	<return>return <expr><name><name>bufferedRead</name><operator>-&gt;</operator><name>largeReadPosition</name></name> <operator>+</operator>
		<name><name>bufferedRead</name><operator>-&gt;</operator><name>bufferOffset</name></name> <operator>+</operator>
		<name><name>bufferedRead</name><operator>-&gt;</operator><name>bufferLen</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Get the next buffer space for reading with a specified max read-ahead
 * amount.
 *
 * Returns NULL when the current file has been completely read.
 */</comment>
<function><type><name>uint8</name> <modifier>*</modifier></type>
<name>BufferedReadGetNextBuffer</name><parameter_list>(
						  <parameter><decl><type><name>BufferedRead</name> <modifier>*</modifier></type><name>bufferedRead</name></decl></parameter>,
						  <parameter><decl><type><name>int32</name></type> <name>maxReadAheadLen</name></decl></parameter>,
						  <parameter><decl><type><name>int32</name> <modifier>*</modifier></type><name>nextBufferLen</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int64</name></type>		<name>inEffectFileLen</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>bufferedRead</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>bufferedRead</name><operator>-&gt;</operator><name>file</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>maxReadAheadLen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nextBufferLen</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>maxReadAheadLen</name> <operator>&gt;</operator> <name><name>bufferedRead</name><operator>-&gt;</operator><name>maxBufferLen</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>maxReadAheadLen</name> <operator>&lt;=</operator> <name><name>bufferedRead</name><operator>-&gt;</operator><name>maxBufferLen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Read ahead length %d is greater than maximum buffer length %d"</literal></expr></argument>,
			 <argument><expr><name>maxReadAheadLen</name></expr></argument>, <argument><expr><name><name>bufferedRead</name><operator>-&gt;</operator><name>maxBufferLen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>bufferedRead</name><operator>-&gt;</operator><name>haveTemporaryLimitInEffect</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>inEffectFileLen</name> <operator>=</operator> <name><name>bufferedRead</name><operator>-&gt;</operator><name>temporaryLimitFileLen</name></name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>inEffectFileLen</name> <operator>=</operator> <name><name>bufferedRead</name><operator>-&gt;</operator><name>fileLen</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * Finish previous buffer.
	 */</comment>
	<expr_stmt><expr><name><name>bufferedRead</name><operator>-&gt;</operator><name>bufferOffset</name></name> <operator>+=</operator> <name><name>bufferedRead</name><operator>-&gt;</operator><name>bufferLen</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>bufferedRead</name><operator>-&gt;</operator><name>bufferLen</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>bufferedRead</name><operator>-&gt;</operator><name>largeReadPosition</name></name> <operator>==</operator> <name>inEffectFileLen</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * At end of file.
		 */</comment>
		<expr_stmt><expr><operator>*</operator><name>nextBufferLen</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>bufferedRead</name><operator>-&gt;</operator><name>haveTemporaryLimitInEffect</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Any more left in current read?
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>bufferedRead</name><operator>-&gt;</operator><name>bufferOffset</name></name> <operator>==</operator> <name><name>bufferedRead</name><operator>-&gt;</operator><name>largeReadLen</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int64</name></type>		<name>remainingFileLen</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Used exactly all of it.  Attempt read more.
		 */</comment>
		<expr_stmt><expr><name><name>bufferedRead</name><operator>-&gt;</operator><name>largeReadPosition</name></name> <operator>+=</operator> <name><name>bufferedRead</name><operator>-&gt;</operator><name>largeReadLen</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>bufferedRead</name><operator>-&gt;</operator><name>bufferOffset</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

		<expr_stmt><expr><name>remainingFileLen</name> <operator>=</operator> <name>inEffectFileLen</name> <operator>-</operator>
			<name><name>bufferedRead</name><operator>-&gt;</operator><name>largeReadPosition</name></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>remainingFileLen</name> <operator>&gt;</operator> <name><name>bufferedRead</name><operator>-&gt;</operator><name>maxLargeReadLen</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>bufferedRead</name><operator>-&gt;</operator><name>largeReadLen</name></name> <operator>=</operator> <name><name>bufferedRead</name><operator>-&gt;</operator><name>maxLargeReadLen</name></name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>bufferedRead</name><operator>-&gt;</operator><name>largeReadLen</name></name> <operator>=</operator> <operator>(</operator><name>int32</name><operator>)</operator> <name>remainingFileLen</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>bufferedRead</name><operator>-&gt;</operator><name>largeReadLen</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * At end of file.
			 */</comment>
			<expr_stmt><expr><operator>*</operator><name>nextBufferLen</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>bufferedRead</name><operator>-&gt;</operator><name>haveTemporaryLimitInEffect</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>BufferedReadIo</name><argument_list>(<argument><expr><name>bufferedRead</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>maxReadAheadLen</name> <operator>&gt;</operator> <name><name>bufferedRead</name><operator>-&gt;</operator><name>largeReadLen</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>bufferedRead</name><operator>-&gt;</operator><name>bufferLen</name></name> <operator>=</operator> <name><name>bufferedRead</name><operator>-&gt;</operator><name>largeReadLen</name></name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>bufferedRead</name><operator>-&gt;</operator><name>bufferLen</name></name> <operator>=</operator> <name>maxReadAheadLen</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>bufferedRead</name><operator>-&gt;</operator><name>bufferOffset</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>bufferedRead</name><operator>-&gt;</operator><name>bufferLen</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><operator>*</operator><name>nextBufferLen</name> <operator>=</operator> <name><name>bufferedRead</name><operator>-&gt;</operator><name>bufferLen</name></name></expr>;</expr_stmt>
		<return>return <expr><name><name>bufferedRead</name><operator>-&gt;</operator><name>largeReadMemory</name></name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>bufferedRead</name><operator>-&gt;</operator><name>bufferOffset</name></name> <operator>+</operator> <name>maxReadAheadLen</name> <operator>&gt;</operator> <name><name>bufferedRead</name><operator>-&gt;</operator><name>largeReadLen</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Odd boundary.  Use before memory to carry us over.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>bufferedRead</name><operator>-&gt;</operator><name>largeReadLen</name></name> <operator>-</operator> <name><name>bufferedRead</name><operator>-&gt;</operator><name>bufferOffset</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return <expr><call><name>BufferedReadUseBeforeBuffer</name><argument_list>(
										   <argument><expr><name>bufferedRead</name></expr></argument>,
										   <argument><expr><name>maxReadAheadLen</name></expr></argument>,
										   <argument><expr><name>nextBufferLen</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * We can satisify request from current read.
	 */</comment>
	<expr_stmt><expr><name><name>bufferedRead</name><operator>-&gt;</operator><name>bufferLen</name></name> <operator>=</operator> <name>maxReadAheadLen</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>bufferedRead</name><operator>-&gt;</operator><name>bufferLen</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>nextBufferLen</name> <operator>=</operator> <name><name>bufferedRead</name><operator>-&gt;</operator><name>bufferLen</name></name></expr>;</expr_stmt>
	<return>return <expr><operator>&amp;</operator><name><name>bufferedRead</name><operator>-&gt;</operator><name>largeReadMemory</name><index>[<expr><name><name>bufferedRead</name><operator>-&gt;</operator><name>bufferOffset</name></name></expr>]</index></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Grow the available length of the current buffer.
 *
 * NOTE: The buffer address returned can be different, even for previously
 * examined buffer data.  In other words, don't keep buffer pointers in
 * the buffer region.  Use offsets to re-establish pointers after this call.
 *
 * If the current file has been completely read, bufferLen will remain
 * the current value.
 */</comment>
<function><type><name>uint8</name> <modifier>*</modifier></type>
<name>BufferedReadGrowBuffer</name><parameter_list>(
					   <parameter><decl><type><name>BufferedRead</name> <modifier>*</modifier></type><name>bufferedRead</name></decl></parameter>,
					   <parameter><decl><type><name>int32</name></type> <name>newMaxReadAheadLen</name></decl></parameter>,
					   <parameter><decl><type><name>int32</name> <modifier>*</modifier></type><name>growBufferLen</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int32</name></type>		<name>newNextOffset</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>bufferedRead</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>bufferedRead</name><operator>-&gt;</operator><name>file</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>newMaxReadAheadLen</name> <operator>&gt;</operator> <name><name>bufferedRead</name><operator>-&gt;</operator><name>bufferLen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>newMaxReadAheadLen</name> <operator>&lt;=</operator> <name><name>bufferedRead</name><operator>-&gt;</operator><name>maxBufferLen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>growBufferLen</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>newNextOffset</name> <operator>=</operator> <name><name>bufferedRead</name><operator>-&gt;</operator><name>bufferOffset</name></name> <operator>+</operator> <name>newMaxReadAheadLen</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>newNextOffset</name> <operator>&gt;</operator> <name><name>bufferedRead</name><operator>-&gt;</operator><name>largeReadLen</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Odd boundary.  Use before memory to carry us over.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>bufferedRead</name><operator>-&gt;</operator><name>largeReadLen</name></name> <operator>-</operator> <name><name>bufferedRead</name><operator>-&gt;</operator><name>bufferOffset</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return <expr><call><name>BufferedReadUseBeforeBuffer</name><argument_list>(
										   <argument><expr><name>bufferedRead</name></expr></argument>,
										   <argument><expr><name>newMaxReadAheadLen</name></expr></argument>,
										   <argument><expr><name>growBufferLen</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * There is maxReadAheadLen more left in current large-read memory.
	 */</comment>
	<expr_stmt><expr><name><name>bufferedRead</name><operator>-&gt;</operator><name>bufferLen</name></name> <operator>=</operator> <name>newMaxReadAheadLen</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>bufferedRead</name><operator>-&gt;</operator><name>bufferLen</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>growBufferLen</name> <operator>=</operator> <name><name>bufferedRead</name><operator>-&gt;</operator><name>bufferLen</name></name></expr>;</expr_stmt>
	<return>return <expr><operator>&amp;</operator><name><name>bufferedRead</name><operator>-&gt;</operator><name>largeReadMemory</name><index>[<expr><name><name>bufferedRead</name><operator>-&gt;</operator><name>bufferOffset</name></name></expr>]</index></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Return the address of the current read buffer.
 */</comment>
<function><type><name>uint8</name> <modifier>*</modifier></type>
<name>BufferedReadGetCurrentBuffer</name><parameter_list>(
							 <parameter><decl><type><name>BufferedRead</name> <modifier>*</modifier></type><name>bufferedRead</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>bufferedRead</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>bufferedRead</name><operator>-&gt;</operator><name>file</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><operator>&amp;</operator><name><name>bufferedRead</name><operator>-&gt;</operator><name>largeReadMemory</name><index>[<expr><name><name>bufferedRead</name><operator>-&gt;</operator><name>bufferOffset</name></name></expr>]</index></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Return the current buffer's start position.
 */</comment>
<function><type><name>int64</name></type>
<name>BufferedReadCurrentPosition</name><parameter_list>(
							<parameter><decl><type><name>BufferedRead</name> <modifier>*</modifier></type><name>bufferedRead</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>bufferedRead</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>bufferedRead</name><operator>-&gt;</operator><name>file</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>bufferedRead</name><operator>-&gt;</operator><name>largeReadPosition</name></name> <operator>+</operator> <name><name>bufferedRead</name><operator>-&gt;</operator><name>bufferOffset</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Flushes the current file for append.  Caller is responsible for closing
 * the file afterwards.
 */</comment>
<function><type><name>void</name></type>
<name>BufferedReadCompleteFile</name><parameter_list>(
						 <parameter><decl><type><name>BufferedRead</name> <modifier>*</modifier></type><name>bufferedRead</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>bufferedRead</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>bufferedRead</name><operator>-&gt;</operator><name>file</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>bufferedRead</name><operator>-&gt;</operator><name>file</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>bufferedRead</name><operator>-&gt;</operator><name>filePathName</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>bufferedRead</name><operator>-&gt;</operator><name>fileLen</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>bufferedRead</name><operator>-&gt;</operator><name>bufferOffset</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>bufferedRead</name><operator>-&gt;</operator><name>bufferLen</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>bufferedRead</name><operator>-&gt;</operator><name>largeReadPosition</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>bufferedRead</name><operator>-&gt;</operator><name>largeReadLen</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Finish with reading all together.
 */</comment>
<function><type><name>void</name></type>
<name>BufferedReadFinish</name><parameter_list>(<parameter><decl><type><name>BufferedRead</name> <modifier>*</modifier></type><name>bufferedRead</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>bufferedRead</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Assert(bufferedRead-&gt;file == -1); */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>bufferedRead</name><operator>-&gt;</operator><name>fileLen</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>bufferedRead</name><operator>-&gt;</operator><name>bufferOffset</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>bufferedRead</name><operator>-&gt;</operator><name>bufferLen</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>bufferedRead</name><operator>-&gt;</operator><name>memory</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>bufferedRead</name><operator>-&gt;</operator><name>memory</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>bufferedRead</name><operator>-&gt;</operator><name>memory</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>bufferedRead</name><operator>-&gt;</operator><name>memoryLen</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>bufferedRead</name><operator>-&gt;</operator><name>relationName</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>bufferedRead</name><operator>-&gt;</operator><name>relationName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>bufferedRead</name><operator>-&gt;</operator><name>relationName</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>
</unit>
