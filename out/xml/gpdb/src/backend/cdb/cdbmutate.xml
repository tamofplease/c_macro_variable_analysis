<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/backend/cdb/cdbmutate.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * cdbmutate.c
 *	  Parallelize a PostgreSQL sequential plan tree.
 *
 * Portions Copyright (c) 2004-2008, Greenplum inc
 * Portions Copyright (c) 2012-Present VMware, Inc. or its affiliates.
 *
 *
 * IDENTIFICATION
 *	    src/backend/cdb/cdbmutate.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/relation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parsetree.h"</cpp:file></cpp:include>	<comment type="block">/* for rt_fetch() */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/planmain.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_relation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/fmgroids.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/guc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/datum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/clauses.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/optimizer.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/pathnode.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/tablecmds.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/tablespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/trigger.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_operator.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_proc.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbhash.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbllize.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbmutate.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbplan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbpullup.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbvars.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbutil.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbtargeteddispatch.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/executor.h"</cpp:file></cpp:include>

<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>plan_tree_base_prefix</name></type> <name>base</name></decl>;</decl_stmt> <comment type="block">/* Required prefix for
								 * plan_tree_walker/mutator */</comment>
	<decl_stmt><decl><type><name>EState</name>	   <modifier>*</modifier></type><name>estate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>single_row_insert</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>cursorPositions</name></decl>;</decl_stmt>
}</block></struct></type> <name>pre_dispatch_function_evaluation_context</name>;</typedef>

<comment type="block">/*
 * Forward Declarations
 */</comment>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>pre_dispatch_function_evaluation_mutator</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
										 <parameter><decl><type><name>pre_dispatch_function_evaluation_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>replace_shareinput_targetlists_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>fPop</name></decl></parameter>)</parameter_list>;</function_decl>


<function><type><name>Motion</name> <modifier>*</modifier></type>
<name>make_union_motion</name><parameter_list>(<parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>lefttree</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Motion</name>	   <modifier>*</modifier></type><name>motion</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>motion</name> <operator>=</operator> <call><name>make_motion</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>lefttree</name></expr></argument>,
						 <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument> <comment type="block">/* no ordering */</comment>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>motion</name><operator>-&gt;</operator><name>motionType</name></name> <operator>=</operator> <name>MOTIONTYPE_GATHER</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>motion</name><operator>-&gt;</operator><name>hashExprs</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>motion</name><operator>-&gt;</operator><name>hashFuncs</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<return>return <expr><name>motion</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>Motion</name> <modifier>*</modifier></type>
<name>make_sorted_union_motion</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>lefttree</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>numSortCols</name></decl></parameter>,
						 <parameter><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>sortColIdx</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>sortOperators</name></decl></parameter>,
						 <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>collations</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>nullsFirst</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Motion</name>	   <modifier>*</modifier></type><name>motion</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>motion</name> <operator>=</operator> <call><name>make_motion</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>lefttree</name></expr></argument>,
						 <argument><expr><name>numSortCols</name></expr></argument>, <argument><expr><name>sortColIdx</name></expr></argument>, <argument><expr><name>sortOperators</name></expr></argument>, <argument><expr><name>collations</name></expr></argument>, <argument><expr><name>nullsFirst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>motion</name><operator>-&gt;</operator><name>motionType</name></name> <operator>=</operator> <name>MOTIONTYPE_GATHER</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>motion</name><operator>-&gt;</operator><name>hashExprs</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>motion</name><operator>-&gt;</operator><name>hashFuncs</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<return>return <expr><name>motion</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>Motion</name> <modifier>*</modifier></type>
<name>make_hashed_motion</name><parameter_list>(<parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>lefttree</name></decl></parameter>,
				   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>hashExprs</name></decl></parameter>,
				   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>hashOpfamilies</name></decl></parameter>,
				   <parameter><decl><type><name>int</name></type> <name>numHashSegments</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Motion</name>	   <modifier>*</modifier></type><name>motion</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name>		   <modifier>*</modifier></type><name>hashFuncs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>expr_cell</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>opf_cell</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>numHashSegments</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>hashExprs</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>hashOpfamilies</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Look up the right hash functions for the hash expressions */</comment>
	<expr_stmt><expr><name>hashFuncs</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>hashExprs</name></expr></argument>)</argument_list></call> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<macro><name>forboth</name><argument_list>(<argument>expr_cell</argument>, <argument>hashExprs</argument>, <argument>opf_cell</argument>, <argument>hashOpfamilies</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>expr</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>expr_cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>opfamily</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>opf_cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>typeoid</name> <init>= <expr><call><name>exprType</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>hashFuncs</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>cdb_hashproc_in_opfamily</name><argument_list>(<argument><expr><name>opfamily</name></expr></argument>, <argument><expr><name>typeoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><name>motion</name> <operator>=</operator> <call><name>make_motion</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>lefttree</name></expr></argument>,
						 <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument> <comment type="block">/* no ordering */</comment>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>motion</name><operator>-&gt;</operator><name>motionType</name></name> <operator>=</operator> <name>MOTIONTYPE_HASH</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>motion</name><operator>-&gt;</operator><name>hashExprs</name></name> <operator>=</operator> <name>hashExprs</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>motion</name><operator>-&gt;</operator><name>hashFuncs</name></name> <operator>=</operator> <name>hashFuncs</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>motion</name><operator>-&gt;</operator><name>numHashSegments</name></name> <operator>=</operator> <name>numHashSegments</name></expr>;</expr_stmt>

	<return>return <expr><name>motion</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>Motion</name> <modifier>*</modifier></type>
<name>make_broadcast_motion</name><parameter_list>(<parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>lefttree</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Motion</name>	   <modifier>*</modifier></type><name>motion</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>motion</name> <operator>=</operator> <call><name>make_motion</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>lefttree</name></expr></argument>,
						 <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument> <comment type="block">/* no ordering */</comment>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>motion</name><operator>-&gt;</operator><name>motionType</name></name> <operator>=</operator> <name>MOTIONTYPE_BROADCAST</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>motion</name><operator>-&gt;</operator><name>hashExprs</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>motion</name><operator>-&gt;</operator><name>hashFuncs</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<return>return <expr><name>motion</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>Plan</name> <modifier>*</modifier></type>
<name>make_explicit_motion</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>lefttree</name></decl></parameter>, <parameter><decl><type><name>AttrNumber</name></type> <name>segidColIdx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Motion</name>	   <modifier>*</modifier></type><name>motion</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>plan_tree_base_prefix</name></type> <name>base</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>base</name><operator>.</operator><name>node</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>root</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>segidColIdx</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>segidColIdx</name> <operator>&lt;=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>lefttree</name><operator>-&gt;</operator><name>targetlist</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>motion</name> <operator>=</operator> <call><name>make_motion</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>lefttree</name></expr></argument>,
						 <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument> <comment type="block">/* no ordering */</comment>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>motion</name><operator>-&gt;</operator><name>motionType</name></name> <operator>=</operator> <name>MOTIONTYPE_EXPLICIT</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>motion</name><operator>-&gt;</operator><name>hashExprs</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>motion</name><operator>-&gt;</operator><name>hashFuncs</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>motion</name><operator>-&gt;</operator><name>segidColIdx</name></name> <operator>=</operator> <name>segidColIdx</name></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <name>motion</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* --------------------------------------------------------------------
 *
 *	Static Helper routines
 * --------------------------------------------------------------------
 */</comment>

<comment type="block">/* ----------------------------------------------------------------
 * getExprListFromTargetList
 *
 * Creates a VAR that references the indicated entries from the target list,
 * sets the restype and restypmod fields from the target list info,
 * and puts them into a list.
 *
 * The AttrNumber indexes actually refer to the 1 based index into the
 * target list.
 *
 * The entries have the varno field replaced by references in OUTER_VAR.
 * ----------------------------------------------------------------
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>getExprListFromTargetList</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>,
						  <parameter><decl><type><name>int</name></type> <name>numCols</name></decl></parameter>,
						  <parameter><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>colIdx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>elist</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numCols</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<comment type="block">/* Find expr in TargetList */</comment>
		<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>n</name> <init>= <expr><name><name>colIdx</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>target</name> <init>= <expr><call><name>get_tle_by_resno</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>target</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"no tlist entry for key %d"</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>elist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>elist</name></expr></argument>, <argument><expr><call><name>copyObject</name><argument_list>(<argument><expr><name><name>target</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>elist</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------------- *
 * cdbmutate_warn_ctid_without_segid() warns the user if the plan refers to a
 * partitioned table's ctid column without also referencing its
 * gp_segment_id column.
 * ----------------------------------------------------------------------- *
 */</comment>
<typedef>typedef <type><struct>struct <name>ctid_inventory_context</name>
<block>{
	<decl_stmt><decl><type><name>plan_tree_base_prefix</name></type> <name>base</name></decl>;</decl_stmt> <comment type="block">/* Required prefix for
								 * plan_tree_walker/mutator */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>uses_ctid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>uses_segid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Index</name></type>		<name>relid</name></decl>;</decl_stmt>
}</block></struct></type> <name>ctid_inventory_context</name>;</typedef>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ctid_inventory_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>ctid_inventory_context</name> <modifier>*</modifier></type><name>inv</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>var</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
			<name><name>var</name><operator>-&gt;</operator><name>varno</name></name> <operator>==</operator> <name><name>inv</name><operator>-&gt;</operator><name>relid</name></name> <operator>&amp;&amp;</operator>
			<name><name>var</name><operator>-&gt;</operator><name>varlevelsup</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name> <operator>==</operator> <name>SelfItemPointerAttributeNumber</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>inv</name><operator>-&gt;</operator><name>uses_ctid</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name> <operator>==</operator> <name>GpSegmentIdAttributeNumber</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>inv</name><operator>-&gt;</operator><name>uses_segid</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><call><name>plan_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>ctid_inventory_walker</name></expr></argument>, <argument><expr><name>inv</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>cdbmutate_warn_ctid_without_segid</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>PlannerInfo</name></name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>RelOptInfo</name></name> <modifier>*</modifier></type><name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ctid_inventory_context</name></type> <name>inv</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relids</name></type>		<name>relids_to_ignore</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>attno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ndx</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>planner_init_plan_tree_base</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>inv</name><operator>.</operator><name>base</name></name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>inv</name><operator>.</operator><name>uses_ctid</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>inv</name><operator>.</operator><name>uses_segid</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>inv</name><operator>.</operator><name>relid</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>relid</name></name></expr>;</expr_stmt>

	<comment type="block">/* Rel not distributed?  Then segment id doesn't matter. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>rel</name><operator>-&gt;</operator><name>cdbpolicy</name></name> <operator>||</operator>
		<name><name>rel</name><operator>-&gt;</operator><name>cdbpolicy</name><operator>-&gt;</operator><name>ptype</name></name> <operator>==</operator> <name>POLICYTYPE_ENTRY</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Ignore references occurring in the Query's final output targetlist. */</comment>
	<expr_stmt><expr><name>relids_to_ignore</name> <operator>=</operator> <call><name>bms_make_singleton</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Is 'ctid' referenced in join quals? */</comment>
	<expr_stmt><expr><name>attno</name> <operator>=</operator> <name>SelfItemPointerAttributeNumber</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>attno</name> <operator>&gt;=</operator> <name><name>rel</name><operator>-&gt;</operator><name>min_attr</name></name> <operator>&amp;&amp;</operator> <name>attno</name> <operator>&lt;=</operator> <name><name>rel</name><operator>-&gt;</operator><name>max_attr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ndx</name> <operator>=</operator> <name>attno</name> <operator>-</operator> <name><name>rel</name><operator>-&gt;</operator><name>min_attr</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>bms_nonempty_difference</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>attr_needed</name><index>[<expr><name>ndx</name></expr>]</index></name></expr></argument>, <argument><expr><name>relids_to_ignore</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>inv</name><operator>.</operator><name>uses_ctid</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Is 'gp_segment_id' referenced in join quals? */</comment>
	<expr_stmt><expr><name>attno</name> <operator>=</operator> <name>GpSegmentIdAttributeNumber</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>attno</name> <operator>&gt;=</operator> <name><name>rel</name><operator>-&gt;</operator><name>min_attr</name></name> <operator>&amp;&amp;</operator> <name>attno</name> <operator>&lt;=</operator> <name><name>rel</name><operator>-&gt;</operator><name>max_attr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ndx</name> <operator>=</operator> <name>attno</name> <operator>-</operator> <name><name>rel</name><operator>-&gt;</operator><name>min_attr</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>bms_nonempty_difference</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>attr_needed</name><index>[<expr><name>ndx</name></expr>]</index></name></expr></argument>, <argument><expr><name>relids_to_ignore</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>inv</name><operator>.</operator><name>uses_segid</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Examine the single-table quals on this rel. */</comment>
	<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>rel-&gt;baserestrictinfo</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>rinfo</name> <init>= <expr><operator>(</operator><name>RestrictInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>rinfo</name></expr></argument>, <argument><expr><name>RestrictInfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ctid_inventory_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>rinfo</name><operator>-&gt;</operator><name>clause</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>inv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/* Notify client if found a reference to ctid only, without gp_segment_id */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>inv</name><operator>.</operator><name>uses_ctid</name></name> <operator>&amp;&amp;</operator>
		<operator>!</operator><name><name>inv</name><operator>.</operator><name>uses_segid</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><call><name>rt_fetch</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cmd</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>elevel</name></decl>;</decl_stmt>

		<comment type="block">/* Reject if UPDATE or DELETE.  Otherwise just give info msg. */</comment>
		<switch>switch <condition>(<expr><name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>commandType</name></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>CMD_UPDATE</name></expr>:</case>
				<expr_stmt><expr><name>cmd</name> <operator>=</operator> <literal type="string">"UPDATE"</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name>elevel</name> <operator>=</operator> <name>ERROR</name></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>CMD_DELETE</name></expr>:</case>
				<expr_stmt><expr><name>cmd</name> <operator>=</operator> <literal type="string">"DELETE"</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name>elevel</name> <operator>=</operator> <name>ERROR</name></expr>;</expr_stmt>
				<break>break;</break>

			<default>default:</default>
				<expr_stmt><expr><name>cmd</name> <operator>=</operator> <literal type="string">"SELECT"</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name>elevel</name> <operator>=</operator> <name>NOTICE</name></expr>;</expr_stmt>
		</block_content>}</block></switch>

		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s uses system-defined column \"%s.ctid\" without the necessary companion column \"%s.gp_segment_id\""</literal></expr></argument>,
						<argument><expr><name>cmd</name></expr></argument>, <argument><expr><name><name>rte</name><operator>-&gt;</operator><name>eref</name><operator>-&gt;</operator><name>aliasname</name></name></expr></argument>, <argument><expr><name><name>rte</name><operator>-&gt;</operator><name>eref</name><operator>-&gt;</operator><name>aliasname</name></name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"To uniquely identify a row within a distributed table, use the \"gp_segment_id\" column together with the \"ctid\" column."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>bms_free</name><argument_list>(<argument><expr><name>relids_to_ignore</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>								<comment type="block">/* cdbmutate_warn_ctid_without_segid */</comment>


<comment type="block">/*
 * Code that mutate the tree for share input
 *
 * After the planner, the plan is really a DAG.  SISCs will have valid
 * pointer to the underlying share.  However, other code (setrefs etc)
 * depends on the fact that the plan is a tree.  We first mutate the DAG
 * to a tree.
 *
 * Next, we will need to decide if the share is cross slices.  If the share
 * is not cross slice, we do not need the syncrhonization, and it is possible to
 * keep the Material/Sort in memory to save a sort.
 *
 * It is essential that we walk the tree in the same order as the ExecProcNode start
 * execution, otherwise, deadlock may rise.
 */</comment>

<comment type="block">/* Walk the tree for shareinput.
 * Shareinput fix shared_as_id and underlying_share_id of nodes in place.  We do not want to use
 * the ordinary tree walker as it is unnecessary to make copies etc.
 */</comment>
<typedef>typedef <function_decl><type><name>bool</name></type> (<modifier>*</modifier><name>SHAREINPUT_MUTATOR</name>) <parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>fPop</name></decl></parameter>)</parameter_list>;</function_decl></typedef>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>shareinput_walker</name><parameter_list>(<parameter><decl><type><name>SHAREINPUT_MUTATOR</name></type> <name>f</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>plan</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>recursive_down</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>List</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>l</name> <init>= <expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>l</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>n</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>shareinput_walker</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_plan_node</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>plan</name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>recursive_down</name> <operator>=</operator> <call>(<modifier>*</modifier><name>f</name>) <argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>recursive_down</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Append</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Append</name>	   <modifier>*</modifier></type><name>app</name> <init>= <expr><operator>(</operator><name>Append</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

			<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>app-&gt;appendplans</argument>)</argument_list></macro>
				<expr_stmt><expr><call><name>shareinput_walker</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>ModifyTable</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ModifyTable</name> <modifier>*</modifier></type><name>mt</name> <init>= <expr><operator>(</operator><name>ModifyTable</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

			<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>mt-&gt;plans</argument>)</argument_list></macro>
				<expr_stmt><expr><call><name>shareinput_walker</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>SubqueryScan</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>SubqueryScan</name>  <modifier>*</modifier></type><name>subqscan</name> <init>= <expr><operator>(</operator><name>SubqueryScan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>PlannerGlobal</name> <modifier>*</modifier></type><name>glob</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>glob</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>PlannerInfo</name>   <modifier>*</modifier></type><name>subroot</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>List</name>	      <modifier>*</modifier></type><name>save_rtable</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>RelOptInfo</name>    <modifier>*</modifier></type><name>rel</name></decl>;</decl_stmt>

			<comment type="block">/*
			 * If glob-&gt;finalrtable is not NULL, rtables have been flatten,
			 * thus we should use glob-&gt;finalrtable instead.
			 */</comment>
			<expr_stmt><expr><name>save_rtable</name> <operator>=</operator> <name><name>glob</name><operator>-&gt;</operator><name>share</name><operator>.</operator><name>curr_rtable</name></name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>root</name><operator>-&gt;</operator><name>glob</name><operator>-&gt;</operator><name>finalrtable</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>find_base_rel</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>subqscan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>scanrelid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/*
				 * The Assert() on RelOptInfo's subplan being
				 * same as the subqueryscan's subplan, is valid
				 * in Upstream but for not for GPDB, since we
				 * create a new copy of the subplan if two
				 * SubPlans refer to the same initplan.
				 */</comment>
				<expr_stmt><expr><name>subroot</name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>subroot</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>glob</name><operator>-&gt;</operator><name>share</name><operator>.</operator><name>curr_rtable</name></name> <operator>=</operator> <name><name>subroot</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>rtable</name></name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><name>subroot</name> <operator>=</operator> <name>root</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>glob</name><operator>-&gt;</operator><name>share</name><operator>.</operator><name>curr_rtable</name></name> <operator>=</operator> <name><name>glob</name><operator>-&gt;</operator><name>finalrtable</name></name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
			<expr_stmt><expr><call><name>shareinput_walker</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>subqscan</name><operator>-&gt;</operator><name>subplan</name></name></expr></argument>, <argument><expr><name>subroot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>glob</name><operator>-&gt;</operator><name>share</name><operator>.</operator><name>curr_rtable</name></name> <operator>=</operator> <name>save_rtable</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>TableFunctionScan</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>TableFunctionScan</name>  <modifier>*</modifier></type><name>tfscan</name> <init>= <expr><operator>(</operator><name>TableFunctionScan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>PlannerGlobal</name> <modifier>*</modifier></type><name>glob</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>glob</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>PlannerInfo</name>   <modifier>*</modifier></type><name>subroot</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>List</name>	      <modifier>*</modifier></type><name>save_rtable</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>RelOptInfo</name>    <modifier>*</modifier></type><name>rel</name></decl>;</decl_stmt>

			<comment type="block">/*
			 * If glob-&gt;finalrtable is not NULL, rtables have been flatten,
			 * thus we should use glob-&gt;finalrtable instead.
			 */</comment>
			<expr_stmt><expr><name>save_rtable</name> <operator>=</operator> <name><name>glob</name><operator>-&gt;</operator><name>share</name><operator>.</operator><name>curr_rtable</name></name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>root</name><operator>-&gt;</operator><name>glob</name><operator>-&gt;</operator><name>finalrtable</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>find_base_rel</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>tfscan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>scanrelid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>subroot</name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>subroot</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>glob</name><operator>-&gt;</operator><name>share</name><operator>.</operator><name>curr_rtable</name></name> <operator>=</operator> <name><name>subroot</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>rtable</name></name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><name>subroot</name> <operator>=</operator> <name>root</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>glob</name><operator>-&gt;</operator><name>share</name><operator>.</operator><name>curr_rtable</name></name> <operator>=</operator> <name><name>glob</name><operator>-&gt;</operator><name>finalrtable</name></name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
			<expr_stmt><expr><call><name>shareinput_walker</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator>  <name><name>tfscan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>lefttree</name></name></expr></argument>, <argument><expr><name>subroot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>glob</name><operator>-&gt;</operator><name>share</name><operator>.</operator><name>curr_rtable</name></name> <operator>=</operator> <name>save_rtable</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>BitmapAnd</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>BitmapAnd</name>  <modifier>*</modifier></type><name>ba</name> <init>= <expr><operator>(</operator><name>BitmapAnd</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

			<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>ba-&gt;bitmapplans</argument>)</argument_list></macro>
				<expr_stmt><expr><call><name>shareinput_walker</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>BitmapOr</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>BitmapOr</name>   <modifier>*</modifier></type><name>bo</name> <init>= <expr><operator>(</operator><name>BitmapOr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

			<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>bo-&gt;bitmapplans</argument>)</argument_list></macro>
				<expr_stmt><expr><call><name>shareinput_walker</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>NestLoop</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Nest loop join is strange.  Exec order depends on
			 * prefetch_inner
			 */</comment>
			<decl_stmt><decl><type><name>NestLoop</name>   <modifier>*</modifier></type><name>nl</name> <init>= <expr><operator>(</operator><name>NestLoop</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>nl</name><operator>-&gt;</operator><name>join</name><operator>.</operator><name>prefetch_inner</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>shareinput_walker</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>plan</name><operator>-&gt;</operator><name>righttree</name></name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>shareinput_walker</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>plan</name><operator>-&gt;</operator><name>lefttree</name></name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><call><name>shareinput_walker</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>plan</name><operator>-&gt;</operator><name>lefttree</name></name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>shareinput_walker</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>plan</name><operator>-&gt;</operator><name>righttree</name></name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>HashJoin</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Hash join the hash table is at inner */</comment>
			<expr_stmt><expr><call><name>shareinput_walker</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>plan</name><operator>-&gt;</operator><name>righttree</name></name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>shareinput_walker</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>plan</name><operator>-&gt;</operator><name>lefttree</name></name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>MergeJoin</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>MergeJoin</name>  <modifier>*</modifier></type><name>mj</name> <init>= <expr><operator>(</operator><name>MergeJoin</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>mj</name><operator>-&gt;</operator><name>unique_outer</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>shareinput_walker</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>plan</name><operator>-&gt;</operator><name>lefttree</name></name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>shareinput_walker</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>plan</name><operator>-&gt;</operator><name>righttree</name></name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><call><name>shareinput_walker</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>plan</name><operator>-&gt;</operator><name>righttree</name></name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>shareinput_walker</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>plan</name><operator>-&gt;</operator><name>lefttree</name></name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Sequence</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Sequence</name>   <modifier>*</modifier></type><name>sequence</name> <init>= <expr><operator>(</operator><name>Sequence</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

			<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>sequence-&gt;subplans</argument>)</argument_list></macro>
			<block>{<block_content>
				<expr_stmt><expr><call><name>shareinput_walker</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>shareinput_walker</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>plan</name><operator>-&gt;</operator><name>lefttree</name></name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>shareinput_walker</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>plan</name><operator>-&gt;</operator><name>righttree</name></name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>shareinput_walker</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>plan</name><operator>-&gt;</operator><name>initPlan</name></name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call>(<modifier>*</modifier><name>f</name>) <argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Create a fake CTE range table entry that reflects the target list of a
 * shared input.
 */</comment>
<function><type><specifier>static</specifier> <name>RangeTblEntry</name> <modifier>*</modifier></type>
<name>create_shareinput_producer_rte</name><parameter_list>(<parameter><decl><type><name>ApplyShareInputContext</name> <modifier>*</modifier></type><name>ctxt</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>share_id</name></decl></parameter>,
							   <parameter><decl><type><name>int</name></type> <name>refno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>attno</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>subplan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>buf</name><index>[<expr><literal type="number">100</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>colnames</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>coltypes</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>coltypmods</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>colcollations</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>ctxt</name><operator>-&gt;</operator><name>shared_plans</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>ctxt</name><operator>-&gt;</operator><name>shared_input_count</name></name> <operator>&gt;</operator> <name>share_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>subplan</name> <operator>=</operator> <name><name>ctxt</name><operator>-&gt;</operator><name>shared_plans</name><index>[<expr><name>share_id</name></expr>]</index></name></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>subplan-&gt;targetlist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>vartype</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int32</name></type>		<name>vartypmod</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>varcollid</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>resname</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>vartype</name> <operator>=</operator> <call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>vartypmod</name> <operator>=</operator> <call><name>exprTypmod</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>varcollid</name> <operator>=</operator> <call><name>exprCollation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * We should've filled in tle-&gt;resname in shareinput_save_producer().
		 * Note that it's too late to call get_tle_name() here, because this
		 * runs after all the varnos in Vars have already been changed to
		 * INNER_VAR/OUTER_VAR.
		 */</comment>
		<expr_stmt><expr><name>resname</name> <operator>=</operator> <name><name>tle</name><operator>-&gt;</operator><name>resname</name></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>resname</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>resname</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><literal type="string">"unnamed_attr"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>colnames</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>colnames</name></expr></argument>, <argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name>resname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>coltypes</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>coltypes</name></expr></argument>, <argument><expr><name>vartype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>coltypmods</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>coltypmods</name></expr></argument>, <argument><expr><name>vartypmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>colcollations</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>colcollations</name></expr></argument>, <argument><expr><name>varcollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>attno</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * Create a new RTE. Note that we use a different RTE for each reference,
	 * because we want to give each reference a different name.
	 */</comment>
	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"share%d_ref%d"</literal></expr></argument>, <argument><expr><name>share_id</name></expr></argument>, <argument><expr><name>refno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>RangeTblEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>=</operator> <name>RTE_CTE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>ctename</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>ctelevelsup</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>self_reference</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>alias</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>eref</name></name> <operator>=</operator> <call><name>makeAlias</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>ctename</name></name></expr></argument>, <argument><expr><name>colnames</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>coltypes</name></name> <operator>=</operator> <name>coltypes</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>coltypmods</name></name> <operator>=</operator> <name>coltypmods</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>colcollations</name></name> <operator>=</operator> <name>colcollations</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>inh</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>inFromCl</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>requiredPerms</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>checkAsUser</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>

	<return>return <expr><name>rte</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Memorize the shared plan of a shared input in an array, one per share_id.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>shareinput_save_producer</name><parameter_list>(<parameter><decl><type><name>ShareInputScan</name> <modifier>*</modifier></type><name>plan</name></decl></parameter>, <parameter><decl><type><name>ApplyShareInputContext</name> <modifier>*</modifier></type><name>ctxt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>share_id</name> <init>= <expr><name><name>plan</name><operator>-&gt;</operator><name>share_id</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>new_shared_input_count</name> <init>= <expr><operator>(</operator><name>share_id</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>plan</name><operator>-&gt;</operator><name>share_id</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>ctxt</name><operator>-&gt;</operator><name>shared_plans</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>ctxt</name><operator>-&gt;</operator><name>shared_plans</name></name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Plan</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>new_shared_input_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ctxt</name><operator>-&gt;</operator><name>shared_input_count</name></name> <operator>=</operator> <name>new_shared_input_count</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>ctxt</name><operator>-&gt;</operator><name>shared_input_count</name></name> <operator>&lt;</operator> <name>new_shared_input_count</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>ctxt</name><operator>-&gt;</operator><name>shared_plans</name></name> <operator>=</operator> <call><name>repalloc</name><argument_list>(<argument><expr><name><name>ctxt</name><operator>-&gt;</operator><name>shared_plans</name></name></expr></argument>, <argument><expr><name>new_shared_input_count</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Plan</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctxt</name><operator>-&gt;</operator><name>shared_plans</name><index>[<expr><name><name>ctxt</name><operator>-&gt;</operator><name>shared_input_count</name></name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>new_shared_input_count</name> <operator>-</operator> <name><name>ctxt</name><operator>-&gt;</operator><name>shared_input_count</name></name><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Plan</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ctxt</name><operator>-&gt;</operator><name>shared_input_count</name></name> <operator>=</operator> <name>new_shared_input_count</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>ctxt</name><operator>-&gt;</operator><name>shared_plans</name><index>[<expr><name>share_id</name></expr>]</index></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctxt</name><operator>-&gt;</operator><name>shared_plans</name><index>[<expr><name>share_id</name></expr>]</index></name> <operator>=</operator> <name><name>plan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>lefttree</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * When a plan comes out of the planner, all the ShareInputScan nodes belonging
 * to the same "share" have the same child node. apply_shareinput_dag_to_tree()
 * turns the DAG into a proper tree. The first occurrence of a ShareInput scan,
 * with a particular child tree, becomes the "producer" of the share, and the
 * others becomes consumers. The subtree is removed from all the consumer nodes.
 *
 * Also, a share_id is assigned to each ShareInputScan node, as well as the
 * Material/Sort nodes below the producers. The producers and its consumers
 * are linked together by the same share_id.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>shareinput_mutator_dag_to_tree</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>fPop</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PlannerGlobal</name> <modifier>*</modifier></type><name>glob</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>glob</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ApplyShareInputContext</name> <modifier>*</modifier></type><name>ctxt</name> <init>= <expr><operator>&amp;</operator><name><name>glob</name><operator>-&gt;</operator><name>share</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>plan</name> <init>= <expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>fPop</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><name>ShareInputScan</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ShareInputScan</name> <modifier>*</modifier></type><name>siscan</name> <init>= <expr><operator>(</operator><name>ShareInputScan</name> <operator>*</operator><operator>)</operator> <name>plan</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>subplan</name> <init>= <expr><name><name>plan</name><operator>-&gt;</operator><name>lefttree</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>share_id</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>attno</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

		<comment type="block">/* on entry, all ShareInputScans should have a child */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>subplan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Is there a producer for this sub-tree already? */</comment>
		<for>for <control>(<init><expr><name>share_id</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>share_id</name> <operator>&lt;</operator> <name><name>ctxt</name><operator>-&gt;</operator><name>shared_input_count</name></name></expr>;</condition> <incr><expr><name>share_id</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>ctxt</name><operator>-&gt;</operator><name>shared_plans</name><index>[<expr><name>share_id</name></expr>]</index></name> <operator>==</operator> <name>subplan</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * Yes. This is a consumer. Remove the subtree, and assign the
				 * same share_id as the producer.
				 */</comment>
				<expr_stmt><expr><name><name>siscan</name><operator>-&gt;</operator><name>share_id</name></name> <operator>=</operator> <name>share_id</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>siscan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>lefttree</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
				<return>return <expr><name>false</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>

		<comment type="block">/*
		 * Couldn't find a match in existing list of producers, so this is a
		 * producer. Add this to the list of producers, and assign a new
		 * share_id.
		 */</comment>
		<expr_stmt><expr><name><name>siscan</name><operator>-&gt;</operator><name>share_id</name></name> <operator>=</operator> <name>share_id</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>shareinput_save_producer</name><argument_list>(<argument><expr><name>siscan</name></expr></argument>, <argument><expr><name>ctxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Also make sure that all the entries in the subplan's target list
		 * have human-readable column names. They are used for EXPLAIN.
		 */</comment>
		<expr_stmt><expr><name>attno</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>subplan-&gt;targetlist</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>tle</name><operator>-&gt;</operator><name>resname</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>char</name></type>		<name><name>default_name</name><index>[<expr><literal type="number">100</literal></expr>]</index></name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>resname</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>default_name</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>default_name</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"col_%d"</literal></expr></argument>, <argument><expr><name>attno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>resname</name> <operator>=</operator> <call><name>strVal</name><argument_list>(<argument><expr><call><name>get_tle_name</name><argument_list>(<argument><expr><name>tle</name></expr></argument>, <argument><expr><name><name>ctxt</name><operator>-&gt;</operator><name>curr_rtable</name></name></expr></argument>, <argument><expr><name>default_name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>tle</name><operator>-&gt;</operator><name>resname</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>resname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>attno</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>Plan</name> <modifier>*</modifier></type>
<name>apply_shareinput_dag_to_tree</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>plan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PlannerGlobal</name> <modifier>*</modifier></type><name>glob</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>glob</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>glob</name><operator>-&gt;</operator><name>share</name><operator>.</operator><name>curr_rtable</name></name> <operator>=</operator> <name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>rtable</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>shareinput_walker</name><argument_list>(<argument><expr><name>shareinput_mutator_dag_to_tree</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>plan</name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>plan</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Collect all the producer ShareInput nodes into an array, for later use by
 * replace_shareinput_targetlists().
 *
 * This is a stripped-down version of apply_shareinput_dag_to_tree(), for use
 * on ORCA-produced plans. ORCA assigns share_ids to all ShareInputScan nodes,
 * and only producer nodes have a subtree, so we don't need to do the DAG to
 * tree conversion or assign share_ids here.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>collect_shareinput_producers_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>fPop</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PlannerGlobal</name> <modifier>*</modifier></type><name>glob</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>glob</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ApplyShareInputContext</name> <modifier>*</modifier></type><name>ctxt</name> <init>= <expr><operator>&amp;</operator><name><name>glob</name><operator>-&gt;</operator><name>share</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>fPop</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>ShareInputScan</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ShareInputScan</name> <modifier>*</modifier></type><name>siscan</name> <init>= <expr><operator>(</operator><name>ShareInputScan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>subplan</name> <init>= <expr><name><name>siscan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>lefttree</name></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>siscan</name><operator>-&gt;</operator><name>share_id</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>subplan</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>shareinput_save_producer</name><argument_list>(<argument><expr><name>siscan</name></expr></argument>, <argument><expr><name>ctxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>collect_shareinput_producers</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>plan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PlannerGlobal</name> <modifier>*</modifier></type><name>glob</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>glob</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>glob</name><operator>-&gt;</operator><name>share</name><operator>.</operator><name>curr_rtable</name></name> <operator>=</operator> <name><name>glob</name><operator>-&gt;</operator><name>finalrtable</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>shareinput_walker</name><argument_list>(<argument><expr><name>collect_shareinput_producers_walker</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>plan</name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Some helper: implements a stack using List. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>shareinput_pushmot</name><parameter_list>(<parameter><decl><type><name>ApplyShareInputContext</name> <modifier>*</modifier></type><name>ctxt</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>motid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>ctxt</name><operator>-&gt;</operator><name>motStack</name></name> <operator>=</operator> <call><name>lcons_int</name><argument_list>(<argument><expr><name>motid</name></expr></argument>, <argument><expr><name><name>ctxt</name><operator>-&gt;</operator><name>motStack</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>shareinput_popmot</name><parameter_list>(<parameter><decl><type><name>ApplyShareInputContext</name> <modifier>*</modifier></type><name>ctxt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>list_delete_first</name><argument_list>(<argument><expr><name><name>ctxt</name><operator>-&gt;</operator><name>motStack</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>shareinput_peekmot</name><parameter_list>(<parameter><decl><type><name>ApplyShareInputContext</name> <modifier>*</modifier></type><name>ctxt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>linitial_int</name><argument_list>(<argument><expr><name><name>ctxt</name><operator>-&gt;</operator><name>motStack</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Replace the target list of ShareInputScan nodes, with references
 * to CTEs that we build on the fly.
 *
 * Only one of the ShareInputScan nodes in a plan tree contains the real
 * child plan, while others contain just a "share id" that binds all the
 * ShareInputScan nodes sharing the same input together. The missing
 * child plan is a problem for EXPLAIN, as any OUTER Vars in the
 * ShareInputScan's target list cannot be resolved without the child
 * plan.
 *
 * To work around that issue, create a CTE for each shared input node, with
 * columns that match the target list of the SharedInputScan's subplan,
 * and replace the target list entries of the SharedInputScan with
 * Vars that point to the CTE instead of the child plan.
 */</comment>
<function><type><name>Plan</name> <modifier>*</modifier></type>
<name>replace_shareinput_targetlists</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>plan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>shareinput_walker</name><argument_list>(<argument><expr><name>replace_shareinput_targetlists_walker</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>plan</name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>plan</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>replace_shareinput_targetlists_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>fPop</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PlannerGlobal</name> <modifier>*</modifier></type><name>glob</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>glob</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ApplyShareInputContext</name> <modifier>*</modifier></type><name>ctxt</name> <init>= <expr><operator>&amp;</operator><name><name>glob</name><operator>-&gt;</operator><name>share</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>fPop</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>ShareInputScan</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ShareInputScan</name> <modifier>*</modifier></type><name>sisc</name> <init>= <expr><operator>(</operator><name>ShareInputScan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>share_id</name> <init>= <expr><name><name>sisc</name><operator>-&gt;</operator><name>share_id</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>attno</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>newtargetlist</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Note that even though the planner assigns sequential share_ids for
		 * each shared node, so that share_id is always below
		 * list_length(ctxt-&gt;sharedNodes), ORCA has a different assignment
		 * scheme. So we have to be prepared for any share_id, at least when
		 * ORCA is in use.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>ctxt</name><operator>-&gt;</operator><name>share_refcounts</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>new_sz</name> <init>= <expr><name>share_id</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>ctxt</name><operator>-&gt;</operator><name>share_refcounts</name></name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>new_sz</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>ctxt</name><operator>-&gt;</operator><name>share_refcounts_sz</name></name> <operator>=</operator> <name>new_sz</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>share_id</name> <operator>&gt;=</operator> <name><name>ctxt</name><operator>-&gt;</operator><name>share_refcounts_sz</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>old_sz</name> <init>= <expr><name><name>ctxt</name><operator>-&gt;</operator><name>share_refcounts_sz</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>new_sz</name> <init>= <expr><name>share_id</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>ctxt</name><operator>-&gt;</operator><name>share_refcounts</name></name> <operator>=</operator> <call><name>repalloc</name><argument_list>(<argument><expr><name><name>ctxt</name><operator>-&gt;</operator><name>share_refcounts</name></name></expr></argument>, <argument><expr><name>new_sz</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctxt</name><operator>-&gt;</operator><name>share_refcounts</name><index>[<expr><name>old_sz</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>new_sz</name> <operator>-</operator> <name>old_sz</name><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>ctxt</name><operator>-&gt;</operator><name>share_refcounts_sz</name></name> <operator>=</operator> <name>new_sz</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name><name>ctxt</name><operator>-&gt;</operator><name>share_refcounts</name><index>[<expr><name>share_id</name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>

		<comment type="block">/*
		 * Create a new RTE. Note that we use a different RTE for each
		 * reference, because we want to give each reference a different name.
		 */</comment>
		<expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>create_shareinput_producer_rte</name><argument_list>(<argument><expr><name>ctxt</name></expr></argument>, <argument><expr><name>share_id</name></expr></argument>,
											 <argument><expr><name><name>ctxt</name><operator>-&gt;</operator><name>share_refcounts</name><index>[<expr><name>share_id</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>glob</name><operator>-&gt;</operator><name>finalrtable</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>glob</name><operator>-&gt;</operator><name>finalrtable</name></name></expr></argument>, <argument><expr><name>rte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sisc</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>scanrelid</name></name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>glob</name><operator>-&gt;</operator><name>finalrtable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Replace all the target list entries.
		 *
		 * SharedInputScan nodes are not projection-capable, so the target
		 * list of the SharedInputScan matches the subplan's target list.
		 */</comment>
		<expr_stmt><expr><name>newtargetlist</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>attno</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>sisc-&gt;scan.plan.targetlist</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>newtle</name> <init>= <expr><call><name>flatCopyTargetEntry</name><argument_list>(<argument><expr><name>tle</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>newtle</name><operator>-&gt;</operator><name>expr</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>makeVar</name><argument_list>(<argument><expr><name><name>sisc</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>scanrelid</name></name></expr></argument>, <argument><expr><name>attno</name></expr></argument>,
											<argument><expr><call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr></argument>,
											<argument><expr><call><name>exprTypmod</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr></argument>,
											<argument><expr><call><name>exprCollation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr></argument>,
											<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>newtargetlist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>newtargetlist</name></expr></argument>, <argument><expr><name>newtle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>attno</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block>
		<expr_stmt><expr><name><name>sisc</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>targetlist</name></name> <operator>=</operator> <name>newtargetlist</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * First walk on shareinput xslice. Collect information about the producer
 * and consumer slice IDs for each share. It also builds a list of shares
 * that should run in the QD.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>shareinput_mutator_xslice_1</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>fPop</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PlannerGlobal</name> <modifier>*</modifier></type><name>glob</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>glob</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ApplyShareInputContext</name> <modifier>*</modifier></type><name>ctxt</name> <init>= <expr><operator>&amp;</operator><name><name>glob</name><operator>-&gt;</operator><name>share</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>plan</name> <init>= <expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>fPop</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><name>Motion</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>shareinput_popmot</name><argument_list>(<argument><expr><name>ctxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><name>Motion</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Motion</name>	   <modifier>*</modifier></type><name>motion</name> <init>= <expr><operator>(</operator><name>Motion</name> <operator>*</operator><operator>)</operator> <name>plan</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>shareinput_pushmot</name><argument_list>(<argument><expr><name>ctxt</name></expr></argument>, <argument><expr><name><name>motion</name><operator>-&gt;</operator><name>motionID</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><name>ShareInputScan</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ShareInputScan</name> <modifier>*</modifier></type><name>sisc</name> <init>= <expr><operator>(</operator><name>ShareInputScan</name> <operator>*</operator><operator>)</operator> <name>plan</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>motId</name> <init>= <expr><call><name>shareinput_peekmot</name><argument_list>(<argument><expr><name>ctxt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>shared</name> <init>= <expr><name><name>plan</name><operator>-&gt;</operator><name>lefttree</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PlanSlice</name>  <modifier>*</modifier></type><name>currentSlice</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ApplyShareInputContextPerShare</name> <modifier>*</modifier></type><name>share_info</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>share_info</name> <operator>=</operator> <operator>&amp;</operator><name><name>ctxt</name><operator>-&gt;</operator><name>shared_inputs</name><index>[<expr><name><name>sisc</name><operator>-&gt;</operator><name>share_id</name></name></expr>]</index></name></expr>;</expr_stmt>

		<expr_stmt><expr><name>currentSlice</name> <operator>=</operator> <operator>&amp;</operator><name><name>ctxt</name><operator>-&gt;</operator><name>slices</name><index>[<expr><name>motId</name></expr>]</index></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>currentSlice</name><operator>-&gt;</operator><name>gangType</name></name> <operator>==</operator> <name>GANGTYPE_UNALLOCATED</name> <operator>||</operator>
			<name><name>currentSlice</name><operator>-&gt;</operator><name>gangType</name></name> <operator>==</operator> <name>GANGTYPE_ENTRYDB_READER</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>ctxt</name><operator>-&gt;</operator><name>qdShares</name></name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name><name>ctxt</name><operator>-&gt;</operator><name>qdShares</name></name></expr></argument>, <argument><expr><name><name>sisc</name><operator>-&gt;</operator><name>share_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Remember information about the slice that this instance appears in. */</comment>
		<if_stmt><if>if <condition>(<expr><name>shared</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>ctxt</name><operator>-&gt;</operator><name>shared_inputs</name><index>[<expr><name><name>sisc</name><operator>-&gt;</operator><name>share_id</name></name></expr>]</index></name><operator>.</operator><name>producer_slice_id</name> <operator>=</operator> <name>motId</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>share_info</name><operator>-&gt;</operator><name>participant_slices</name></name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name><name>share_info</name><operator>-&gt;</operator><name>participant_slices</name></name></expr></argument>, <argument><expr><name>motId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>sisc</name><operator>-&gt;</operator><name>this_slice_id</name></name> <operator>=</operator> <name>motId</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Second pass:
 * 1. Mark shareinput scans with multiple consumer slices as cross-slice.
 * 2. Fill 'share_type' and 'share_id' fields in the shared Material/Sort nodes.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>shareinput_mutator_xslice_2</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>fPop</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PlannerGlobal</name> <modifier>*</modifier></type><name>glob</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>glob</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ApplyShareInputContext</name> <modifier>*</modifier></type><name>ctxt</name> <init>= <expr><operator>&amp;</operator><name><name>glob</name><operator>-&gt;</operator><name>share</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>plan</name> <init>= <expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>fPop</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><name>Motion</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>shareinput_popmot</name><argument_list>(<argument><expr><name>ctxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><name>Motion</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Motion</name>	   <modifier>*</modifier></type><name>motion</name> <init>= <expr><operator>(</operator><name>Motion</name> <operator>*</operator><operator>)</operator> <name>plan</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>shareinput_pushmot</name><argument_list>(<argument><expr><name>ctxt</name></expr></argument>, <argument><expr><name><name>motion</name><operator>-&gt;</operator><name>motionID</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><name>ShareInputScan</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ShareInputScan</name> <modifier>*</modifier></type><name>sisc</name> <init>= <expr><operator>(</operator><name>ShareInputScan</name> <operator>*</operator><operator>)</operator> <name>plan</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>motId</name> <init>= <expr><call><name>shareinput_peekmot</name><argument_list>(<argument><expr><name>ctxt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ApplyShareInputContextPerShare</name> <modifier>*</modifier></type><name>pershare</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>pershare</name> <operator>=</operator> <operator>&amp;</operator><name><name>ctxt</name><operator>-&gt;</operator><name>shared_inputs</name><index>[<expr><name><name>sisc</name><operator>-&gt;</operator><name>share_id</name></name></expr>]</index></name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>bms_num_members</name><argument_list>(<argument><expr><name><name>pershare</name><operator>-&gt;</operator><name>participant_slices</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>sisc</name><operator>-&gt;</operator><name>cross_slice</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>sisc</name><operator>-&gt;</operator><name>cross_slice</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name><name>sisc</name><operator>-&gt;</operator><name>producer_slice_id</name></name> <operator>=</operator> <name><name>pershare</name><operator>-&gt;</operator><name>producer_slice_id</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sisc</name><operator>-&gt;</operator><name>nconsumers</name></name> <operator>=</operator> <call><name>bms_num_members</name><argument_list>(<argument><expr><name><name>pershare</name><operator>-&gt;</operator><name>participant_slices</name></name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

		<comment type="block">/*
		 * If this share needs to run in the QD, mark the slice accordingly.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>bms_is_member</name><argument_list>(<argument><expr><name><name>sisc</name><operator>-&gt;</operator><name>share_id</name></name></expr></argument>, <argument><expr><name><name>ctxt</name><operator>-&gt;</operator><name>qdShares</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>PlanSlice</name>  <modifier>*</modifier></type><name>currentSlice</name> <init>= <expr><operator>&amp;</operator><name><name>ctxt</name><operator>-&gt;</operator><name>slices</name><index>[<expr><name>motId</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<switch>switch <condition>(<expr><name><name>currentSlice</name><operator>-&gt;</operator><name>gangType</name></name></expr>)</condition>
			<block>{<block_content>
				<case>case <expr><name>GANGTYPE_UNALLOCATED</name></expr>:</case>
				<case>case <expr><name>GANGTYPE_ENTRYDB_READER</name></expr>:</case>
					<break>break;</break>
				<case>case <expr><name>GANGTYPE_SINGLETON_READER</name></expr>:</case>
					<expr_stmt><expr><name><name>currentSlice</name><operator>-&gt;</operator><name>gangType</name></name> <operator>=</operator> <name>GANGTYPE_ENTRYDB_READER</name></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>GANGTYPE_PRIMARY_READER</name></expr>:</case>
				<case>case <expr><name>GANGTYPE_PRIMARY_WRITER</name></expr>:</case>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cannot share ShareInputScan between QD and primary reader/write gang"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
			</block_content>}</block></switch>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Scan through the plan tree and make note of which Share Input Scans
 * are cross-slice.
 */</comment>
<function><type><name>Plan</name> <modifier>*</modifier></type>
<name>apply_shareinput_xslice</name><parameter_list>(<parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>plan</name></decl></parameter>, <parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PlannerGlobal</name> <modifier>*</modifier></type><name>glob</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>glob</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ApplyShareInputContext</name> <modifier>*</modifier></type><name>ctxt</name> <init>= <expr><operator>&amp;</operator><name><name>glob</name><operator>-&gt;</operator><name>share</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lp</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>lr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>subplan_id</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * If the plan tree has only one slice, there cannot be any cross-slice
	 * Share Input Scans. They were all marked as cross_slice=false when they
	 * were created. Note that we won't set slice_ids on them correctly;
	 * the executor knows not to expect that when numSlices == 1.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>root</name><operator>-&gt;</operator><name>glob</name><operator>-&gt;</operator><name>numSlices</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>plan</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>ctxt</name><operator>-&gt;</operator><name>motStack</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctxt</name><operator>-&gt;</operator><name>qdShares</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctxt</name><operator>-&gt;</operator><name>slices</name></name> <operator>=</operator> <name><name>root</name><operator>-&gt;</operator><name>glob</name><operator>-&gt;</operator><name>slices</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>ctxt</name><operator>-&gt;</operator><name>shared_inputs</name></name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name><name>ctxt</name><operator>-&gt;</operator><name>shared_input_count</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ApplyShareInputContextPerShare</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>shareinput_pushmot</name><argument_list>(<argument><expr><name>ctxt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Walk the tree.  See comment for each pass for what each pass will do.
	 * The context is used to carry information from one pass to another, as
	 * well as within a pass.
	 */</comment>

	<comment type="block">/*
	 * A subplan might have a SharedScan consumer while the SharedScan
	 * producer is in the main plan, or vice versa. So in the first pass, we
	 * walk through all plans and collect all producer subplans into the
	 * context, before processing the consumers.
	 */</comment>
	<expr_stmt><expr><name>subplan_id</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<macro><name>forboth</name><argument_list>(<argument>lp</argument>, <argument>glob-&gt;subplans</argument>, <argument>lr</argument>, <argument>glob-&gt;subroots</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>subplan</name> <init>= <expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>subroot</name> <init>=  <expr><operator>(</operator><name>PlannerInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>slice_id</name> <init>= <expr><name><name>glob</name><operator>-&gt;</operator><name>subplan_sliceIds</name><index>[<expr><name>subplan_id</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>shareinput_pushmot</name><argument_list>(<argument><expr><name>ctxt</name></expr></argument>, <argument><expr><name>slice_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>shareinput_walker</name><argument_list>(<argument><expr><name>shareinput_mutator_xslice_1</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>subplan</name></expr></argument>, <argument><expr><name>subroot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>shareinput_popmot</name><argument_list>(<argument><expr><name>ctxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>subplan_id</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>shareinput_walker</name><argument_list>(<argument><expr><name>shareinput_mutator_xslice_1</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>plan</name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Now walk the tree again, and process all the consumers. */</comment>
	<expr_stmt><expr><name>subplan_id</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<macro><name>forboth</name><argument_list>(<argument>lp</argument>, <argument>glob-&gt;subplans</argument>, <argument>lr</argument>, <argument>glob-&gt;subroots</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>subplan</name> <init>= <expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>subroot</name> <init>=  <expr><operator>(</operator><name>PlannerInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>slice_id</name> <init>= <expr><name><name>glob</name><operator>-&gt;</operator><name>subplan_sliceIds</name><index>[<expr><name>subplan_id</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>shareinput_pushmot</name><argument_list>(<argument><expr><name>ctxt</name></expr></argument>, <argument><expr><name>slice_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>shareinput_walker</name><argument_list>(<argument><expr><name>shareinput_mutator_xslice_2</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>subplan</name></expr></argument>, <argument><expr><name>subroot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>shareinput_popmot</name><argument_list>(<argument><expr><name>ctxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>subplan_id</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>shareinput_walker</name><argument_list>(<argument><expr><name>shareinput_mutator_xslice_2</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>plan</name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>plan</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Hash a list of const values with GPDB's hash function
 */</comment>
<function><type><name>int32</name></type>
<name>cdbhash_const_list</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>plConsts</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iSegments</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>hashfuncs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CdbHash</name>    <modifier>*</modifier></type><name>pcdbhash</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><literal type="number">0</literal> <operator>&lt;</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>plConsts</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>pcdbhash</name> <operator>=</operator> <call><name>makeCdbHash</name><argument_list>(<argument><expr><name>iSegments</name></expr></argument>, <argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>plConsts</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>hashfuncs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>cdbhashinit</name><argument_list>(<argument><expr><name>pcdbhash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><literal type="number">0</literal> <operator>&lt;</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>plConsts</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>plConsts</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Const</name>	   <modifier>*</modifier></type><name>pconst</name> <init>= <expr><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>cdbhash</name><argument_list>(<argument><expr><name>pcdbhash</name></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name><name>pconst</name><operator>-&gt;</operator><name>constvalue</name></name></expr></argument>, <argument><expr><name><name>pconst</name><operator>-&gt;</operator><name>constisnull</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><call><name>cdbhashreduce</name><argument_list>(<argument><expr><name>pcdbhash</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Construct an expression that checks whether the current segment is
 * 'segid'.
 */</comment>
<function><type><name>Node</name> <modifier>*</modifier></type>
<name>makeSegmentFilterExpr</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>segid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Build an expression: gp_execution_segment() = &lt;segid&gt; */</comment>
	<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator>
		<call><name>make_opclause</name><argument_list>(<argument><expr><name>Int4EqualOperator</name></expr></argument>,
					  <argument><expr><name>BOOLOID</name></expr></argument>,
					  <argument><expr><name>false</name></expr></argument>,	<comment type="block">/* opretset */</comment>
					  <argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>makeFuncExpr</name><argument_list>(<argument><expr><name>F_MPP_EXECUTION_SEGMENT</name></expr></argument>,
											<argument><expr><name>INT4OID</name></expr></argument>,
											<argument><expr><name>NIL</name></expr></argument>,	<comment type="block">/* args */</comment>
											<argument><expr><name>InvalidOid</name></expr></argument>,
											<argument><expr><name>InvalidOid</name></expr></argument>,
											<argument><expr><name>COERCE_EXPLICIT_CALL</name></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>makeConst</name><argument_list>(<argument><expr><name>INT4OID</name></expr></argument>,
										 <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,		<comment type="block">/* consttypmod */</comment>
										 <argument><expr><name>InvalidOid</name></expr></argument>, <comment type="block">/* constcollid */</comment>
										 <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int32</name></expr></argument>)</argument_list></sizeof></expr></argument>,
										 <argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>segid</name></expr></argument>)</argument_list></call></expr></argument>,
										 <argument><expr><name>false</name></expr></argument>,		<comment type="block">/* constisnull */</comment>
										 <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></argument>,		<comment type="block">/* constbyval */</comment>
					  <argument><expr><name>InvalidOid</name></expr></argument>,	<comment type="block">/* opcollid */</comment>
					  <argument><expr><name>InvalidOid</name></expr></argument>	<comment type="block">/* inputcollid */</comment>
			)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<typedef>typedef <type><struct>struct <name>ParamWalkerContext</name>
<block>{
	<decl_stmt><decl><type><name>plan_tree_base_prefix</name></type> <name>base</name></decl>;</decl_stmt> <comment type="block">/* Required prefix for
								 * plan_tree_walker/mutator */</comment>
	<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>paramids</name></decl>;</decl_stmt>		<comment type="block">/* Bitmapset for Param */</comment>
	<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>scanrelids</name></decl>;</decl_stmt>		<comment type="block">/* Bitmapset for scanrelid */</comment>
}</block></struct></type> <name>ParamWalkerContext</name>;</typedef>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>param_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>ParamWalkerContext</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name> <init>= <expr><operator>(</operator><name>PlannerInfo</name> <operator>*</operator><operator>)</operator> <name><name>context</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>node</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Param</name>	   <modifier>*</modifier></type><name>param</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Aggref</name>	   <modifier>*</modifier></type><name>aggref</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Scan</name>	   <modifier>*</modifier></type><name>scan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>T_Param</name></expr>:</case>
			<expr_stmt><expr><name>param</name> <operator>=</operator> <operator>(</operator><name>Param</name> <operator>*</operator><operator>)</operator> <name>node</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>param</name><operator>-&gt;</operator><name>paramkind</name></name> <operator>==</operator> <name>PARAM_EXEC</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>bms_is_member</name><argument_list>(<argument><expr><name><name>param</name><operator>-&gt;</operator><name>paramid</name></name></expr></argument>, <argument><expr><name><name>context</name><operator>-&gt;</operator><name>paramids</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>paramids</name></name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>paramids</name></name></expr></argument>,
													   <argument><expr><name><name>param</name><operator>-&gt;</operator><name>paramid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
			<return>return <expr><name>false</name></expr>;</return>

		<case>case <expr><name>T_Aggref</name></expr>:</case>
			<comment type="block">/*
			 * See if it's an Aggref that will be replaced by a Param in
			 * set_plan_references()
			 */</comment>
			<expr_stmt><expr><name>aggref</name> <operator>=</operator> <operator>(</operator><name>Aggref</name> <operator>*</operator><operator>)</operator> <name>node</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>root</name><operator>-&gt;</operator><name>minmax_aggs</name></name> <operator>!=</operator> <name>NIL</name> <operator>&amp;&amp;</operator>
				<call><name>list_length</name><argument_list>(<argument><expr><name><name>aggref</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>curTarget</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>aggref</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

				<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>root-&gt;minmax_aggs</argument>)</argument_list></macro>
				<block>{<block_content>
					<decl_stmt><decl><type><name>MinMaxAggInfo</name> <modifier>*</modifier></type><name>mminfo</name> <init>= <expr><operator>(</operator><name>MinMaxAggInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><name><name>mminfo</name><operator>-&gt;</operator><name>aggfnoid</name></name> <operator>==</operator> <name><name>aggref</name><operator>-&gt;</operator><name>aggfnoid</name></name> <operator>&amp;&amp;</operator>
						<call><name>equal</name><argument_list>(<argument><expr><name><name>mminfo</name><operator>-&gt;</operator><name>target</name></name></expr></argument>, <argument><expr><name><name>curTarget</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>param_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>mminfo</name><operator>-&gt;</operator><name>param</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				</block_content>}</block>
			</block_content>}</block></if></if_stmt>
			<break>break;</break>

		<case>case <expr><name>T_ValuesScan</name></expr>:</case>
		<case>case <expr><name>T_FunctionScan</name></expr>:</case>
		<case>case <expr><name>T_TableFunctionScan</name></expr>:</case>
			<expr_stmt><expr><name>scan</name> <operator>=</operator> <operator>(</operator><name>Scan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>bms_is_member</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>scanrelid</name></name></expr></argument>, <argument><expr><name><name>context</name><operator>-&gt;</operator><name>scanrelids</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>scanrelids</name></name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>scanrelids</name></name></expr></argument>,
													 <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>scanrelid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>

		<case>case <expr><name>T_SubPlan</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name> <init>= <expr><operator>(</operator><name>PlannerInfo</name> <operator>*</operator><operator>)</operator> <name><name>context</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>node</name></name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>SubPlan</name>	   <modifier>*</modifier></type><name>spexpr</name> <init>= <expr><operator>(</operator><name>SubPlan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>subplan_plan</name> <init>= <expr><call><name>planner_subplan_get_plan</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>spexpr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>subplan_root</name> <init>= <expr><call><name>planner_subplan_get_root</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>spexpr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>save_root</name></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>spexpr</name><operator>-&gt;</operator><name>subLinkType</name></name> <operator>==</operator> <name>MULTIEXPR_SUBLINK</name> <operator>&amp;&amp;</operator>
					<name><name>spexpr</name><operator>-&gt;</operator><name>is_initplan</name></name></expr>)</condition>
				<block>{<block_content>
					<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>spexpr-&gt;setParam</argument>)</argument_list></macro>
					<block>{<block_content>
						<decl_stmt><decl><type><name>int</name></type>			<name>paramid</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

						<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>bms_is_member</name><argument_list>(<argument><expr><name>paramid</name></expr></argument>, <argument><expr><name><name>context</name><operator>-&gt;</operator><name>paramids</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>paramids</name></name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>paramids</name></name></expr></argument>,
															   <argument><expr><name>paramid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					</block_content>}</block>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/* recurse into the subplan */</comment>
				<expr_stmt><expr><name>save_root</name> <operator>=</operator> <name><name>context</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>node</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>node</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>subplan_root</name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>param_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>subplan_plan</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

				<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>node</name></name> <operator>=</operator> <name>save_root</name></expr>;</expr_stmt>

				<comment type="block">/*
				 * fall through to let plan_tree_walker() handle any expressions in
				 * testexpr and args
				 */</comment>
			</block_content>}</block>
			<break>break;</break>

		<default>default:</default>
			<break>break;</break>
	</block_content>}</block></switch>

	<return>return <expr><call><name>plan_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>param_walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Retrieve param ids that are referenced in RTEs.
 * We can't simply use range_table_walker() here, because we only
 * want to walk through RTEs that are referenced in the plan.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>rte_param_walker</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>rtable</name></decl></parameter>, <parameter><decl><type><name>ParamWalkerContext</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>rteid</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>func_lc</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>rtable</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><name>rteid</name><operator>++</operator></expr>;</expr_stmt>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><operator>(</operator><name>RangeTblEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>bms_is_member</name><argument_list>(<argument><expr><name>rteid</name></expr></argument>, <argument><expr><name><name>context</name><operator>-&gt;</operator><name>scanrelids</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* rte not referenced in the plan */</comment>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<switch>switch <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>RTE_RELATION</name></expr>:</case>
			<case>case <expr><name>RTE_VOID</name></expr>:</case>
			<case>case <expr><name>RTE_CTE</name></expr>:</case>
			<case>case <expr><name>RTE_RESULT</name></expr>:</case>
			<case>case <expr><name>RTE_NAMEDTUPLESTORE</name></expr>:</case>
				<comment type="block">/* nothing to do */</comment>
				<break>break;</break>
			<case>case <expr><name>RTE_SUBQUERY</name></expr>:</case>
				<expr_stmt><expr><call><name>param_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>rte</name><operator>-&gt;</operator><name>subquery</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>RTE_JOIN</name></expr>:</case>
				<expr_stmt><expr><call><name>param_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>rte</name><operator>-&gt;</operator><name>joinaliasvars</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>RTE_FUNCTION</name></expr>:</case>
				<macro><name>foreach</name><argument_list>(<argument>func_lc</argument>, <argument>rte-&gt;functions</argument>)</argument_list></macro>
				<block>{<block_content>
					<decl_stmt><decl><type><name>RangeTblFunction</name> <modifier>*</modifier></type><name>rtfunc</name> <init>= <expr><operator>(</operator><name>RangeTblFunction</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>func_lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<expr_stmt><expr><call><name>param_walker</name><argument_list>(<argument><expr><name><name>rtfunc</name><operator>-&gt;</operator><name>funcexpr</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block>
				<break>break;</break>
			<case>case <expr><name>RTE_TABLEFUNCTION</name></expr>:</case>
				<expr_stmt><expr><call><name>param_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>rte</name><operator>-&gt;</operator><name>subquery</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<macro><name>foreach</name><argument_list>(<argument>func_lc</argument>, <argument>rte-&gt;functions</argument>)</argument_list></macro>
				<block>{<block_content>
					<decl_stmt><decl><type><name>RangeTblFunction</name> <modifier>*</modifier></type><name>rtfunc</name> <init>= <expr><operator>(</operator><name>RangeTblFunction</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>func_lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<expr_stmt><expr><call><name>param_walker</name><argument_list>(<argument><expr><name><name>rtfunc</name><operator>-&gt;</operator><name>funcexpr</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block>
				<break>break;</break>
			<case>case <expr><name>RTE_TABLEFUNC</name></expr>:</case>
				<expr_stmt><expr><call><name>param_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>rte</name><operator>-&gt;</operator><name>tablefunc</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>RTE_VALUES</name></expr>:</case>
				<expr_stmt><expr><call><name>param_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>rte</name><operator>-&gt;</operator><name>values_lists</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
		</block_content>}</block></switch>
	</block_content>}</block>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>initplan_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>ParamWalkerContext</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>new_initplans</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>lp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>anyused</name></decl>;</decl_stmt>		<comment type="block">/* Are any of this Init Plan's output
								 * parameters actually used? */</comment>

	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>is_plan_node</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>root</name> <operator>=</operator> <operator>(</operator><name>PlannerInfo</name> <operator>*</operator><operator>)</operator> <name><name>context</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>node</name></name></expr>;</expr_stmt>
		<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>plan</name> <init>= <expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>plan-&gt;initPlan</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>SubPlan</name>    <modifier>*</modifier></type><name>subplan</name> <init>= <expr><operator>(</operator><name>SubPlan</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>subplan</name><operator>-&gt;</operator><name>is_initplan</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>anyused</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<macro><name>foreach</name><argument_list>(<argument>lp</argument>, <argument>subplan-&gt;setParam</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>int</name></type>			<name>paramid</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>bms_is_member</name><argument_list>(<argument><expr><name>paramid</name></expr></argument>, <argument><expr><name><name>context</name><operator>-&gt;</operator><name>paramids</name></name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>anyused</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block>

			<comment type="block">/* If none of its params are used, leave out from the new list */</comment>
			<if_stmt><if>if <condition>(<expr><name>anyused</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>new_initplans</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>new_initplans</name></expr></argument>, <argument><expr><name>subplan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/*
				 * This init plan is unused. Leave it out of this plan node's
				 * initPlan list, and also replace it in the global list of
				 * subplans with a dummy. (We can't just remove it from the
				 * global list, because that would screw up the plan_id
				 * numbering of the subplans).
				 */</comment>
				<decl_stmt><decl><type><name>Result</name>	   <modifier>*</modifier></type><name>dummy</name> <init>= <expr><call><name>make_result</name><argument_list>(<argument><expr><name>NIL</name></expr></argument>,
												<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>list_make1</name><argument_list>(<argument><expr><call><name>makeBoolConst</name><argument_list>(<argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
												<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>planner_subplan_put_plan</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>subplan</name></expr></argument>, <argument><expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <name>dummy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block>

		<comment type="block">/* remove unused params */</comment>
		<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>allParam</name></name> <operator>=</operator> <call><name>bms_intersect</name><argument_list>(<argument><expr><name><name>plan</name><operator>-&gt;</operator><name>allParam</name></name></expr></argument>, <argument><expr><name><name>context</name><operator>-&gt;</operator><name>paramids</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name><name>plan</name><operator>-&gt;</operator><name>initPlan</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>plan</name><operator>-&gt;</operator><name>initPlan</name></name> <operator>=</operator> <name>new_initplans</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><call><name>plan_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>initplan_walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Remove unused initplans from the given plan object
 */</comment>
<function><type><name>void</name></type>
<name>remove_unused_initplans</name><parameter_list>(<parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>top_plan</name></decl></parameter>, <parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ParamWalkerContext</name></type> <name>context</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>root</name><operator>-&gt;</operator><name>glob</name><operator>-&gt;</operator><name>subplans</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>base</name><operator>.</operator><name>node</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>root</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>paramids</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>scanrelids</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Collect param ids of all the Params that are referenced in the plan,and
	 * the IDs of all the range table entries that are referenced in the Plan.
	 */</comment>
	<expr_stmt><expr><call><name>param_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>top_plan</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Now that we know which range table entries are referenced in the plan,
	 * also collect Params from those range table entries.
	 */</comment>
	<expr_stmt><expr><call><name>rte_param_walker</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>glob</name><operator>-&gt;</operator><name>finalrtable</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* workhorse to remove unused initplans */</comment>
	<expr_stmt><expr><call><name>initplan_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>top_plan</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>bms_free</name><argument_list>(<argument><expr><name><name>context</name><operator>.</operator><name>paramids</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>bms_free</name><argument_list>(<argument><expr><name><name>context</name><operator>.</operator><name>scanrelids</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Evaluate functions to constants.
 */</comment>
<function><type><name>Node</name> <modifier>*</modifier></type>
<name>exec_make_plan_constant</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>PlannedStmt</name></name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>, <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_SRI</name></decl></parameter>,
						<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>cursorPositions</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>pre_dispatch_function_evaluation_context</name></type> <name>pcontext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>exec_init_plan_tree_base</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pcontext</name><operator>.</operator><name>base</name></name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pcontext</name><operator>.</operator><name>single_row_insert</name></name> <operator>=</operator> <name>is_SRI</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pcontext</name><operator>.</operator><name>cursorPositions</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pcontext</name><operator>.</operator><name>estate</name></name> <operator>=</operator> <name>estate</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>pre_dispatch_function_evaluation_mutator</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>stmt</name><operator>-&gt;</operator><name>planTree</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>cursorPositions</name> <operator>=</operator> <name><name>pcontext</name><operator>.</operator><name>cursorPositions</name></name></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Remove subquery field in RTE's with subquery kind.
 */</comment>
<function><type><name>void</name></type>
<name>remove_subquery_in_RTEs</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>RangeTblEntry</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><operator>(</operator><name>RangeTblEntry</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>RTE_SUBQUERY</name> <operator>==</operator> <name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>&amp;&amp;</operator> <name>NULL</name> <operator>!=</operator> <name><name>rte</name><operator>-&gt;</operator><name>subquery</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Replace subquery with a dummy subquery.
			 *
			 * XXX: We could save a lot more memory by deep-freeing the many
			 * fields in the Query too. But I'm not sure which of them might
			 * be shared by other objects in the tree.
			 */</comment>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>subquery</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>subquery</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>List</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>list</name> <init>= <expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>list</argument>)</argument_list></macro>
		<block>{<block_content>
			<expr_stmt><expr><call><name>remove_subquery_in_RTEs</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Let's evaluate all STABLE functions that have constant args before
 * dispatch, so we get a consistent view across QEs
 *
 * Also, if this is a single_row insert, let's evaluate nextval() and
 * currval() before dispatching
 */</comment>
<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>pre_dispatch_function_evaluation_mutator</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
										 <parameter><decl><type><name>pre_dispatch_function_evaluation_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>new_node</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Param</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Param</name>	   <modifier>*</modifier></type><name>param</name> <init>= <expr><operator>(</operator><name>Param</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Not replaceable, so just copy the Param (no need to recurse) */</comment>
		<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>param</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>FuncExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>FuncExpr</name>   <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>FuncExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>args</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>arg</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>simple</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>FuncExpr</name>   <modifier>*</modifier></type><name>newexpr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>has_nonconst_input</name></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>Form_pg_proc</name></type> <name>funcform</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>EState</name>	   <modifier>*</modifier></type><name>estate</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ExprState</name>  <modifier>*</modifier></type><name>exprstate</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>const_val</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>const_is_null</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int16</name></type>		<name>resultTypLen</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>resultTypByVal</name></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>Oid</name></type>			<name>funcid</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>func_tuple</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Reduce constants in the FuncExpr's arguments. We know args is
		 * either NIL or a List node, so we can call expression_tree_mutator
		 * directly rather than recursing to self.
		 */</comment>
		<expr_stmt><expr><name>args</name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>expression_tree_mutator</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>expr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>,
												<argument><expr><name>pre_dispatch_function_evaluation_mutator</name></expr></argument>,
												<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>funcid</name> <operator>=</operator> <name><name>expr</name><operator>-&gt;</operator><name>funcid</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><name>newexpr</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>FuncExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newexpr</name><operator>-&gt;</operator><name>funcid</name></name> <operator>=</operator> <name><name>expr</name><operator>-&gt;</operator><name>funcid</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newexpr</name><operator>-&gt;</operator><name>funcresulttype</name></name> <operator>=</operator> <name><name>expr</name><operator>-&gt;</operator><name>funcresulttype</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newexpr</name><operator>-&gt;</operator><name>funcretset</name></name> <operator>=</operator> <name><name>expr</name><operator>-&gt;</operator><name>funcretset</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newexpr</name><operator>-&gt;</operator><name>funcvariadic</name></name> <operator>=</operator> <name><name>expr</name><operator>-&gt;</operator><name>funcvariadic</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newexpr</name><operator>-&gt;</operator><name>funcformat</name></name> <operator>=</operator> <name><name>expr</name><operator>-&gt;</operator><name>funcformat</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newexpr</name><operator>-&gt;</operator><name>funccollid</name></name> <operator>=</operator> <name><name>expr</name><operator>-&gt;</operator><name>funccollid</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newexpr</name><operator>-&gt;</operator><name>inputcollid</name></name> <operator>=</operator> <name><name>expr</name><operator>-&gt;</operator><name>inputcollid</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newexpr</name><operator>-&gt;</operator><name>args</name></name> <operator>=</operator> <name>args</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newexpr</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <name><name>expr</name><operator>-&gt;</operator><name>location</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newexpr</name><operator>-&gt;</operator><name>is_tablefunc</name></name> <operator>=</operator> <name><name>expr</name><operator>-&gt;</operator><name>is_tablefunc</name></name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Check for constant inputs
		 */</comment>
		<expr_stmt><expr><name>has_nonconst_input</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

		<macro><name>foreach</name><argument_list>(<argument>arg</argument>, <argument>args</argument>)</argument_list></macro>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>has_nonconst_input</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>has_nonconst_input</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>bool</name></type>		<name>is_seq_func</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>tup_or_set</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>func_tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>funcid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>func_tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for function %u"</literal></expr></argument>, <argument><expr><name>funcid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>funcform</name> <operator>=</operator> <operator>(</operator><name>Form_pg_proc</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>func_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* can't handle set returning or row returning functions */</comment>
			<expr_stmt><expr><name>tup_or_set</name> <operator>=</operator> <operator>(</operator><name><name>funcform</name><operator>-&gt;</operator><name>proretset</name></name> <operator>||</operator> <call><name>type_is_rowtype</name><argument_list>(<argument><expr><name><name>funcform</name><operator>-&gt;</operator><name>prorettype</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>func_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* can't handle it */</comment>
			<if_stmt><if>if <condition>(<expr><name>tup_or_set</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * We haven't mutated this node, but we still return the
				 * mutated arguments.
				 *
				 * If we don't do this, we'll miss out on transforming
				 * function arguments which are themselves functions we need
				 * to mutated. For example, select foo(now()).
				 */</comment>
				<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newexpr</name></expr>;</return>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * Here we want to mark any statement that is going to use a
			 * sequence as dirty.  Doing this means that the QD will flush the
			 * xlog which will also flush any xlog writes that the sequence
			 * server might do.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>funcid</name> <operator>==</operator> <name>F_NEXTVAL_OID</name> <operator>||</operator> <name>funcid</name> <operator>==</operator> <name>F_CURRVAL_OID</name> <operator>||</operator>
				<name>funcid</name> <operator>==</operator> <name>F_SETVAL_OID</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ExecutorMarkTransactionUsesSequences</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>is_seq_func</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>funcform</name><operator>-&gt;</operator><name>provolatile</name></name> <operator>==</operator> <name>PROVOLATILE_IMMUTABLE</name></expr>)</condition><block type="pseudo"><block_content>
				 <comment type="block">/* okay */</comment> <empty_stmt>;</empty_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><name><name>funcform</name><operator>-&gt;</operator><name>provolatile</name></name> <operator>==</operator> <name>PROVOLATILE_STABLE</name></expr>)</condition><block type="pseudo"><block_content>
				 <comment type="block">/* okay */</comment> <empty_stmt>;</empty_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>single_row_insert</name></name> <operator>&amp;&amp;</operator> <name>is_seq_func</name></expr>)</condition><block type="pseudo"><block_content>
				<empty_stmt>;</empty_stmt></block_content></block></if>				<comment type="block">/* Volatile, but special sequence function */</comment>
			<else>else<block type="pseudo"><block_content>
				<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newexpr</name></expr>;</return></block_content></block></else></if_stmt>

			<comment type="block">/*
			 * Ok, we have a function that is STABLE (or IMMUTABLE), with
			 * constant args. Let's try to evaluate it.
			 */</comment>

			<comment type="block">/*
			 * To use the executor, we need an EState.
			 */</comment>
			<expr_stmt><expr><name>estate</name> <operator>=</operator> <call><name>CreateExecutorState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* We can use the estate's working context to avoid memory leaks. */</comment>
			<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_query_cxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Prepare expr for execution.
			 */</comment>
			<expr_stmt><expr><name>exprstate</name> <operator>=</operator> <call><name>ExecPrepareExpr</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>newexpr</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * And evaluate it.
			 *
			 * It is OK to use a default econtext because none of the
			 * ExecEvalExpr() code used in this situation will use econtext.
			 * That might seem fortuitous, but it's not so unreasonable --- a
			 * constant expression does not depend on context, by definition,
			 * n'est-ce pas?
			 */</comment>
			<expr_stmt><expr><name>const_val</name> <operator>=</operator> <call><name>ExecEvalExprSwitchContext</name><argument_list>(<argument><expr><name>exprstate</name></expr></argument>,
												  <argument><expr><call><name>GetPerTupleExprContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr></argument>,
												  <argument><expr><operator>&amp;</operator><name>const_is_null</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Get info needed about result datatype */</comment>
			<expr_stmt><expr><call><name>get_typlenbyval</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>funcresulttype</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>resultTypLen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>resultTypByVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Get back to outer memory context */</comment>
			<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Must copy result out of sub-context used by expression eval */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>const_is_null</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>const_val</name> <operator>=</operator> <call><name>datumCopy</name><argument_list>(<argument><expr><name>const_val</name></expr></argument>, <argument><expr><name>resultTypByVal</name></expr></argument>, <argument><expr><name>resultTypLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/* Release all the junk we just created */</comment>
			<expr_stmt><expr><call><name>FreeExecutorState</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Make the constant result node.
			 */</comment>
			<expr_stmt><expr><name>simple</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>makeConst</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>funcresulttype</name></name></expr></argument>,
										<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
										<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>funccollid</name></name></expr></argument>,
										<argument><expr><name>resultTypLen</name></expr></argument>,
										<argument><expr><name>const_val</name></expr></argument>, <argument><expr><name>const_is_null</name></expr></argument>,
										<argument><expr><name>resultTypByVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* successfully simplified it */</comment>
			<if_stmt><if>if <condition>(<expr><name>simple</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>simple</name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * The expression cannot be simplified any further, so build and
		 * return a replacement FuncExpr node using the possibly-simplified
		 * arguments.
		 */</comment>
		<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newexpr</name></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>OpExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>OpExpr</name>	   <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>OpExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>args</name></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>OpExpr</name>	   <modifier>*</modifier></type><name>newexpr</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Reduce constants in the OpExpr's arguments.  We know args is either
		 * NIL or a List node, so we can call expression_tree_mutator directly
		 * rather than recursing to self.
		 */</comment>
		<expr_stmt><expr><name>args</name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>expression_tree_mutator</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>expr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>,
												<argument><expr><name>pre_dispatch_function_evaluation_mutator</name></expr></argument>,
												<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Need to get OID of underlying function.	Okay to scribble on input
		 * to this extent.
		 */</comment>
		<expr_stmt><expr><call><name>set_opfuncid</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>newexpr</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>OpExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newexpr</name><operator>-&gt;</operator><name>opno</name></name> <operator>=</operator> <name><name>expr</name><operator>-&gt;</operator><name>opno</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newexpr</name><operator>-&gt;</operator><name>opfuncid</name></name> <operator>=</operator> <name><name>expr</name><operator>-&gt;</operator><name>opfuncid</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newexpr</name><operator>-&gt;</operator><name>opresulttype</name></name> <operator>=</operator> <name><name>expr</name><operator>-&gt;</operator><name>opresulttype</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newexpr</name><operator>-&gt;</operator><name>opretset</name></name> <operator>=</operator> <name><name>expr</name><operator>-&gt;</operator><name>opretset</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newexpr</name><operator>-&gt;</operator><name>opcollid</name></name> <operator>=</operator> <name><name>expr</name><operator>-&gt;</operator><name>opcollid</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newexpr</name><operator>-&gt;</operator><name>inputcollid</name></name> <operator>=</operator> <name><name>expr</name><operator>-&gt;</operator><name>inputcollid</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newexpr</name><operator>-&gt;</operator><name>args</name></name> <operator>=</operator> <name>args</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newexpr</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <name><name>expr</name><operator>-&gt;</operator><name>location</name></name></expr>;</expr_stmt>

		<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newexpr</name></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>CurrentOfExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * updatable cursors
		 *
		 * During constant folding, we collect the current position of each
		 * cursor mentioned in the plan into a list, and dispatch them to the
		 * QEs.
		 *
		 * We should not get here if called from planner_make_plan_constant().
		 * That is only used for simple Result plans, which should not contain
		 * CURRENT OF expressions.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>estate</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>CurrentOfExpr</name> <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>CurrentOfExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>CursorPosInfo</name> <modifier>*</modifier></type><name>cpos</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>cpos</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>CursorPosInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>getCurrentOf</name><argument_list>(<argument><expr><name>expr</name></expr></argument>,
						 <argument><expr><call><name>GetPerTupleExprContext</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>estate</name></name></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><name><name>expr</name><operator>-&gt;</operator><name>target_relid</name></name></expr></argument>,
						 <argument><expr><operator>&amp;</operator><name><name>cpos</name><operator>-&gt;</operator><name>ctid</name></name></expr></argument>,
						 <argument><expr><operator>&amp;</operator><name><name>cpos</name><operator>-&gt;</operator><name>gp_segment_id</name></name></expr></argument>,
						 <argument><expr><operator>&amp;</operator><name><name>cpos</name><operator>-&gt;</operator><name>table_oid</name></name></expr></argument>,
						 <argument><expr><operator>&amp;</operator><name><name>cpos</name><operator>-&gt;</operator><name>cursor_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>cursorPositions</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>cursorPositions</name></name></expr></argument>, <argument><expr><name>cpos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * For any node type not handled above, we recurse using
	 * plan_tree_mutator, which will copy the node unchanged but try to
	 * simplify its arguments (if any) using this routine.
	 */</comment>
	<expr_stmt><expr><name>new_node</name> <operator>=</operator> <call><name>plan_tree_mutator</name><argument_list>(<argument><expr><name>node</name></expr></argument>,
								 <argument><expr><name>pre_dispatch_function_evaluation_mutator</name></expr></argument>,
								 <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>context</name></expr></argument>,
								 <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>new_node</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * cdbpathtoplan_create_sri_path
 *
 * Optimize for single-row-insertion for const result. If result is const, and
 * result relation is partitioned, we could decide partition relation during
 * plan time and replace targetPolicy by partition relation's targetPolicy.
 * In addition, we don't need tuple distribution, but do filter on each writer
 * segment.
 *
 * Inputs:
 *
 * root		PlannerInfo passed by caller
 * plan		should always be result node
 * rte		is the target relation entry
 *
 * Inputs/Outputs:
 *
 * targetPolicy(in/out) is the target relation policy, and would be replaced
 * by partition relation.
 * hashExpr is distribution expression of target relation, and would be
 * replaced by partition relation.
 */</comment>
<function><type><name>Plan</name> <modifier>*</modifier></type>
<name>cdbpathtoplan_create_sri_plan</name><parameter_list>(<parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>, <parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>subroot</name></decl></parameter>, <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>subpath</name></decl></parameter>,
							  <parameter><decl><type><name>int</name></type> <name>createplan_flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CdbMotionPath</name> <modifier>*</modifier></type><name>motionpath</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>resultpath</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Result</name>	   <modifier>*</modifier></type><name>resultplan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GpPolicy</name>   <modifier>*</modifier></type><name>targetPolicy</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>hashExprs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>hashOpfamilies</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numHashAttrs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>hashAttrs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name>		   <modifier>*</modifier></type><name>hashFuncs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>gp_enable_fast_sri</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>subpath</name></expr></argument>, <argument><expr><name>CdbMotionPath</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>motionpath</name> <operator>=</operator> <operator>(</operator><name>CdbMotionPath</name> <operator>*</operator><operator>)</operator> <name>subpath</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>motionpath</name><operator>-&gt;</operator><name>subpath</name></name></expr></argument>, <argument><expr><name>GroupResultPath</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* ok */</comment>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>motionpath</name><operator>-&gt;</operator><name>subpath</name></name></expr></argument>, <argument><expr><name>ProjectionPath</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			 <call><name>IsA</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>ProjectionPath</name> <operator>*</operator><operator>)</operator> <name><name>motionpath</name><operator>-&gt;</operator><name>subpath</name></name><operator>)</operator><operator>-&gt;</operator><name>subpath</name></expr></argument>, <argument><expr><name>GroupResultPath</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* ProjectionPath with a GroupResultPath beneath is also ok. */</comment>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></else></if_stmt>

	<expr_stmt><expr><name>resultpath</name> <operator>=</operator> <name><name>motionpath</name><operator>-&gt;</operator><name>subpath</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>contain_mutable_functions</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>resultpath</name><operator>-&gt;</operator><name>pathtarget</name><operator>-&gt;</operator><name>exprs</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>resultplan</name> <operator>=</operator> <operator>(</operator><name>Result</name> <operator>*</operator><operator>)</operator> <call><name>create_plan_recurse</name><argument_list>(<argument><expr><name>subroot</name></expr></argument>, <argument><expr><name>resultpath</name></expr></argument>, <argument><expr><name>createplan_flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>resultplan</name></expr></argument>, <argument><expr><name>Result</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* A GroupResultPath really should produce a Result node. */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Suppose caller already hold proper locks for relation. */</comment>
	<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>relation_open</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>targetPolicy</name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_cdbpolicy</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>hashExprs</name> <operator>=</operator> <call><name>getExprListFromTargetList</name><argument_list>(<argument><expr><name><name>resultplan</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>targetlist</name></name></expr></argument>,
										  <argument><expr><name><name>targetPolicy</name><operator>-&gt;</operator><name>nattrs</name></name></expr></argument>,
										  <argument><expr><name><name>targetPolicy</name><operator>-&gt;</operator><name>attrs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>hashOpfamilies</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>targetPolicy</name><operator>-&gt;</operator><name>nattrs</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>opfamily</name> <init>= <expr><call><name>get_opclass_family</name><argument_list>(<argument><expr><name><name>targetPolicy</name><operator>-&gt;</operator><name>opclasses</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>hashOpfamilies</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>hashOpfamilies</name></expr></argument>, <argument><expr><name>opfamily</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * If there is no distribution key, don't do direct dispatch.
	 *
	 * GPDB_90_MERGE_FIXME: Is that the right thing to do? Couldn't we
	 * direct dispatch to any arbitrarily chosen segment, in that case?
	 */</comment>
	<expr_stmt><expr><name>numHashAttrs</name> <operator>=</operator> <name><name>targetPolicy</name><operator>-&gt;</operator><name>nattrs</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>numHashAttrs</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Get hash functions for the columns. */</comment>
		<expr_stmt><expr><name>hashFuncs</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>numHashAttrs</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>hashExprs</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>elem</name> <init>= <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>att_type</name> <init>= <expr><call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>elem</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>opclass</name> <init>= <expr><name><name>targetPolicy</name><operator>-&gt;</operator><name>opclasses</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>hashFuncs</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator>
				<call><name>cdb_hashproc_in_opfamily</name><argument_list>(<argument><expr><call><name>get_opclass_family</name><argument_list>(<argument><expr><name>opclass</name></expr></argument>)</argument_list></call></expr></argument>,
										 <argument><expr><name>att_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<comment type="block">/*
		 * all constants in values clause -- no need to repartition.
		 */</comment>

		<comment type="block">/* copy the attributes array */</comment>
		<expr_stmt><expr><name>hashAttrs</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>numHashAttrs</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>AttrNumber</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numHashAttrs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>hashAttrs</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>targetPolicy</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>

		<if_stmt><if>if <condition>(<expr><name><name>subroot</name><operator>-&gt;</operator><name>config</name><operator>-&gt;</operator><name>gp_enable_direct_dispatch</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>DirectDispatchUpdateContentIdsForInsert</name><argument_list>(<argument><expr><name>subroot</name></expr></argument>,
													<argument><expr><operator>&amp;</operator><name><name>resultplan</name><operator>-&gt;</operator><name>plan</name></name></expr></argument>,
													<argument><expr><name>targetPolicy</name></expr></argument>,
													<argument><expr><name>hashFuncs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * we now either have a hash-code, or we've marked the plan
			 * non-directed.
			 */</comment>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name><name>resultplan</name><operator>-&gt;</operator><name>numHashFilterCols</name></name> <operator>=</operator> <name>numHashAttrs</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>resultplan</name><operator>-&gt;</operator><name>hashFilterColIdx</name></name> <operator>=</operator> <name>hashAttrs</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>resultplan</name><operator>-&gt;</operator><name>hashFilterFuncs</name></name> <operator>=</operator> <name>hashFuncs</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>resultplan</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <name>resultplan</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Does the given expression contain Params that are passed down from
 * outer query?
 */</comment>
<function><type><name>bool</name></type>
<name>contains_outer_params</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name> <init>= <expr><operator>(</operator><name>PlannerInfo</name> <operator>*</operator><operator>)</operator> <name>context</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Param</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Param</name>	   <modifier>*</modifier></type><name>param</name> <init>= <expr><operator>(</operator><name>Param</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>param</name><operator>-&gt;</operator><name>paramkind</name></name> <operator>==</operator> <name>PARAM_EXEC</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Does this Param refer to a value that an outer query provides? */</comment>
			<decl_stmt><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>parent</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>parent_root</name></name></expr></init></decl>;</decl_stmt>

			<while>while <condition>(<expr><name>parent</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

				<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>parent-&gt;plan_params</argument>)</argument_list></macro>
				<block>{<block_content>
					<decl_stmt><decl><type><name>PlannerParamItem</name> <modifier>*</modifier></type><name>ppi</name> <init>= <expr><operator>(</operator><name>PlannerParamItem</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><name><name>ppi</name><operator>-&gt;</operator><name>paramId</name></name> <operator>==</operator> <name><name>param</name><operator>-&gt;</operator><name>paramid</name></name></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>		<comment type="block">/* abort the tree traversal and return true */</comment>
				</block_content>}</block>

				<expr_stmt><expr><name>parent</name> <operator>=</operator> <name><name>parent</name><operator>-&gt;</operator><name>parent_root</name></name></expr>;</expr_stmt>
			</block_content>}</block></while>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>contains_outer_params</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
</unit>
