<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/backend/cdb/cdbllize.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * cdbllize.c
 *	  Parallelize a PostgreSQL sequential plan tree.
 *
 * Portions Copyright (c) 2005-2008, Greenplum inc
 * Portions Copyright (c) 2012-Present VMware, Inc. or its affiliates.
 *
 * This file contains functions to process plan tree, at various stages in
 * planning, to produce a parallelize MPP plan. Outline of the stages,
 * as they happen in standard_planner():
 *
 * 1. Call subquery_planner(), to build the best Path.
 *
 * 2. Call cdbllize_adjust_top_path().
 *
 *    cdbllize_adjust_top_path() adds Motion paths on top of the best Path, so
 *    that the query's final result is made available at the correct nodes.
 *    That's usually the QD node, so that the QD can send the query result
 *    back to the client, but in a DML statement or CREATE TABLE AS, the final
 *    result might be needed in the segments instead.
 *
 *    (There's a similar function for Init Plans,
 *    cdbllize_adjust_init_plan_path(). The planner calls it when it builds
 *    Paths for SubPlans that are run as Init Plans before the main query.)
 *
 * 3. Call create_plan() to turn the best Path into a Plan tree.
 *
 * 4. Call cdbllize_decorate_subplans_with_motions()
 *
 *    cdbllize_decorate_subplans_with_motions() adds Motions to subplans as
 *    needed, to make subplan results available in the parent nodes.
 *
 * 5. Call set_plan_references()
 *
 * 6. Call cdbllize_build_slice_table().
 *
 *    cdbllize_build_slice_table() assigns slice IDs to Motion nodes, and
 *    builds the slice table needed by the executor to set up the gang of
 *    processes and the interconnects between them. It also eliminates unused
 *    subplans, and zaps some fields from the Query tree that are not needed
 *    after planning, to reduce the amount of data that needs to be dispatched.
 *
 *
 * In addition to the above-mentioned functions, there's a
 * motion_sanity_check() function, which is used to check that the query
 * plan doesn't contain deadlock hazards involving Motions across nodes.
 *
 * IDENTIFICATION
 *	    src/backend/cdb/cdbllize.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_am.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/defrem.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/clauses.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/pathnode.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/primnodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/parsenodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/plannodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/print.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/paths.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/planmain.h"</cpp:file></cpp:include> <comment type="block">/* for make_result() */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parsetree.h"</cpp:file></cpp:include>	<comment type="block">/* for rt_fetch() */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>	<comment type="block">/* for makeTargetEntry() */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/guc.h"</cpp:file></cpp:include>			<comment type="block">/* for Debug_pretty_print */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbhash.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbvars.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbpath.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbplan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbpullup.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbllize.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbmutate.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbutil.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/tlist.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/optimizer.h"</cpp:file></cpp:include> <comment type="block">/* for contain_volatile_functions() */</comment>

<comment type="block">/*
 * decorate_subplans_with_motions_context holds state for the recursive
 * cdbllize_decorate_subplans_with_motions() function.
 */</comment>
<typedef>typedef <type><struct>struct <name>decorate_subplan_info</name>
<block>{
	<decl_stmt><decl><type><name>int</name></type>			<name>sliceDepth</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Flow</name>	   <modifier>*</modifier></type><name>parentFlow</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>is_initplan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>useHashTable</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>processed</name></decl>;</decl_stmt>

}</block></struct></type> <name>decorate_subplan_info</name>;</typedef>

<typedef>typedef <type><struct>struct <name>decorate_subplans_with_motions_context</name>
<block>{
	<decl_stmt><decl><type><name>plan_tree_base_prefix</name></type> <name>base</name></decl>;</decl_stmt> <comment type="block">/* Required prefix for
								 * plan_tree_walker/mutator */</comment>

	<comment type="block">/* Queue of subplan IDs that we seen, but processed yet. */</comment>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>subplan_workingQueue</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * array, one element for each subplan. Use subplans[plan_id - 1] to
	 * access the struct for a particular subplan.
	 */</comment>
	<decl_stmt><decl><type><name>decorate_subplan_info</name> <modifier>*</modifier></type><name>subplans</name></decl>;</decl_stmt>

	<comment type="block">/* Current position in the tree. */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>sliceDepth</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Flow</name>	   <modifier>*</modifier></type><name>currentPlanFlow</name></decl>;</decl_stmt>
}</block></struct></type> <name>decorate_subplans_with_motions_context</name>;</typedef>

<comment type="block">/* State for the recursive build_slice_table() function. */</comment>
<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>plan_tree_base_prefix</name></type> <name>base</name></decl>;</decl_stmt> <comment type="block">/* Required prefix for
								 * plan_tree_walker/mutator */</comment>

	<comment type="block">/*
	 * PlanSlice structs. Indexed by slice Id. This List is converted
	 * into an array, for PlannedStmt-&gt;slices, at the end of
	 * build_slice_table().
	 */</comment>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>slices</name></decl>;</decl_stmt>

	<comment type="block">/* Current slice in the traversal. */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>currentSliceIndex</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Subplan IDs that we have seen. Used to prevent scanning the
	 * same subplan more than once, even if there are multiple SubPlan
	 * nodes referring it, and to eliminate unused subplans.
	 */</comment>
	<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>seen_subplans</name></decl>;</decl_stmt>
}</block></struct></type> <name>build_slice_table_context</name>;</typedef>

<comment type="block">/*
 * Forward Declarations
 */</comment>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>fix_outer_query_motions_mutator</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>decorate_subplans_with_motions_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Plan</name> <modifier>*</modifier></type><name>fix_subplan_motion</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>subplan</name></decl></parameter>, <parameter><decl><type><name>Flow</name> <modifier>*</modifier></type><name>outer_query_flow</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>build_slice_table_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>build_slice_table_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>adjust_top_path_for_parallel_retrieve_cursor</name><parameter_list>(<parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>PlanSlice</name> <modifier>*</modifier></type><name>slice</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * Create a GpPolicy that matches the natural distribution of the given plan.
 *
 * This is used with CREATE TABLE AS, to derive the distribution
 * key for the table from the query plan.
 */</comment>
<function><type><specifier>static</specifier> <name>GpPolicy</name> <modifier>*</modifier></type>
<name>get_partitioned_policy_from_path</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Find out what the flow is partitioned on */</comment>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>policykeys</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>policyopclasses</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>dk_cell</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>ec_cell</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>em_cell</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Is it a Hashed distribution?
	 *
	 * NOTE: HashedOJ is not OK, because we cannot let the NULLs be stored
	 * multiple segments.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>path</name><operator>-&gt;</operator><name>locus</name><operator>.</operator><name>locustype</name></name> <operator>!=</operator> <name>CdbLocusType_Hashed</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>policykeys</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>policyopclasses</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>dk_cell</argument>, <argument>path-&gt;locus.distkey</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>DistributionKey</name> <modifier>*</modifier></type><name>dk</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>dk_cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>found_expr</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>ec_cell</argument>, <argument>dk-&gt;dk_eclasses</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>EquivalenceClass</name> <modifier>*</modifier></type><name>ec</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>ec_cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<while>while <condition>(<expr><name><name>ec</name><operator>-&gt;</operator><name>ec_merged</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>ec</name> <operator>=</operator> <name><name>ec</name><operator>-&gt;</operator><name>ec_merged</name></name></expr>;</expr_stmt></block_content></block></while>

			<macro><name>foreach</name><argument_list>(<argument>em_cell</argument>, <argument>ec-&gt;ec_members</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>EquivalenceMember</name> <modifier>*</modifier></type><name>em</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>em_cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>var1</name> <init>= <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name><name>em</name><operator>-&gt;</operator><name>em_expr</name></name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>attno</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>tle_cell</name></decl>;</decl_stmt>

				<comment type="block">/*
				 * Right side variable may be encapsulated by a relabel node.
				 * Motion, however, does not care about relabel nodes.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>var1</name></expr></argument>, <argument><expr><name>RelabelType</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>var1</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>RelabelType</name> <operator>*</operator><operator>)</operator> <name>var1</name><operator>)</operator><operator>-&gt;</operator><name>arg</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<comment type="block">/* See if this Expr is a column of the result table */</comment>
				<expr_stmt><expr><name>attno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				<macro><name>foreach</name><argument_list>(<argument>tle_cell</argument>, <argument>root-&gt;processed_tlist</argument>)</argument_list></macro>
				<block>{<block_content>
					<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>target</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>tle_cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<expr_stmt><expr><name>attno</name><operator>++</operator></expr>;</expr_stmt>

					<if_stmt><if>if <condition>(<expr><name><name>target</name><operator>-&gt;</operator><name>resjunk</name></name></expr>)</condition><block type="pseudo"><block_content>
						<continue>continue;</continue></block_content></block></if></if_stmt>

					<if_stmt><if>if <condition>(<expr><call><name>equal</name><argument_list>(<argument><expr><name>var1</name></expr></argument>, <argument><expr><name><name>target</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/*
						 * If it is, use it to partition the result table, to avoid
						 * unnecessary redistribution of data
						 */</comment>
						<decl_stmt><decl><type><name>Oid</name></type>			<name>opclass</name></decl>;</decl_stmt>
						<decl_stmt><decl><type><name>Oid</name></type>			<name>eqop</name></decl>;</decl_stmt>
						<decl_stmt><decl><type><name>Oid</name></type>			<name>typeid</name></decl>;</decl_stmt>
						<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>opfam_cell</name></decl>;</decl_stmt>

						<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>policykeys</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>MaxPolicyAttributeNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<if_stmt><if>if <condition>(<expr><call><name>list_member_int</name><argument_list>(<argument><expr><name>policykeys</name></expr></argument>, <argument><expr><name>attno</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
									<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DUPLICATE_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
									 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"duplicate DISTRIBUTED BY column '%s'"</literal></expr></argument>,
											<argument><expr><ternary><condition><expr><name><name>target</name><operator>-&gt;</operator><name>resname</name></name></expr> ?</condition><then> <expr><name><name>target</name><operator>-&gt;</operator><name>resname</name></name></expr> </then><else>: <expr><literal type="string">"???"</literal></expr></else></ternary></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

						<comment type="block">/*
						 * We know the btree operator family corresponding to
						 * the distribution, but we don't know the exact
						 * hash operator class that corresponds to that. In
						 * the common case, the datatype has exactly one
						 * default operator class, and you usually use only
						 * that. So look up the default operator class for the
						 * datatype, and if it's compatible with the btree
						 * operator family, use that.
						 *
						 * If that fails, we could do some further checks. We
						 * could check if there is some other operator class
						 * for the datatype, and if so, use that. But it
						 * doesn't seem worth adding much extra code to deal
						 * with more obscure cases. Deriving the distribution
						 * key from the query plan is a heuristic, anyway.
						 */</comment>
						<expr_stmt><expr><name>typeid</name> <operator>=</operator> <call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>target</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<expr_stmt><expr><name>opclass</name> <operator>=</operator> <call><name>GetDefaultOpClass</name><argument_list>(<argument><expr><name>typeid</name></expr></argument>, <argument><expr><name>HASH_AM_OID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>eqop</name> <operator>=</operator> <call><name>cdb_eqop_in_hash_opfamily</name><argument_list>(<argument><expr><call><name>get_opclass_family</name><argument_list>(<argument><expr><name>opclass</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>typeid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<macro><name>foreach</name><argument_list>(<argument>opfam_cell</argument>, <argument>ec-&gt;ec_opfamilies</argument>)</argument_list></macro>
						<block>{<block_content>
							<decl_stmt><decl><type><name>Oid</name></type>			<name>btopfamily</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>opfam_cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

							<if_stmt><if>if <condition>(<expr><call><name>get_op_opfamily_strategy</name><argument_list>(<argument><expr><name>eqop</name></expr></argument>, <argument><expr><name>btopfamily</name></expr></argument>)</argument_list></call></expr>)</condition>
							<block>{<block_content>
								<expr_stmt><expr><name>policykeys</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>policykeys</name></expr></argument>, <argument><expr><name>attno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
								<expr_stmt><expr><name>policyopclasses</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>policyopclasses</name></expr></argument>, <argument><expr><name>opclass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
								<expr_stmt><expr><name>found_expr</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
								<break>break;</break>
							</block_content>}</block></if></if_stmt>
						</block_content>}</block>
					</block_content>}</block></if></if_stmt>
					<if_stmt><if>if <condition>(<expr><name>found_expr</name></expr>)</condition><block type="pseudo"><block_content>
						<break>break;</break></block_content></block></if></if_stmt>
				</block_content>}</block>
				<if_stmt><if>if <condition>(<expr><name>found_expr</name></expr>)</condition><block type="pseudo"><block_content>
					<break>break;</break></block_content></block></if></if_stmt>
			</block_content>}</block>
			<if_stmt><if>if <condition>(<expr><name>found_expr</name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
		</block_content>}</block>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found_expr</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * This distribution key is not present in the target list. Give
			 * up.
			 */</comment>
			<return>return <expr><name>NULL</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * We use the default number of segments, even if the flow was partially
	 * distributed. That defeats the performance benefit of using the same
	 * distribution key columns, because we'll need a Restribute Motion
	 * anyway. But presumably if the user had expanded the cluster, they want
	 * to use all the segments for new tables.
	 */</comment>
	<return>return <expr><call><name>createHashPartitionedPolicy</name><argument_list>(<argument><expr><name>policykeys</name></expr></argument>,
									   <argument><expr><name>policyopclasses</name></expr></argument>,
									   <argument><expr><call><name>GP_POLICY_DEFAULT_NUMSEGMENTS</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Get a locus that represents the desired distribution of the query result.
 *
 * This is a stripped down version of the logic in cdbllize_adjut_top_path(),
 * used to hint the planner on where the result is needed. Sometimes, the
 * final distribution is not representable as a locus, a Null locus
 * returned in that case.
 *
 * TODO: This only handles a few cases. For example, INSERT INTO SELECT ...
 * is not handled, because the parser injects a subquery for ti which makes
 * it tricky.
 */</comment>
<function><type><name>CdbPathLocus</name></type>
<name>cdbllize_get_final_locus</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>target</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CdbPathLocus</name></type> <name>nullLocus</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>query</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>parse</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_SELECT</name> <operator>&amp;&amp;</operator>
		<operator>(</operator><name><name>query</name><operator>-&gt;</operator><name>parentStmtType</name></name> <operator>==</operator> <name>PARENTSTMTTYPE_CTAS</name> <operator>||</operator>
		 <name><name>query</name><operator>-&gt;</operator><name>parentStmtType</name></name> <operator>==</operator> <name>PARENTSTMTTYPE_REFRESH_MATVIEW</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* CREATE TABLE AS or SELECT INTO or REFERSH MATERIALIZED VIEW */</comment>
		<decl_stmt><decl><type><name>GpPolicy</name>   <modifier>*</modifier></type><name>intoPolicy</name> <init>= <expr><name><name>query</name><operator>-&gt;</operator><name>intoPolicy</name></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>intoPolicy</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>intoPolicy</name><operator>-&gt;</operator><name>ptype</name></name> <operator>!=</operator> <name>POLICYTYPE_ENTRY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>intoPolicy</name><operator>-&gt;</operator><name>nattrs</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>intoPolicy</name><operator>-&gt;</operator><name>nattrs</name></name> <operator>&lt;=</operator> <name>MaxPolicyAttributeNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>intoPolicy</name><operator>-&gt;</operator><name>ptype</name></name> <operator>==</operator> <name>POLICYTYPE_PARTITIONED</name> <operator>&amp;&amp;</operator>
				<name><name>intoPolicy</name><operator>-&gt;</operator><name>nattrs</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<return>return <expr><call><name>cdbpathlocus_for_insert</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>intoPolicy</name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</return>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name><name>intoPolicy</name><operator>-&gt;</operator><name>ptype</name></name> <operator>==</operator> <name>POLICYTYPE_REPLICATED</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>CdbPathLocus</name></type> <name>locus</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>CdbPathLocus_MakeReplicated</name><argument_list>(<argument><expr><operator>&amp;</operator><name>locus</name></expr></argument>, <argument><expr><name><name>intoPolicy</name><operator>-&gt;</operator><name>numsegments</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>locus</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_SELECT</name> <operator>&amp;&amp;</operator> <name><name>query</name><operator>-&gt;</operator><name>parentStmtType</name></name> <operator>==</operator> <name>PARENTSTMTTYPE_NONE</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Query result needs to be brought back to the QD.
		 *
		 * NOTE: we don't do this for RETURNING list, like cdbllize_adjust_top_path()
		 * does below. The locus we construct here is for the plan result before
		 * evaluating possible RETURNING clauses.
		 */</comment>
		<decl_stmt><decl><type><name>CdbPathLocus</name></type> <name>entryLocus</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>CdbPathLocus_MakeEntry</name><argument_list>(<argument><expr><operator>&amp;</operator><name>entryLocus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return <expr><name>entryLocus</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>CdbPathLocus_MakeNull</name><argument_list>(<argument><expr><operator>&amp;</operator><name>nullLocus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>nullLocus</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * cdbllize_adjust_top_path -- Adjust top Path for MPP
 *
 * Add a Motion to the top of the query path, so that the final result
 * is distributed correctly for the kind of query. For example, an INSERT
 * statement's result must be sent to the correct segments where the data
 * needs to be inserted, and a SELECT query's result must be brought to the
 * dispatcher, so that it can be sent to the client.
 *
 * For a CREATE TABLE AS command, this also determines the distribution
 * policy for the table, if it was not given explicitly with DISTRIBUTED BY.
 *
 * The input is a Path, produced by subquery_planner(). The result is a
 * Path, with a Motion added on top, if needed. Also, *topslice is adjusted
 * to reflect how/where the top slice needs to be executed.
 *
 * NB: keep cdbllize_get_final_locus() up to date with any changes here!
 */</comment>
<function><type><name>Path</name> <modifier>*</modifier></type>
<name>cdbllize_adjust_top_path</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>,
		<parameter><decl><type><name>PlanSlice</name> <modifier>*</modifier></type><name>topslice</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>query</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>parse</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GpPolicy</name>   <modifier>*</modifier></type><name>targetPolicy</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * NOTE: This code makes the assumption that if we are working on a
	 * hierarchy of tables, all the tables are distributed, or all are on the
	 * entry DB.  Any mixture will fail.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>resultRelation</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><call><name>rt_fetch</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>resultRelation</name></name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_RELATION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>targetPolicy</name> <operator>=</operator> <call><name>GpPolicyFetch</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_SELECT</name> <operator>&amp;&amp;</operator> <name><name>query</name><operator>-&gt;</operator><name>parentStmtType</name></name> <operator>==</operator> <name>PARENTSTMTTYPE_CTAS</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* CREATE TABLE AS or SELECT INTO */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>intoPolicy</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>targetPolicy</name> <operator>=</operator> <name><name>query</name><operator>-&gt;</operator><name>intoPolicy</name></name></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>intoPolicy</name><operator>-&gt;</operator><name>ptype</name></name> <operator>!=</operator> <name>POLICYTYPE_ENTRY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>intoPolicy</name><operator>-&gt;</operator><name>nattrs</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>intoPolicy</name><operator>-&gt;</operator><name>nattrs</name></name> <operator>&lt;=</operator> <name>MaxPolicyAttributeNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>gp_create_table_random_default_distribution</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>targetPolicy</name> <operator>=</operator> <call><name>createRandomPartitionedPolicy</name><argument_list>(<argument><expr><call><name>GP_POLICY_DEFAULT_NUMSEGMENTS</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SUCCESSFUL_COMPLETION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"using default RANDOM distribution since no distribution was specified"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Consider including the 'DISTRIBUTED BY' clause to determine the distribution of rows."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* First try to deduce the distribution from the query */</comment>
			<expr_stmt><expr><name>targetPolicy</name> <operator>=</operator> <call><name>get_partitioned_policy_from_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>best_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * If that fails, hash on the first hashable column we can
			 * find.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>targetPolicy</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>policykeys</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>policyopclasses</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>best_path-&gt;pathtarget-&gt;exprs</argument>)</argument_list></macro>
				<block>{<block_content>
					<decl_stmt><decl><type><name>Oid</name></type>			<name>typeOid</name> <init>= <expr><call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>Oid</name></type>			<name>opclass</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>

					<comment type="block">/*
					 * Check for a legacy hash operator class if
					 * gp_use_legacy_hashops GUC is set. If
					 * InvalidOid is returned or the GUC is not
					 * set, we'll get the default operator class.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><name>gp_use_legacy_hashops</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>opclass</name> <operator>=</operator> <call><name>get_legacy_cdbhash_opclass_for_base_type</name><argument_list>(<argument><expr><name>typeOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

					<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>opclass</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>opclass</name> <operator>=</operator> <call><name>cdb_default_distribution_opclass_for_type</name><argument_list>(<argument><expr><name>typeOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


					<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>opclass</name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name>policykeys</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>policykeys</name></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>policyopclasses</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>policyopclasses</name></expr></argument>, <argument><expr><name>opclass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					</block_content>}</block></if></if_stmt>
					<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
				</block_content>}</block>
				<expr_stmt><expr><name>targetPolicy</name> <operator>=</operator> <call><name>createHashPartitionedPolicy</name><argument_list>(<argument><expr><name>policykeys</name></expr></argument>,
														   <argument><expr><name>policyopclasses</name></expr></argument>,
														   <argument><expr><call><name>GP_POLICY_DEFAULT_NUMSEGMENTS</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* If we deduced the policy from the query, give a NOTICE */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>parentStmtType</name></name> <operator>==</operator> <name>PARENTSTMTTYPE_CTAS</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>StringInfoData</name></type> <name>columnsbuf</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>columnsbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>targetPolicy</name><operator>-&gt;</operator><name>nattrs</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
				<block>{<block_content>
					<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>target</name> <init>= <expr><call><name>get_tle_by_resno</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>processed_tlist</name></name></expr></argument>, <argument><expr><name><name>targetPolicy</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>columnsbuf</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<if_stmt><if>if <condition>(<expr><name><name>target</name><operator>-&gt;</operator><name>resname</name></name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>columnsbuf</name></expr></argument>, <argument><expr><name><name>target</name><operator>-&gt;</operator><name>resname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>columnsbuf</name></expr></argument>, <argument><expr><literal type="string">"???"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

				</block_content>}</block></for>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SUCCESSFUL_COMPLETION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Table doesn't have 'DISTRIBUTED BY' clause -- Using column(s) "</literal>
								<literal type="string">"named '%s' as the Greenplum Database data distribution key for this "</literal>
								<literal type="string">"table. "</literal></expr></argument>, <argument><expr><name><name>columnsbuf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"The 'DISTRIBUTED BY' clause determines the distribution of data."</literal>
								 <literal type="string">" Make sure column(s) chosen are the optimal data distribution key to minimize skew."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>targetPolicy</name><operator>-&gt;</operator><name>ptype</name></name> <operator>!=</operator> <name>POLICYTYPE_ENTRY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>intoPolicy</name></name> <operator>=</operator> <name>targetPolicy</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>GpPolicyIsReplicated</name><argument_list>(<argument><expr><name>targetPolicy</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<operator>!</operator><call><name>contain_volatile_functions</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name><operator>*</operator><operator>)</operator> <name><name>query</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<operator>!</operator><call><name>contain_volatile_functions</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name><operator>*</operator><operator>)</operator> <name><name>query</name><operator>-&gt;</operator><name>havingQual</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>CdbPathLocus</name></type> <name>replicatedLocus</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>CdbPathLocus_MakeReplicated</name><argument_list>(<argument><expr><operator>&amp;</operator><name>replicatedLocus</name></expr></argument>,
										<argument><expr><name><name>targetPolicy</name><operator>-&gt;</operator><name>numsegments</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>best_path</name> <operator>=</operator> <call><name>cdbpath_create_motion_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
												   <argument><expr><name>best_path</name></expr></argument>,
												   <argument><expr><name>NIL</name></expr></argument>,
												   <argument><expr><name>false</name></expr></argument>,
												   <argument><expr><name>replicatedLocus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * Make sure the top level flow is partitioned on the
			 * partitioning key of the target relation.	Since this is
			 * a SELECT INTO (basically same as an INSERT) command,
			 * the target list will correspond to the attributes of
			 * the target relation in order.
			 */</comment>
			<expr_stmt><expr><name>best_path</name> <operator>=</operator> <call><name>create_motion_path_for_ctas</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>targetPolicy</name></expr></argument>,
													<argument><expr><name>best_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name><name>topslice</name><operator>-&gt;</operator><name>numsegments</name></name> <operator>=</operator> <name><name>targetPolicy</name><operator>-&gt;</operator><name>numsegments</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>topslice</name><operator>-&gt;</operator><name>segindex</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>topslice</name><operator>-&gt;</operator><name>gangType</name></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>targetPolicy</name><operator>-&gt;</operator><name>ptype</name></name> <operator>==</operator> <name>POLICYTYPE_ENTRY</name><operator>)</operator></expr> ?</condition><then> <expr><name>GANGTYPE_UNALLOCATED</name></expr> </then><else>: <expr><name>GANGTYPE_PRIMARY_WRITER</name></expr></else></ternary></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_SELECT</name> <operator>&amp;&amp;</operator> <name><name>query</name><operator>-&gt;</operator><name>parentStmtType</name></name> <operator>==</operator> <name>PARENTSTMTTYPE_REFRESH_MATVIEW</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * REFRESH MATERIALIZED VIEW
		 *
		 * This is the same as the logic for CREATE TABLE AS with an explicit
		 * DISTRIBUTED BY above.
		 */</comment>
		<expr_stmt><expr><name>targetPolicy</name> <operator>=</operator> <name><name>query</name><operator>-&gt;</operator><name>intoPolicy</name></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>targetPolicy</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"materialized view has no distribution policy"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>targetPolicy</name><operator>-&gt;</operator><name>ptype</name></name> <operator>==</operator> <name>POLICYTYPE_ENTRY</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"materialized view with entry distribution policy not supported"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>GpPolicyIsReplicated</name><argument_list>(<argument><expr><name>targetPolicy</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>CdbPathLocus</name></type> <name>broadcastLocus</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>CdbPathLocus_MakeSegmentGeneral</name><argument_list>(<argument><expr><operator>&amp;</operator><name>broadcastLocus</name></expr></argument>,
											<argument><expr><name><name>targetPolicy</name><operator>-&gt;</operator><name>numsegments</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>best_path</name> <operator>=</operator> <call><name>cdbpath_create_motion_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
												   <argument><expr><name>best_path</name></expr></argument>,
												   <argument><expr><name>NIL</name></expr></argument>,
												   <argument><expr><name>false</name></expr></argument>,
												   <argument><expr><name>broadcastLocus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * Make sure the top level flow is partitioned on the
			 * partitioning key of the target relation.	Since this is
			 * a SELECT INTO (basically same as an INSERT) command,
			 * the target list will correspond to the attributes of
			 * the target relation in order.
			 */</comment>
			<expr_stmt><expr><name>best_path</name> <operator>=</operator> <call><name>create_motion_path_for_insert</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>targetPolicy</name></expr></argument>,
													  <argument><expr><name>best_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name><name>topslice</name><operator>-&gt;</operator><name>numsegments</name></name> <operator>=</operator> <name><name>targetPolicy</name><operator>-&gt;</operator><name>numsegments</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>topslice</name><operator>-&gt;</operator><name>segindex</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>topslice</name><operator>-&gt;</operator><name>gangType</name></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>targetPolicy</name><operator>-&gt;</operator><name>ptype</name></name> <operator>==</operator> <name>POLICYTYPE_ENTRY</name><operator>)</operator></expr> ?</condition><then> <expr><name>GANGTYPE_UNALLOCATED</name></expr> </then><else>: <expr><name>GANGTYPE_PRIMARY_WRITER</name></expr></else></ternary></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_SELECT</name> <operator>&amp;&amp;</operator> <name><name>query</name><operator>-&gt;</operator><name>parentStmtType</name></name> <operator>==</operator> <name>PARENTSTMTTYPE_COPY</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* COPY (SELECT ...) TO */</comment>
		<expr_stmt><expr><name><name>topslice</name><operator>-&gt;</operator><name>directDispatch</name><operator>.</operator><name>isDirectDispatch</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>topslice</name><operator>-&gt;</operator><name>directDispatch</name><operator>.</operator><name>haveProcessedAnyCalculations</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>topslice</name><operator>-&gt;</operator><name>numsegments</name></name> <operator>=</operator> <call><name>getgpsegmentCount</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>topslice</name><operator>-&gt;</operator><name>segindex</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>topslice</name><operator>-&gt;</operator><name>gangType</name></name> <operator>=</operator> <name>GANGTYPE_PRIMARY_READER</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_SELECT</name> <operator>||</operator>
			 <name><name>query</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_INSERT</name> <operator>||</operator>
			 <name><name>query</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_UPDATE</name> <operator>||</operator>
			 <name><name>query</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_DELETE</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>parentStmtType</name></name> <operator>==</operator> <name>PARENTSTMTTYPE_NONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_SELECT</name> <operator>||</operator> <name><name>query</name><operator>-&gt;</operator><name>returningList</name></name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>root</name><operator>-&gt;</operator><name>glob</name><operator>-&gt;</operator><name>is_parallel_cursor</name></name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * Query result needs to be brought back to the QD. Ask for
				 * a motion to bring it in. If the result already has the
				 * right locus, cdbpath_create_motion_path() will return it
				 * unmodified.
				 *
				 * If the query has an ORDER BY clause, use Merge Receive to
				 * preserve the ordering. The plan has already been set up to
				 * ensure each qExec's result is properly ordered according to
				 * the ORDER BY specification.
				 */</comment>
				<decl_stmt><decl><type><name>CdbPathLocus</name></type> <name>entryLocus</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>CdbPathLocus_MakeEntry</name><argument_list>(<argument><expr><operator>&amp;</operator><name>entryLocus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * In a Motion to Entry locus, the numsegments indicates the
				 * number of segments in the *sender*.
				 */</comment>
				<expr_stmt><expr><name><name>entryLocus</name><operator>.</operator><name>numsegments</name></name> <operator>=</operator> <name><name>best_path</name><operator>-&gt;</operator><name>locus</name><operator>.</operator><name>numsegments</name></name></expr>;</expr_stmt>

				<expr_stmt><expr><name>best_path</name> <operator>=</operator> <call><name>cdbpath_create_motion_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
													   <argument><expr><name>best_path</name></expr></argument>,
													   <argument><expr><name><name>root</name><operator>-&gt;</operator><name>sort_pathkeys</name></name></expr></argument>,
													   <argument><expr><name>false</name></expr></argument>,
													   <argument><expr><name>entryLocus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>topslice</name><operator>-&gt;</operator><name>numsegments</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>topslice</name><operator>-&gt;</operator><name>segindex</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>topslice</name><operator>-&gt;</operator><name>gangType</name></name> <operator>=</operator> <name>GANGTYPE_UNALLOCATED</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>adjust_top_path_for_parallel_retrieve_cursor</name><argument_list>(<argument><expr><name>best_path</name></expr></argument>, <argument><expr><name>topslice</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name><name>topslice</name><operator>-&gt;</operator><name>numsegments</name></name> <operator>=</operator> <name><name>targetPolicy</name><operator>-&gt;</operator><name>numsegments</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>topslice</name><operator>-&gt;</operator><name>segindex</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>topslice</name><operator>-&gt;</operator><name>gangType</name></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>targetPolicy</name><operator>-&gt;</operator><name>ptype</name></name> <operator>==</operator> <name>POLICYTYPE_ENTRY</name><operator>)</operator></expr> ?</condition><then> <expr><name>GANGTYPE_UNALLOCATED</name></expr> </then><else>: <expr><name>GANGTYPE_PRIMARY_WRITER</name></expr></else></ternary></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_UTILITY</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* nothing to do */</comment>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unknown command type %d"</literal></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>commandType</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<return>return <expr><name>best_path</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * cdbllize_adjust_init_plan_path -- Adjust Init Plan's Path for MPP
 *
 * Init Plans are dispatched and executed before the main query. Adjust the
 * Path to bring the result back to the QD.
 */</comment>
<function><type><name>Path</name> <modifier>*</modifier></type>
<name>cdbllize_adjust_init_plan_path</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>best_path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CdbPathLocus</name></type> <name>entryLocus</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>CdbPathLocus_MakeEntry</name><argument_list>(<argument><expr><operator>&amp;</operator><name>entryLocus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * In a Motion to Entry locus, the numsegments indicates the
	 * number of segments in the *sender*.
	 */</comment>
	<expr_stmt><expr><name><name>entryLocus</name><operator>.</operator><name>numsegments</name></name> <operator>=</operator> <name><name>best_path</name><operator>-&gt;</operator><name>locus</name><operator>.</operator><name>numsegments</name></name></expr>;</expr_stmt>

	<return>return <expr><call><name>cdbpath_create_motion_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
									  <argument><expr><name>best_path</name></expr></argument>,
									  <argument><expr><name><name>root</name><operator>-&gt;</operator><name>sort_pathkeys</name></name></expr></argument>,
									  <argument><expr><name>false</name></expr></argument>,
									  <argument><expr><name>entryLocus</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * cdbllize_decorate_subplans_with_motions - Adjust subplans for MPP.
 *
 * This function adds Motion nodes on top of plan trees for SubPlans, so that
 * the subplan results are available at the correct segment for the outer
 * query. It also fixes up any MOTIONTYPE_OUTER_QUERY Motions, changing them
 * into Gather or Broadcast Motions, depending on the parent slice. The plan
 * tree can contain outer-query Motions, even if there are no SubPlans, if it
 * contains subquery RTEs.
 *
 * The input is a Plan tree, from create_plan().
 *
 * Outline of processing:
 *
 * - Walk through the main Plan tree. Make note of all SubPlan expressions,
 *   and the context they appear in.
 *
 * - Recurse to process each subplan that was encountered. At the top of the
 *   subplan, add a Motion if needed, so that the result of the subplan is
 *   available in the outer slice. For example, if the SubPlan appears in
 *   a slice that's executed only on a single QE node, then the subplan's
 *   result must also be present at that node. A Gather Motion is put on
 *   top of the subplan, if needed. Or if the parent slice is executes on all
 *   nodes (Replicated or Partitioned), then a Broadcast Motion is put on
 *   top of the subplan, unless the subplan's result is already available on
 *   all QEs.
 *
 * - If any of the subplans contained more SubPlan expressions, process those
 *   too.
 *
 * The result is a deep copy of the argument Plan tree with added/modified
 * Motion nodes, or the original Plan tree unmodified if no changes are
 * needed.
 *
 * Note: Subqueries in from-list can contain MOTIONTYPE_OUTER_QUERY Motions,
 * too, so we need to scan the tree even if there are no SubPlans.
 */</comment>
<function><type><name>Plan</name> <modifier>*</modifier></type>
<name>cdbllize_decorate_subplans_with_motions</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>plan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>decorate_subplans_with_motions_context</name></type> <name>context</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nsubplans</name></decl>;</decl_stmt>

	<comment type="block">/* Initialize mutator context. */</comment>
	<expr_stmt><expr><call><name>planner_init_plan_tree_base</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>context</name><operator>.</operator><name>base</name></name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>sliceDepth</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>subplan_workingQueue</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>nsubplans</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>glob</name><operator>-&gt;</operator><name>subplans</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>subplans</name></name> <operator>=</operator> <operator>(</operator><name>decorate_subplan_info</name> <operator>*</operator><operator>)</operator>
		<call><name>palloc</name><argument_list>(<argument><expr><operator>(</operator><name>nsubplans</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>decorate_subplan_info</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>nsubplans</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>decorate_subplan_info</name> <modifier>*</modifier></type><name>sstate</name> <init>= <expr><operator>&amp;</operator><name><name>context</name><operator>.</operator><name>subplans</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>sstate</name><operator>-&gt;</operator><name>sliceDepth</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sstate</name><operator>-&gt;</operator><name>parentFlow</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sstate</name><operator>-&gt;</operator><name>is_initplan</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sstate</name><operator>-&gt;</operator><name>processed</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Process the main plan tree.
	 */</comment>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>currentPlanFlow</name></name> <operator>=</operator> <name><name>plan</name><operator>-&gt;</operator><name>flow</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>fix_outer_query_motions_mutator</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>plan</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Process any SubPlans that were reachable from the main plan tree.
	 * While we process the SubPlans, we might encounter more SubPlans.
	 * They will be added to the working queue, so keep going until the
	 * working queue is empty.
	 */</comment>
	<while>while <condition>(<expr><name><name>context</name><operator>.</operator><name>subplan_workingQueue</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>plan_id</name> <init>= <expr><call><name>linitial_int</name><argument_list>(<argument><expr><name><name>context</name><operator>.</operator><name>subplan_workingQueue</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>decorate_subplan_info</name> <modifier>*</modifier></type><name>sstate</name> <init>= <expr><operator>&amp;</operator><name><name>context</name><operator>.</operator><name>subplans</name><index>[<expr><name>plan_id</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>planlist_cell</name> <init>= <expr><call><name>list_nth_cell</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>glob</name><operator>-&gt;</operator><name>subplans</name></name></expr></argument>, <argument><expr><name>plan_id</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>subplan</name> <init>= <expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>planlist_cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>context</name><operator>.</operator><name>subplan_workingQueue</name></name> <operator>=</operator> <call><name>list_delete_first</name><argument_list>(<argument><expr><name><name>context</name><operator>.</operator><name>subplan_workingQueue</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>sstate</name><operator>-&gt;</operator><name>processed</name></name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>sstate</name><operator>-&gt;</operator><name>is_initplan</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"SubPlan %d already processed"</literal></expr></argument>, <argument><expr><name>plan_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name><name>sstate</name><operator>-&gt;</operator><name>processed</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>sstate</name><operator>-&gt;</operator><name>is_initplan</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * InitPlans are dispatched separately, before the main plan,
			 * and the result is brought to the QD.
			 */</comment>
			<decl_stmt><decl><type><name>Flow</name>	   <modifier>*</modifier></type><name>topFlow</name> <init>= <expr><call><name>makeFlow</name><argument_list>(<argument><expr><name>FLOW_SINGLETON</name></expr></argument>, <argument><expr><call><name>getgpsegmentCount</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>topFlow</name><operator>-&gt;</operator><name>segindex</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>context</name><operator>.</operator><name>sliceDepth</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>context</name><operator>.</operator><name>currentPlanFlow</name></name> <operator>=</operator> <name>topFlow</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name><name>context</name><operator>.</operator><name>sliceDepth</name></name> <operator>=</operator> <name><name>sstate</name><operator>-&gt;</operator><name>sliceDepth</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>context</name><operator>.</operator><name>currentPlanFlow</name></name> <operator>=</operator> <name><name>sstate</name><operator>-&gt;</operator><name>parentFlow</name></name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>subplan</name><operator>-&gt;</operator><name>flow</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"subplan is missing Flow information"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * If the subquery result is not available where the outer query needs it,
		 * we have to add a Motion node to redistribute it.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>subplan</name><operator>-&gt;</operator><name>flow</name><operator>-&gt;</operator><name>locustype</name></name> <operator>!=</operator> <name>CdbLocusType_OuterQuery</name> <operator>&amp;&amp;</operator>
			<name><name>subplan</name><operator>-&gt;</operator><name>flow</name><operator>-&gt;</operator><name>locustype</name></name> <operator>!=</operator> <name>CdbLocusType_SegmentGeneral</name> <operator>&amp;&amp;</operator>
			<name><name>subplan</name><operator>-&gt;</operator><name>flow</name><operator>-&gt;</operator><name>locustype</name></name> <operator>!=</operator> <name>CdbLocusType_General</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>subplan</name> <operator>=</operator> <call><name>fix_subplan_motion</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>subplan</name></expr></argument>, <argument><expr><name><name>context</name><operator>.</operator><name>currentPlanFlow</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * If we created a Motion, protect it from rescanning. Init Plans
			 * and hashed SubPlans are never rescanned.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>subplan</name></expr></argument>, <argument><expr><name>Motion</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>sstate</name><operator>-&gt;</operator><name>is_initplan</name></name> <operator>&amp;&amp;</operator>
				<operator>!</operator><name><name>sstate</name><operator>-&gt;</operator><name>useHashTable</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>subplan</name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>make_material</name><argument_list>(<argument><expr><name>subplan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>subplan</name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>fix_outer_query_motions_mutator</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>subplan</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>planlist_cell</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>subplan</name></expr>;</expr_stmt>
	</block_content>}</block></while>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Workhorse for cdbllize_fix_outer_query_motions().
 */</comment>
<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>fix_outer_query_motions_mutator</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>decorate_subplans_with_motions_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>newnode</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>plan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Flow</name>	   <modifier>*</modifier></type><name>saveCurrentPlanFlow</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ASSERT_CHECKING</name></cpp:ifdef>
	<decl_stmt><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name> <init>= <expr><operator>(</operator><name>PlannerInfo</name> <operator>*</operator><operator>)</operator> <name><name>context</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>node</name></name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>root</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>PlannerInfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* An expression node might have subtrees containing plans to be mutated. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_plan_node</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>node</name> <operator>=</operator> <call><name>plan_tree_mutator</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>fix_outer_query_motions_mutator</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If we see a SubPlan, remember the context where we saw it. We memorize
		 * the parent's node's Flow, so that we know where the SubPlan needs to
		 * bring the result. There might be multiple references to the same SubPlan,
		 * if e.g. the result of the SubPlan is passed up the plan for use in later
		 * joins or for the final target list. Remember the *deepest* slice level
		 * where we saw it. We cannot pass SubPlan's result down the tree, but we
		 * can propagate it upwards if we put it to the target list. So it needs
		 * to be calculated at the bottom level, and propagated up from there.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>SubPlan</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>SubPlan</name>	   <modifier>*</modifier></type><name>spexpr</name> <init>= <expr><operator>(</operator><name>SubPlan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>decorate_subplan_info</name> <modifier>*</modifier></type><name>sstate</name> <init>= <expr><operator>&amp;</operator><name><name>context</name><operator>-&gt;</operator><name>subplans</name><index>[<expr><name><name>spexpr</name><operator>-&gt;</operator><name>plan_id</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>sstate</name><operator>-&gt;</operator><name>is_initplan</name></name> <operator>=</operator> <name><name>spexpr</name><operator>-&gt;</operator><name>is_initplan</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>sstate</name><operator>-&gt;</operator><name>useHashTable</name></name> <operator>=</operator> <name><name>spexpr</name><operator>-&gt;</operator><name>useHashTable</name></name></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>sstate</name><operator>-&gt;</operator><name>processed</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"found reference to already-processed SubPlan"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>sstate</name><operator>-&gt;</operator><name>sliceDepth</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>subplan_workingQueue</name></name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>subplan_workingQueue</name></name></expr></argument>,
															<argument><expr><name><name>spexpr</name><operator>-&gt;</operator><name>plan_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>spexpr</name><operator>-&gt;</operator><name>is_initplan</name></name> <operator>&amp;&amp;</operator> <name><name>context</name><operator>-&gt;</operator><name>sliceDepth</name></name> <operator>&gt;</operator> <name><name>sstate</name><operator>-&gt;</operator><name>sliceDepth</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>sstate</name><operator>-&gt;</operator><name>sliceDepth</name></name> <operator>=</operator> <name><name>context</name><operator>-&gt;</operator><name>sliceDepth</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>sstate</name><operator>-&gt;</operator><name>parentFlow</name></name> <operator>=</operator> <name><name>context</name><operator>-&gt;</operator><name>currentPlanFlow</name></name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
		<return>return <expr><name>node</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>plan</name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><name>Motion</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Motion</name>	   <modifier>*</modifier></type><name>motion</name> <init>= <expr><operator>(</operator><name>Motion</name> <operator>*</operator><operator>)</operator> <name>plan</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* sanity check: Sub plan must have flow */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>motion</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>lefttree</name><operator>-&gt;</operator><name>flow</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* sanity check: we haven't assigned slice/motion IDs yet */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>motion</name><operator>-&gt;</operator><name>motionID</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Recurse into the Motion's initPlans and other fields, and the
		 * subtree.
		 *
		 * All the fields on the Motion node are considered part of the sending
		 * slice.
		 */</comment>
		<expr_stmt><expr><name>saveCurrentPlanFlow</name> <operator>=</operator> <name><name>context</name><operator>-&gt;</operator><name>currentPlanFlow</name></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>plan</name><operator>-&gt;</operator><name>lefttree</name><operator>-&gt;</operator><name>flow</name><operator>-&gt;</operator><name>locustype</name></name> <operator>!=</operator> <name>CdbLocusType_OuterQuery</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>currentPlanFlow</name></name> <operator>=</operator> <name><name>plan</name><operator>-&gt;</operator><name>lefttree</name><operator>-&gt;</operator><name>flow</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>sliceDepth</name></name><operator>++</operator></expr>;</expr_stmt>

		<expr_stmt><expr><name>plan</name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>plan_tree_mutator</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>plan</name></expr></argument>,
										  <argument><expr><name>fix_outer_query_motions_mutator</name></expr></argument>,
										  <argument><expr><name>context</name></expr></argument>,
										  <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>motion</name> <operator>=</operator> <operator>(</operator><name>Motion</name> <operator>*</operator><operator>)</operator> <name>plan</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>sliceDepth</name></name><operator>--</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>currentPlanFlow</name></name> <operator>=</operator> <name>saveCurrentPlanFlow</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * If this is a Motion node in a correlated SubPlan, where we bring
		 * the result to the parent, the Motion was marked as type
		 * MOTIONTYPE_OUTER_QUERY. Because we didn't know whether the parent
		 * is distributed, replicated, or a single QD/QE process, when the
		 * subquery was planned, we fix that up here. Modify the Motion node
		 * so that it brings the result to the parent.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>motion</name><operator>-&gt;</operator><name>motionType</name></name> <operator>==</operator> <name>MOTIONTYPE_OUTER_QUERY</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>motion</name><operator>-&gt;</operator><name>sendSorted</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>currentPlanFlow</name><operator>-&gt;</operator><name>flotype</name></name> <operator>==</operator> <name>FLOW_SINGLETON</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>motion</name><operator>-&gt;</operator><name>motionType</name></name> <operator>=</operator> <name>MOTIONTYPE_GATHER</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>currentPlanFlow</name><operator>-&gt;</operator><name>flotype</name></name> <operator>==</operator> <name>FLOW_REPLICATED</name> <operator>||</operator>
					 <name><name>context</name><operator>-&gt;</operator><name>currentPlanFlow</name><operator>-&gt;</operator><name>flotype</name></name> <operator>==</operator> <name>FLOW_PARTITIONED</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>motion</name><operator>-&gt;</operator><name>motionType</name></name> <operator>=</operator> <name>MOTIONTYPE_BROADCAST</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected Flow type in parent of a SubPlan"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * For non-top slice, if this motion is QE singleton and subplan's locus
		 * is CdbLocusType_SegmentGeneral, omit this motion.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>sliceDepth</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
			<name><name>context</name><operator>-&gt;</operator><name>currentPlanFlow</name><operator>-&gt;</operator><name>flotype</name></name> <operator>==</operator> <name>FLOW_SINGLETON</name> <operator>&amp;&amp;</operator>
			<name><name>context</name><operator>-&gt;</operator><name>currentPlanFlow</name><operator>-&gt;</operator><name>segindex</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
			<name><name>motion</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>lefttree</name><operator>-&gt;</operator><name>flow</name><operator>-&gt;</operator><name>locustype</name></name> <operator>==</operator> <name>CdbLocusType_SegmentGeneral</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Omit this motion. If there were any InitPlans attached to it,
			 * make sure we keep them.
			 */</comment>
			<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>child</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>child</name> <operator>=</operator> <name><name>motion</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>lefttree</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>child</name><operator>-&gt;</operator><name>initPlan</name></name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name><name>child</name><operator>-&gt;</operator><name>initPlan</name></name></expr></argument>, <argument><expr><name><name>motion</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>initPlan</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>newnode</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>child</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>newnode</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>motion</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * Copy this node and mutate its children. Afterwards, this node should be
		 * an exact image of the input node, except that contained nodes requiring
		 * parallelization will have had it applied.
		 */</comment>
		<expr_stmt><expr><name>saveCurrentPlanFlow</name> <operator>=</operator> <name><name>context</name><operator>-&gt;</operator><name>currentPlanFlow</name></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>plan</name><operator>-&gt;</operator><name>flow</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>plan</name><operator>-&gt;</operator><name>flow</name><operator>-&gt;</operator><name>locustype</name></name> <operator>!=</operator> <name>CdbLocusType_OuterQuery</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>currentPlanFlow</name></name> <operator>=</operator> <name><name>plan</name><operator>-&gt;</operator><name>flow</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>newnode</name> <operator>=</operator> <call><name>plan_tree_mutator</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>fix_outer_query_motions_mutator</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>currentPlanFlow</name></name> <operator>=</operator> <name>saveCurrentPlanFlow</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>newnode</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Add a Motion node on top of a Plan if needed, to make the result available
 * in 'outer_query_flow'. Subroutine of cdbllize_fix_outer_query_motions().
 */</comment>
<function><type><specifier>static</specifier> <name>Plan</name> <modifier>*</modifier></type>
<name>fix_subplan_motion</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>subplan</name></decl></parameter>, <parameter><decl><type><name>Flow</name> <modifier>*</modifier></type><name>outer_query_flow</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>need_motion</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>outer_query_flow</name><operator>-&gt;</operator><name>flotype</name></name> <operator>==</operator> <name>FLOW_SINGLETON</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>subplan</name><operator>-&gt;</operator><name>flow</name><operator>-&gt;</operator><name>flotype</name></name> <operator>!=</operator> <name>FLOW_SINGLETON</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>need_motion</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>need_motion</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>outer_query_flow</name><operator>-&gt;</operator><name>flotype</name></name> <operator>==</operator> <name>FLOW_REPLICATED</name> <operator>||</operator>
			 <name><name>outer_query_flow</name><operator>-&gt;</operator><name>flotype</name></name> <operator>==</operator> <name>FLOW_PARTITIONED</name></expr>)</condition>
	<block>{<block_content>
		<comment type="line">// FIXME: Isn't it pointless to broadcast if it's already replicated?</comment>
		<expr_stmt><expr><name>need_motion</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected flow type %d in parent of SubPlan expression"</literal></expr></argument>,
			 <argument><expr><name><name>outer_query_flow</name><operator>-&gt;</operator><name>flotype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>need_motion</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We need to add a Motion to the top.
		 */</comment>
		<decl_stmt><decl><type><name>PlanSlice</name>  <modifier>*</modifier></type><name>sendSlice</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Motion</name>	   <modifier>*</modifier></type><name>motion</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Flow</name>	   <modifier>*</modifier></type><name>subFlow</name> <init>= <expr><name><name>subplan</name><operator>-&gt;</operator><name>flow</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>initPlans</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>subFlow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Strip off any Material nodes at the top. There's no point in
		 * materializing just below a Motion, because a Motion is never
		 * rescanned.
		 *
		 * If we strip off any nodes, make sure we preserve any initPlans
		 * that were attached to them.
		 */</comment>
		<while>while <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>subplan</name></expr></argument>, <argument><expr><name>Material</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>initPlans</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>initPlans</name></expr></argument>, <argument><expr><name><name>subplan</name><operator>-&gt;</operator><name>initPlan</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>subplan</name> <operator>=</operator> <name><name>subplan</name><operator>-&gt;</operator><name>lefttree</name></name></expr>;</expr_stmt>
		</block_content>}</block></while>

		<comment type="block">/*
		 * If there's an existing Motion on top, we can remove it, and
		 * replace it with a new Motion. But make sure we reuse the sender
		 * slice information. We could build a new one here, but then we'd
		 * lose any direct dispatch information.
		 *
		 * Otherwise, build a new sender slice.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>subplan</name></expr></argument>, <argument><expr><name>Motion</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Motion</name> <modifier>*</modifier></type><name>strippedMotion</name> <init>= <expr><operator>(</operator><name>Motion</name> <operator>*</operator><operator>)</operator> <name>subplan</name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>sendSlice</name> <operator>=</operator> <name><name>strippedMotion</name><operator>-&gt;</operator><name>senderSliceInfo</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>subplan</name> <operator>=</operator> <name><name>subplan</name><operator>-&gt;</operator><name>lefttree</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>initPlans</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>initPlans</name></expr></argument>, <argument><expr><name><name>strippedMotion</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>initPlan</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>sendSlice</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PlanSlice</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>sendSlice</name><operator>-&gt;</operator><name>gangType</name></name> <operator>=</operator> <name>GANGTYPE_PRIMARY_READER</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>sendSlice</name><operator>-&gt;</operator><name>sliceIndex</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>subFlow</name><operator>-&gt;</operator><name>flotype</name></name> <operator>!=</operator> <name>FLOW_SINGLETON</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>sendSlice</name><operator>-&gt;</operator><name>numsegments</name></name> <operator>=</operator> <name><name>subFlow</name><operator>-&gt;</operator><name>numsegments</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>sendSlice</name><operator>-&gt;</operator><name>segindex</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>subFlow</name><operator>-&gt;</operator><name>segindex</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>sendSlice</name><operator>-&gt;</operator><name>gangType</name></name> <operator>=</operator> <name>GANGTYPE_ENTRYDB_READER</name></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>sendSlice</name><operator>-&gt;</operator><name>gangType</name></name> <operator>=</operator> <name>GANGTYPE_SINGLETON_READER</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
				<expr_stmt><expr><name><name>sendSlice</name><operator>-&gt;</operator><name>numsegments</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>sendSlice</name><operator>-&gt;</operator><name>segindex</name></name> <operator>=</operator> <name><name>subFlow</name><operator>-&gt;</operator><name>segindex</name></name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name>motion</name> <operator>=</operator> <call><name>make_motion</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>subplan</name></expr></argument>,
							 <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument> <comment type="block">/* no ordering */</comment>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>motion</name><operator>-&gt;</operator><name>motionType</name></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>outer_query_flow</name><operator>-&gt;</operator><name>flotype</name></name> <operator>==</operator> <name>FLOW_SINGLETON</name><operator>)</operator></expr> ?</condition><then>
			<expr><name>MOTIONTYPE_GATHER</name></expr> </then><else>: <expr><name>MOTIONTYPE_BROADCAST</name></expr></else></ternary></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>motion</name><operator>-&gt;</operator><name>hashExprs</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>motion</name><operator>-&gt;</operator><name>hashFuncs</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>motion</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>lefttree</name><operator>-&gt;</operator><name>flow</name></name> <operator>=</operator> <name>subFlow</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>motion</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>initPlan</name></name> <operator>=</operator> <name>initPlans</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>motion</name><operator>-&gt;</operator><name>senderSliceInfo</name></name> <operator>=</operator> <name>sendSlice</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>subplan</name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <name>motion</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>subplan</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * cdbllize_build_slice_table -- Build the (planner) slice table for a query.
 */</comment>
<function><type><name>void</name></type>
<name>cdbllize_build_slice_table</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>top_plan</name></decl></parameter>,
						   <parameter><decl><type><name>PlanSlice</name> <modifier>*</modifier></type><name>top_slice</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PlannerGlobal</name> <modifier>*</modifier></type><name>glob</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>glob</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>query</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>parse</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>build_slice_table_context</name></type> <name>cxt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>sliceIndex</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>all_root_slices</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * This can modify nodes, so the nodes we memorized earlier are no longer
	 * valid. Clear this array just to be sure we don't accidentally use the
	 * obsolete copies of the nodes later on.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>glob</name><operator>-&gt;</operator><name>share</name><operator>.</operator><name>shared_plans</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>glob</name><operator>-&gt;</operator><name>share</name><operator>.</operator><name>shared_plans</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>glob</name><operator>-&gt;</operator><name>share</name><operator>.</operator><name>shared_plans</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* subplan_sliceIds array needs to exist, even in non-dispatcher mode */</comment>
	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>glob</name><operator>-&gt;</operator><name>subplan_sliceIds</name></name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>glob</name><operator>-&gt;</operator><name>subplans</name></name></expr></argument>)</argument_list></call> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for<control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>glob</name><operator>-&gt;</operator><name>subplans</name></name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>glob</name><operator>-&gt;</operator><name>subplan_sliceIds</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></for>

	<comment type="block">/*
	 * In non-dispatcher mode, there are no motions and no dispatching.
	 * In utility mode, we still need a slice, at least some of the
	 * EXPLAIN code expects it.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_UTILITY</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PlanSlice</name> <modifier>*</modifier></type><name>dummySlice</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>dummySlice</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PlanSlice</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>dummySlice</name><operator>-&gt;</operator><name>sliceIndex</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>dummySlice</name><operator>-&gt;</operator><name>parentIndex</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>dummySlice</name><operator>-&gt;</operator><name>gangType</name></name> <operator>=</operator> <name>GANGTYPE_UNALLOCATED</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>dummySlice</name><operator>-&gt;</operator><name>numsegments</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>dummySlice</name><operator>-&gt;</operator><name>segindex</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>glob</name><operator>-&gt;</operator><name>numSlices</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>glob</name><operator>-&gt;</operator><name>slices</name></name> <operator>=</operator> <name>dummySlice</name></expr>;</expr_stmt>

		<return>return;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_EXECUTE</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>planner_init_plan_tree_base</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cxt</name><operator>.</operator><name>base</name></name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>seen_subplans</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>glob</name><operator>-&gt;</operator><name>slices</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>top_slice</name><operator>-&gt;</operator><name>sliceIndex</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>top_slice</name><operator>-&gt;</operator><name>parentIndex</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>slices</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>top_slice</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>currentSliceIndex</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * Walk through the main plan tree, and recursively all SubPlans.
	 * Create a new PlanSlice, and assign a slice ID at every Motion
	 * and Init Plan. Also makes note of all the Subplans that are
	 * reachable from the top plan, so that unused SubPlans can be
	 * eliminated later.
	 */</comment>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>build_slice_table_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>top_plan</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Remove unused subplans, and Init Plans.
	 *
	 */</comment>
	<expr_stmt><expr><call><name>remove_unused_initplans</name><argument_list>(<argument><expr><name>top_plan</name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Remove unused subplans.
	 *
	 * Executor initializes state for subplans even they are unused.
	 * When the generated subplan is not used and has motion inside,
	 * causing motionID not being assigned, which will break sanity
	 * check when executor tries to initialize subplan state.
	 */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>plan_id</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>root-&gt;glob-&gt;subplans</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>bms_is_member</name><argument_list>(<argument><expr><name>plan_id</name></expr></argument>, <argument><expr><name><name>cxt</name><operator>.</operator><name>seen_subplans</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>dummy_plan</name></decl>;</decl_stmt>

			<comment type="block">/*
			 * This subplan is unused. Replace it in the global list of
			 * subplans with a dummy. (We can't just remove it from the global
			 * list, because that would screw up the plan_id numbering of the
			 * subplans).
			 */</comment>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>dummy_plan</name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>make_result</name><argument_list>(<argument><expr><name>NIL</name></expr></argument>,
											  <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>list_make1</name><argument_list>(<argument><expr><call><name>makeBoolConst</name><argument_list>(<argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
											  <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>dummy_plan</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>plan_id</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * If none of the slices require dispatching, we can run everything in one slice.
	 */</comment>
	<expr_stmt><expr><name>all_root_slices</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>cxt.slices</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PlanSlice</name> <modifier>*</modifier></type><name>slice</name> <init>= <expr><operator>(</operator><name>PlanSlice</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>slice</name><operator>-&gt;</operator><name>gangType</name></name> <operator>!=</operator> <name>GANGTYPE_UNALLOCATED</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>all_root_slices</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>
	<if_stmt><if>if <condition>(<expr><name>all_root_slices</name></expr>)</condition>
	<block>{<block_content>
		<for>for<control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>glob</name><operator>-&gt;</operator><name>subplans</name></name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>glob</name><operator>-&gt;</operator><name>subplan_sliceIds</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></for>
		<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>slices</name></name> <operator>=</operator> <call><name>list_truncate</name><argument_list>(<argument><expr><name><name>cxt</name><operator>.</operator><name>slices</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Turn the list of PlanSlices into an array, for dispatching.
	 */</comment>
	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>glob</name><operator>-&gt;</operator><name>numSlices</name></name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>cxt</name><operator>.</operator><name>slices</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>glob</name><operator>-&gt;</operator><name>slices</name></name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>glob</name><operator>-&gt;</operator><name>numSlices</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PlanSlice</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>sliceIndex</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>cxt.slices</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PlanSlice</name> <modifier>*</modifier></type><name>src</name> <init>= <expr><operator>(</operator><name>PlanSlice</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>root</name><operator>-&gt;</operator><name>glob</name><operator>-&gt;</operator><name>slices</name><index>[<expr><name>sliceIndex</name></expr>]</index></name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PlanSlice</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>sliceIndex</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>list_free_deep</name><argument_list>(<argument><expr><name><name>cxt</name><operator>.</operator><name>slices</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Discard subtrees of Query node that aren't needed for execution. Note
	 * the targetlist (query-&gt;targetList) is used in execution of prepared
	 * statements, so we leave that alone.
	 */</comment>
	<expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>jointree</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>groupClause</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>havingQual</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>distinctClause</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>sortClause</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>limitCount</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>limitOffset</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>setOperations</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>build_slice_table_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>build_slice_table_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name> <init>= <expr><operator>(</operator><name>PlannerInfo</name> <operator>*</operator><operator>)</operator> <name><name>context</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>node</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>SubPlan</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SubPlan</name>	   <modifier>*</modifier></type><name>spexpr</name> <init>= <expr><operator>(</operator><name>SubPlan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>plan_id</name> <init>= <expr><name><name>spexpr</name><operator>-&gt;</operator><name>plan_id</name></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * Recurse into each subplan only once, even if there are multiple
		 * SubPlans referring to it.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>bms_is_member</name><argument_list>(<argument><expr><name>plan_id</name></expr></argument>, <argument><expr><name><name>context</name><operator>-&gt;</operator><name>seen_subplans</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>bool</name></type>		<name>result</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>save_currentSliceIndex</name></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>seen_subplans</name></name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>seen_subplans</name></name></expr></argument>, <argument><expr><name>plan_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>save_currentSliceIndex</name> <operator>=</operator> <name><name>context</name><operator>-&gt;</operator><name>currentSliceIndex</name></name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>spexpr</name><operator>-&gt;</operator><name>is_initplan</name></name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>PlanSlice</name> <modifier>*</modifier></type><name>initTopSlice</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>initTopSlice</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PlanSlice</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>initTopSlice</name><operator>-&gt;</operator><name>gangType</name></name> <operator>=</operator> <name>GANGTYPE_UNALLOCATED</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>initTopSlice</name><operator>-&gt;</operator><name>numsegments</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>initTopSlice</name><operator>-&gt;</operator><name>segindex</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>initTopSlice</name><operator>-&gt;</operator><name>parentIndex</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>initTopSlice</name><operator>-&gt;</operator><name>sliceIndex</name></name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>slices</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>slices</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>slices</name></name></expr></argument>, <argument><expr><name>initTopSlice</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>currentSliceIndex</name></name> <operator>=</operator> <name><name>initTopSlice</name><operator>-&gt;</operator><name>sliceIndex</name></name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>glob</name><operator>-&gt;</operator><name>subplan_sliceIds</name><index>[<expr><name>plan_id</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>context</name><operator>-&gt;</operator><name>currentSliceIndex</name></name></expr>;</expr_stmt>

			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>plan_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>,
									  <argument><expr><name>build_slice_table_walker</name></expr></argument>,
									  <argument><expr><name>context</name></expr></argument>,
									  <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>currentSliceIndex</name></name> <operator>=</operator> <name>save_currentSliceIndex</name></expr>;</expr_stmt>

			<return>return <expr><name>result</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Motion</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Motion</name>	   <modifier>*</modifier></type><name>motion</name> <init>= <expr><operator>(</operator><name>Motion</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PlanSlice</name>  <modifier>*</modifier></type><name>sendSlice</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>save_currentSliceIndex</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>result</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>motion</name><operator>-&gt;</operator><name>motionID</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* set up a new slice */</comment>
		<expr_stmt><expr><name>sendSlice</name> <operator>=</operator> <name><name>motion</name><operator>-&gt;</operator><name>senderSliceInfo</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>sendSlice</name><operator>-&gt;</operator><name>sliceIndex</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sendSlice</name><operator>-&gt;</operator><name>sliceIndex</name></name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>slices</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sendSlice</name><operator>-&gt;</operator><name>parentIndex</name></name> <operator>=</operator> <name><name>context</name><operator>-&gt;</operator><name>currentSliceIndex</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>motion</name><operator>-&gt;</operator><name>motionID</name></name> <operator>=</operator> <name><name>sendSlice</name><operator>-&gt;</operator><name>sliceIndex</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>motion</name><operator>-&gt;</operator><name>senderSliceInfo</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>slices</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>slices</name></name></expr></argument>, <argument><expr><name>sendSlice</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>save_currentSliceIndex</name> <operator>=</operator> <name><name>context</name><operator>-&gt;</operator><name>currentSliceIndex</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>currentSliceIndex</name></name> <operator>=</operator> <name><name>sendSlice</name><operator>-&gt;</operator><name>sliceIndex</name></name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>sendSlice</name><operator>-&gt;</operator><name>directDispatch</name><operator>.</operator><name>isDirectDispatch</name></name> <operator>&amp;&amp;</operator>
			<name><name>sendSlice</name><operator>-&gt;</operator><name>directDispatch</name><operator>.</operator><name>contentIds</name></name> <operator>==</operator> <name>NIL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Direct dispatch, but we've already determined that there will
			 * be no match on any segment. Doesn't matter which segmnent produces
			 * the non-result.
			 *
			 * XXX: Would've been better to replace this with a dummy Result
			 * node or something in the planner.
			 */</comment>
			<expr_stmt><expr><name><name>sendSlice</name><operator>-&gt;</operator><name>directDispatch</name><operator>.</operator><name>contentIds</name></name> <operator>=</operator> <call><name>list_make1_int</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>plan_tree_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>motion</name></expr></argument>,
								  <argument><expr><name>build_slice_table_walker</name></expr></argument>,
								  <argument><expr><name>context</name></expr></argument>,
								  <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>currentSliceIndex</name></name> <operator>=</operator> <name>save_currentSliceIndex</name></expr>;</expr_stmt>

		<return>return <expr><name>result</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><call><name>plan_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>,
							<argument><expr><name>build_slice_table_walker</name></expr></argument>,
							<argument><expr><name>context</name></expr></argument>,
							<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Construct a new Flow in the current memory context.
 */</comment>
<function><type><name>Flow</name> <modifier>*</modifier></type>
<name>makeFlow</name><parameter_list>(<parameter><decl><type><name>FlowType</name></type> <name>flotype</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>numsegments</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Flow</name>	   <modifier>*</modifier></type><name>flow</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>Flow</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>numsegments</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>flow</name><operator>-&gt;</operator><name>flotype</name></name> <operator>=</operator> <name>flotype</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>flow</name><operator>-&gt;</operator><name>locustype</name></name> <operator>=</operator> <name>CdbLocusType_Null</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>flow</name><operator>-&gt;</operator><name>numsegments</name></name> <operator>=</operator> <name>numsegments</name></expr>;</expr_stmt>

	<return>return <expr><name>flow</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Is the node a "subclass" of Plan?
 */</comment>
<function><type><name>bool</name></type>
<name>is_plan_node</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <name>T_Plan_Start</name> <operator>&amp;&amp;</operator> <call><name>nodeTag</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>T_Plan_End</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SANITY_MOTION</name></cpp:macro> <cpp:value>0x1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SANITY_DEADLOCK</name></cpp:macro> <cpp:value>0x2</cpp:value></cpp:define>

<typedef>typedef <type><struct>struct <name>sanity_result_t</name>
<block>{
	<decl_stmt><decl><type><name>plan_tree_base_prefix</name></type> <name>base</name></decl>;</decl_stmt> <comment type="block">/* Required prefix for
								 * plan_tree_walker/mutator */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>flags</name></decl>;</decl_stmt>
}</block></struct></type> <name>sanity_result_t</name>;</typedef>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>motion_sanity_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>sanity_result_t</name> <modifier>*</modifier></type><name>result</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>sanity_result_t</name></type> <name>left_result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sanity_result_t</name></type> <name>right_result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>deadlock_safe</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>branch_label</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>left_result</name><operator>.</operator><name>base</name></name> <operator>=</operator> <name><name>result</name><operator>-&gt;</operator><name>base</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>left_result</name><operator>.</operator><name>flags</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>right_result</name><operator>.</operator><name>base</name></name> <operator>=</operator> <name><name>result</name><operator>-&gt;</operator><name>base</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>right_result</name><operator>.</operator><name>flags</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_plan_node</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Special handling for branch points because there is a possibility of a
	 * deadlock if there are Motions in both branches and one side is not
	 * first pre-fetched.
	 *
	 * The deadlock occurs because, when the buffers on the Send side of a
	 * Motion are completely filled with tuples, it blocks waiting for an ACK.
	 * Without prefetch_inner, the Join node reads one tuple from the outer
	 * side first and then starts retrieving tuples from the inner side -
	 * either to build a hash table (in case of HashJoin) or for joining (in
	 * case of MergeJoin and NestedLoopJoin).
	 *
	 * Thus we can end up with 4 processes infinitely waiting for each other :
	 *
	 * A : Join slice that already retrieved an outer tuple, and is waiting
	 * for inner tuples from D. B : Join slice that is still waiting for the
	 * first outer tuple from C. C : Outer slice whose buffer is full sending
	 * tuples to A and is blocked waiting for an ACK from A. D : Inner slice
	 * that is full sending tuples to B and is blocked waiting for an ACK from
	 * B.
	 *
	 * A cannot ACK C because it is waiting to finish retrieving inner tuples
	 * from D. B cannot ACK D because it is waiting for it's first outer tuple
	 * from C before accepting any inner tuples. This forms a circular
	 * dependency resulting in a deadlock : C -&gt; A -&gt; D -&gt; B -&gt; C.
	 *
	 * We avoid this by pre-fetching all the inner tuples in such cases and
	 * materializing them in some fashion, before moving on to outer_tuples.
	 * This effectively breaks the cycle and prevents deadlock.
	 *
	 * Details:
	 * https://groups.google.com/a/greenplum.org/forum/#!msg/gpdb-dev/gMa1tW0x_fk/wuzvGXBaBAAJ
	 */</comment>
	<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>T_HashJoin</name></expr>:</case>		<comment type="block">/* Hash join can't deadlock -- it fully
								 * materializes its inner before switching to
								 * its outer. */</comment>
			<expr_stmt><expr><name>branch_label</name> <operator>=</operator> <literal type="string">"HJ"</literal></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>HashJoin</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name><name>join</name><operator>.</operator><name>prefetch_inner</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>deadlock_safe</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>T_NestLoop</name></expr>:</case>		<comment type="block">/* Nested loop joins are safe only if the
								 * prefetch flag is set */</comment>
			<expr_stmt><expr><name>branch_label</name> <operator>=</operator> <literal type="string">"NL"</literal></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>NestLoop</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name><name>join</name><operator>.</operator><name>prefetch_inner</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>deadlock_safe</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>T_MergeJoin</name></expr>:</case>
			<expr_stmt><expr><name>branch_label</name> <operator>=</operator> <literal type="string">"MJ"</literal></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>MergeJoin</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name><name>join</name><operator>.</operator><name>prefetch_inner</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>deadlock_safe</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><name>branch_label</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<comment type="block">/* now scan the subplans */</comment>
	<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>T_Result</name></expr>:</case>
		<case>case <expr><name>T_WindowAgg</name></expr>:</case>
		<case>case <expr><name>T_TableFunctionScan</name></expr>:</case>
		<case>case <expr><name>T_ShareInputScan</name></expr>:</case>
		<case>case <expr><name>T_Append</name></expr>:</case>
		<case>case <expr><name>T_MergeAppend</name></expr>:</case>
		<case>case <expr><name>T_SeqScan</name></expr>:</case>
		<case>case <expr><name>T_SampleScan</name></expr>:</case>
		<case>case <expr><name>T_IndexScan</name></expr>:</case>
		<case>case <expr><name>T_BitmapIndexScan</name></expr>:</case>
		<case>case <expr><name>T_BitmapHeapScan</name></expr>:</case>
		<case>case <expr><name>T_TidScan</name></expr>:</case>
		<case>case <expr><name>T_SubqueryScan</name></expr>:</case>
		<case>case <expr><name>T_FunctionScan</name></expr>:</case>
		<case>case <expr><name>T_ValuesScan</name></expr>:</case>
		<case>case <expr><name>T_Agg</name></expr>:</case>
		<case>case <expr><name>T_TupleSplit</name></expr>:</case>
		<case>case <expr><name>T_Unique</name></expr>:</case>
		<case>case <expr><name>T_Hash</name></expr>:</case>
		<case>case <expr><name>T_SetOp</name></expr>:</case>
		<case>case <expr><name>T_Limit</name></expr>:</case>
		<case>case <expr><name>T_Sort</name></expr>:</case>
		<case>case <expr><name>T_Material</name></expr>:</case>
		<case>case <expr><name>T_ForeignScan</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><call><name>plan_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>motion_sanity_walker</name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			<break>break;</break>

		<case>case <expr><name>T_Motion</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><call><name>plan_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>motion_sanity_walker</name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>SANITY_MOTION</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG5</name></expr></argument>, <argument><expr><literal type="string">"   found motion"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_HashJoin</name></expr>:</case>
		<case>case <expr><name>T_NestLoop</name></expr>:</case>
		<case>case <expr><name>T_MergeJoin</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>plan</name> <init>= <expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG5</name></expr></argument>, <argument><expr><literal type="string">"    %s going left"</literal></expr></argument>, <argument><expr><name>branch_label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>motion_sanity_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>plan</name><operator>-&gt;</operator><name>lefttree</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>left_result</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG5</name></expr></argument>, <argument><expr><literal type="string">"    %s going right"</literal></expr></argument>, <argument><expr><name>branch_label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>motion_sanity_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>plan</name><operator>-&gt;</operator><name>righttree</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>right_result</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG5</name></expr></argument>, <argument><expr><literal type="string">"    %s branch point left 0x%x right 0x%x"</literal></expr></argument>,
					 <argument><expr><name>branch_label</name></expr></argument>, <argument><expr><name><name>left_result</name><operator>.</operator><name>flags</name></name></expr></argument>, <argument><expr><name><name>right_result</name><operator>.</operator><name>flags</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* deadlocks get sent up immediately */</comment>
				<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>left_result</name><operator>.</operator><name>flags</name></name> <operator>&amp;</operator> <name>SANITY_DEADLOCK</name><operator>)</operator> <operator>||</operator>
					<operator>(</operator><name><name>right_result</name><operator>.</operator><name>flags</name></name> <operator>&amp;</operator> <name>SANITY_DEADLOCK</name><operator>)</operator></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>SANITY_DEADLOCK</name></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/*
				 * if this node is "deadlock safe" then even if we have motion
				 * on both sides we will not deadlock (because the access
				 * pattern is deadlock safe: all rows are retrieved from one
				 * side before the first row from the other).
				 */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>deadlock_safe</name> <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name><name>left_result</name><operator>.</operator><name>flags</name></name> <operator>&amp;</operator> <name>SANITY_MOTION</name><operator>)</operator> <operator>&amp;&amp;</operator>
									   <operator>(</operator><name><name>right_result</name><operator>.</operator><name>flags</name></name> <operator>&amp;</operator> <name>SANITY_MOTION</name><operator>)</operator><operator>)</operator></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"FOUND MOTION DEADLOCK in %s"</literal></expr></argument>, <argument><expr><name>branch_label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>SANITY_DEADLOCK</name></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>

				<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name><name>left_result</name><operator>.</operator><name>flags</name></name> <operator>|</operator> <name><name>right_result</name><operator>.</operator><name>flags</name></name></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG5</name></expr></argument>, <argument><expr><literal type="string">"    %s branch point left 0x%x right 0x%x res 0x%x%s"</literal></expr></argument>,
					 <argument><expr><name>branch_label</name></expr></argument>, <argument><expr><name><name>left_result</name><operator>.</operator><name>flags</name></name></expr></argument>, <argument><expr><name><name>right_result</name><operator>.</operator><name>flags</name></name></expr></argument>, <argument><expr><name><name>result</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><ternary><condition><expr><name>deadlock_safe</name></expr> ?</condition><then> <expr><literal type="string">" deadlock safe: prefetching"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<default>default:</default>
			<break>break;</break>
	</block_content>}</block></switch>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>motion_sanity_check</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>plan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>sanity_result_t</name></type> <name>sanity_result</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>planner_init_plan_tree_base</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sanity_result</name><operator>.</operator><name>base</name></name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sanity_result</name><operator>.</operator><name>flags</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG5</name></expr></argument>, <argument><expr><literal type="string">"Motion Deadlock Sanity Check"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>motion_sanity_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>plan</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sanity_result</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"motion sanity walker returned true"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>sanity_result</name><operator>.</operator><name>flags</name></name> <operator>&amp;</operator> <name>SANITY_DEADLOCK</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Post-planning sanity check detected motion deadlock."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>adjust_top_path_for_parallel_retrieve_cursor</name><parameter_list>(<parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>PlanSlice</name> <modifier>*</modifier></type><name>slice</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>CdbPathLocus_IsSingleQE</name><argument_list>(<argument><expr><name><name>path</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>)</argument_list></call>
		<operator>||</operator> <call><name>CdbPathLocus_IsGeneral</name><argument_list>(<argument><expr><name><name>path</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>)</argument_list></call>
		<operator>||</operator> <call><name>CdbPathLocus_IsEntry</name><argument_list>(<argument><expr><name><name>path</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * For these scenarios, parallel retrieve cursor needs to run on entrydb
		 * since endpoint QE needs to interact with the retrieve connections.
		 */</comment>
		<expr_stmt><expr><name><name>slice</name><operator>-&gt;</operator><name>numsegments</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>slice</name><operator>-&gt;</operator><name>gangType</name></name> <operator>=</operator> <name>GANGTYPE_ENTRYDB_READER</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>CdbPathLocus_IsSegmentGeneral</name><argument_list>(<argument><expr><name><name>path</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * queries to replicated table run on a single segment.
		 */</comment>
		<expr_stmt><expr><name><name>slice</name><operator>-&gt;</operator><name>segindex</name></name> <operator>=</operator> <name>gp_session_id</name> <operator>%</operator> <name><name>path</name><operator>-&gt;</operator><name>locus</name><operator>.</operator><name>numsegments</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>slice</name><operator>-&gt;</operator><name>numsegments</name></name> <operator>=</operator> <name><name>path</name><operator>-&gt;</operator><name>locus</name><operator>.</operator><name>numsegments</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>slice</name><operator>-&gt;</operator><name>gangType</name></name> <operator>=</operator> <name>GANGTYPE_SINGLETON_READER</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * queries to non-replicated table run on segments.
		 */</comment>
		<expr_stmt><expr><name><name>slice</name><operator>-&gt;</operator><name>numsegments</name></name> <operator>=</operator> <name><name>path</name><operator>-&gt;</operator><name>locus</name><operator>.</operator><name>numsegments</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>slice</name><operator>-&gt;</operator><name>gangType</name></name> <operator>=</operator> <name>GANGTYPE_PRIMARY_READER</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>
</unit>
