<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/backend/cdb/cdbsubselect.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * cdbsubselect.c
 *	  Flattens subqueries, transforms them to joins.
 *
 * Portions Copyright (c) 2005-2008, Greenplum inc
 * Portions Copyright (c) 2012-Present VMware, Inc. or its affiliates.
 *
 *
 * IDENTIFICATION
 *	    src/backend/cdb/cdbsubselect.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/skey.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_operator.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/clauses.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/optimizer.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/subselect.h"</cpp:file></cpp:include>	<comment type="block">/* convert_testexpr() */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/tlist.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/prep.h"</cpp:file></cpp:include>		<comment type="block">/* canonicalize_qual() */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_oper.h"</cpp:file></cpp:include>	<comment type="block">/* make_op() */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_expr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_relation.h"</cpp:file></cpp:include>	<comment type="block">/* addRangeTableEntryForSubquery() */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parsetree.h"</cpp:file></cpp:include>	<comment type="block">/* rt_fetch() */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"rewrite/rewriteManip.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>	<comment type="block">/* get_op_btree_interpretation() */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbsubselect.h"</cpp:file></cpp:include>	<comment type="block">/* me */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lib/stringinfo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbpullup.h"</cpp:file></cpp:include>

<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>add_expr_subquery_rte</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>parse</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>subselect</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>JoinExpr</name> <modifier>*</modifier></type><name>make_join_expr</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>larg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>r_rtindex</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>join_type</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>make_lasj_quals</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>SubLink</name> <modifier>*</modifier></type><name>sublink</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>subquery_indx</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>add_null_match_clause</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>clause</name></decl></parameter>)</parameter_list>;</function_decl>

<typedef>typedef <type><struct>struct <name>NonNullableVarsContext</name>
<block>{
	<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>query</name></decl>;</decl_stmt>              <comment type="block">/* Query in question. */</comment>
	<decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>varsToCheck</name></decl>;</decl_stmt>        <comment type="block">/* Vars to check when walking to RTE */</comment>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>nonNullableVars</name></decl>;</decl_stmt>	<comment type="block">/* Known non-nullable vars */</comment>
}</block></struct></type> <name>NonNullableVarsContext</name>;</typedef>

<typedef>typedef <type><struct>struct <name>FindAllVarsContext</name>
<block>{
	<decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>rtable</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>vars</name></decl>;</decl_stmt>
}</block></struct></type> <name>FindAllVarsContext</name>;</typedef>


<comment type="block" format="doxygen">/**
 * Walker that performs the following tasks:
 * - It checks if a given expr is "safe" to be pulled up to be a join
 * - Extracts out the vars from the outer query in the qual in order
 * - Extracts out the vars from the inner query in the qual in order
 */</comment>
<typedef>typedef <type><struct>struct <name>ConvertSubqueryToJoinContext</name>
<block>{
	<decl_stmt><decl><type><name>bool</name></type>		<name>safeToConvert</name></decl>;</decl_stmt>	<comment type="block">/* Can correlated expression subquery be
								 * pulled up? */</comment>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>joinQual</name></decl>;</decl_stmt>		<comment type="block">/* Qual to employ to join subquery */</comment>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>innerQual</name></decl>;</decl_stmt>		<comment type="block">/* Qual to leave behind in subquery */</comment>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>targetList</name></decl>;</decl_stmt>		<comment type="block">/* targetlist for subquery */</comment>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>groupClause</name></decl>;</decl_stmt>	<comment type="block">/* grouping clause for subquery */</comment>
}</block></struct></type> <name>ConvertSubqueryToJoinContext</name>;</typedef>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ProcessSubqueryToJoin</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>subselect</name></decl></parameter>, <parameter><decl><type><name>ConvertSubqueryToJoinContext</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ProcessSubqueryToJoin_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>jtree</name></decl></parameter>, <parameter><decl><type><name>ConvertSubqueryToJoinContext</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>SubqueryToJoinWalker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>ConvertSubqueryToJoinContext</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>RemoveInnerJoinQuals</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>subselect</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>RemoveInnerJoinQuals_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>jtree</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>cdb_find_nonnullable_vars_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>NonNullableVarsContext</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>is_attribute_nonnullable</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationOid</name></decl></parameter>, <parameter><decl><type><name>AttrNumber</name></type> <name>attrNumber</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>fetch_targetlist_exprs</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>targetlist</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>fetch_outer_exprs</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>testexpr</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type>  <name>is_exprs_nullable</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>exprs</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type>  <name>is_exprs_nullable_internal</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>exprs</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>nonnullable_vars</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>rtable</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>cdb_find_all_vars</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>exprs</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>rtable</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type>  <name>cdb_find_all_vars_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>FindAllVarsContext</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Var</name> <modifier>*</modifier></type><name>cdb_map_to_base_var</name><parameter_list>(<parameter><decl><type><name>Var</name> <modifier>*</modifier></type><name>var</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>rtable</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DUMMY_COLUMN_NAME</name></cpp:macro> <cpp:value>"zero"</cpp:value></cpp:define>

<comment type="block" format="doxygen">/**
 * Initialize context.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>InitConvertSubqueryToJoinContext</name><parameter_list>(<parameter><decl><type><name>ConvertSubqueryToJoinContext</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>safeToConvert</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>joinQual</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>innerQual</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>groupClause</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
 * Process correlated opexpr of the form foo(outer.var) OP bar(inner.var). Extracts
 * bar(inner.var) as innerExpr.
 * Returns true, if this is not a compatible correlated opexpr.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>IsCorrelatedOpExpr</name><parameter_list>(<parameter><decl><type><name>OpExpr</name> <modifier>*</modifier></type><name>opexp</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier><modifier>*</modifier></type><name>innerExpr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>e1</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>e2</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>opexp</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>e1</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>list_nth</name><argument_list>(<argument><expr><name><name>opexp</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>e2</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>list_nth</name><argument_list>(<argument><expr><name><name>opexp</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * One of the vars must be outer, and other must be inner.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>contain_vars_of_level</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>e1</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<operator>!</operator><call><name>contain_vars_of_level</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>e1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<call><name>contain_vars_of_level</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>e2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<operator>!</operator><call><name>contain_vars_of_level</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>e2</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>innerExpr</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>e2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>contain_vars_of_level</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>e1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<operator>!</operator><call><name>contain_vars_of_level</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>e1</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<call><name>contain_vars_of_level</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>e2</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<operator>!</operator><call><name>contain_vars_of_level</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>e2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>innerExpr</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>e1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
 * Checks if an opexpression is of the form (foo(outervar) = bar(innervar))
 * Input:
 *	opexp - op expression
 * Output:
 *	returns true if correlated equality condition
 *	*innerExpr - points to the inner expr i.e. bar(innervar) in the condition
 *	*eqOp and *sortOp - equality and &lt; operators, to implement the condition as a mergejoin.
 *  The *eqOp and *sortOp should be determined according to innervar's type.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>IsCorrelatedEqualityOpExpr</name><parameter_list>(<parameter><decl><type><name>OpExpr</name> <modifier>*</modifier></type><name>opexp</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier><modifier>*</modifier></type><name>innerExpr</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>eqOp</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>sortOp</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>hashable</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>opfamily</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>innerExprType</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>opexp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>opexp</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>innerExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>eqOp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>sortOp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsCorrelatedOpExpr</name><argument_list>(<argument><expr><name>opexp</name></expr></argument>, <argument><expr><name>innerExpr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>*</operator><name>innerExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>innerExprType</name> <operator>=</operator> <call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><operator>*</operator><name>innerExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If this is an expression of the form a = b, then we want to know about
	 * the vars involved.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>op_mergejoinable</name><argument_list>(<argument><expr><name><name>opexp</name><operator>-&gt;</operator><name>opno</name></name></expr></argument>, <argument><expr><name>innerExprType</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Arbitrarily use the first operator family containing the operator that
	 * we can find.
	 */</comment>
	<expr_stmt><expr><name>l</name> <operator>=</operator> <call><name>get_mergejoin_opfamilies</name><argument_list>(<argument><expr><name><name>opexp</name><operator>-&gt;</operator><name>opno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>l</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>opfamily</name> <operator>=</operator> <call><name>linitial_oid</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Look up the correct equility/sort operators from the chosen opfamily.
	 */</comment>
	<expr_stmt><expr><operator>*</operator><name>eqOp</name> <operator>=</operator> <call><name>get_opfamily_member</name><argument_list>(<argument><expr><name>opfamily</name></expr></argument>, <argument><expr><name>innerExprType</name></expr></argument>, <argument><expr><name>innerExprType</name></expr></argument>, <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><operator>*</operator><name>eqOp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>	<comment type="block">/* should not happen */</comment>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not find member %d(%u,%u) of opfamily %u"</literal></expr></argument>,
			 <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>innerExprType</name></expr></argument>, <argument><expr><name>innerExprType</name></expr></argument>, <argument><expr><name>opfamily</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><operator>*</operator><name>sortOp</name> <operator>=</operator> <call><name>get_opfamily_member</name><argument_list>(<argument><expr><name>opfamily</name></expr></argument>, <argument><expr><name>innerExprType</name></expr></argument>, <argument><expr><name>innerExprType</name></expr></argument>, <argument><expr><name>BTLessStrategyNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><operator>*</operator><name>sortOp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>	<comment type="block">/* should not happen */</comment>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not find member %d(%u,%u) of opfamily %u"</literal></expr></argument>,
			 <argument><expr><name>BTLessStrategyNumber</name></expr></argument>, <argument><expr><name>innerExprType</name></expr></argument>, <argument><expr><name>innerExprType</name></expr></argument>, <argument><expr><name>opfamily</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><operator>*</operator><name>hashable</name> <operator>=</operator> <call><name>op_hashjoinable</name><argument_list>(<argument><expr><operator>*</operator><name>eqOp</name></expr></argument>, <argument><expr><name>innerExprType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
 * Process subquery to extract useful information to be able to convert it to
 * a join.
 *
 * This scans the join tree, and verifies that it consists entirely of inner
 * joins. The inner joins can be represented as explicit JOIN_INNER JoinExprs*
 * or as FromExprs. All the join quals are collected in context-&gt;innerQual.
 *
 * context-&gt;safeToConvert must be 'true' on entry. This sets it to false if
 * there are any non-inner joins in the tree.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ProcessSubqueryToJoin</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>subselect</name></decl></parameter>, <parameter><decl><type><name>ConvertSubqueryToJoinContext</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>safeToConvert</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>subselect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ProcessSubqueryToJoin_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>subselect</name><operator>-&gt;</operator><name>jointree</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ProcessSubqueryToJoin_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>jtree</name></decl></parameter>, <parameter><decl><type><name>ConvertSubqueryToJoinContext</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>jtree</name></expr></argument>, <argument><expr><name>JoinExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>JoinExpr</name>   <modifier>*</modifier></type><name>je</name> <init>= <expr><operator>(</operator><name>JoinExpr</name> <operator>*</operator><operator>)</operator> <name>jtree</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * If subselect's join tree is not a plain relation or an inner join,
		 * we refuse to convert.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>je</name><operator>-&gt;</operator><name>jointype</name></name> <operator>!=</operator> <name>JOIN_INNER</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>safeToConvert</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>ProcessSubqueryToJoin_walker</name><argument_list>(<argument><expr><name><name>je</name><operator>-&gt;</operator><name>larg</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>context</name><operator>-&gt;</operator><name>safeToConvert</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return;</return></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>ProcessSubqueryToJoin_walker</name><argument_list>(<argument><expr><name><name>je</name><operator>-&gt;</operator><name>rarg</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>context</name><operator>-&gt;</operator><name>safeToConvert</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return;</return></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>SubqueryToJoinWalker</name><argument_list>(<argument><expr><name><name>je</name><operator>-&gt;</operator><name>quals</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>jtree</name></expr></argument>, <argument><expr><name>FromExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>FromExpr</name>   <modifier>*</modifier></type><name>fe</name> <init>= <expr><operator>(</operator><name>FromExpr</name> <operator>*</operator><operator>)</operator> <name>jtree</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>fe-&gt;fromlist</argument>)</argument_list></macro>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ProcessSubqueryToJoin_walker</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>context</name><operator>-&gt;</operator><name>safeToConvert</name></name></expr>)</condition><block type="pseudo"><block_content>
				<return>return;</return></block_content></block></if></if_stmt>
		</block_content>}</block>

		<expr_stmt><expr><call><name>SubqueryToJoinWalker</name><argument_list>(<argument><expr><name><name>fe</name><operator>-&gt;</operator><name>quals</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>jtree</name></expr></argument>, <argument><expr><name>RangeTblRef</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* nothing to do */</comment>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected node of type %d in join tree"</literal></expr></argument>, <argument><expr><name><name>jtree</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
 * Wipe out join quals i.e. top-level where clause and any quals in the top-level inner join.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>RemoveInnerJoinQuals</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>subselect</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>RemoveInnerJoinQuals_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>subselect</name><operator>-&gt;</operator><name>jointree</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>RemoveInnerJoinQuals_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>jtree</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>jtree</name></expr></argument>, <argument><expr><name>JoinExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>JoinExpr</name>   <modifier>*</modifier></type><name>je</name> <init>= <expr><operator>(</operator><name>JoinExpr</name> <operator>*</operator><operator>)</operator> <name>jtree</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * We already checked in ProcessSubqueryToJoin() that there
		 * are no outer joins, but doesn't hurt to check again.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>je</name><operator>-&gt;</operator><name>jointype</name></name> <operator>!=</operator> <name>JOIN_INNER</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected join type encountered while converting subquery to join"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>RemoveInnerJoinQuals_walker</name><argument_list>(<argument><expr><name><name>je</name><operator>-&gt;</operator><name>larg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>RemoveInnerJoinQuals_walker</name><argument_list>(<argument><expr><name><name>je</name><operator>-&gt;</operator><name>rarg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>je</name><operator>-&gt;</operator><name>quals</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>jtree</name></expr></argument>, <argument><expr><name>FromExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>FromExpr</name>   <modifier>*</modifier></type><name>fe</name> <init>= <expr><operator>(</operator><name>FromExpr</name> <operator>*</operator><operator>)</operator> <name>jtree</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>fe-&gt;fromlist</argument>)</argument_list></macro>
		<block>{<block_content>
			<expr_stmt><expr><call><name>RemoveInnerJoinQuals_walker</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<expr_stmt><expr><name><name>fe</name><operator>-&gt;</operator><name>quals</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>jtree</name></expr></argument>, <argument><expr><name>RangeTblRef</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* nothing to do */</comment>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected node of type %d in join tree"</literal></expr></argument>, <argument><expr><name><name>jtree</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
 * This method recursively walks down the quals of an expression subquery to see if it can be pulled up to a join
 * and constructs the pieces necessary to perform the pullup.
 * E.g. SELECT * FROM outer o WHERE o.a &lt; (SELECT avg(i.x) FROM inner i WHERE o.b = i.y)
 * This extracts interesting pieces of the subquery so as to create SELECT i.y, avg(i.x) from inner i GROUP by i.y
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>SubqueryToJoinWalker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>ConvertSubqueryToJoinContext</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>safeToConvert</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>BoolExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>

		<comment type="block" format="doxygen">/**
		 * Be extremely conservative. If there are any outer vars under an or or a not expression, then give up.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>is_notclause</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call>
			<operator>||</operator> <call><name>is_orclause</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>contain_vars_of_level_or_above</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>safeToConvert</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<return>return;</return>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>innerQual</name></name> <operator>=</operator> <call><name>make_and_qual</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>innerQual</name></name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>is_andclause</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>BoolExpr</name>   <modifier>*</modifier></type><name>bexp</name> <init>= <expr><operator>(</operator><name>BoolExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>bexp-&gt;args</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>arg</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block" format="doxygen">/**
			 * If there is an outer var anywhere in the boolean expression, walk recursively.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>contain_vars_of_level_or_above</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>SubqueryToJoinWalker</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>context</name><operator>-&gt;</operator><name>safeToConvert</name></name></expr>)</condition>
				<block>{<block_content>
					<return>return;</return>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block" format="doxygen">/**
				 * This qual should be part of the subquery's inner qual.
				 */</comment>
				<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>innerQual</name></name> <operator>=</operator> <call><name>make_and_qual</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>innerQual</name></name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block>
		<return>return;</return>
	</block_content>}</block></if>

	<comment type="block" format="doxygen">/**
	 * If this is a correlated opexpression, we'd need to look inside.
	 */</comment>
	<if type="elseif">else if <condition>(<expr><call><name>contain_vars_of_level_or_above</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>OpExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>OpExpr</name>	   <modifier>*</modifier></type><name>opexp</name> <init>= <expr><operator>(</operator><name>OpExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

		<comment type="block" format="doxygen">/**
		 * If this is an expression of the form foo(outervar) = bar(innervar), then we want to know about the inner expression.
		 */</comment>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>eqOp</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>sortOp</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>hashable</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>innerExpr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>considerOpExpr</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>considerOpExpr</name> <operator>=</operator> <call><name>IsCorrelatedEqualityOpExpr</name><argument_list>(<argument><expr><name>opexp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>innerExpr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>eqOp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sortOp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hashable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>considerOpExpr</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>SortGroupClause</name> <modifier>*</modifier></type><name>gc</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>tle</name> <operator>=</operator> <call><name>makeTargetEntry</name><argument_list>(<argument><expr><name>innerExpr</name></expr></argument>,
											   <argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
											   <argument><expr><name>NULL</name></expr></argument>,
											   <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tle</name><operator>-&gt;</operator><name>ressortgroupref</name></name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>, <argument><expr><name>tle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>gc</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>SortGroupClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>gc</name><operator>-&gt;</operator><name>tleSortGroupRef</name></name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>gc</name><operator>-&gt;</operator><name>eqop</name></name> <operator>=</operator> <name>eqOp</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>gc</name><operator>-&gt;</operator><name>sortop</name></name> <operator>=</operator> <name>sortOp</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>gc</name><operator>-&gt;</operator><name>hashable</name></name> <operator>=</operator> <name>hashable</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>groupClause</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>, <argument><expr><name>gc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>groupClause</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>joinQual</name></name> <operator>=</operator> <call><name>make_and_qual</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>joinQual</name></name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>opexp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<return>return;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block" format="doxygen">/**
		 * Correlated join expression contains incompatible operators. Not safe to convert.
		 */</comment>
		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>safeToConvert</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>contain_vars_of_level_or_above</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * This is a correlated expression, but we don't know how to deal with
		 * it. Give up.
		 */</comment>
		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>safeToConvert</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return;</return>
</block_content>}</block></function>

<comment type="block">/*
 * cdbsubselect_drop_distinct
 */</comment>
<function><type><name>void</name></type>
<name>cdbsubselect_drop_distinct</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>subselect</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>subselect</name><operator>-&gt;</operator><name>limitCount</name></name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
		<name><name>subselect</name><operator>-&gt;</operator><name>limitOffset</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Delete DISTINCT. */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>subselect</name><operator>-&gt;</operator><name>hasDistinctOn</name></name> <operator>||</operator>
			<call><name>list_length</name><argument_list>(<argument><expr><name><name>subselect</name><operator>-&gt;</operator><name>distinctClause</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>subselect</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>subselect</name><operator>-&gt;</operator><name>distinctClause</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Delete GROUP BY if subquery has no aggregates and no HAVING. */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>subselect</name><operator>-&gt;</operator><name>hasAggs</name></name> <operator>&amp;&amp;</operator>
			<name><name>subselect</name><operator>-&gt;</operator><name>havingQual</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>subselect</name><operator>-&gt;</operator><name>groupClause</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>	<comment type="block">/* cdbsubselect_drop_distinct */</comment>

<comment type="block">/*
 * cdbsubselect_drop_orderby
 */</comment>
<function><type><name>void</name></type>
<name>cdbsubselect_drop_orderby</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>subselect</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>subselect</name><operator>-&gt;</operator><name>limitCount</name></name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
		<name><name>subselect</name><operator>-&gt;</operator><name>limitOffset</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Delete ORDER BY. */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>subselect</name><operator>-&gt;</operator><name>hasDistinctOn</name></name> <operator>||</operator>
			<call><name>list_length</name><argument_list>(<argument><expr><name><name>subselect</name><operator>-&gt;</operator><name>distinctClause</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>subselect</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>subselect</name><operator>-&gt;</operator><name>sortClause</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>	<comment type="block">/* cdbsubselect_drop_orderby */</comment>

<comment type="block" format="doxygen">/**
 * Safe to convert expr sublink to a join
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>safe_to_convert_EXPR</name><parameter_list>(<parameter><decl><type><name>SubLink</name> <modifier>*</modifier></type><name>sublink</name></decl></parameter>, <parameter><decl><type><name>ConvertSubqueryToJoinContext</name> <modifier>*</modifier></type><name>ctx1</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ctx1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>subselect</name> <init>= <expr><operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <name><name>sublink</name><operator>-&gt;</operator><name>subselect</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>subselect</name><operator>-&gt;</operator><name>jointree</name><operator>-&gt;</operator><name>fromlist</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>expression_returns_set</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>subselect</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* No set operations in the subquery */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>subselect</name><operator>-&gt;</operator><name>setOperations</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block" format="doxygen">/**
	 * If there are no correlations in the WHERE clause, then don't bother.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsSubqueryCorrelated</name><argument_list>(<argument><expr><name>subselect</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block" format="doxygen">/**
	 * If there are correlations in a func expr in the from clause, then don't bother.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>has_correlation_in_funcexpr_rte</name><argument_list>(<argument><expr><name><name>subselect</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block" format="doxygen">/**
	 * If there is a having qual, then don't bother.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>subselect</name><operator>-&gt;</operator><name>havingQual</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block" format="doxygen">/**
	 * If it does not have aggs, then don't bother. This could result in a run-time error.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>subselect</name><operator>-&gt;</operator><name>hasAggs</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block" format="doxygen">/**
	 * A LIMIT or OFFSET could interfere with the transformation of the
	 * correlated qual to GROUP BY. (LIMIT &gt;0 in a subquery that contains a
	 * plain aggregate is actually a no-op, so we could try to remove it,
	 * but it doesn't seem worth the trouble to optimize queries with
	 * pointless limits like that.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>subselect</name><operator>-&gt;</operator><name>limitOffset</name></name> <operator>||</operator> <name><name>subselect</name><operator>-&gt;</operator><name>limitCount</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block" format="doxygen">/**
	 * Cannot support grouping clause in subselect.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>subselect</name><operator>-&gt;</operator><name>groupClause</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block" format="doxygen">/**
	 * If targetlist of the subquery does not contain exactly one element, don't bother.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>subselect</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>


	<comment type="block" format="doxygen">/**
	 * Walk the quals of the subquery to do a more fine grained check as to whether this subquery
	 * may be pulled up. Identify useful fragments to construct join condition if possible to pullup.
	 */</comment>
	<expr_stmt><expr><call><name>ProcessSubqueryToJoin</name><argument_list>(<argument><expr><name>subselect</name></expr></argument>, <argument><expr><name>ctx1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block" format="doxygen">/**
	 * There should be no outer vars in innerQual
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>contain_vars_of_level_or_above</name><argument_list>(<argument><expr><name><name>ctx1</name><operator>-&gt;</operator><name>innerQual</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>ctx1</name><operator>-&gt;</operator><name>safeToConvert</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block" format="doxygen">/**
 * convert_EXPR_to_join
 *
 * Method attempts to convert an EXPR_SUBLINK of the form select * from T where a &gt; (select 10*avg(x) from R where T.b=R.y)
 */</comment>
<function><type><name>JoinExpr</name> <modifier>*</modifier></type>
<name>convert_EXPR_to_join</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>OpExpr</name> <modifier>*</modifier></type><name>opexp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>opexp</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>rarg</name> <init>= <expr><call><name>list_nth</name><argument_list>(<argument><expr><name><name>opexp</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>rarg</name></expr></argument>, <argument><expr><name>SubLink</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>SubLink</name>    <modifier>*</modifier></type><name>sublink</name> <init>= <expr><operator>(</operator><name>SubLink</name> <operator>*</operator><operator>)</operator> <name>rarg</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>ConvertSubqueryToJoinContext</name></type> <name>ctx1</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>InitConvertSubqueryToJoinContext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ctx1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>safe_to_convert_EXPR</name><argument_list>(<argument><expr><name>sublink</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ctx1</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>subselect</name> <init>= <expr><operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name><name>sublink</name><operator>-&gt;</operator><name>subselect</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>subselect</name></expr></argument>, <argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block" format="doxygen">/**
		 * Original subselect must have a single output column (e.g. 10*avg(x) )
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>subselect</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block" format="doxygen">/**
		 * To pull up the subquery, we need to construct a new "Query" object that has grouping
		 * columns extracted from the correlated join predicate and the extra column from the subquery's
		 * targetlist.
		 */</comment>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>origSubqueryTLE</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>list_nth</name><argument_list>(<argument><expr><name><name>subselect</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>subselectTargetList</name> <init>= <expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name><name>ctx1</name><operator>.</operator><name>targetList</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>subselectTargetList</name> <operator>=</operator> <call><name>add_to_flat_tlist</name><argument_list>(<argument><expr><name>subselectTargetList</name></expr></argument>, <argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name><name>origSubqueryTLE</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>subselect</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <name>subselectTargetList</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>subselect</name><operator>-&gt;</operator><name>groupClause</name></name> <operator>=</operator> <name><name>ctx1</name><operator>.</operator><name>groupClause</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>RemoveInnerJoinQuals</name><argument_list>(<argument><expr><name>subselect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>subselect</name><operator>-&gt;</operator><name>jointree</name><operator>-&gt;</operator><name>quals</name></name> <operator>=</operator> <name><name>ctx1</name><operator>.</operator><name>innerQual</name></name></expr>;</expr_stmt>

		<comment type="block" format="doxygen">/**
		 * Construct a new range table entry for the new pulled up subquery.
		 */</comment>
		<decl_stmt><decl><type><name>int</name></type>			<name>rteIndex</name> <init>= <expr><call><name>add_expr_subquery_rte</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>parse</name></name></expr></argument>, <argument><expr><name>subselect</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>rteIndex</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block" format="doxygen">/**
		 * Construct the join expression involving the new pulled up subselect.
		 */</comment>
		<decl_stmt><decl><type><name>JoinExpr</name>   <modifier>*</modifier></type><name>join_expr</name> <init>= <expr><call><name>make_join_expr</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>rteIndex</name></expr></argument>, <argument><expr><name>JOIN_INNER</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>joinQual</name> <init>= <expr><name><name>ctx1</name><operator>.</operator><name>joinQual</name></name></expr></init></decl>;</decl_stmt>

		<comment type="block" format="doxygen">/**
		 * Make outer ones regular and regular ones correspond to rteIndex
		 */</comment>
		<expr_stmt><expr><name>joinQual</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>cdbpullup_expr</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>joinQual</name></expr></argument>, <argument><expr><name><name>subselect</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>rteIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>IncrementVarSublevelsUp</name><argument_list>(<argument><expr><name>joinQual</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>join_expr</name><operator>-&gt;</operator><name>quals</name></name> <operator>=</operator> <name>joinQual</name></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>subselectAggTLE</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>list_nth</name><argument_list>(<argument><expr><name><name>subselect</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>, <argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>subselect</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block" format="doxygen">/**
		 *	modify the op expr to involve the column that has the computed aggregate that needs to compared.
		 */</comment>
		<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>aggVar</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <call><name>makeVar</name><argument_list>(<argument><expr><name>rteIndex</name></expr></argument>,
											 <argument><expr><name><name>subselectAggTLE</name><operator>-&gt;</operator><name>resno</name></name></expr></argument>,
											 <argument><expr><call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>subselectAggTLE</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr></argument>,
											 <argument><expr><call><name>exprTypmod</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>subselectAggTLE</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr></argument>,
											 <argument><expr><call><name>exprCollation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>subselectAggTLE</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr></argument>,
											 <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>list_nth_replace</name><argument_list>(<argument><expr><name><name>opexp</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>aggVar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return <expr><name>join_expr</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* NOTIN subquery transformation -start */</comment>

<comment type="block">/* check if NOT IN conversion to antijoin is possible */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>safe_to_convert_NOTIN</name><parameter_list>(<parameter><decl><type><name>SubLink</name> <modifier>*</modifier></type><name>sublink</name></decl></parameter>, <parameter><decl><type><name>Relids</name></type> <name>available_rels</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>subselect</name> <init>= <expr><operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <name><name>sublink</name><operator>-&gt;</operator><name>subselect</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relids</name></type>		<name>left_varnos</name></decl>;</decl_stmt>

	<comment type="block">/* cases we don't currently handle are listed below. */</comment>

	<comment type="block">/* ARRAY sublinks have empty test expressions */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>sublink</name><operator>-&gt;</operator><name>testexpr</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* No volatile functions in the subquery */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>contain_volatile_functions</name><argument_list>(<argument><expr><name><name>sublink</name><operator>-&gt;</operator><name>testexpr</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block" format="doxygen">/**
	 * If there are correlations in a func expr in the from clause, then don't bother.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>has_correlation_in_funcexpr_rte</name><argument_list>(<argument><expr><name><name>subselect</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Left-hand expressions must contain some Vars of the current */</comment>
	<expr_stmt><expr><name>left_varnos</name> <operator>=</operator> <call><name>pull_varnos</name><argument_list>(<argument><expr><name><name>sublink</name><operator>-&gt;</operator><name>testexpr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>bms_is_empty</name><argument_list>(<argument><expr><name>left_varnos</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * However, it can't refer to anything outside available_rels.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>bms_is_subset</name><argument_list>(<argument><expr><name>left_varnos</name></expr></argument>, <argument><expr><name>available_rels</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Correlation - subquery referencing Vars of parent not handled */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>contain_vars_of_level</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>subselect</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* No set operations in the subquery */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>subselect</name><operator>-&gt;</operator><name>setOperations</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Find if the supplied targetlist has any resjunk
 * entries. We only have to check the tail since
 * resjunks (if any) can only appear in the end.
 */</comment>
<function><type><specifier>inline</specifier> <specifier>static</specifier> <name>bool</name></type>
<name>has_resjunk</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>resjunk</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>tlnode</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><call><name>lfirst</name><argument_list>(<argument><expr><name><name>tlist</name><operator>-&gt;</operator><name>tail</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>tlnode</name></expr></argument>, <argument><expr><name>TargetEntry</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>te</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <name>tlnode</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>te</name><operator>-&gt;</operator><name>resjunk</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>resjunk</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>resjunk</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* add a dummy constant var to the end of the supplied list */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>add_dummy_const</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>dummy</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Const</name>	   <modifier>*</modifier></type><name>zconst</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>resno</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>zconst</name> <operator>=</operator> <call><name>makeConst</name><argument_list>(<argument><expr><name>INT4OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int32</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr></argument>,
					   <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* isnull, byval */</comment>
	<expr_stmt><expr><name>resno</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>dummy</name> <operator>=</operator> <call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>zconst</name></expr></argument>,
							<argument><expr><name>resno</name></expr></argument>,
							<argument><expr><name>DUMMY_COLUMN_NAME</name></expr></argument>,
							<argument><expr><name>false</name></expr></argument> <comment type="block">/* resjunk */</comment> )</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>tlist</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>tlist</name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>dummy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>tlist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>, <argument><expr><name>dummy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<return>return <expr><name>tlist</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Add a dummy variable to the supplied target list. The
 * variable is added to end of targetlist but before all
 * resjunk vars (if any). The caller should make use of
 * the returned targetlist since this code might modify
 * the list in-place.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>mutate_targetlist</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>new_list</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>has_resjunk</name><argument_list>(<argument><expr><name>tlist</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>curr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>junk</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>curr</argument>, <argument>tlist</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>curr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>tle</name><operator>-&gt;</operator><name>resjunk</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>tle</name><operator>-&gt;</operator><name>resno</name></name> <operator>=</operator> <name><name>tle</name><operator>-&gt;</operator><name>resno</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>junk</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>junk</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>new_list</name> <operator>=</operator> <call><name>add_dummy_const</name><argument_list>(<argument><expr><name>new_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>new_list</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>new_list</name></expr></argument>, <argument><expr><name>tle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>new_list</name> <operator>=</operator> <name>tlist</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>new_list</name> <operator>=</operator> <call><name>add_dummy_const</name><argument_list>(<argument><expr><name>new_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<return>return <expr><name>new_list</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Pulls up the subquery into the top-level range table.
 * Before that add a dummy column zero to the target list
 * of the subquery.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>add_notin_subquery_rte</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>parse</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>subselect</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>subq_rte</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>subq_indx</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Create a RTE entry in the parent query for the subquery.
	 * It is marked as lateral, because any correlation quals will
	 * refer to other RTEs in the parent query.
	 */</comment>
	<expr_stmt><expr><name><name>subselect</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <call><name>mutate_targetlist</name><argument_list>(<argument><expr><name><name>subselect</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>subq_rte</name> <operator>=</operator> <call><name>addRangeTableEntryForSubquery</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>,	<comment type="block">/* pstate */</comment>
											 <argument><expr><name>subselect</name></expr></argument>,
											 <argument><expr><call><name>makeAlias</name><argument_list>(<argument><expr><literal type="string">"NotIn_SUBQUERY"</literal></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr></argument>,
											 <argument><expr><name>false</name></expr></argument>, <comment type="block">/* not lateral */</comment>
											 <argument><expr><name>false</name></expr></argument> <comment type="block">/* inFromClause */</comment> )</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>parse</name><operator>-&gt;</operator><name>rtable</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>parse</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>, <argument><expr><name>subq_rte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* assume new rte is at end */</comment>
	<expr_stmt><expr><name>subq_indx</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>parse</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>subq_rte</name> <operator>==</operator> <call><name>rt_fetch</name><argument_list>(<argument><expr><name>subq_indx</name></expr></argument>, <argument><expr><name><name>parse</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>subq_indx</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Pulls up the expr sublink subquery into the top-level range table.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>add_expr_subquery_rte</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>parse</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>subselect</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>subq_rte</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>subq_indx</name></decl>;</decl_stmt>

	<comment type="block" format="doxygen">/**
	 * Generate column names.
	 * TODO: improve this to keep old names around
	 */</comment>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>teNum</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>subselect-&gt;targetList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>te</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>te</name><operator>-&gt;</operator><name>resname</name></name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"csq_c%d"</literal></expr></argument>, <argument><expr><name>teNum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>teNum</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * Create a RTE entry in the parent query for the subquery.
	 * It is marked as lateral, because any correlation quals will
	 * refer to other RTEs in the parent query.
	 */</comment>
	<expr_stmt><expr><name>subq_rte</name> <operator>=</operator> <call><name>addRangeTableEntryForSubquery</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>,	<comment type="block">/* pstate */</comment>
											 <argument><expr><name>subselect</name></expr></argument>,
											 <argument><expr><call><name>makeAlias</name><argument_list>(<argument><expr><literal type="string">"Expr_SUBQUERY"</literal></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr></argument>,
											 <argument><expr><name>true</name></expr></argument>, <comment type="block">/* lateral */</comment>
											 <argument><expr><name>false</name></expr></argument> <comment type="block">/* inFromClause */</comment> )</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>parse</name><operator>-&gt;</operator><name>rtable</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>parse</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>, <argument><expr><name>subq_rte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* assume new rte is at end */</comment>
	<expr_stmt><expr><name>subq_indx</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>parse</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>subq_rte</name> <operator>==</operator> <call><name>rt_fetch</name><argument_list>(<argument><expr><name>subq_indx</name></expr></argument>, <argument><expr><name><name>parse</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>subq_indx</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* Create a join expression linking the supplied larg node
 * with the pulled up NOT IN subquery located at r_rtindex
 * in the range table. The appropriate JOIN_RTE has already
 * been created by the caller and can be located at j_rtindex
 */</comment>
<function><type><specifier>static</specifier> <name>JoinExpr</name> <modifier>*</modifier></type>
<name>make_join_expr</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>larg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>r_rtindex</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>join_type</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>JoinExpr</name>   <modifier>*</modifier></type><name>jexpr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeTblRef</name> <modifier>*</modifier></type><name>rhs</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>rhs</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>RangeTblRef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rhs</name><operator>-&gt;</operator><name>rtindex</name></name> <operator>=</operator> <name>r_rtindex</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>jexpr</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>JoinExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>jexpr</name><operator>-&gt;</operator><name>jointype</name></name> <operator>=</operator> <name>join_type</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>jexpr</name><operator>-&gt;</operator><name>isNatural</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>jexpr</name><operator>-&gt;</operator><name>larg</name></name> <operator>=</operator> <name>larg</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>jexpr</name><operator>-&gt;</operator><name>rarg</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>rhs</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>jexpr</name><operator>-&gt;</operator><name>rtindex</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<return>return <expr><name>jexpr</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Convert subquery's test expr to a suitable predicate.
 * If we wanted to add correlated subquery support, this would be the place to do it.
 */</comment>
<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>make_lasj_quals</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>SubLink</name> <modifier>*</modifier></type><name>sublink</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>subquery_indx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>subselect</name> <init>= <expr><operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <name><name>sublink</name><operator>-&gt;</operator><name>subselect</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>join_pred</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>subquery_vars</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>sublink</name><operator>-&gt;</operator><name>subLinkType</name></name> <operator>==</operator> <name>ALL_SUBLINK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Build a list of Vars representing the subselect outputs.
	 */</comment>
	<expr_stmt><expr><name>subquery_vars</name> <operator>=</operator> <call><name>generate_subquery_vars</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
										   <argument><expr><name><name>subselect</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>,
										   <argument><expr><name>subquery_indx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Build the result qual expression, replacing Params with these Vars.
	 */</comment>
	<expr_stmt><expr><name>join_pred</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>convert_testexpr</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
										  <argument><expr><name><name>sublink</name><operator>-&gt;</operator><name>testexpr</name></name></expr></argument>,
										  <argument><expr><name>subquery_vars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>join_pred</name> <operator>=</operator> <call><name>canonicalize_qual</name><argument_list>(<argument><expr><call><name>make_notclause</name><argument_list>(<argument><expr><name>join_pred</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>join_pred</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>join_pred</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* add IS NOT FALSE clause on top of the clause */</comment>
<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>add_null_match_clause</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>clause</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BooleanTest</name> <modifier>*</modifier></type><name>btest</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>clause</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>btest</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>BooleanTest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>btest</name><operator>-&gt;</operator><name>arg</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>clause</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>btest</name><operator>-&gt;</operator><name>booltesttype</name></name> <operator>=</operator> <name>IS_NOT_FALSE</name></expr>;</expr_stmt>
	<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>btest</name></expr>;</return>
</block_content>}</block></function>


<comment type="block" format="doxygen">/**
 * Is the attribute of a base relation non-nullable?
 * Input:
 *	relationOid
 *	attributeNumber
 * Output:
 *	true if the attribute is non-nullable
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>is_attribute_nonnullable</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationOid</name></decl></parameter>, <parameter><decl><type><name>AttrNumber</name></type> <name>attrNumber</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>attributeTuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attribute</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>result</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>attributeTuple</name> <operator>=</operator> <call><name>SearchSysCache2</name><argument_list>(<argument><expr><name>ATTNUM</name></expr></argument>,
									 <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relationOid</name></expr></argument>)</argument_list></call></expr></argument>,
									 <argument><expr><call><name>Int16GetDatum</name><argument_list>(<argument><expr><name>attrNumber</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>attributeTuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>attribute</name> <operator>=</operator> <operator>(</operator><name>Form_pg_attribute</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>attributeTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>attribute</name><operator>-&gt;</operator><name>attisdropped</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>attribute</name><operator>-&gt;</operator><name>attnotnull</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>attributeTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>


<comment type="block" format="doxygen">/**
 * This walker goes through a query's join-tree to determine the set of non-nullable
 * vars. E.g.
 * select x from t1, t2 where x=y .. the walker determines that x and y are involved in an inner join
 * and therefore are non-nullable.
 * select x from t1 where x &gt; 20 .. the walker determines that the quals ensures that x is non-nullable
 *
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>cdb_find_nonnullable_vars_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>NonNullableVarsContext</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>query</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>T_Var</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>var</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>varlevelsup</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>nonNullableVars</name></name> <operator>=</operator> <call><name>list_append_unique</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>nonNullableVars</name></name></expr></argument>, <argument><expr><name>var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<return>return <expr><name>false</name></expr>;</return>
			</block_content>}</block>
		<case>case <expr><name>T_FuncExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>FuncExpr</name>   <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>FuncExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>func_strict</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>funcid</name></name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					 * If a function is not strict, it can return non-null
					 * values for null inputs. Thus, input vars can be null
					 * and sneak through. Therefore, ignore all vars
					 * underneath.
					 */</comment>
					<return>return <expr><name>false</name></expr>;</return>
				</block_content>}</block></if></if_stmt>
				<break>break;</break>
			</block_content>}</block>
		<case>case <expr><name>T_OpExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>OpExpr</name>	   <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>OpExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>op_strict</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>opno</name></name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					 * If an op is not strict, it can return non-null values
					 * for null inputs. Ignore all vars underneath.
					 */</comment>
					<return>return <expr><name>false</name></expr>;</return>
				</block_content>}</block></if></if_stmt>

				<break>break;</break>
			</block_content>}</block>
		<case>case <expr><name>T_BoolExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>BoolExpr</name>   <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>BoolExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>expr</name><operator>-&gt;</operator><name>boolop</name></name> <operator>==</operator> <name>NOT_EXPR</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block" format="doxygen">/**
					 * Not negates all conditions underneath. We choose to not handle
					 * this situation.
					 */</comment>
					<return>return <expr><name>false</name></expr>;</return>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><name><name>expr</name><operator>-&gt;</operator><name>boolop</name></name> <operator>==</operator> <name>OR_EXPR</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block" format="doxygen">/**
					 * We add the intersection of variables determined to be
					 * non-nullable by each arg to the OR expression.
					 */</comment>
					<decl_stmt><decl><type><name>NonNullableVarsContext</name></type> <name>c1</name></decl>;</decl_stmt>

					<expr_stmt><expr><name><name>c1</name><operator>.</operator><name>query</name></name> <operator>=</operator> <name><name>context</name><operator>-&gt;</operator><name>query</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>c1</name><operator>.</operator><name>varsToCheck</name></name> <operator>=</operator> <name><name>context</name><operator>-&gt;</operator><name>varsToCheck</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>c1</name><operator>.</operator><name>nonNullableVars</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
					<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>int</name></type>			<name>orArgNum</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

					<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>expr-&gt;args</argument>)</argument_list></macro>
					<block>{<block_content>
						<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>orArg</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

						<decl_stmt><decl><type><name>NonNullableVarsContext</name></type> <name>c2</name></decl>;</decl_stmt>

						<expr_stmt><expr><name><name>c2</name><operator>.</operator><name>query</name></name> <operator>=</operator> <name><name>context</name><operator>-&gt;</operator><name>query</name></name></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>c2</name><operator>.</operator><name>varsToCheck</name></name> <operator>=</operator> <name><name>context</name><operator>-&gt;</operator><name>varsToCheck</name></name></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>c2</name><operator>.</operator><name>nonNullableVars</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><name>orArg</name></expr></argument>, <argument><expr><name>cdb_find_nonnullable_vars_walker</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>c2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<if_stmt><if>if <condition>(<expr><name>orArgNum</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>c1</name><operator>.</operator><name>nonNullableVars</name></name> <operator>==</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><name><name>c1</name><operator>.</operator><name>nonNullableVars</name></name> <operator>=</operator> <name><name>c2</name><operator>.</operator><name>nonNullableVars</name></name></expr>;</expr_stmt>
						</block_content>}</block></if>
						<else>else
						<block>{<block_content>
							<expr_stmt><expr><name><name>c1</name><operator>.</operator><name>nonNullableVars</name></name> <operator>=</operator> <call><name>list_intersection</name><argument_list>(<argument><expr><name><name>c1</name><operator>.</operator><name>nonNullableVars</name></name></expr></argument>, <argument><expr><name><name>c2</name><operator>.</operator><name>nonNullableVars</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						</block_content>}</block></else></if_stmt>
						<expr_stmt><expr><name>orArgNum</name><operator>++</operator></expr>;</expr_stmt>
					</block_content>}</block>

					<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>nonNullableVars</name></name> <operator>=</operator> <call><name>list_concat_unique</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>nonNullableVars</name></name></expr></argument>, <argument><expr><name><name>c1</name><operator>.</operator><name>nonNullableVars</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return <expr><name>false</name></expr>;</return>
				</block_content>}</block></if></if_stmt>

				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>boolop</name></name> <operator>==</operator> <name>AND_EXPR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block" format="doxygen">/**
				 * AND_EXPR is automatically handled by the walking algorithm.
				 */</comment>
				<break>break;</break>
			</block_content>}</block>
		<case>case <expr><name>T_NullTest</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>NullTest</name>   <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>NullTest</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>expr</name><operator>-&gt;</operator><name>nulltesttype</name></name> <operator>!=</operator> <name>IS_NOT_NULL</name></expr>)</condition>
				<block>{<block_content>
					<return>return <expr><name>false</name></expr>;</return>
				</block_content>}</block></if></if_stmt>

				<break>break;</break>
			</block_content>}</block>
		<case>case <expr><name>T_BooleanTest</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>BooleanTest</name> <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>BooleanTest</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>expr</name><operator>-&gt;</operator><name>booltesttype</name></name> <operator>==</operator> <name>IS_NOT_UNKNOWN</name>
					  <operator>||</operator> <name><name>expr</name><operator>-&gt;</operator><name>booltesttype</name></name> <operator>==</operator> <name>IS_TRUE</name>
					  <operator>||</operator> <name><name>expr</name><operator>-&gt;</operator><name>booltesttype</name></name> <operator>==</operator> <name>IS_FALSE</name><operator>)</operator></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* Other tests may allow a null value to pass through. */</comment>
					<return>return <expr><name>false</name></expr>;</return>
				</block_content>}</block></if></if_stmt>
				<break>break;</break>
			</block_content>}</block>
		<case>case <expr><name>T_JoinExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>JoinExpr</name>   <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>JoinExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>expr</name><operator>-&gt;</operator><name>jointype</name></name> <operator>!=</operator> <name>JOIN_INNER</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* Do not descend below any other join type */</comment>
					<return>return <expr><name>false</name></expr>;</return>
				</block_content>}</block></if></if_stmt>
				<break>break;</break>
			</block_content>}</block>
		<case>case <expr><name>T_FromExpr</name></expr>:</case>
		<case>case <expr><name>T_List</name></expr>:</case>
			<block>{<block_content>
				<comment type="block">/*
				 * Top-level where clause is fine -- equivalent to an inner
				 * join
				 */</comment>
				<break>break;</break>
			</block_content>}</block>
		<case>case <expr><name>T_RangeTblRef</name></expr>:</case>
			<block>{<block_content>
				<comment type="block">/*
				 * If we've gotten this far, then we can look for non-null
				 * constraints on the vars in the query's targetlist.
				 */</comment>
				<decl_stmt><decl><type><name>RangeTblRef</name> <modifier>*</modifier></type><name>rtf</name> <init>= <expr><operator>(</operator><name>RangeTblRef</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><call><name>rt_fetch</name><argument_list>(<argument><expr><name><name>rtf</name><operator>-&gt;</operator><name>rtindex</name></name></expr></argument>, <argument><expr><name><name>context</name><operator>-&gt;</operator><name>query</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_RELATION</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					 * Find all vars in the query's targetlist that are from
					 * this relation and check if the attribute is
					 * non-nullable by base table constraint.
					 */</comment>

					<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

					<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>context-&gt;varsToCheck</argument>)</argument_list></macro>
					<block>{<block_content>
						<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>var</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

						<if_stmt><if>if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>varno</name></name> <operator>==</operator> <name><name>rtf</name><operator>-&gt;</operator><name>rtindex</name></name></expr>)</condition>
						<block>{<block_content>
							<decl_stmt><decl><type><name>int</name></type>			<name>attNum</name> <init>= <expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name></expr></init></decl>;</decl_stmt>
							<decl_stmt><decl><type><name>int</name></type>			<name>relOid</name> <init>= <expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></init></decl>;</decl_stmt>

							<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>relOid</name> <operator>!=</operator> <name>InvalidOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

							<if_stmt><if>if <condition>(<expr><call><name>is_attribute_nonnullable</name><argument_list>(<argument><expr><name>relOid</name></expr></argument>, <argument><expr><name>attNum</name></expr></argument>)</argument_list></call></expr>)</condition>
							<block>{<block_content>
								<comment type="block">/*
								 * Base table constraint on the var. Add
								 * it to the list!
								 */</comment>
								<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>nonNullableVars</name></name> <operator>=</operator> <call><name>list_append_unique</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>nonNullableVars</name></name></expr></argument>, <argument><expr><name>var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							</block_content>}</block></if></if_stmt>
						</block_content>}</block></if></if_stmt>
					</block_content>}</block>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_SUBQUERY</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					 * When the RTE is a subquery, the algorithm to extend non-nullable Vars is:
					 *   1. based on the interested VarsToCheck, find those pointing to this RTE,
					 *      and build a list of exprs containing the corresponding target entry's
					 *      expr.
					 *   2. recusrively invoke is_exprs_nullable for The new list of exprs and the
					 *      subquery:
					 *        a. if they are non-nullable, let's expand the knowledage databse
					 *           using the corresponding Vars in original VarsToCheck
					 *        b. otherwise, we know the result is nullable, terminate the walk.
					 */</comment>
					<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>List</name>     <modifier>*</modifier></type><name>exprs</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
					<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>context-&gt;varsToCheck</argument>)</argument_list></macro>
					<block>{<block_content>
						<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>var</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
						<if_stmt><if>if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>varno</name></name> <operator>==</operator> <name><name>rtf</name><operator>-&gt;</operator><name>rtindex</name></name></expr>)</condition>
						<block>{<block_content>
							<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name></decl>;</decl_stmt>
							<expr_stmt><expr><name>tle</name> <operator>=</operator> <call><name>list_nth</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>subquery</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><name>exprs</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>exprs</name></expr></argument>, <argument><expr><name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						</block_content>}</block></if></if_stmt>
					</block_content>}</block>

					<comment type="block">/*
					 * The vars fetched from special RTEs (RTE_JOIN ) are mapped to those in base RTEs,
					 * so when the walker reach these special RTEs, the exprs can be NIL.
					 * Empty exprs means no check is needed in this step and the walker should continue
					 * scanning other parts of the jointree.
					 * NOTE: break is also needed to avoid call the function 'is_exprs_nullable' on NIL exprs,
					 * which reports NIL as nullable and terminates the walker
					 */</comment>
					<if_stmt><if>if <condition>(<expr><name>exprs</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
						<break>break;</break></block_content></block></if></if_stmt>

					<if_stmt><if>if <condition>(<expr><call><name>is_exprs_nullable</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>exprs</name></expr></argument>, <argument><expr><name><name>rte</name><operator>-&gt;</operator><name>subquery</name></name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/*
						 * The VarsTocheck must be nullable, terminate here.
						 * Since we are sure the nullable check will fail, so
						 * set the knowledage database to NIL here.
						 * */</comment>
						<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>nonNullableVars</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
						<return>return <expr><name>true</name></expr>;</return>
					</block_content>}</block></if></if_stmt>

					<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>context-&gt;varsToCheck</argument>)</argument_list></macro>
					<block>{<block_content>
						<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>var</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
						<if_stmt><if>if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>varno</name></name> <operator>==</operator> <name><name>rtf</name><operator>-&gt;</operator><name>rtindex</name></name></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>nonNullableVars</name></name> <operator>=</operator> <call><name>list_append_unique</name><argument_list>(
											<argument><expr><name><name>context</name><operator>-&gt;</operator><name>nonNullableVars</name></name></expr></argument>, <argument><expr><name>var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						</block_content>}</block></if></if_stmt>
					</block_content>}</block>

				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_VALUES</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					 * TODO: make this work for values scan someday.
					 */</comment>
				</block_content>}</block></if></if_stmt>
				<return>return <expr><name>false</name></expr>;</return>
			</block_content>}</block>
		<case>case <expr><name>T_PlaceHolderVar</name></expr>:</case>
			<block>{<block_content>
				<comment type="block">/*
				 * GPDB_84_MERGE_FIXME: Confirm if we need to do special
				 * handling for PlaceHolderVar. Currently we are just fall
				 * through the mutator.
				 */</comment>
				<break>break;</break>
			</block_content>}</block>
		<default>default:</default>
			<block>{<block_content>
				<comment type="block">/* Do not descend beyond any other node */</comment>
				<return>return <expr><name>false</name></expr>;</return>
			</block_content>}</block>
	</block_content>}</block></switch>
	<return>return <expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>cdb_find_nonnullable_vars_walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>fetch_targetlist_exprs</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>targetlist</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>        <modifier>*</modifier></type><name>exprs</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>    <modifier>*</modifier></type><name>lc</name>    <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>targetlist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>tle</name><operator>-&gt;</operator><name>resjunk</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Previously, we take it nullable when we
			 * see any resjunk target entry. I think it
			 * is safe to just ignore them.
			 */</comment>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>exprs</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>exprs</name></expr></argument>, <argument><expr><name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>exprs</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * fetch_outer_exprs
 *   @param testexpr: the NOT-IN sublink's test exprs
 *
 *   For a two-col NOT_IN query: select * from t1 where (a,b) not in (select a,b from t2)
 *   this testexpr should be:
 *   BoolExpr [boolop=NOT_EXPR]
 *      BoolExpr [boolop=AND_EXPR]
 *        OpExpr [opno=96 opfuncid=65 opresulttype=16 opretset=false]
 *                Var [varno=1 varattno=1 vartype=23 varnoold=1 varoattno=1]
 *                Param [paramkind=PARAM_SUBLINK paramid=1 paramtype=23]
 *        OpExpr [opno=96 opfuncid=65 opresulttype=16 opretset=false]
 *                Var [varno=1 varattno=2 vartype=23 varnoold=1 varoattno=2]
 *                Param [paramkind=PARAM_SUBLINK paramid=2 paramtype=23]
 *
 *  For a two-col &lt;&gt; ALL query: select * from t1 where (a,b) &lt;&gt; (select a,b from t2)
 *  this testexpr should be:
 *  BoolExpr [boolop=OR_EXPR]
 *     OpExpr [opno=518 opfuncid=144 opresulttype=16 opretset=false]
 *              Var [varno=1 varattno=1 vartype=23 varnoold=1 varoattno=1]
 *              Param [paramkind=PARAM_SUBLINK paramid=1 paramtype=23]
 *      OpExpr [opno=518 opfuncid=144 opresulttype=16 opretset=false]
 *              Var [varno=1 varattno=2 vartype=23 varnoold=1 varoattno=2]
 *              Param [paramkind=PARAM_SUBLINK paramid=2 paramtype=23]
 *
 * This function fetches all the outer parts and put them in a list as the
 * result.
 *
 * NOTE: we want to be conservative for cases we are not interested or
 * we are not sure. Returning a NIL is conservative policy here since
 * is_exprs_nullable will return true for NULL input.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>fetch_outer_exprs</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>testexpr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>testexpr</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NIL</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>testexpr</name></expr></argument>, <argument><expr><name>BoolExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>BoolExpr</name> <modifier>*</modifier></type><name>be</name> <init>= <expr><operator>(</operator><name>BoolExpr</name> <operator>*</operator><operator>)</operator> <name>testexpr</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>      <name>seen_not_atop</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Node</name>     <modifier>*</modifier></type><name>expr</name></decl>;</decl_stmt>
		<expr_stmt><expr><name>seen_not_atop</name> <operator>=</operator> <name><name>be</name><operator>-&gt;</operator><name>boolop</name></name> <operator>==</operator> <name>NOT_EXPR</name></expr>;</expr_stmt>

		<comment type="block">/* strip off the top NOT */</comment>
		<if_stmt><if>if <condition>(<expr><name>seen_not_atop</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>expr</name> <operator>=</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>be</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>expr</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>be</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/*
		 * The above expr should be a single OpExpr when single-column not-in,
		 * or a BoolExpr of AND when multi-column not-in. We are not interested
		 * in other cases.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>BoolExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>BoolExpr</name> <modifier>*</modifier></type><name>be</name>    <init>= <expr><operator>(</operator><name>BoolExpr</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>List</name>     <modifier>*</modifier></type><name>exprs</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

			<comment type="block">/*
			 * The following cases should not happen, instead of
			 * erroring out, let's be conservative by returning NIL.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>be</name><operator>-&gt;</operator><name>boolop</name></name> <operator>==</operator> <name>AND_EXPR</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>seen_not_atop</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>NIL</name></expr>;</return></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>be</name><operator>-&gt;</operator><name>boolop</name></name> <operator>==</operator> <name>OR_EXPR</name> <operator>&amp;&amp;</operator> <name>seen_not_atop</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>NIL</name></expr>;</return></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>be</name><operator>-&gt;</operator><name>boolop</name></name> <operator>!=</operator> <name>OR_EXPR</name> <operator>&amp;&amp;</operator> <name><name>be</name><operator>-&gt;</operator><name>boolop</name></name> <operator>!=</operator> <name>AND_EXPR</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>NIL</name></expr>;</return></block_content></block></if></if_stmt>

			<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>be-&gt;args</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>OpExpr</name> <modifier>*</modifier></type><name>op_expr</name> <init>= <expr><operator>(</operator><name>OpExpr</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>op_expr</name></expr></argument>, <argument><expr><name>OpExpr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>NIL</name></expr>;</return></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>exprs</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>exprs</name></expr></argument>, <argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>op_expr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<return>return <expr><name>exprs</name></expr>;</return>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>OpExpr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><call><name>list_make1</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>OpExpr</name> <operator>*</operator><operator>)</operator><name>expr</name><operator>)</operator><operator>-&gt;</operator><name>args</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<return>return <expr><name>NIL</name></expr>;</return></block_content></block></else></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>testexpr</name></expr></argument>, <argument><expr><name>OpExpr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>list_make1</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>OpExpr</name> <operator>*</operator><operator>)</operator><name>testexpr</name><operator>)</operator><operator>-&gt;</operator><name>args</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><name>NIL</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * is_exprs_nullable
 *   Return true if any of the exprs might be null, otherwise false.
 *   We want to be conservative for those cases either we are not
 *   interested or not sure.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>is_exprs_nullable</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>exprs</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>NonNullableVarsContext</name></type> <name>context</name></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>query</name></name>           <operator>=</operator> <name>query</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>varsToCheck</name></name>     <operator>=</operator> <call><name>cdb_find_all_vars</name><argument_list>(<argument><expr><name>exprs</name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>nonNullableVars</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<comment type="block">/* Find nullable vars in the jointree */</comment>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>expression_tree_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>query</name><operator>-&gt;</operator><name>jointree</name></name></expr></argument>,
								  <argument><expr><name>cdb_find_nonnullable_vars_walker</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>is_exprs_nullable_internal</name><argument_list>(<argument><expr><name>exprs</name></expr></argument>, <argument><expr><name><name>context</name><operator>.</operator><name>nonNullableVars</name></name></expr></argument>, <argument><expr><name><name>query</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>is_exprs_nullable_internal</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>exprs</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>nonnullable_vars</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>rtable</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>exprs</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Be conservative when input is Empty. Keep consistent
		 * with fetch_outer_exprs and fetch_targetlist_exprs.
		 */</comment>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>exprs</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>tmpvar</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator><name>exprs</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* params treat as nullable exprs */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>tmpvar</name><operator>-&gt;</operator><name>varlevelsup</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

		<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>var</name> <init>= <expr><call><name>cdb_map_to_base_var</name><argument_list>(<argument><expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>exprs</name></expr></argument>, <argument><expr><name>rtable</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* once not found RTE of var, return as nullable expr */</comment>
		<if_stmt><if>if <condition>(<expr><name>var</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

		<return>return <expr><operator>!</operator><call><name>list_member</name><argument_list>(<argument><expr><name>nonnullable_vars</name></expr></argument>, <argument><expr><name>var</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>exprs</name></expr></argument>, <argument><expr><name>List</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>(List *) exprs</argument>)</argument_list></macro>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>is_exprs_nullable_internal</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>,
										   <argument><expr><name>nonnullable_vars</name></expr></argument>, <argument><expr><name>rtable</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>exprs</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Const</name>	   <modifier>*</modifier></type><name>constant</name> <init>= <expr><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>exprs</name></expr></init></decl>;</decl_stmt>
		<return>return <expr><name><name>constant</name><operator>-&gt;</operator><name>constisnull</name></name></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>exprs</name></expr></argument>, <argument><expr><name>RelabelType</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RelabelType</name>    <modifier>*</modifier></type><name>rt</name> <init>= <expr><operator>(</operator><name>RelabelType</name> <operator>*</operator><operator>)</operator> <name>exprs</name></expr></init></decl>;</decl_stmt>
		<return>return <expr><call><name>is_exprs_nullable_internal</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>rt</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>, <argument><expr><name>nonnullable_vars</name></expr></argument>, <argument><expr><name>rtable</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>exprs</name></expr></argument>, <argument><expr><name>OpExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>OpExpr</name>   <modifier>*</modifier></type><name>op_expr</name> <init>= <expr><operator>(</operator><name>OpExpr</name> <operator>*</operator><operator>)</operator> <name>exprs</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>op_expr-&gt;args</argument>)</argument_list></macro>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>is_exprs_nullable_internal</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>,
										   <argument><expr><name>nonnullable_vars</name></expr></argument>, <argument><expr><name>rtable</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Be conservative here */</comment>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * convert_IN_to_antijoin: can we convert an ALL SubLink to join style?
 * If not appropriate to process this SubLink, return it as it is.
 * Side effects of a successful conversion include adding the SubLink's
 * subselect to the top-level rangetable, adding a JOIN RTE linking the outer
 * query with the subselect and setting up the qualifiers correctly.
 *
 * The transformation is to rewrite a query of the form:
 *		select c1 from t1 where c1 NOT IN (select c2 from t2);
 *						(to)
 *		select c1 from t1 left anti semi join (select 0 as zero, c2 from t2) foo
 *						  ON (c1 = c2) IS NOT FALSE where zero is NULL;
 *
 * The pseudoconstant column zero is needed to correctly pipe in the NULLs
 * from the subselect upstream.
 *
 * The current implementation assumes that the sublink expression occurs
 * in a top-level where clause (or through a series of inner joins).
 */</comment>
<function><type><name>JoinExpr</name> <modifier>*</modifier></type>
<name>convert_IN_to_antijoin</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>SubLink</name> <modifier>*</modifier></type><name>sublink</name></decl></parameter>,
					   <parameter><decl><type><name>Relids</name></type> <name>available_rels</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>parse</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>parse</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>subselect</name> <init>= <expr><operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <name><name>sublink</name><operator>-&gt;</operator><name>subselect</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>safe_to_convert_NOTIN</name><argument_list>(<argument><expr><name>sublink</name></expr></argument>, <argument><expr><name>available_rels</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Delete ORDER BY and DISTINCT.
		 *
		 * There is no need to do the group-by or order-by inside the
		 * subquery, if we have decided to pull up the sublink. For the
		 * group-by case, after the sublink pull-up, there will be a semi-join
		 * plan node generated in top level, which will weed out duplicate
		 * tuples naturally. For the order-by case, after the sublink pull-up,
		 * the subquery will become a jointree, inside which the tuples' order
		 * doesn't matter. In a summary, it's safe to elimate the group-by or
		 * order-by causes here.
		 */</comment>
		<expr_stmt><expr><call><name>cdbsubselect_drop_orderby</name><argument_list>(<argument><expr><name>subselect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>cdbsubselect_drop_distinct</name><argument_list>(<argument><expr><name>subselect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>int</name></type>			<name>subq_indx</name>      <init>= <expr><call><name>add_notin_subquery_rte</name><argument_list>(<argument><expr><name>parse</name></expr></argument>, <argument><expr><name>subselect</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>inner_exprs</name>    <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>outer_exprs</name>    <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>        <name>inner_nullable</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>        <name>outer_nullable</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>inner_exprs</name> <operator>=</operator> <call><name>fetch_targetlist_exprs</name><argument_list>(<argument><expr><name><name>subselect</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>outer_exprs</name> <operator>=</operator> <call><name>fetch_outer_exprs</name><argument_list>(<argument><expr><name><name>sublink</name><operator>-&gt;</operator><name>testexpr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>inner_nullable</name> <operator>=</operator> <call><name>is_exprs_nullable</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>inner_exprs</name></expr></argument>, <argument><expr><name>subselect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>outer_nullable</name> <operator>=</operator> <call><name>is_exprs_nullable</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>outer_exprs</name></expr></argument>, <argument><expr><name>parse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>JoinExpr</name>   <modifier>*</modifier></type><name>join_expr</name> <init>= <expr><call><name>make_join_expr</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>subq_indx</name></expr></argument>, <argument><expr><name>JOIN_LASJ_NOTIN</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>join_expr</name><operator>-&gt;</operator><name>quals</name></name> <operator>=</operator> <call><name>make_lasj_quals</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>sublink</name></expr></argument>, <argument><expr><name>subq_indx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>inner_nullable</name> <operator>||</operator> <name>outer_nullable</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>join_expr</name><operator>-&gt;</operator><name>quals</name></name> <operator>=</operator> <call><name>add_null_match_clause</name><argument_list>(<argument><expr><name><name>join_expr</name><operator>-&gt;</operator><name>quals</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<return>return <expr><name>join_expr</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Not safe to perform transformation. */</comment>
	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Check if there is a range table entry of type func expr whose arguments
 * are correlated
 */</comment>
<function><type><name>bool</name></type>
<name>has_correlation_in_funcexpr_rte</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>rtable</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * check if correlation occurs in a func expr in the from clause of the
	 * subselect
	 */</comment>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc_rte</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc_rte</argument>, <argument>rtable</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><operator>(</operator><name>RangeTblEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc_rte</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>functions</name></name>  <operator>&amp;&amp;</operator> <call><name>contain_vars_of_level_or_above</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>rte</name><operator>-&gt;</operator><name>functions</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>cdb_find_all_vars</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>exprs</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>rtable</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FindAllVarsContext</name></type>    <name>context</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>rtable</name></name> <operator>=</operator> <name>rtable</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>vars</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><name>exprs</name></expr></argument>, <argument><expr><name>cdb_find_all_vars_walker</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>context</name><operator>.</operator><name>vars</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>cdb_find_all_vars_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>FindAllVarsContext</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Var</name> <modifier>*</modifier></type><name>var</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator><name>node</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>varlevelsup</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * The vars fetched from targetList/testexpr.. can be from virtual range table (RTE_JOIN),
		 * which do not directly match base vars fetched by cdb_find_nonnullable_vars_walker, aligning
		 * them to base vars is needed before check nullable.
		 */</comment>
		<expr_stmt><expr><name>var</name> <operator>=</operator> <call><name>cdb_map_to_base_var</name><argument_list>(<argument><expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>, <argument><expr><name><name>context</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>var</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>vars</name></name> <operator>=</operator> <call><name>list_append_unique</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>vars</name></name></expr></argument>, <argument><expr><name>var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>cdb_find_all_vars_walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Var</name> <modifier>*</modifier></type>
<name>cdb_map_to_base_var</name><parameter_list>(<parameter><decl><type><name>Var</name> <modifier>*</modifier></type><name>var</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>rtable</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name>    <init>= <expr><call><name>rt_fetch</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>varno</name></name></expr></argument>, <argument><expr><name>rtable</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<while>while<condition>(<expr><name>rte</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_JOIN</name> <operator>&amp;&amp;</operator> <name><name>rte</name><operator>-&gt;</operator><name>joinaliasvars</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>var</name> <operator>=</operator> <operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <call><name>list_nth</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>joinaliasvars</name></name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>rt_fetch</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>varno</name></name></expr></argument>, <argument><expr><name>rtable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<comment type="block">/* not found RTE in current level rtable */</comment>
	<if_stmt><if>if <condition>(<expr><name>rte</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name>var</name></expr>;</return>
</block_content>}</block></function>
</unit>
