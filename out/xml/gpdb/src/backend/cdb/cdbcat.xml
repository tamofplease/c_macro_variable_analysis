<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/backend/cdb/cdbcat.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * cdbcat.c
 *	  Routines for dealing with GpPolicy
 *
 * Portions Copyright (c) 2005-2008, Greenplum inc
 * Portions Copyright (c) 2012-Present VMware, Inc. or its affiliates.
 *
 *
 * IDENTIFICATION
 *	    src/backend/cdb/cdbcat.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/external.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/genam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/hash.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/heapam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/dependency.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/gp_distribution_policy.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/indexing.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/namespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/objectaddress.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_constraint.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_namespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_opclass.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbcat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbhash.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbutil.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbvars.h"</cpp:file></cpp:include>		<comment type="block">/* Gp_role */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"foreign/foreign.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/array.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/fmgroids.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/regproc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/uri.h"</cpp:file></cpp:include>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>errdetails_index_policy</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>attname</name></decl></parameter>,
								   <parameter><decl><type><name>Oid</name></type> <name>policy_indclass</name></decl></parameter>,
								   <parameter><decl><type><name>Oid</name></type> <name>policy_eqop</name></decl></parameter>,
								   <parameter><decl><type><name>Oid</name></type> <name>found_indclass</name></decl></parameter>,
								   <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>exclop</name></decl></parameter>,
								   <parameter><decl><type><name>index_check_policy_compatible_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * The default numsegments when creating tables.  The value can be an integer
 * between 1 and getgpsegmentCount() or one of below magic numbers:
 *
 * - GP_DEFAULT_NUMSEGMENTS_FULL: all the segments;
 * - GP_DEFAULT_NUMSEGMENTS_RANDOM: pick a random set of segments each time;
 * - GP_DEFAULT_NUMSEGMENTS_MINIMAL: the minimal set of segments;
 *
 * A wrapper macro GP_POLICY_DEFAULT_NUMSEGMENTS() is defined to get the default
 * numsegments according to the setting of this variable, always use that macro
 * instead of this variable.
 */</comment>
<decl_stmt><decl><type><name>int</name></type>			<name>gp_create_table_default_numsegments</name> <init>= <expr><name>GP_DEFAULT_NUMSEGMENTS_FULL</name></expr></init></decl>;</decl_stmt>


<function><type><name>GpPolicy</name> <modifier>*</modifier></type>
<name>makeGpPolicy</name><parameter_list>(<parameter><decl><type><name>GpPolicyType</name></type> <name>ptype</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nattrs</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>numsegments</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>GpPolicy</name>   <modifier>*</modifier></type><name>policy</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type>		<name>size</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>GpPolicy</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>+</operator>
		<call><name>MAXALIGN</name><argument_list>(<argument><expr><name>nattrs</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>AttrNumber</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>+</operator>
		<call><name>MAXALIGN</name><argument_list>(<argument><expr><name>nattrs</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>policy</name> <operator>=</operator> <operator>(</operator><name>GpPolicy</name> <operator>*</operator><operator>)</operator> <name>p</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>p</name> <operator>+=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>GpPolicy</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>nattrs</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>policy</name><operator>-&gt;</operator><name>attrs</name></name> <operator>=</operator> <operator>(</operator><name>AttrNumber</name> <operator>*</operator><operator>)</operator> <name>p</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>p</name> <operator>+=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>nattrs</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>AttrNumber</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>policy</name><operator>-&gt;</operator><name>opclasses</name></name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <name>p</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>p</name> <operator>+=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>nattrs</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>policy</name><operator>-&gt;</operator><name>attrs</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>policy</name><operator>-&gt;</operator><name>opclasses</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name><name>policy</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>T_GpPolicy</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>policy</name><operator>-&gt;</operator><name>ptype</name></name> <operator>=</operator> <name>ptype</name></expr>;</expr_stmt> 
	<expr_stmt><expr><name><name>policy</name><operator>-&gt;</operator><name>numsegments</name></name> <operator>=</operator> <name>numsegments</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>policy</name><operator>-&gt;</operator><name>nattrs</name></name> <operator>=</operator> <name>nattrs</name></expr>;</expr_stmt> 

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>numsegments</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator>
		   <operator>(</operator><name>ptype</name> <operator>==</operator> <name>POLICYTYPE_ENTRY</name> <operator>&amp;&amp;</operator> <name>numsegments</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>policy</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * createReplicatedGpPolicy-- Create a policy with replicated distribution
 */</comment>
<function><type><name>GpPolicy</name> <modifier>*</modifier></type>
<name>createReplicatedGpPolicy</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>numsegments</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>makeGpPolicy</name><argument_list>(<argument><expr><name>POLICYTYPE_REPLICATED</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>numsegments</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * createRandomPartitionedPolicy -- Create a policy with randomly
 * partitioned distribution
 */</comment>
<function><type><name>GpPolicy</name> <modifier>*</modifier></type>
<name>createRandomPartitionedPolicy</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>numsegments</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>makeGpPolicy</name><argument_list>(<argument><expr><name>POLICYTYPE_PARTITIONED</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>numsegments</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * createHashPartitionedPolicy-- Create a policy with data
 * partitioned by keys 
 */</comment>
<function><type><name>GpPolicy</name> <modifier>*</modifier></type>
<name>createHashPartitionedPolicy</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>keys</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>opclasses</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>numsegments</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>GpPolicy</name>	<modifier>*</modifier></type><name>policy</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> 	<modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> 	<modifier>*</modifier></type><name>lop</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> 		<name>idx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> 		<name>len</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name>keys</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>keys</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>opclasses</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>createRandomPartitionedPolicy</name><argument_list>(<argument><expr><name>numsegments</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>policy</name> <operator>=</operator> <call><name>makeGpPolicy</name><argument_list>(<argument><expr><name>POLICYTYPE_PARTITIONED</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>numsegments</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<macro><name>forboth</name><argument_list>(<argument>lc</argument>, <argument>keys</argument>, <argument>lop</argument>, <argument>opclasses</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><name><name>policy</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><name>idx</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>AttrNumber</name><operator>)</operator> <call><name>lfirst_int</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>policy</name><operator>-&gt;</operator><name>opclasses</name><index>[<expr><name>idx</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>Oid</name><operator>)</operator> <call><name>lfirst_oid</name><argument_list>(<argument><expr><name>lop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>idx</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>policy</name></expr>;</return>	
</block_content>}</block></function>

<comment type="block">/*
 * GpPolicyCopy -- Return a copy of a GpPolicy object.
 *
 * The copy is palloc'ed.
 */</comment>
<function><type><name>GpPolicy</name> <modifier>*</modifier></type>
<name>GpPolicyCopy</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>GpPolicy</name> <modifier>*</modifier></type><name>src</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>GpPolicy</name>   <modifier>*</modifier></type><name>tgt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>src</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>tgt</name> <operator>=</operator> <call><name>makeGpPolicy</name><argument_list>(<argument><expr><name><name>src</name><operator>-&gt;</operator><name>ptype</name></name></expr></argument>, <argument><expr><name><name>src</name><operator>-&gt;</operator><name>nattrs</name></name></expr></argument>, <argument><expr><name><name>src</name><operator>-&gt;</operator><name>numsegments</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>src</name><operator>-&gt;</operator><name>nattrs</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>tgt</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>src</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tgt</name><operator>-&gt;</operator><name>opclasses</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>src</name><operator>-&gt;</operator><name>opclasses</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>tgt</name></expr>;</return>
</block_content>}</block></function>								<comment type="block">/* GpPolicyCopy */</comment>

<comment type="block">/*
 * GpPolicyEqual -- Test equality of policies (by value only).
 */</comment>
<function><type><name>bool</name></type>
<name>GpPolicyEqual</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>GpPolicy</name> <modifier>*</modifier></type><name>lft</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>GpPolicy</name> <modifier>*</modifier></type><name>rgt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>lft</name> <operator>==</operator> <name>rgt</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>lft</name> <operator>||</operator> <operator>!</operator><name>rgt</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>lft</name><operator>-&gt;</operator><name>ptype</name></name> <operator>!=</operator> <name><name>rgt</name><operator>-&gt;</operator><name>ptype</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>lft</name><operator>-&gt;</operator><name>numsegments</name></name> <operator>!=</operator> <name><name>rgt</name><operator>-&gt;</operator><name>numsegments</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>lft</name><operator>-&gt;</operator><name>nattrs</name></name> <operator>!=</operator> <name><name>rgt</name><operator>-&gt;</operator><name>nattrs</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>lft</name><operator>-&gt;</operator><name>nattrs</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>lft</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name><name>rgt</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>lft</name><operator>-&gt;</operator><name>opclasses</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name><name>rgt</name><operator>-&gt;</operator><name>opclasses</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>								<comment type="block">/* GpPolicyEqual */</comment>

<comment type="block">/*
 * Like GpPolicyEqual, but the attributes are matched by name.
 */</comment>
<function><type><name>bool</name></type>
<name>GpPolicyEqualByName</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>TupleDesc</name></type> <name>ltd</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>GpPolicy</name> <modifier>*</modifier></type><name>lpol</name></decl></parameter>,
					<parameter><decl><type><specifier>const</specifier> <name>TupleDesc</name></type> <name>rtd</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>GpPolicy</name> <modifier>*</modifier></type><name>rpol</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>lpol</name> <operator>||</operator> <operator>!</operator><name>rpol</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>lpol</name><operator>-&gt;</operator><name>ptype</name></name> <operator>!=</operator> <name><name>rpol</name><operator>-&gt;</operator><name>ptype</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>lpol</name><operator>-&gt;</operator><name>numsegments</name></name> <operator>!=</operator> <name><name>rpol</name><operator>-&gt;</operator><name>numsegments</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>lpol</name><operator>-&gt;</operator><name>nattrs</name></name> <operator>!=</operator> <name><name>rpol</name><operator>-&gt;</operator><name>nattrs</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>lpol</name><operator>-&gt;</operator><name>nattrs</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>latt</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>ltd</name></expr></argument>, <argument><expr><name><name>lpol</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><name>i</name></expr>]</index></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>ratt</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>rtd</name></expr></argument>, <argument><expr><name><name>rpol</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><name>i</name></expr>]</index></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>latt</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>ratt</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>lpol</name><operator>-&gt;</operator><name>opclasses</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name><name>rpol</name><operator>-&gt;</operator><name>opclasses</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>IsReplicatedTable</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>GpPolicyIsReplicated</name><argument_list>(<argument><expr><call><name>GpPolicyFetch</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Returns true only if the policy is a replicated.
 */</comment>
<function><type><name>bool</name></type>
<name>GpPolicyIsReplicated</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>GpPolicy</name> <modifier>*</modifier></type><name>policy</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>policy</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name><name>policy</name><operator>-&gt;</operator><name>ptype</name></name> <operator>==</operator> <name>POLICYTYPE_REPLICATED</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Randomly-partitioned or keys-partitioned
 */</comment>
<function><type><name>bool</name></type>
<name>GpPolicyIsPartitioned</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>GpPolicy</name> <modifier>*</modifier></type><name>policy</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><operator>(</operator><name>policy</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>policy</name><operator>-&gt;</operator><name>ptype</name></name> <operator>==</operator> <name>POLICYTYPE_PARTITIONED</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>GpPolicyIsRandomPartitioned</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>GpPolicy</name> <modifier>*</modifier></type><name>policy</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>policy</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name><name>policy</name><operator>-&gt;</operator><name>ptype</name></name> <operator>==</operator> <name>POLICYTYPE_PARTITIONED</name> <operator>&amp;&amp;</operator>
			<name><name>policy</name><operator>-&gt;</operator><name>nattrs</name></name> <operator>==</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>GpPolicyIsHashPartitioned</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>GpPolicy</name> <modifier>*</modifier></type><name>policy</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>policy</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name><name>policy</name><operator>-&gt;</operator><name>ptype</name></name> <operator>==</operator> <name>POLICYTYPE_PARTITIONED</name> <operator>&amp;&amp;</operator>
			<name><name>policy</name><operator>-&gt;</operator><name>nattrs</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>GpPolicyIsEntry</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>GpPolicy</name> <modifier>*</modifier></type><name>policy</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>policy</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name><name>policy</name><operator>-&gt;</operator><name>ptype</name></name> <operator>==</operator> <name>POLICYTYPE_ENTRY</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * GpPolicyFetch
 *
 * Looks up the distribution policy of given relation from
 * gp_distribution_policy table (or by implicit rules for external tables)
 * Returns an GpPolicy object, allocated in the current memory context,
 * containing the information.
 *
 * The caller is responsible for passing in a valid relation oid.  This
 * function does not check, and assigns a policy of type POLICYTYPE_ENTRY
 * for any oid not found in gp_distribution_policy.
 */</comment>
<function><type><name>GpPolicy</name> <modifier>*</modifier></type>
<name>GpPolicyFetch</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>tbloid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>GpPolicy</name>   <modifier>*</modifier></type><name>policy</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>	<comment type="block">/* The result */</comment>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>gp_policy_tuple</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * EXECUTE-type external tables have an "ON ..." specification.
	 * See if it's "COORDINATOR_ONLY". Other types of external tables have a
	 * gp_distribution_policy row, like normal tables.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>rel_is_external_table</name><argument_list>(<argument><expr><name>tbloid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * An external table really should have a catalog entry, but
		 * there's currently a transient state during creation of an external
		 * table, where the pg_class entry has been created, and its loaded
		 * into the relcache, before the catalog entry has been created.
		 * Silently ignore missing catalog rows to cope with that.
		 */</comment>
		<decl_stmt><decl><type><name>ExtTableEntry</name> <modifier>*</modifier></type><name>e</name> <init>= <expr><call><name>GetExtTableEntryIfExists</name><argument_list>(<argument><expr><name>tbloid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * Writeable external tables have gp_distribution_policy entries, like
		 * regular tables. Readable external tables are implicitly randomly
		 * distributed, except for "EXECUTE ... ON MASTER" ones.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>e</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>on_clause</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>strVal</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>e</name><operator>-&gt;</operator><name>execlocations</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>e</name><operator>-&gt;</operator><name>iswritable</name></name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>on_clause</name></expr></argument>, <argument><expr><literal type="string">"COORDINATOR_ONLY"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<return>return <expr><call><name>makeGpPolicy</name><argument_list>(<argument><expr><name>POLICYTYPE_ENTRY</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
				</block_content>}</block></if></if_stmt>
				<return>return <expr><call><name>createRandomPartitionedPolicy</name><argument_list>(<argument><expr><call><name>getgpsegmentCount</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>on_clause</name></expr></argument>, <argument><expr><literal type="string">"COORDINATOR_ONLY"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>e</name><operator>-&gt;</operator><name>urilocations</name></name> <operator>!=</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* set policy for writable s3 on master external table */</comment>
				<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>e-&gt;urilocations</argument>)</argument_list></macro>
				<block>{<block_content>
					<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>uri_str</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>strVal</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>Uri</name>	<modifier>*</modifier></type><name>uri</name> <init>= <expr><call><name>ParseExternalTableUri</name><argument_list>(<argument><expr><name>uri_str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<if_stmt><if>if <condition>(<expr><name><name>uri</name><operator>-&gt;</operator><name>protocol</name></name> <operator>==</operator> <name>URI_CUSTOM</name> <operator>&amp;&amp;</operator> <literal type="number">0</literal> <operator>==</operator> <call><name>pg_strncasecmp</name><argument_list>(<argument><expr><name><name>uri</name><operator>-&gt;</operator><name>customprotocol</name></name></expr></argument>, <argument><expr><literal type="string">"s3"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<return>return <expr><call><name>makeGpPolicy</name><argument_list>(<argument><expr><name>POLICYTYPE_ENTRY</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>get_rel_relkind</name><argument_list>(<argument><expr><name>tbloid</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>RELKIND_FOREIGN_TABLE</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Similar to the external table creation, there is a transient state
		 * during creation of a foreign table, where the pg_class entry has
		 * been created, before the pg_foreign_table entry has been created.
		 */</comment>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tp</name> <init>= <expr><call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>FOREIGNTABLEREL</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>tbloid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<decl_stmt><decl><type><name>ForeignTable</name> <modifier>*</modifier></type><name>f</name> <init>= <expr><call><name>GetForeignTable</name><argument_list>(<argument><expr><name>tbloid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>f</name><operator>-&gt;</operator><name>exec_location</name></name> <operator>==</operator> <name>FTEXECLOCATION_ALL_SEGMENTS</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * Currently, foreign tables do not support a distribution
				 * policy, as opposed to writable external tables. For now,
				 * we will create a random partitioned policy for foreign
				 * tables that run on all segments. This will allow writing
				 * to foreign tables from all segments when the mpp_execute
				 * option is set to 'all segments'
				 */</comment>
				<return>return <expr><call><name>createRandomPartitionedPolicy</name><argument_list>(<argument><expr><call><name>getgpsegmentCount</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Select by value of the localoid field
	 *
	 * SELECT * FROM gp_distribution_policy WHERE localoid = :1
	 */</comment>
	<expr_stmt><expr><name>gp_policy_tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>GPPOLICYID</name></expr></argument>,
									 <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>tbloid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Read first (and only) tuple
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>gp_policy_tuple</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_gp_distribution_policy</name></type> <name>policyform</name> <init>= <expr><operator>(</operator><name>Form_gp_distribution_policy</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>gp_policy_tuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>isNull</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>nattrs</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int2vector</name> <modifier>*</modifier></type><name>distkey</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>oidvector</name>  <modifier>*</modifier></type><name>distopclasses</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Sanity check of numsegments.
		 *
		 * Currently, Gxact always use a fixed size of cluster after the Gxact started,
		 * If a table is expanded after Gxact started, we should report an error,
		 * otherwise, planner will arrange a gang whose size is larger than the size
		 * of cluster and dispatcher cannot handle this.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name> <operator>||</operator> <name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_EXECUTE</name><operator>)</operator> <operator>&amp;&amp;</operator>
			<name><name>policyform</name><operator>-&gt;</operator><name>numsegments</name></name> <operator>&gt;</operator> <call><name>getgpsegmentCount</name><argument_list>()</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>gp_policy_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_GP_FEATURE_NOT_YET</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot access table \"%s\" in current transaction"</literal></expr></argument>,
							<argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>tbloid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"New segments are concurrently added to the cluster during the execution of current transaction, "</literal>
							   <literal type="string">"the table has data on some of the new segments, "</literal>
							   <literal type="string">"but these new segments are invisible and inaccessible to current transaction."</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Re-run the query in a new transaction."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<switch>switch <condition>(<expr><name><name>policyform</name><operator>-&gt;</operator><name>policytype</name></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>SYM_POLICYTYPE_REPLICATED</name></expr>:</case>
				<expr_stmt><expr><name>policy</name> <operator>=</operator> <call><name>createReplicatedGpPolicy</name><argument_list>(<argument><expr><name><name>policyform</name><operator>-&gt;</operator><name>numsegments</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>SYM_POLICYTYPE_PARTITIONED</name></expr>:</case>
				<comment type="block">/*
				 * Get the attributes on which to partition.
				 */</comment>
				<expr_stmt><expr><name>distkey</name> <operator>=</operator> <operator>(</operator><name>int2vector</name> <operator>*</operator><operator>)</operator> <call><name>DatumGetPointer</name><argument_list>(
					<argument><expr><call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>GPPOLICYID</name></expr></argument>, <argument><expr><name>gp_policy_tuple</name></expr></argument>,
									<argument><expr><name>Anum_gp_distribution_policy_distkey</name></expr></argument>,
									<argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * Get distribution keys only if this table has a policy.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isNull</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>nattrs</name> <operator>=</operator> <name><name>distkey</name><operator>-&gt;</operator><name>dim1</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name>distopclasses</name> <operator>=</operator> <operator>(</operator><name>oidvector</name> <operator>*</operator><operator>)</operator> <call><name>DatumGetPointer</name><argument_list>(
						<argument><expr><call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>GPPOLICYID</name></expr></argument>, <argument><expr><name>gp_policy_tuple</name></expr></argument>,
										<argument><expr><name>Anum_gp_distribution_policy_distclass</name></expr></argument>,
										<argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>distopclasses</name><operator>-&gt;</operator><name>dim1</name></name> <operator>==</operator> <name>nattrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name>nattrs</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

				<comment type="block">/* Create a GpPolicy object. */</comment>
				<expr_stmt><expr><name>policy</name> <operator>=</operator> <call><name>makeGpPolicy</name><argument_list>(<argument><expr><name>POLICYTYPE_PARTITIONED</name></expr></argument>,
									  <argument><expr><name>nattrs</name></expr></argument>, <argument><expr><name><name>policyform</name><operator>-&gt;</operator><name>numsegments</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nattrs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
				<block>{<block_content>
					<expr_stmt><expr><name><name>policy</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>distkey</name><operator>-&gt;</operator><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>policy</name><operator>-&gt;</operator><name>opclasses</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>distopclasses</name><operator>-&gt;</operator><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
				</block_content>}</block></for>
				<break>break;</break>
			<default>default:</default>
				<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>gp_policy_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized distribution policy type"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>	
		</block_content>}</block></switch>

		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>gp_policy_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Interpret absence of a valid policy row as POLICYTYPE_ENTRY */</comment>
	<if_stmt><if>if <condition>(<expr><name>policy</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><call><name>makeGpPolicy</name><argument_list>(<argument><expr><name>POLICYTYPE_ENTRY</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>policy</name></expr>;</return>
</block_content>}</block></function>								<comment type="block">/* GpPolicyFetch */</comment>

<comment type="block">/*
 * Sets the policy of a table into the gp_distribution_policy table
 * from a GpPolicy structure.
 */</comment>
<function><type><name>void</name></type>
<name>GpPolicyStore</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>tbloid</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>GpPolicy</name> <modifier>*</modifier></type><name>policy</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>gp_policy_rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>gp_policy_tuple</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>bool</name></type>		<name><name>nulls</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name><name>values</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>myself</name></decl>,
				<decl><type ref="prev"/><name>referenced</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/* Sanity check the policy and its opclasses before storing it. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>policy</name><operator>-&gt;</operator><name>ptype</name></name> <operator>==</operator> <name>POLICYTYPE_ENTRY</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cannot store entry-type policy in gp_distribution_policy"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>policy</name><operator>-&gt;</operator><name>nattrs</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>policy</name><operator>-&gt;</operator><name>opclasses</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"no hash operator class for distribution key column %d"</literal></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>tbloid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name><name>policy</name><operator>-&gt;</operator><name>numsegments</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Open and lock the gp_distribution_policy catalog.
	 */</comment>
	<expr_stmt><expr><name>gp_policy_rel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>GpPolicyRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>GpPolicyIsReplicated</name><argument_list>(<argument><expr><name>policy</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>CharGetDatum</name><argument_list>(<argument><expr><name>SYM_POLICYTYPE_REPLICATED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * Convert C arrays into Postgres arrays.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>GpPolicyIsPartitioned</name><argument_list>(<argument><expr><name>policy</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>CharGetDatum</name><argument_list>(<argument><expr><name>SYM_POLICYTYPE_PARTITIONED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<decl_stmt><decl><type><name>int2vector</name> <modifier>*</modifier></type><name>attrnums</name> <init>= <expr><call><name>buildint2vector</name><argument_list>(<argument><expr><name><name>policy</name><operator>-&gt;</operator><name>attrs</name></name></expr></argument>, <argument><expr><name><name>policy</name><operator>-&gt;</operator><name>nattrs</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>oidvector</name>  <modifier>*</modifier></type><name>opclasses</name> <init>= <expr><call><name>buildoidvector</name><argument_list>(<argument><expr><name><name>policy</name><operator>-&gt;</operator><name>opclasses</name></name></expr></argument>, <argument><expr><name><name>policy</name><operator>-&gt;</operator><name>nattrs</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>attrnums</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>opclasses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>gp_policy_tuple</name> <operator>=</operator> <call><name>heap_form_tuple</name><argument_list>(<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>gp_policy_rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Insert tuple into the relation */</comment>
	<expr_stmt><expr><call><name>CatalogTupleInsert</name><argument_list>(<argument><expr><name>gp_policy_rel</name></expr></argument>, <argument><expr><name>gp_policy_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Register the table as dependent on the operator classes used in the
	 * distribution key.
	 *
	 * XXX: This prevents you from dropping the operator class, which is
	 * good. However, CASCADE behaviour is not so nice: if you do DROP
	 * OPERATOR CLASS CASCADE, we drop the whole table. Ideally, we would
	 * just change the policy to randomly distributed.
	 */</comment>
	<expr_stmt><expr><name><name>myself</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>RelationRelationId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>myself</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name>tbloid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>myself</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>policy</name><operator>-&gt;</operator><name>nattrs</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>OperatorClassRelationId</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name><name>policy</name><operator>-&gt;</operator><name>opclasses</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>recordDependencyOn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>myself</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>referenced</name></expr></argument>, <argument><expr><name>DEPENDENCY_NORMAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Close the gp_distribution_policy relcache entry without unlocking. We
	 * have updated the catalog: consequently the lock must be held until end
	 * of transaction.
	 */</comment>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>gp_policy_rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>								<comment type="block">/* GpPolicyStore */</comment>

<comment type="block">/*
 * Sets the policy of a table into the gp_distribution_policy table
 * from a GpPolicy structure.
 */</comment>
<function><type><name>void</name></type>
<name>GpPolicyReplace</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>tbloid</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>GpPolicy</name> <modifier>*</modifier></type><name>policy</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>gp_policy_rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>gp_policy_tuple</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name>skey</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name><name>nulls</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name><name>values</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name><name>repl</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>myself</name></decl>,
				<decl><type ref="prev"/><name>referenced</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/* Sanity check the policy and its opclasses before storing it. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>policy</name><operator>-&gt;</operator><name>ptype</name></name> <operator>==</operator> <name>POLICYTYPE_ENTRY</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cannot store entry-type policy in gp_distribution_policy"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>policy</name><operator>-&gt;</operator><name>nattrs</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>policy</name><operator>-&gt;</operator><name>opclasses</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"no hash operator class for distribution key column %d"</literal></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>tbloid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name><name>policy</name><operator>-&gt;</operator><name>numsegments</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Open and lock the gp_distribution_policy catalog.
	 */</comment>
	<expr_stmt><expr><name>gp_policy_rel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>GpPolicyRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>GpPolicyIsReplicated</name><argument_list>(<argument><expr><name>policy</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>CharGetDatum</name><argument_list>(<argument><expr><name>SYM_POLICYTYPE_REPLICATED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * Convert C arrays into Postgres arrays.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>GpPolicyIsPartitioned</name><argument_list>(<argument><expr><name>policy</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>CharGetDatum</name><argument_list>(<argument><expr><name>SYM_POLICYTYPE_PARTITIONED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<decl_stmt><decl><type><name>int2vector</name> <modifier>*</modifier></type><name>attrnums</name> <init>= <expr><call><name>buildint2vector</name><argument_list>(<argument><expr><name><name>policy</name><operator>-&gt;</operator><name>attrs</name></name></expr></argument>, <argument><expr><name><name>policy</name><operator>-&gt;</operator><name>nattrs</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>oidvector</name>  <modifier>*</modifier></type><name>opclasses</name> <init>= <expr><call><name>buildoidvector</name><argument_list>(<argument><expr><name><name>policy</name><operator>-&gt;</operator><name>opclasses</name></name></expr></argument>, <argument><expr><name><name>policy</name><operator>-&gt;</operator><name>nattrs</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>attrnums</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>opclasses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>repl</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>repl</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>repl</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>repl</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>repl</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>


	<comment type="block">/*
	 * Select by value of the localoid field
	 */</comment>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>skey</name></expr></argument>,
				<argument><expr><name>Anum_gp_distribution_policy_localoid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>tbloid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>gp_policy_rel</name></expr></argument>, <argument><expr><name>GpPolicyLocalOidIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
							  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>skey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Read first (and only ) tuple
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>gp_policy_tuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>newtuple</name> <init>= <expr><call><name>heap_modify_tuple</name><argument_list>(<argument><expr><name>gp_policy_tuple</name></expr></argument>,
												 <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>gp_policy_rel</name></expr></argument>)</argument_list></call></expr></argument>,
												 <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>, <argument><expr><name>repl</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>gp_policy_rel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>gp_policy_tuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>newtuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>newtuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>gp_policy_tuple</name> <operator>=</operator> <call><name>heap_form_tuple</name><argument_list>(<argument><expr><name><name>gp_policy_rel</name><operator>-&gt;</operator><name>rd_att</name></name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CatalogTupleInsert</name><argument_list>(<argument><expr><name>gp_policy_rel</name></expr></argument>, <argument><expr><name>gp_policy_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Remove old dependencies on opclasses, and store dependencies on the
	 * new ones.
	 */</comment>
	<expr_stmt><expr><call><name>deleteDependencyRecordsForClass</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>tbloid</name></expr></argument>,
									<argument><expr><name>OperatorClassRelationId</name></expr></argument>, <argument><expr><name>DEPENDENCY_NORMAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>myself</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>RelationRelationId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>myself</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name>tbloid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>myself</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>policy</name><operator>-&gt;</operator><name>nattrs</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>OperatorClassRelationId</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name><name>policy</name><operator>-&gt;</operator><name>opclasses</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>recordDependencyOn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>myself</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>referenced</name></expr></argument>, <argument><expr><name>DEPENDENCY_NORMAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Close the gp_distribution_policy relcache entry without unlocking. We
	 * have updated the catalog: consequently the lock must be held until end
	 * of transaction.
	 */</comment>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>gp_policy_rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>								<comment type="block">/* GpPolicyReplace */</comment>


<comment type="block">/*
 * Removes the policy of a table from the gp_distribution_policy table
 * Does nothing if the policy doesn't exist.
 */</comment>
<function><type><name>void</name></type>
<name>GpPolicyRemove</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>tbloid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>gp_policy_rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name>scankey</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>sscan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Open and lock the gp_distribution_policy catalog.
	 */</comment>
	<expr_stmt><expr><name>gp_policy_rel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>GpPolicyRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Delete the policy entry from the catalog. */</comment>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>scankey</name></expr></argument>, <argument><expr><name>Anum_gp_distribution_policy_localoid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>tbloid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>sscan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>gp_policy_rel</name></expr></argument>, <argument><expr><name>GpPolicyLocalOidIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
							   <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>scankey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><operator>(</operator><name>tuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>sscan</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>CatalogTupleDelete</name><argument_list>(<argument><expr><name>gp_policy_rel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>sscan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * This is currently only used while dropping the whole relation, which
	 * removes all pg_depend entries. So no need to remove them here.
	 */</comment>

	<comment type="block">/*
	 * Close the gp_distribution_policy relcache entry without unlocking. We
	 * have updated the catalog: consequently the lock must be held until end
	 * of transaction.
	 */</comment>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>gp_policy_rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>								<comment type="block">/* GpPolicyRemove */</comment>

<comment type="block">/*
 * Is the supplied GpPolicy compatible with a unique or exclusion constraint
 * index?
 *
 * This is used both when a new index is created (CREATE INDEX), and when
 * a table's distribution key is about to be changed (ALTER TABLE SET
 * DISTRIBUTED BY).
 *
 * The set of columns being indexed needs to be a superset of the distribution
 * policy. If the table is distributed randomly, no unique / exclusion
 * indexing is supported. If the table is replicated, all constraints all
 * supported.
 *
 * The index is described by 'indattr', 'indclasses', 'exclop', 'nidxatts'
 * parameters. Note that the parameters don't include expressions for an
 * expression index; expressions can never match distribution keys, so
 * they can be ignored here.
 *
 * Returns 'true', if the policy is compatible with the index.
 */</comment>
<function><type><name>bool</name></type>
<name>index_check_policy_compatible</name><parameter_list>(<parameter><decl><type><name>GpPolicy</name> <modifier>*</modifier></type><name>policy</name></decl></parameter>,
							  <parameter><decl><type><name>TupleDesc</name></type> <name>desc</name></decl></parameter>,
							  <parameter><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>indattr</name></decl></parameter>,
							  <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>indclasses</name></decl></parameter>,
							  <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>exclop</name></decl></parameter>,
							  <parameter><decl><type><name>int</name></type> <name>nidxatts</name></decl></parameter>,
							  <parameter><decl><type><name>bool</name></type> <name>report_error</name></decl></parameter>,
							  <parameter><decl><type><name>index_check_policy_compatible_context</name> <modifier>*</modifier></type><name>error_context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>j</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * POLICYTYPE_ENTRY normally means it's a system table or a table created
	 * in utility mode, so unique/primary key is allowed anywhere.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>GpPolicyIsEntry</name><argument_list>(<argument><expr><name>policy</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Firstly, unique indexes / exclusion constraints are not supported at
	 * all on randomly distributed tables.
	 *
	 * XXX: The error message here is worded as if we're adding a constraint. This
	 * function is also used for ALTER TABLE SET DISTRIBUTED BY, but as of this
	 * writing, with ALTER TABLE SET DISTRIBUTED BY the caller checks for these
	 * cases before calling this function, with a different error message. That
	 * seems redundant, but as long as the caller does that, we can amke that
	 * assumption in the error message.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>GpPolicyIsRandomPartitioned</name><argument_list>(<argument><expr><name>policy</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>report_error</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>error_context</name><operator>-&gt;</operator><name>is_primarykey</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"PRIMARY KEY and DISTRIBUTED RANDOMLY are incompatible"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><name>exclop</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"exclusion constraint and DISTRIBUTED RANDOMLY are incompatible"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"UNIQUE and DISTRIBUTED RANDOMLY are incompatible"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * On the other hand, everything is supported on replicated tables.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>GpPolicyIsReplicated</name><argument_list>(<argument><expr><name>policy</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Otherwise, it's hash distributed.
	 *
	 * Loop through each distribution key column, and check that it's part
	 * of the index.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>GpPolicyIsHashPartitioned</name><argument_list>(<argument><expr><name>policy</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>policy</name><operator>-&gt;</operator><name>nattrs</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>policy</name><operator>-&gt;</operator><name>nattrs</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>policy_attr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>policy_opclass</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>policy_opfamily</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>policy_typeid</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>policy_eqop</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>found_col</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>found_col_indclass</name></decl>;</decl_stmt>

		<comment type="block">/* Look up the equality operator for the distribution key opclass */</comment>
		<expr_stmt><expr><name>policy_attr</name> <operator>=</operator> <name><name>policy</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>policy_typeid</name> <operator>=</operator> <call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>policy_attr</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>atttypid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>policy_opclass</name> <operator>=</operator> <name><name>policy</name><operator>-&gt;</operator><name>opclasses</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>policy_opfamily</name> <operator>=</operator> <call><name>get_opclass_family</name><argument_list>(<argument><expr><name>policy_opclass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>policy_eqop</name> <operator>=</operator> <call><name>cdb_eqop_in_hash_opfamily</name><argument_list>(<argument><expr><name>policy_opfamily</name></expr></argument>, <argument><expr><name>policy_typeid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Scan the index columns to see if any of them match the distribution
		 * key.
		 */</comment>
		<expr_stmt><expr><name>found</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>found_col</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>found_col_indclass</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>nidxatts</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>indopfamily</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>opcintype</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>indeqop</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>indattr</name><index>[<expr><name>j</name></expr>]</index></name> <operator>!=</operator> <name>policy_attr</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>found_col</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

			<comment type="block">/*
			 * Is the index's operator class is compatible with the
			 * distribution key's operator class? It's compatible, if it
			 * has the same equality operator.
			 *
			 * If this is an exclusion constraint, rather than a unique index,
			 * then we compare the exclusion operator instead. The exclusion
			 * operator should be the same operator as the distribution key
			 * opclass's equality operator.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>exclop</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>indeqop</name> <operator>=</operator> <name><name>exclop</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><name>found_col_indclass</name> <operator>=</operator> <name><name>indclasses</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>

				<expr_stmt><expr><name>indopfamily</name> <operator>=</operator> <call><name>get_opclass_family</name><argument_list>(<argument><expr><name><name>indclasses</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>opcintype</name> <operator>=</operator> <call><name>get_opclass_input_type</name><argument_list>(<argument><expr><name><name>indclasses</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>indeqop</name> <operator>=</operator> <call><name>get_opfamily_member</name><argument_list>(<argument><expr><name>indopfamily</name></expr></argument>,
											  <argument><expr><name>opcintype</name></expr></argument>,
											  <argument><expr><name>opcintype</name></expr></argument>,
											  <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>indeqop</name> <operator>==</operator> <name>policy_eqop</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * If the caller asked for an ERROR, construct a suitable error
			 * message. The details of the message depend on the kind of
			 * constraint it is, and whether the distribution key was missing
			 * from the constraint altogther, or if it just had different
			 * opclass.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>report_error</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errdetails_index_policy</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>policy_attr</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>attname</name></expr></argument>)</argument_list></call></expr></argument>,
												 <argument><expr><name>policy_opclass</name></expr></argument>,
												 <argument><expr><name>policy_eqop</name></expr></argument>,
												 <argument><expr><name>found_col_indclass</name></expr></argument>,
												 <argument><expr><name>exclop</name></expr></argument>,
												 <argument><expr><name>error_context</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Print the name of an operator class, for error messages.
 */</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>format_opclass</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>opclass</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>ht_opc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_opclass</name></type> <name>opcrec</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>opcname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>nspname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>ht_opc</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>CLAOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>opclass</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>ht_opc</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for opclass %u"</literal></expr></argument>, <argument><expr><name>opclass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>opcrec</name> <operator>=</operator> <operator>(</operator><name>Form_pg_opclass</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>ht_opc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* do we need to schema-qualify the name? */</comment>
	<expr_stmt><expr><name>opcname</name> <operator>=</operator> <call><name>NameStr</name><argument_list>(<argument><expr><name><name>opcrec</name><operator>-&gt;</operator><name>opcname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>OpclassIsVisible</name><argument_list>(<argument><expr><name>opclass</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>quote_identifier</name><argument_list>(<argument><expr><name>opcname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>nspname</name> <operator>=</operator> <call><name>get_namespace_name</name><argument_list>(<argument><expr><name><name>opcrec</name><operator>-&gt;</operator><name>opcnamespace</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"%s.%s"</literal></expr></argument>,
						  <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name>nspname</name></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name>opcname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>ht_opc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>errdetails_index_policy</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>attname</name></decl></parameter>,
						<parameter><decl><type><name>Oid</name></type> <name>policy_opclass</name></decl></parameter>,
						<parameter><decl><type><name>Oid</name></type> <name>policy_eqop</name></decl></parameter>,
						<parameter><decl><type><name>Oid</name></type> <name>found_indclass</name></decl></parameter>,
						<parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>exclop</name></decl></parameter>,
						<parameter><decl><type><name>index_check_policy_compatible_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Print main message. The wording depends on whether we're ALTERing a
	 * table's distribution key, and the new distribution key isn't compatible
	 * with existing indexes, or if we're trying to build a new index that's
	 * not compatible with the table's distribution key. Both variants contain
	 * the same information, but we try to say that the thing we're changing
	 * is not compatible with the existing stuff, rather than the other way
	 * round.
	 *
	 * In the ALTER TABLE SET DISTRIBUTED BY, we print the name of the conflicting
	 * constraint/index. When we're adding an index, we leave that out, because
	 * that's right there in the CREATE INDEX or ALTER TABLE ADD CONSTRAINT command.
	 *
	 * XXX: If it's a CREATE TABLE with multiple UNIQUE constraints, it would be
	 * to printout which UNIQUE constraint is causing trouble. But we can't
	 * distinguish CREATE TABLE subcommands from a straight CREATE INDEX here.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>for_alter_dist_policy</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>is_primarykey</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"distribution policy is not compatible with the table's PRIMARY KEY"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name>exclop</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"distribution policy is not compatible with exclusion constraint \"%s\""</literal></expr></argument>,
				   <argument><expr><name><name>context</name><operator>-&gt;</operator><name>constraint_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name> <argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>is_unique</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>is_constraint</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"distribution policy is not compatible with UNIQUE constraint \"%s\""</literal></expr></argument>,
					   <argument><expr><name><name>context</name><operator>-&gt;</operator><name>constraint_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"distribution policy is not compatible with UNIQUE index \"%s\""</literal></expr></argument>,
					   <argument><expr><name><name>context</name><operator>-&gt;</operator><name>constraint_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>is_primarykey</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"PRIMARY KEY definition must contain all columns in the table's distribution key"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name>exclop</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"exclusion constraint is not compatible with the table's distribution policy"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name> <argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>is_unique</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>is_constraint</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"UNIQUE constraint must contain all columns in the table's distribution key"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"UNIQUE index must contain all columns in the table's distribution key"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Print details of which distribution column is causing the trouble.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>exclop</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Distribution key column \"%s\" is not included in the constraint."</literal></expr></argument>,
				  <argument><expr><name>attname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Add \"%s\" to the constraint with the %s operator."</literal></expr></argument>,
				<argument><expr><name>attname</name></expr></argument>, <argument><expr><call><name>format_operator</name><argument_list>(<argument><expr><name>policy_eqop</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>found_indclass</name> <operator>!=</operator> <name>InvalidOid</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * A unique index contained the distribution key column, but with
		 * an incompatible opclass.
		 *
		 * It would be nice to hint what a compatible operator class be.
		 * But it'd take some effort to dig that from the catalogs.
		 */</comment>
		<expr_stmt><expr><call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Operator class %s of distribution key column \"%s\" is not compatible with operator class %s used in the constraint."</literal></expr></argument>,
				  <argument><expr><call><name>format_opclass</name><argument_list>(<argument><expr><name>policy_opclass</name></expr></argument>)</argument_list></call></expr></argument>,
				  <argument><expr><name>attname</name></expr></argument>,
				  <argument><expr><call><name>format_opclass</name><argument_list>(<argument><expr><name>found_indclass</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Distribution key column \"%s\" is not included in the constraint."</literal></expr></argument>,
				  <argument><expr><name>attname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>
</unit>
