<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/backend/cdb/cdbpath.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * cdbpath.c
 *
 * Portions Copyright (c) 2005-2008, Greenplum inc
 * Portions Copyright (c) 2012-Present VMware, Inc. or its affiliates.
 *
 *
 * IDENTIFICATION
 *	    src/backend/cdb/cdbpath.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/hash.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/heapam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_amop.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_opclass.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_operator.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_trigger.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/trigger.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>	<comment type="block">/* makeFuncExpr() */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodeFuncs.h"</cpp:file></cpp:include>	<comment type="block">/* exprType() */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/pathnodes.h"</cpp:file></cpp:include>	<comment type="block">/* PlannerInfo, RelOptInfo */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/cost.h"</cpp:file></cpp:include>		<comment type="block">/* set_rel_width() */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/optimizer.h"</cpp:file></cpp:include>	<comment type="block">/* cpu_tuple_cost */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/pathnode.h"</cpp:file></cpp:include> <comment type="block">/* Path, pathnode_walker() */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/paths.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/planmain.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/tlist.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parsetree.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_expr.h"</cpp:file></cpp:include>	<comment type="block">/* exprType() */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_oper.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/catcache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/guc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbdef.h"</cpp:file></cpp:include>			<comment type="block">/* CdbSwap() */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbhash.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbpath.h"</cpp:file></cpp:include>		<comment type="block">/* me */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbutil.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbvars.h"</cpp:file></cpp:include>


<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>CdbPathLocus</name></type> <name>locus</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CdbPathLocus</name></type> <name>move_to</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>bytes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>path</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>       <modifier>*</modifier></type><name>pathkeys</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>ok_to_replicate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>require_existing_order</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>has_wts</name></decl>;</decl_stmt>		<comment type="block">/* Does the rel have WorkTableScan? */</comment>
}</block></struct></type> <name>CdbpathMfjRel</name>;</typedef>

<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>try_redistribute</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>CdbpathMfjRel</name> <modifier>*</modifier></type><name>g</name></decl></parameter>,
							 <parameter><decl><type><name>CdbpathMfjRel</name> <modifier>*</modifier></type><name>o</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>redistribution_clauses</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>SplitUpdatePath</name> <modifier>*</modifier></type><name>make_splitupdate_path</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>subpath</name></decl></parameter>, <parameter><decl><type><name>Index</name></type> <name>rti</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>can_elide_explicit_motion</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Index</name></type> <name>rti</name></decl></parameter>, <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>subpath</name></decl></parameter>, <parameter><decl><type><name>GpPolicy</name> <modifier>*</modifier></type><name>policy</name></decl></parameter>)</parameter_list>;</function_decl>
<comment type="block">/*
 * cdbpath_cost_motion
 *    Fills in the cost estimate fields in a MotionPath node.
 */</comment>
<function><type><name>void</name></type>
<name>cdbpath_cost_motion</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>CdbMotionPath</name> <modifier>*</modifier></type><name>motionpath</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>subpath</name> <init>= <expr><name><name>motionpath</name><operator>-&gt;</operator><name>subpath</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cost</name></type>		<name>cost_per_row</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cost</name></type>		<name>motioncost</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>recvrows</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>sendrows</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>send_segments</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>recv_segments</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>total_rows</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>CdbPathLocus_IsPartitioned</name><argument_list>(<argument><expr><name><name>motionpath</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>recv_segments</name> <operator>=</operator> <call><name>CdbPathLocus_NumSegments</name><argument_list>(<argument><expr><name><name>motionpath</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>recv_segments</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>CdbPathLocus_IsPartitioned</name><argument_list>(<argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>send_segments</name> <operator>=</operator> <call><name>CdbPathLocus_NumSegments</name><argument_list>(<argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>send_segments</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * Estimate the total number of rows being sent.
	 *
	 * The base estimate is computed by multiplying the subpath's rows with
	 * the number of sending segments. But in some cases, that leads to too
	 * large estimates, if the subpath's estimate was "clamped" to 1 row. The
	 * typical example is a single-row select like "SELECT * FROM table WHERE
	 * key = 123. The Scan on the table returns only one row, on one segment,
	 * and the estimate on the Scan node is 1 row. If you have e.g. 3
	 * segments, and we just multiplied the subpath's row estimate by 3, we
	 * would estimate that the Gather returns 3 rows, even though there is
	 * only one matching row in the table. Using the 'rows' estimate on the
	 * RelOptInfo is more accurate in such cases. To correct that, if the
	 * subpath's estimate is 1 row, but the underlying relation's estimate is
	 * smaller, use the underlying relation's estimate.
	 *
	 * We don't always use the relation's estimate, because there might be
	 * nodes like ProjectSet or Limit in the subpath, in which case the
	 * subpath's estimate is more accurate. Also, the relation might not have
	 * a valid 'rows' estimate; upper rels, for example, do not. So check for
	 * that too.
	 */</comment>
	<expr_stmt><expr><name>total_rows</name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>rows</name></name> <operator>*</operator> <name>send_segments</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>subpath</name><operator>-&gt;</operator><name>rows</name></name> <operator>==</operator> <literal type="number">1.0</literal> <operator>&amp;&amp;</operator>
		<name><name>motionpath</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parent</name><operator>-&gt;</operator><name>rows</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
		<name><name>motionpath</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parent</name><operator>-&gt;</operator><name>rows</name></name> <operator>&lt;</operator> <name>total_rows</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* use the RelOptInfo's estimate */</comment>
		<expr_stmt><expr><name>total_rows</name> <operator>=</operator> <name><name>motionpath</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parent</name><operator>-&gt;</operator><name>rows</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>motionpath</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>rows</name></name> <operator>=</operator> <call><name>clamp_row_est</name><argument_list>(<argument><expr><name>total_rows</name> <operator>/</operator> <name>recv_segments</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>cost_per_row</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>gp_motion_cost_per_row</name> <operator>&gt;</operator> <literal type="number">0.0</literal><operator>)</operator></expr>
		?</condition><then> <expr><name>gp_motion_cost_per_row</name></expr>
		</then><else>: <expr><literal type="number">2.0</literal> <operator>*</operator> <name>cpu_tuple_cost</name></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><name>sendrows</name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>rows</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>recvrows</name> <operator>=</operator> <name><name>motionpath</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>rows</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>motioncost</name> <operator>=</operator> <name>cost_per_row</name> <operator>*</operator> <literal type="number">0.5</literal> <operator>*</operator> <operator>(</operator><name>sendrows</name> <operator>+</operator> <name>recvrows</name><operator>)</operator></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>motionpath</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>total_cost</name></name> <operator>=</operator> <name>motioncost</name> <operator>+</operator> <name><name>subpath</name><operator>-&gt;</operator><name>total_cost</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>motionpath</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>startup_cost</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>startup_cost</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>motionpath</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>memory</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>memory</name></name></expr>;</expr_stmt>
</block_content>}</block></function>								<comment type="block">/* cdbpath_cost_motion */</comment>


<comment type="block">/*
 * cdbpath_create_motion_path
 *    Returns a Path that delivers the subpath result to the
 *    given locus, or NULL if it can't be done.
 *
 *    'pathkeys' must specify an ordering equal to or weaker than the
 *    subpath's existing ordering.
 *
 *    If no motion is needed, the caller's subpath is returned unchanged.
 *    Else if require_existing_order is true, NULL is returned if the
 *      motion would not preserve an ordering at least as strong as the
 *      specified ordering; also NULL is returned if pathkeys is NIL
 *      meaning the caller is just checking and doesn't want to add motion.
 *    Else a CdbMotionPath is returned having either the specified pathkeys
 *      (if given and the motion uses Merge Receive), or the pathkeys
 *      of the original subpath (if the motion is order-preserving), or no
 *      pathkeys otherwise (the usual case).
 */</comment>
<function><type><name>Path</name> <modifier>*</modifier></type>
<name>cdbpath_create_motion_path</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
						   <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>subpath</name></decl></parameter>,
						   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>pathkeys</name></decl></parameter>,
						   <parameter><decl><type><name>bool</name></type> <name>require_existing_order</name></decl></parameter>,
						   <parameter><decl><type><name>CdbPathLocus</name></type> <name>locus</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CdbMotionPath</name> <modifier>*</modifier></type><name>pathnode</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>cdbpathlocus_is_valid</name><argument_list>(<argument><expr><name>locus</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		   <call><name>cdbpathlocus_is_valid</name><argument_list>(<argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Motion is to change path's locus, if target locus is the
	 * same as the subpath's, there is no need to add motion.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>cdbpathlocus_equal</name><argument_list>(<argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>, <argument><expr><name>locus</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>subpath</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Moving subpath output to a single executor process (qDisp or qExec)? */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>CdbPathLocus_IsOuterQuery</name><argument_list>(<argument><expr><name>locus</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Outer -&gt; Outer is a no-op */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>CdbPathLocus_IsOuterQuery</name><argument_list>(<argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>subpath</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>CdbPathLocus_IsGeneral</name><argument_list>(<argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* XXX: this is a bit bogus. We just change the subpath's locus. */</comment>
			<expr_stmt><expr><name><name>subpath</name><operator>-&gt;</operator><name>locus</name></name> <operator>=</operator> <name>locus</name></expr>;</expr_stmt>
			<return>return <expr><name>subpath</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>CdbPathLocus_IsEntry</name><argument_list>(<argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
			<call><name>CdbPathLocus_IsSingleQE</name><argument_list>(<argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * XXX: this is a bit bogus. We just change the subpath's locus.
			 *
			 * This is also bogus, because the outer query might need to run
			 * in segments.
			 */</comment>
			<expr_stmt><expr><name><name>subpath</name><operator>-&gt;</operator><name>locus</name></name> <operator>=</operator> <name>locus</name></expr>;</expr_stmt>
			<return>return <expr><name>subpath</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>CdbPathLocus_IsBottleneck</name><argument_list>(<argument><expr><name>locus</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* entry--&gt;entry?  No motion needed. */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>CdbPathLocus_IsEntry</name><argument_list>(<argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<call><name>CdbPathLocus_IsEntry</name><argument_list>(<argument><expr><name>locus</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>subpath</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* singleQE--&gt;singleQE?  No motion needed. */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>CdbPathLocus_IsSingleQE</name><argument_list>(<argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<call><name>CdbPathLocus_IsSingleQE</name><argument_list>(<argument><expr><name>locus</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>subpath</name><operator>-&gt;</operator><name>locus</name><operator>.</operator><name>numsegments</name></name> <operator>=</operator> <call><name>CdbPathLocus_CommonSegments</name><argument_list>(<argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>, <argument><expr><name>locus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>subpath</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* entry--&gt;singleQE?  Don't move.  Slice's QE will run on entry db. */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>CdbPathLocus_IsEntry</name><argument_list>(<argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>subpath</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* outerquery--&gt;entry?  No motion needed. */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>CdbPathLocus_IsOuterQuery</name><argument_list>(<argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<call><name>CdbPathLocus_IsEntry</name><argument_list>(<argument><expr><name>locus</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>subpath</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* singleQE--&gt;entry?  Don't move.  Slice's QE will run on entry db. */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>CdbPathLocus_IsSingleQE</name><argument_list>(<argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * If the subpath requires parameters, we cannot generate Motion atop of it.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>bms_is_empty</name><argument_list>(<argument><expr><call><name>PATH_REQ_OUTER</name><argument_list>(<argument><expr><name>subpath</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * Create CdbMotionPath node to indicate that the slice must be
			 * dispatched to a singleton gang running on the entry db.  We
			 * merely use this node to note that the path has 'Entry' locus;
			 * no corresponding Motion node will be created in the Plan tree.
			 */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>CdbPathLocus_IsEntry</name><argument_list>(<argument><expr><name>locus</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>pathnode</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>CdbMotionPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtype</name></name> <operator>=</operator> <name>T_Motion</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parent</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>parent</name></name></expr>;</expr_stmt>
			<comment type="block">/* Motion doesn't project, so use source path's pathtarget */</comment>
			<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtarget</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>pathtarget</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>locus</name></name> <operator>=</operator> <name>locus</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>rows</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>rows</name></name></expr>;</expr_stmt>

			<comment type="block">/* GPDB_96_MERGE_FIXME: When is a Motion path parallel-safe? I tried
			 * setting this to 'false' initially, to play it safe, but somehow
			 * the Paths with motions ended up in gather plans anyway, and tripped
			 * assertion failures.
			 */</comment>
			<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_aware</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_safe</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>parallel_safe</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_workers</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>parallel_workers</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathkeys</name></name> <operator>=</operator> <name>pathkeys</name></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>subpath</name></name> <operator>=</operator> <name>subpath</name></expr>;</expr_stmt>

			<comment type="block">/* Costs, etc, are same as subpath. */</comment>
			<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>startup_cost</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>total_cost</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>total_cost</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>total_cost</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>memory</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>memory</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>motionHazard</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>motionHazard</name></name></expr>;</expr_stmt>

			<comment type="block">/* Motion nodes are never rescannable. */</comment>
			<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>rescannable</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<return>return <expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <name>pathnode</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>CdbPathLocus_IsSegmentGeneral</name><argument_list>(<argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
			<call><name>CdbPathLocus_IsReplicated</name><argument_list>(<argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * If the subpath requires parameters, we cannot generate Motion atop of it.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>bms_is_empty</name><argument_list>(<argument><expr><call><name>PATH_REQ_OUTER</name><argument_list>(<argument><expr><name>subpath</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * Data is only available on segments, to distingush it with
			 * CdbLocusType_General, adding a motion to indicated this
			 * slice must be executed on a singleton gang.
			 *
			 * This motion may be redundant for segmentGeneral --&gt; singleQE
			 * if the singleQE is not promoted to executed on qDisp in the
			 * end, so in cdbllize_fix_outer_query_motions(), we will omit it.
			 */</comment>
			<expr_stmt><expr><name>pathnode</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>CdbMotionPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtype</name></name> <operator>=</operator> <name>T_Motion</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parent</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>parent</name></name></expr>;</expr_stmt>
			<comment type="block">/* Motion doesn't project, so use source path's pathtarget */</comment>
			<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtarget</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>pathtarget</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>locus</name></name> <operator>=</operator> <name>locus</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>rows</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>rows</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathkeys</name></name> <operator>=</operator> <name>pathkeys</name></expr>;</expr_stmt>

			<comment type="block">/* GPDB_96_MERGE_FIXME: When is a Motion path parallel-safe? I tried
			 * setting this to 'false' initially, to play it safe, but somehow
			 * the Paths with motions ended up in gather plans anyway, and tripped
			 * assertion failures.
			 */</comment>
			<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_aware</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_safe</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>parallel_safe</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_workers</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>parallel_workers</name></name></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>subpath</name></name> <operator>=</operator> <name>subpath</name></expr>;</expr_stmt>

			<comment type="block">/* Costs, etc, are same as subpath. */</comment>
			<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>startup_cost</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>total_cost</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>total_cost</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>total_cost</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>memory</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>memory</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>motionHazard</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>motionHazard</name></name></expr>;</expr_stmt>

			<comment type="block">/* Motion nodes are never rescannable. */</comment>
			<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>rescannable</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<return>return <expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <name>pathnode</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* No motion needed if subpath can run anywhere giving same output. */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>CdbPathLocus_IsGeneral</name><argument_list>(<argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * general--&gt;(entry|singleqe), no motion is needed, can run
			 * directly on any of the common segments
			 */</comment>
			<return>return <expr><name>subpath</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Fail if caller refuses motion. */</comment>
		<if_stmt><if>if <condition>(<expr><name>require_existing_order</name> <operator>&amp;&amp;</operator>
			<operator>!</operator><name>pathkeys</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Must be partitioned--&gt;singleton. If caller gave pathkeys, they'll
		 * be used for Merge Receive. If no pathkeys, Union Receive will
		 * arbitrarily interleave the rows from the subpath partitions in no
		 * special order.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CdbPathLocus_IsPartitioned</name><argument_list>(<argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>invalid_motion_request</name>;</goto></block_content></block></if></if_stmt>
	</block_content>}</block></if>

	<comment type="block">/* Output from a single process to be distributed over a gang? */</comment>
	<if type="elseif">else if <condition>(<expr><call><name>CdbPathLocus_IsBottleneck</name><argument_list>(<argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Must be bottleneck--&gt;partitioned or bottleneck--&gt;replicated */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CdbPathLocus_IsPartitioned</name><argument_list>(<argument><expr><name>locus</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<operator>!</operator><call><name>CdbPathLocus_IsReplicated</name><argument_list>(<argument><expr><name>locus</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>invalid_motion_request</name>;</goto></block_content></block></if></if_stmt>

		<comment type="block">/* Fail if caller disallows motion. */</comment>
		<if_stmt><if>if <condition>(<expr><name>require_existing_order</name> <operator>&amp;&amp;</operator>
			<operator>!</operator><name>pathkeys</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

		<comment type="block">/* Each qExec receives a subset of the rows, with ordering preserved. */</comment>
		<expr_stmt><expr><name>pathkeys</name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>pathkeys</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>

	<comment type="block">/* Redistributing partitioned subpath output from one gang to another? */</comment>
	<if type="elseif">else if <condition>(<expr><call><name>CdbPathLocus_IsPartitioned</name><argument_list>(<argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* partitioned--&gt;partitioned? */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>CdbPathLocus_IsPartitioned</name><argument_list>(<argument><expr><name>locus</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* No motion if subpath partitioning matches caller's request. */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>cdbpathlocus_equal</name><argument_list>(<argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>, <argument><expr><name>locus</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>subpath</name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block></if>

		<comment type="block">/* Must be partitioned--&gt;replicated */</comment>
		<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>CdbPathLocus_IsReplicated</name><argument_list>(<argument><expr><name>locus</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>invalid_motion_request</name>;</goto></block_content></block></if></if_stmt>

		<comment type="block">/* Fail if caller insists on ordered result or no motion. */</comment>
		<if_stmt><if>if <condition>(<expr><name>require_existing_order</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Output streams lose any ordering they had. Only a qDisp or
		 * singleton qExec can merge sorted streams (for now).
		 */</comment>
		<expr_stmt><expr><name>pathkeys</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	</block_content>}</block></if>

	<comment type="block">/* If subplan uses no tables, it can run on qDisp or a singleton qExec. */</comment>
	<if type="elseif">else if <condition>(<expr><call><name>CdbPathLocus_IsGeneral</name><argument_list>(<argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * No motion needed if general--&gt;general or general--&gt;replicated or
		 * general--&gt;segmentGeneral
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>CdbPathLocus_IsGeneral</name><argument_list>(<argument><expr><name>locus</name></expr></argument>)</argument_list></call> <operator>||</operator>
			<call><name>CdbPathLocus_IsReplicated</name><argument_list>(<argument><expr><name>locus</name></expr></argument>)</argument_list></call> <operator>||</operator>
			<call><name>CdbPathLocus_IsSegmentGeneral</name><argument_list>(<argument><expr><name>locus</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>subpath</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Must be general--&gt;partitioned. */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CdbPathLocus_IsPartitioned</name><argument_list>(<argument><expr><name>locus</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>invalid_motion_request</name>;</goto></block_content></block></if></if_stmt>

		<comment type="block">/* Fail if caller wants no motion. */</comment>
		<if_stmt><if>if <condition>(<expr><name>require_existing_order</name> <operator>&amp;&amp;</operator>
			<operator>!</operator><name>pathkeys</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

		<comment type="block">/* Since the motion is 1-to-many, the rows remain in the same order. */</comment>
		<expr_stmt><expr><name>pathkeys</name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>pathkeys</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>

	<comment type="block">/* Does subpath produce same multiset of rows on every qExec of its gang? */</comment>
	<if type="elseif">else if <condition>(<expr><call><name>CdbPathLocus_IsReplicated</name><argument_list>(<argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* No-op if replicated--&gt;replicated. */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>CdbPathLocus_IsReplicated</name><argument_list>(<argument><expr><name>locus</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>CdbPathLocus_NumSegments</name><argument_list>(<argument><expr><name>locus</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator>
				   <call><name>CdbPathLocus_NumSegments</name><argument_list>(<argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>subpath</name><operator>-&gt;</operator><name>locus</name><operator>.</operator><name>numsegments</name></name> <operator>=</operator> <call><name>CdbPathLocus_NumSegments</name><argument_list>(<argument><expr><name>locus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>subpath</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Other destinations aren't used or supported at present. */</comment>
		<goto>goto <name>invalid_motion_request</name>;</goto>
	</block_content>}</block></if>

	<comment type="block">/* Most motions from SegmentGeneral (replicated table) are disallowed */</comment>
	<if type="elseif">else if <condition>(<expr><call><name>CdbPathLocus_IsSegmentGeneral</name><argument_list>(<argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * The only allowed case is a SegmentGeneral to Hashed motion,
		 * and SegmentGeneral's numsegments is smaller than Hashed's.
		 * In such a case we redistribute SegmentGeneral to Hashed.
		 *
		 * FIXME: HashedOJ?
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>CdbPathLocus_IsPartitioned</name><argument_list>(<argument><expr><name>locus</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>pathkeys</name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>pathkeys</name></name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>CdbPathLocus_IsReplicated</name><argument_list>(<argument><expr><name>locus</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>CdbPathLocus_NumSegments</name><argument_list>(<argument><expr><name>locus</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <call><name>CdbPathLocus_NumSegments</name><argument_list>(<argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>subpath</name><operator>-&gt;</operator><name>locus</name><operator>.</operator><name>numsegments</name></name> <operator>=</operator> <call><name>CdbPathLocus_NumSegments</name><argument_list>(<argument><expr><name>locus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>subpath</name></expr>;</return>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><name>pathkeys</name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>pathkeys</name></name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>CdbPathLocus_IsSegmentGeneral</name><argument_list>(<argument><expr><name>locus</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>subpath</name><operator>-&gt;</operator><name>locus</name><operator>.</operator><name>numsegments</name></name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>locus</name><operator>.</operator><name>numsegments</name></name></expr></argument>, <argument><expr><name><name>locus</name><operator>.</operator><name>numsegments</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>subpath</name></expr>;</return>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<goto>goto <name>invalid_motion_request</name>;</goto></block_content></block></else></if_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<goto>goto <name>invalid_motion_request</name>;</goto></block_content></block></else></if_stmt>

	<comment type="block">/* Don't materialize before motion. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>subpath</name></expr></argument>, <argument><expr><name>MaterialPath</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>subpath</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>MaterialPath</name> <operator>*</operator><operator>)</operator> <name>subpath</name><operator>)</operator><operator>-&gt;</operator><name>subpath</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * MPP-3300: materialize *before* motion can never help us, motion pushes
	 * data. other nodes pull. We relieve motion deadlocks by adding
	 * materialize nodes on top of motion nodes
	 */</comment>


    <if_stmt><if>if<condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>subpath</name></expr></argument>,<argument><expr><name>SubqueryScanPath</name></expr></argument>)</argument_list></call>
       <operator>&amp;&amp;</operator> <call><name>CdbPathLocus_IsBottleneck</name><argument_list>(<argument><expr><name>locus</name></expr></argument>)</argument_list></call>
       <operator>&amp;&amp;</operator> <operator>!</operator><name><name>subpath</name><operator>-&gt;</operator><name>pathkeys</name></name>
       <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name>SubqueryScanPath</name> <operator>*</operator><operator>)</operator><name>subpath</name><operator>)</operator><operator>-&gt;</operator><name><name>subpath</name><operator>-&gt;</operator><name>pathkeys</name></name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/*
         * In gpdb, when there is a Gather Motion on top of a SubqueryScan,
         * it is hard to keep the sort order information. The subquery's
         * path key cannot be pulled up, if the parent query doesn't have
         * an equivalence class corresponding to the subquery's sort order.
         *
         * e.g. create a view with an ORDER BY:
         *
         * CREATE VIEW v AS SELECT va, vn FROM sourcetable ORDER BY vn;
         *
         * and query it:
         *
         * SELECT va FROM v_sourcetable;
         *
         * So, push down the Gather Motion if the SubqueryScan dose not 
         * have pathkey but the SubqueryScan's subpath does.
         *
         */</comment>
        <decl_stmt><decl><type><name>SubqueryScanPath</name> <modifier>*</modifier></type><name>subqueryScanPath</name> <init>= <expr><operator>(</operator><name>SubqueryScanPath</name> <operator>*</operator><operator>)</operator><name>subpath</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>SubqueryScanPath</name> <modifier>*</modifier></type><name>newSubqueryScanPath</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Path</name> <modifier>*</modifier></type><name>motionPath</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name>subpath</name> <operator>=</operator> <name><name>subqueryScanPath</name><operator>-&gt;</operator><name>subpath</name></name></expr>;</expr_stmt>

        <expr_stmt><expr><name>motionPath</name> <operator>=</operator> <call><name>cdbpath_create_motion_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
                                                <argument><expr><name>subpath</name></expr></argument>,
                                                <argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>pathkeys</name></name></expr></argument>,
                                                <argument><expr><name>true</name></expr></argument>,
                                                <argument><expr><name>locus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>newSubqueryScanPath</name> <operator>=</operator> <call><name>create_subqueryscan_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
                                                       <argument><expr><name><name>subqueryScanPath</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parent</name></name></expr></argument>,
                                                       <argument><expr><name>motionPath</name></expr></argument>,
                                                       <argument><expr><name><name>subqueryScanPath</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathkeys</name></name></expr></argument>,
                                                       <argument><expr><name>locus</name></expr></argument>,
                                                       <argument><expr><name><name>subqueryScanPath</name><operator>-&gt;</operator><name>required_outer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* apply final path target */</comment>
        <expr_stmt><expr><name>newSubqueryScanPath</name> <operator>=</operator> <operator>(</operator><name>SubqueryScanPath</name> <operator>*</operator><operator>)</operator><call><name>apply_projection_to_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
                                                                           <argument><expr><name><name>subqueryScanPath</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parent</name></name></expr></argument>,
                                                                           <argument><expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <name>newSubqueryScanPath</name></expr></argument>,
                                                                           <argument><expr><name><name>subqueryScanPath</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtarget</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <return>return <expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <name>newSubqueryScanPath</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If the subpath requires parameters, we cannot generate Motion atop of it.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>bms_is_empty</name><argument_list>(<argument><expr><call><name>PATH_REQ_OUTER</name><argument_list>(<argument><expr><name>subpath</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Create CdbMotionPath node. */</comment>
	<expr_stmt><expr><name>pathnode</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>CdbMotionPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtype</name></name> <operator>=</operator> <name>T_Motion</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parent</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>parent</name></name></expr>;</expr_stmt>
	<comment type="block">/* Motion doesn't project, so use source path's pathtarget */</comment>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtarget</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>pathtarget</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>locus</name></name> <operator>=</operator> <name>locus</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>rows</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>rows</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathkeys</name></name> <operator>=</operator> <name>pathkeys</name></expr>;</expr_stmt>

	<comment type="block">/* GPDB_96_MERGE_FIXME: When is a Motion path parallel-safe? I tried
	 * setting this to 'false' initially, to play it safe, but somehow
	 * the Paths with motions ended up in gather plans anyway, and tripped
	 * assertion failures.
	 */</comment>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_aware</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_safe</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>parallel_safe</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_workers</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>parallel_workers</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>subpath</name></name> <operator>=</operator> <name>subpath</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>is_explicit_motion</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/* Cost of motion */</comment>
	<expr_stmt><expr><call><name>cdbpath_cost_motion</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>pathnode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Tell operators above us that slack may be needed for deadlock safety. */</comment>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>motionHazard</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>rescannable</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * A motion to bring data to the outer query's locus needs a Material node
	 * on top, to shield the Motion node from rescanning, when the SubPlan
	 * is rescanned.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>CdbPathLocus_IsOuterQuery</name><argument_list>(<argument><expr><name>locus</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>create_material_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>parent</name></name></expr></argument>,
											 <argument><expr><operator>&amp;</operator><name><name>pathnode</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <name>pathnode</name></expr>;</return>

	<comment type="block">/* Unexpected source or destination locus. */</comment>
<label><name>invalid_motion_request</name>:</label>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not build Motion path"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>								<comment type="block">/* cdbpath_create_motion_path */</comment>

<function><type><name>Path</name> <modifier>*</modifier></type>
<name>cdbpath_create_explicit_motion_path</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
									<parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>subpath</name></decl></parameter>,
									<parameter><decl><type><name>CdbPathLocus</name></type> <name>locus</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CdbMotionPath</name> <modifier>*</modifier></type><name>pathnode</name></decl>;</decl_stmt>

	<comment type="block">/* Create CdbMotionPath node. */</comment>
	<expr_stmt><expr><name>pathnode</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>CdbMotionPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtype</name></name> <operator>=</operator> <name>T_Motion</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parent</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>parent</name></name></expr>;</expr_stmt>
	<comment type="block">/* Motion doesn't project, so use source path's pathtarget */</comment>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtarget</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>pathtarget</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>locus</name></name> <operator>=</operator> <name>locus</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>rows</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>rows</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathkeys</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<comment type="block">/* GPDB_96_MERGE_FIXME: When is a Motion path parallel-safe? I tried
	 * setting this to 'false' initially, to play it safe, but somehow
	 * the Paths with motions ended up in gather plans anyway, and tripped
	 * assertion failures.
	 */</comment>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_aware</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_safe</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>parallel_safe</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_workers</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>parallel_workers</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>subpath</name></name> <operator>=</operator> <name>subpath</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>is_explicit_motion</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<comment type="block">/* Cost of motion */</comment>
	<expr_stmt><expr><call><name>cdbpath_cost_motion</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>pathnode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Tell operators above us that slack may be needed for deadlock safety. */</comment>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>motionHazard</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>rescannable</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <name>pathnode</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>Path</name> <modifier>*</modifier></type>
<name>cdbpath_create_broadcast_motion_path</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
									 <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>subpath</name></decl></parameter>,
									 <parameter><decl><type><name>int</name></type> <name>numsegments</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CdbMotionPath</name> <modifier>*</modifier></type><name>pathnode</name></decl>;</decl_stmt>

	<comment type="block">/* Create CdbMotionPath node. */</comment>
	<expr_stmt><expr><name>pathnode</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>CdbMotionPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtype</name></name> <operator>=</operator> <name>T_Motion</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parent</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>parent</name></name></expr>;</expr_stmt>
	<comment type="block">/* Motion doesn't project, so use source path's pathtarget */</comment>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtarget</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>pathtarget</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CdbPathLocus_MakeReplicated</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>locus</name></name></expr></argument>, <argument><expr><name>numsegments</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>rows</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>rows</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathkeys</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<comment type="block">/* GPDB_96_MERGE_FIXME: When is a Motion path parallel-safe? I tried
	 * setting this to 'false' initially, to play it safe, but somehow
	 * the Paths with motions ended up in gather plans anyway, and tripped
	 * assertion failures.
	 */</comment>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_aware</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_safe</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>parallel_safe</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_workers</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>parallel_workers</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>subpath</name></name> <operator>=</operator> <name>subpath</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>is_explicit_motion</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/* Cost of motion */</comment>
	<expr_stmt><expr><call><name>cdbpath_cost_motion</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>pathnode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Tell operators above us that slack may be needed for deadlock safety. */</comment>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>motionHazard</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>rescannable</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <name>pathnode</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 */</comment>
<function><type><specifier>static</specifier> <name>CdbMotionPath</name> <modifier>*</modifier></type>
<name>make_motion_path</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>subpath</name></decl></parameter>,
				 <parameter><decl><type><name>CdbPathLocus</name></type> <name>locus</name></decl></parameter>,
				 <parameter><decl><type><name>bool</name></type> <name>is_explicit_motion</name></decl></parameter>,
				 <parameter><decl><type><name>GpPolicy</name> <modifier>*</modifier></type><name>policy</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CdbMotionPath</name> <modifier>*</modifier></type><name>pathnode</name></decl>;</decl_stmt>

	<comment type="block">/* Create CdbMotionPath node. */</comment>
	<expr_stmt><expr><name>pathnode</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>CdbMotionPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtype</name></name> <operator>=</operator> <name>T_Motion</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parent</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>parent</name></name></expr>;</expr_stmt>
	<comment type="block">/* Motion doesn't project, so use source path's pathtarget */</comment>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtarget</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>pathtarget</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>locus</name></name> <operator>=</operator> <name>locus</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>rows</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>rows</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathkeys</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<comment type="block">/* GPDB_96_MERGE_FIXME: When is a Motion path parallel-safe? I tried
	 * setting this to 'false' initially, to play it safe, but somehow
	 * the Paths with motions ended up in gather plans anyway, and tripped
	 * assertion failures.
	 */</comment>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_aware</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_safe</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>parallel_safe</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_workers</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>parallel_workers</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>subpath</name></name> <operator>=</operator> <name>subpath</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>is_explicit_motion</name></name> <operator>=</operator> <name>is_explicit_motion</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>policy</name></name> <operator>=</operator> <name>policy</name></expr>;</expr_stmt>

	<comment type="block">/* Cost of motion */</comment>
	<expr_stmt><expr><call><name>cdbpath_cost_motion</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>pathnode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Tell operators above us that slack may be needed for deadlock safety. */</comment>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>motionHazard</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pathnode</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>rescannable</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<return>return <expr><name>pathnode</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * cdbpath_match_preds_to_partkey_tail
 *
 * Returns true if all of the locus's partitioning key expressions are
 * found as comparands of equijoin predicates in the mergeclause_list.
 *
 * NB: for mergeclause_list and pathkey structure assumptions, see:
 *          select_mergejoin_clauses() in joinpath.c
 *          find_mergeclauses_for_pathkeys() in pathkeys.c
 */</comment>

<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>mergeclause_list</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Path</name>       <modifier>*</modifier></type><name>path</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CdbPathLocus</name></type> <name>locus</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CdbPathLocus</name> <modifier>*</modifier></type><name>colocus</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>colocus_eq_locus</name></decl>;</decl_stmt>
}</block></struct></type> <name>CdbpathMatchPredsContext</name>;</typedef>


<comment type="block">/*
 * A helper function to create a DistributionKey for an EquivalenceClass.
 */</comment>
<function><type><specifier>static</specifier> <name>DistributionKey</name> <modifier>*</modifier></type>
<name>makeDistributionKeyForEC</name><parameter_list>(<parameter><decl><type><name>EquivalenceClass</name> <modifier>*</modifier></type><name>eclass</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>opfamily</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DistributionKey</name> <modifier>*</modifier></type><name>dk</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>DistributionKey</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>opfamily</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>dk</name><operator>-&gt;</operator><name>dk_eclasses</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>eclass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dk</name><operator>-&gt;</operator><name>dk_opfamily</name></name> <operator>=</operator> <name>opfamily</name></expr>;</expr_stmt>

	<return>return <expr><name>dk</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * cdbpath_eclass_constant_is_hashable
 *
 * Iterates through a list of equivalence class members and determines if
 * expression in pseudoconstant is hashable under the given hash opfamily.
 *
 * If there are multiple constants in the equivalence class, it is sufficient
 * that one of them is usable.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>cdbpath_eclass_constant_is_hashable</name><parameter_list>(<parameter><decl><type><name>EquivalenceClass</name> <modifier>*</modifier></type><name>ec</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>hashOpFamily</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>j</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>j</argument>, <argument>ec-&gt;ec_members</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>EquivalenceMember</name> <modifier>*</modifier></type><name>em</name> <init>= <expr><operator>(</operator><name>EquivalenceMember</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>j</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>em</name><operator>-&gt;</operator><name>em_is_const</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>get_opfamily_member</name><argument_list>(<argument><expr><name>hashOpFamily</name></expr></argument>, <argument><expr><name><name>em</name><operator>-&gt;</operator><name>em_datatype</name></name></expr></argument>, <argument><expr><name><name>em</name><operator>-&gt;</operator><name>em_datatype</name></name></expr></argument>,
								<argument><expr><name>HTEqualStrategyNumber</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>cdbpath_match_preds_to_distkey_tail</name><parameter_list>(<parameter><decl><type><name>CdbpathMatchPredsContext</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>,
									<parameter><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>distkeycell</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DistributionKey</name> <modifier>*</modifier></type><name>distkey</name> <init>= <expr><operator>(</operator><name>DistributionKey</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>distkeycell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DistributionKey</name> <modifier>*</modifier></type><name>codistkey</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>rcell</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>CdbPathLocus_IsHashed</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
		   <call><name>CdbPathLocus_IsHashedOJ</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*----------------
	 * Is there a "&lt;distkey item&gt; = &lt;constant expr&gt;" predicate?
	 *
	 * If table T is distributed on cols (C,D,E) and query contains preds
	 *		T.C = U.A AND T.D = &lt;constant expr&gt; AND T.E = U.B
	 * then we would like to report a match and return the colocus
	 * 		(U.A, &lt;constant expr&gt;, U.B)
	 * so the caller can join T and U by redistributing only U.
	 * (Note that "T.D = &lt;constant expr&gt;" won't be in the mergeclause_list
	 * because it isn't a join pred.)
	 *----------------
	 */</comment>
	<expr_stmt><expr><name>codistkey</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>distkey-&gt;dk_eclasses</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>EquivalenceClass</name> <modifier>*</modifier></type><name>ec</name> <init>= <expr><operator>(</operator><name>EquivalenceClass</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>CdbEquivClassIsConstant</name><argument_list>(<argument><expr><name>ec</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<call><name>cdbpath_eclass_constant_is_hashable</name><argument_list>(<argument><expr><name>ec</name></expr></argument>, <argument><expr><name><name>distkey</name><operator>-&gt;</operator><name>dk_opfamily</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>codistkey</name> <operator>=</operator> <name>distkey</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/* Look for an equijoin comparison to the distkey item. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>codistkey</name></expr>)</condition>
	<block>{<block_content>
		<macro><name>foreach</name><argument_list>(<argument>rcell</argument>, <argument>ctx-&gt;mergeclause_list</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>EquivalenceClass</name> <modifier>*</modifier></type><name>a_ec</name></decl>;</decl_stmt> <comment type="block">/* Corresponding to ctx-&gt;path. */</comment>
			<decl_stmt><decl><type><name>EquivalenceClass</name> <modifier>*</modifier></type><name>b_ec</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>i</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>rinfo</name> <init>= <expr><operator>(</operator><name>RestrictInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>rcell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>update_mergeclause_eclasses</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>root</name></name></expr></argument>, <argument><expr><name>rinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>bms_is_subset</name><argument_list>(<argument><expr><name><name>rinfo</name><operator>-&gt;</operator><name>right_relids</name></name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>path</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>a_ec</name> <operator>=</operator> <name><name>rinfo</name><operator>-&gt;</operator><name>right_ec</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name>b_ec</name> <operator>=</operator> <name><name>rinfo</name><operator>-&gt;</operator><name>left_ec</name></name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><name>a_ec</name> <operator>=</operator> <name><name>rinfo</name><operator>-&gt;</operator><name>left_ec</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name>b_ec</name> <operator>=</operator> <name><name>rinfo</name><operator>-&gt;</operator><name>right_ec</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>bms_is_subset</name><argument_list>(<argument><expr><name><name>rinfo</name><operator>-&gt;</operator><name>left_relids</name></name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>path</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<macro><name>foreach</name><argument_list>(<argument>i</argument>, <argument>distkey-&gt;dk_eclasses</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>EquivalenceClass</name> <modifier>*</modifier></type><name>dk_eclass</name> <init>= <expr><operator>(</operator><name>EquivalenceClass</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name>dk_eclass</name> <operator>==</operator> <name>a_ec</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>codistkey</name> <operator>=</operator> <call><name>makeDistributionKeyForEC</name><argument_list>(<argument><expr><name>b_ec</name></expr></argument>, <argument><expr><name><name>distkey</name><operator>-&gt;</operator><name>dk_opfamily</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt> <comment type="block">/* break earlier? */</comment>
			</block_content>}</block>

			<if_stmt><if>if <condition>(<expr><name>codistkey</name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
		</block_content>}</block>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Fail if didn't find a match for this distkey item. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>codistkey</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Might need to build co-locus if locus is outer join source or result. */</comment>
	<if_stmt><if>if <condition>(<expr><name>codistkey</name> <operator>!=</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>distkeycell</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>colocus_eq_locus</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Match remaining partkey items. */</comment>
	<expr_stmt><expr><name>distkeycell</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>distkeycell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>distkeycell</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>cdbpath_match_preds_to_distkey_tail</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>distkeycell</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Success!  Matched all items.  Return co-locus if requested. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>colocus</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>colocus_eq_locus</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name><name>ctx</name><operator>-&gt;</operator><name>colocus</name></name> <operator>=</operator> <name><name>ctx</name><operator>-&gt;</operator><name>locus</name></name></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><operator>!</operator><name>distkeycell</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>CdbPathLocus_MakeHashed</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>colocus</name></name></expr></argument>, <argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name>codistkey</name></expr></argument>)</argument_list></call></expr></argument>,
									<argument><expr><call><name>CdbPathLocus_NumSegments</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>colocus</name><operator>-&gt;</operator><name>distkey</name></name> <operator>=</operator> <call><name>lcons</name><argument_list>(<argument><expr><name>codistkey</name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>colocus</name><operator>-&gt;</operator><name>distkey</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>cdbpathlocus_is_valid</name><argument_list>(<argument><expr><operator>*</operator><name><name>ctx</name><operator>-&gt;</operator><name>colocus</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>								<comment type="block">/* cdbpath_match_preds_to_partkey_tail */</comment>



<comment type="block">/*
 * cdbpath_match_preds_to_partkey
 *
 * Returns true if an equijoin predicate is found in the mergeclause_list
 * for each item of the locus's partitioning key.
 *
 * (Also, a partkey item that is equal to a constant is treated as a match.)
 *
 * Readers may refer also to these related functions:
 *          select_mergejoin_clauses() in joinpath.c
 *          find_mergeclauses_for_pathkeys() in pathkeys.c
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>cdbpath_match_preds_to_distkey</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
							   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>mergeclause_list</name></decl></parameter>,
							   <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>path</name></decl></parameter>,
							   <parameter><decl><type><name>CdbPathLocus</name></type> <name>locus</name></decl></parameter>,
							   <parameter><decl><type><name>CdbPathLocus</name> <modifier>*</modifier></type><name>colocus</name></decl></parameter>)</parameter_list>	<comment type="block">/* OUT */</comment>
<block>{<block_content>
	<decl_stmt><decl><type><name>CdbpathMatchPredsContext</name></type> <name>ctx</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CdbPathLocus_IsHashed</name><argument_list>(<argument><expr><name>locus</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<operator>!</operator><call><name>CdbPathLocus_IsHashedOJ</name><argument_list>(<argument><expr><name>locus</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>cdbpathlocus_is_valid</name><argument_list>(<argument><expr><name>locus</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>root</name></name> <operator>=</operator> <name>root</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>mergeclause_list</name></name> <operator>=</operator> <name>mergeclause_list</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>path</name></name> <operator>=</operator> <name>path</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>locus</name></name> <operator>=</operator> <name>locus</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>colocus</name></name> <operator>=</operator> <name>colocus</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>colocus_eq_locus</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<return>return <expr><call><name>cdbpath_match_preds_to_distkey_tail</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ctx</name></expr></argument>, <argument><expr><call><name>list_head</name><argument_list>(<argument><expr><name><name>locus</name><operator>.</operator><name>distkey</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * cdbpath_match_preds_to_both_distkeys
 *
 * Returns true if the mergeclause_list contains equijoin
 * predicates between each item of the outer_locus distkey and
 * the corresponding item of the inner_locus distkey.
 *
 * Readers may refer also to these related functions:
 *          select_mergejoin_clauses() in joinpath.c
 *          find_mergeclauses_for_pathkeys() in pathkeys.c
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>cdbpath_match_preds_to_both_distkeys</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
									 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>mergeclause_list</name></decl></parameter>,
									 <parameter><decl><type><name>CdbPathLocus</name></type> <name>outer_locus</name></decl></parameter>,
									 <parameter><decl><type><name>CdbPathLocus</name></type> <name>inner_locus</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>outercell</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>innercell</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>outer_distkey</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>inner_distkey</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>mergeclause_list</name> <operator>||</operator>
		<call><name>CdbPathLocus_NumSegments</name><argument_list>(<argument><expr><name>outer_locus</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>CdbPathLocus_NumSegments</name><argument_list>(<argument><expr><name>inner_locus</name></expr></argument>)</argument_list></call> <operator>||</operator>
		<name><name>outer_locus</name><operator>.</operator><name>distkey</name></name> <operator>==</operator> <name>NIL</name> <operator>||</operator> <name><name>inner_locus</name><operator>.</operator><name>distkey</name></name> <operator>==</operator> <name>NIL</name> <operator>||</operator>
		<call><name>list_length</name><argument_list>(<argument><expr><name><name>outer_locus</name><operator>.</operator><name>distkey</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>inner_locus</name><operator>.</operator><name>distkey</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>CdbPathLocus_IsHashed</name><argument_list>(<argument><expr><name>outer_locus</name></expr></argument>)</argument_list></call> <operator>||</operator>
		   <call><name>CdbPathLocus_IsHashedOJ</name><argument_list>(<argument><expr><name>outer_locus</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>CdbPathLocus_IsHashed</name><argument_list>(<argument><expr><name>inner_locus</name></expr></argument>)</argument_list></call> <operator>||</operator>
		   <call><name>CdbPathLocus_IsHashedOJ</name><argument_list>(<argument><expr><name>inner_locus</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>outer_distkey</name> <operator>=</operator> <name><name>outer_locus</name><operator>.</operator><name>distkey</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>inner_distkey</name> <operator>=</operator> <name><name>inner_locus</name><operator>.</operator><name>distkey</name></name></expr>;</expr_stmt>

	<macro><name>forboth</name><argument_list>(<argument>outercell</argument>, <argument>outer_distkey</argument>, <argument>innercell</argument>, <argument>inner_distkey</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>DistributionKey</name> <modifier>*</modifier></type><name>outer_dk</name> <init>= <expr><operator>(</operator><name>DistributionKey</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>outercell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DistributionKey</name> <modifier>*</modifier></type><name>inner_dk</name> <init>= <expr><operator>(</operator><name>DistributionKey</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>innercell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>rcell</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>outer_dk</name><operator>-&gt;</operator><name>dk_opfamily</name></name> <operator>!=</operator> <name><name>inner_dk</name><operator>-&gt;</operator><name>dk_opfamily</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>	<comment type="block">/* incompatible hashing scheme */</comment>

		<macro><name>foreach</name><argument_list>(<argument>rcell</argument>, <argument>mergeclause_list</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>bool</name></type>		<name>not_found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>rinfo</name> <init>= <expr><operator>(</operator><name>RestrictInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>rcell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>i</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>update_mergeclause_eclasses</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Skip predicate if neither side matches outer distkey item. */</comment>
			<macro><name>foreach</name><argument_list>(<argument>i</argument>, <argument>outer_dk-&gt;dk_eclasses</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>EquivalenceClass</name> <modifier>*</modifier></type><name>outer_ec</name> <init>= <expr><operator>(</operator><name>EquivalenceClass</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name>outer_ec</name> <operator>!=</operator> <name><name>rinfo</name><operator>-&gt;</operator><name>left_ec</name></name> <operator>&amp;&amp;</operator> <name>outer_ec</name> <operator>!=</operator> <name><name>rinfo</name><operator>-&gt;</operator><name>right_ec</name></name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>not_found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block>
			<if_stmt><if>if <condition>(<expr><name>not_found</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<comment type="block">/* Skip predicate if neither side matches inner distkey item. */</comment>
			<if_stmt><if>if <condition>(<expr><name>inner_dk</name> <operator>!=</operator> <name>outer_dk</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>i</name></decl>;</decl_stmt>

				<macro><name>foreach</name><argument_list>(<argument>i</argument>, <argument>inner_dk-&gt;dk_eclasses</argument>)</argument_list></macro>
				<block>{<block_content>
					<decl_stmt><decl><type><name>EquivalenceClass</name> <modifier>*</modifier></type><name>inner_ec</name> <init>= <expr><operator>(</operator><name>EquivalenceClass</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><name>inner_ec</name> <operator>!=</operator> <name><name>rinfo</name><operator>-&gt;</operator><name>left_ec</name></name> <operator>&amp;&amp;</operator> <name>inner_ec</name> <operator>!=</operator> <name><name>rinfo</name><operator>-&gt;</operator><name>right_ec</name></name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name>not_found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
						<break>break;</break>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block>
				<if_stmt><if>if <condition>(<expr><name>not_found</name></expr>)</condition><block type="pseudo"><block_content>
					<continue>continue;</continue></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* Found equijoin between outer distkey item &amp; inner distkey item */</comment>
			<break>break;</break>
		</block_content>}</block>

		<comment type="block">/* Fail if didn't find equijoin between this pair of distkey items. */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>rcell</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>								<comment type="block">/* cdbpath_match_preds_to_both_distkeys */</comment>

<comment type="block">/*
 * cdbpath_distkeys_from_preds
 *
 * Makes a CdbPathLocus for repartitioning, driven by
 * the equijoin predicates in the mergeclause_list (a List of RestrictInfo).
 * Returns true if successful, or false if no usable equijoin predicates.
 *
 * Readers may refer also to these related functions:
 *      select_mergejoin_clauses() in joinpath.c
 *      make_pathkeys_for_mergeclauses() in pathkeys.c
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>cdbpath_distkeys_from_preds</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
							<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>mergeclause_list</name></decl></parameter>,
							<parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>a_path</name></decl></parameter>,
							<parameter><decl><type><name>int</name></type> <name>numsegments</name></decl></parameter>,
							<parameter><decl><type><name>CdbPathLocus</name> <modifier>*</modifier></type><name>a_locus</name></decl></parameter>,	<comment type="block">/* OUT */</comment>
							<parameter><decl><type><name>CdbPathLocus</name> <modifier>*</modifier></type><name>b_locus</name></decl></parameter>)</parameter_list>	<comment type="block">/* OUT */</comment>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>a_distkeys</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>b_distkeys</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>rcell</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>rcell</argument>, <argument>mergeclause_list</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>rinfo</name> <init>= <expr><operator>(</operator><name>RestrictInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>rcell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>lhs_opno</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>rhs_opno</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>opfamily</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>update_mergeclause_eclasses</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * skip non-hashable keys
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>rinfo</name><operator>-&gt;</operator><name>hashjoinoperator</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * look up a hash operator family that is compatible for the left and right datatypes
		 * of the hashjoin = operator
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>get_compatible_hash_operators_and_family</name><argument_list>(<argument><expr><name><name>rinfo</name><operator>-&gt;</operator><name>hashjoinoperator</name></name></expr></argument>,
													  <argument><expr><operator>&amp;</operator><name>lhs_opno</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rhs_opno</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>opfamily</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* Left &amp; right pathkeys are usually the same... */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>b_distkeys</name> <operator>&amp;&amp;</operator> <name><name>rinfo</name><operator>-&gt;</operator><name>left_ec</name></name> <operator>==</operator> <name><name>rinfo</name><operator>-&gt;</operator><name>right_ec</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>i</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>        <name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

			<macro><name>foreach</name><argument_list>(<argument>i</argument>, <argument>a_distkeys</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>DistributionKey</name> <modifier>*</modifier></type><name>distkey</name> <init>= <expr><operator>(</operator><name>DistributionKey</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>EquivalenceClass</name> <modifier>*</modifier></type><name>dk_eclass</name></decl>;</decl_stmt>

				<comment type="block">/*
				 * we only create Hashed DistributionKeys with a single eclass
				 * in this function.
				 */</comment>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>distkey</name><operator>-&gt;</operator><name>dk_eclasses</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>dk_eclass</name> <operator>=</operator> <operator>(</operator><name>EquivalenceClass</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>distkey</name><operator>-&gt;</operator><name>dk_eclasses</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name>dk_eclass</name> <operator>==</operator> <name><name>rinfo</name><operator>-&gt;</operator><name>left_ec</name></name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>DistributionKey</name> <modifier>*</modifier></type><name>a_dk</name> <init>= <expr><call><name>makeDistributionKeyForEC</name><argument_list>(<argument><expr><name><name>rinfo</name><operator>-&gt;</operator><name>left_ec</name></name></expr></argument>, <argument><expr><name>opfamily</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<expr_stmt><expr><name>a_distkeys</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>a_distkeys</name></expr></argument>, <argument><expr><name>a_dk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>

		<comment type="block">/* ... except in outer join ON-clause. */</comment>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>EquivalenceClass</name> <modifier>*</modifier></type><name>a_ec</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>EquivalenceClass</name> <modifier>*</modifier></type><name>b_ec</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>i</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>bms_is_subset</name><argument_list>(<argument><expr><name><name>rinfo</name><operator>-&gt;</operator><name>right_relids</name></name></expr></argument>, <argument><expr><name><name>a_path</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>a_ec</name> <operator>=</operator> <name><name>rinfo</name><operator>-&gt;</operator><name>right_ec</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name>b_ec</name> <operator>=</operator> <name><name>rinfo</name><operator>-&gt;</operator><name>left_ec</name></name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><name>a_ec</name> <operator>=</operator> <name><name>rinfo</name><operator>-&gt;</operator><name>left_ec</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name>b_ec</name> <operator>=</operator> <name><name>rinfo</name><operator>-&gt;</operator><name>right_ec</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>bms_is_subset</name><argument_list>(<argument><expr><name><name>rinfo</name><operator>-&gt;</operator><name>left_relids</name></name></expr></argument>, <argument><expr><name><name>a_path</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>b_ec</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>b_ec</name> <operator>=</operator> <name>a_ec</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * Convoluted logic to ensure that (a_ec not in a_distkeys) AND
			 * (b_ec not in b_distkeys)
			 */</comment>
			<expr_stmt><expr><name>found</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<macro><name>foreach</name><argument_list>(<argument>i</argument>, <argument>a_distkeys</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>DistributionKey</name> <modifier>*</modifier></type><name>distkey</name> <init>= <expr><operator>(</operator><name>DistributionKey</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>EquivalenceClass</name> <modifier>*</modifier></type><name>dk_eclass</name></decl>;</decl_stmt>

				<comment type="block">/*
				 * we only create Hashed DistributionKeys with a single eclass
				 * in this function.
				 */</comment>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>distkey</name><operator>-&gt;</operator><name>dk_eclasses</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>dk_eclass</name> <operator>=</operator> <operator>(</operator><name>EquivalenceClass</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>distkey</name><operator>-&gt;</operator><name>dk_eclasses</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name>dk_eclass</name> <operator>==</operator> <name>a_ec</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
			<block>{<block_content>
				<macro><name>foreach</name><argument_list>(<argument>i</argument>, <argument>b_distkeys</argument>)</argument_list></macro>
				<block>{<block_content>
					<decl_stmt><decl><type><name>DistributionKey</name> <modifier>*</modifier></type><name>distkey</name> <init>= <expr><operator>(</operator><name>DistributionKey</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>EquivalenceClass</name> <modifier>*</modifier></type><name>dk_eclass</name></decl>;</decl_stmt>

					<comment type="block">/*
					 * we only create Hashed DistributionKeys with a single eclass
					 * in this function.
					 */</comment>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>distkey</name><operator>-&gt;</operator><name>dk_eclasses</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>dk_eclass</name> <operator>=</operator> <operator>(</operator><name>EquivalenceClass</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>distkey</name><operator>-&gt;</operator><name>dk_eclasses</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<if_stmt><if>if <condition>(<expr><name>dk_eclass</name> <operator>==</operator> <name>b_ec</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
						<break>break;</break>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>DistributionKey</name> <modifier>*</modifier></type><name>a_dk</name> <init>= <expr><call><name>makeDistributionKeyForEC</name><argument_list>(<argument><expr><name>a_ec</name></expr></argument>, <argument><expr><name>opfamily</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>DistributionKey</name> <modifier>*</modifier></type><name>b_dk</name> <init>= <expr><call><name>makeDistributionKeyForEC</name><argument_list>(<argument><expr><name>b_ec</name></expr></argument>, <argument><expr><name>opfamily</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name>a_distkeys</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>a_distkeys</name></expr></argument>, <argument><expr><name>a_dk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>b_distkeys</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>b_distkeys</name></expr></argument>, <argument><expr><name>b_dk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>a_distkeys</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">20</literal></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
	</block_content>}</block>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>a_distkeys</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>CdbPathLocus_MakeHashed</name><argument_list>(<argument><expr><name>a_locus</name></expr></argument>, <argument><expr><name>a_distkeys</name></expr></argument>, <argument><expr><name>numsegments</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>b_distkeys</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>CdbPathLocus_MakeHashed</name><argument_list>(<argument><expr><name>b_locus</name></expr></argument>, <argument><expr><name>b_distkeys</name></expr></argument>, <argument><expr><name>numsegments</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>b_locus</name> <operator>=</operator> <operator>*</operator><name>a_locus</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>								<comment type="block">/* cdbpath_distkeys_from_preds */</comment>

<comment type="block">/*
 * Add a RowIdExpr to the target list of 'path'. Returns the ID
 * of the generated rowid expression in *rowidexpr_id.
 */</comment>
<function><type><specifier>static</specifier> <name>Path</name> <modifier>*</modifier></type>
<name>add_rowid_to_path</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>rowidexpr_id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RowIdExpr</name> <modifier>*</modifier></type><name>rowidexpr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>newpathtarget</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * 'last_rowidexpr_id' is used to generate a unique ID for the RowIdExpr
	 * node that we generate. It only needs to be unique within this query
	 * plan, and the simplest way to achieve that is to just have a global
	 * counter. (Actually, it isn't really needed at the moment because the
	 * deduplication is always done immediately on top of the join, so two
	 * different RowIdExprs should never appear in the same part of the plan
	 * tree. But it might come handy when debugging, if nothing else.
	 * XXX: If we start to rely on it for something important, consider
	 * overflow behavior more carefully.)
	 */</comment>
	<decl_stmt><decl><type><specifier>static</specifier> <name>uint32</name></type> <name>last_rowidexpr_id</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>rowidexpr</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>RowIdExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>last_rowidexpr_id</name><operator>++</operator></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>rowidexpr_id</name> <operator>=</operator> <name><name>rowidexpr</name><operator>-&gt;</operator><name>rowidexpr_id</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <name>last_rowidexpr_id</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>newpathtarget</name> <operator>=</operator> <call><name>copy_pathtarget</name><argument_list>(<argument><expr><name><name>path</name><operator>-&gt;</operator><name>pathtarget</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>add_column_to_pathtarget</name><argument_list>(<argument><expr><name>newpathtarget</name></expr></argument>, <argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>rowidexpr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>create_projection_path_with_quals</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>path</name><operator>-&gt;</operator><name>parent</name></name></expr></argument>,
													  <argument><expr><name>path</name></expr></argument>, <argument><expr><name>newpathtarget</name></expr></argument>,
													  <argument><expr><name>NIL</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * cdbpath_motion_for_join
 *
 * Decides where a join should be done.  Adds Motion operators atop
 * the subpaths if needed to deliver their results to the join locus.
 * Returns the join locus if ok, or a null locus otherwise. If
 * jointype is JOIN_SEMI_DEDUP or JOIN_SEMI_DEDUP_REVERSE, this also
 * tacks a RowIdExpr on one side of the join, and *p_rowidexpr_id is
 * set to the ID of that. The caller is expected to uniquefy
 * the result after the join, passing the rowidexpr_id to
 * create_unique_rowid_path().
 *
 * mergeclause_list is a List of RestrictInfo.  Its members are
 * the equijoin predicates between the outer and inner rel.
 * It comes from select_mergejoin_clauses() in joinpath.c.
 */</comment>
<function><type><name>CdbPathLocus</name></type>
<name>cdbpath_motion_for_join</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
						<parameter><decl><type><name>JoinType</name></type> <name>jointype</name></decl></parameter>,	<comment type="block">/* JOIN_INNER/FULL/LEFT/RIGHT/IN */</comment>
						<parameter><decl><type><name>Path</name> <modifier>*</modifier><modifier>*</modifier></type><name>p_outer_path</name></decl></parameter>,	<comment type="block">/* INOUT */</comment>
						<parameter><decl><type><name>Path</name> <modifier>*</modifier><modifier>*</modifier></type><name>p_inner_path</name></decl></parameter>,	<comment type="block">/* INOUT */</comment>
						<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>p_rowidexpr_id</name></decl></parameter>,	<comment type="block">/* OUT */</comment>
						<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>redistribution_clauses</name></decl></parameter>, <comment type="block">/* equijoin RestrictInfo list */</comment>
						<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>restrict_clauses</name></decl></parameter>,
						<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>outer_pathkeys</name></decl></parameter>,
						<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>inner_pathkeys</name></decl></parameter>,
						<parameter><decl><type><name>bool</name></type> <name>outer_require_existing_order</name></decl></parameter>,
						<parameter><decl><type><name>bool</name></type> <name>inner_require_existing_order</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CdbpathMfjRel</name></type> <name>outer</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CdbpathMfjRel</name></type> <name>inner</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numsegments</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>join_quals_contain_outer_references</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<expr_stmt><expr><operator>*</operator><name>p_rowidexpr_id</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>outer</name><operator>.</operator><name>pathkeys</name></name> <operator>=</operator> <name>outer_pathkeys</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>inner</name><operator>.</operator><name>pathkeys</name></name> <operator>=</operator> <name>inner_pathkeys</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>outer</name><operator>.</operator><name>path</name></name> <operator>=</operator> <operator>*</operator><name>p_outer_path</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>inner</name><operator>.</operator><name>path</name></name> <operator>=</operator> <operator>*</operator><name>p_inner_path</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>outer</name><operator>.</operator><name>locus</name></name> <operator>=</operator> <name><name>outer</name><operator>.</operator><name>path</name><operator>-&gt;</operator><name>locus</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>inner</name><operator>.</operator><name>locus</name></name> <operator>=</operator> <name><name>inner</name><operator>.</operator><name>path</name><operator>-&gt;</operator><name>locus</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CdbPathLocus_MakeNull</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>outer</name><operator>.</operator><name>move_to</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CdbPathLocus_MakeNull</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>inner</name><operator>.</operator><name>move_to</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>cdbpathlocus_is_valid</name><argument_list>(<argument><expr><name><name>outer</name><operator>.</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>cdbpathlocus_is_valid</name><argument_list>(<argument><expr><name><name>inner</name><operator>.</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Does the join quals contain references to outer query? If so, we must
	 * evaluate them in the outer query's locus. That means pulling both
	 * inputs to outer locus, and performing the join there.
	 *
	 * XXX: If there are pseudoconstant quals, they will be executed by a
	 * gating Result with a One-Time Filter. In that case, the join's inputs
	 * wouldn't need to be brought to the outer locus. We could execute the
	 * join normally, and bring the result to the outer locus and put the
	 * gating Result above the Motion, instead. But for now, we're not smart
	 * like that.
	 */</comment>
	<expr_stmt><expr><name>join_quals_contain_outer_references</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>restrict_clauses</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>rinfo</name> <init>= <expr><operator>(</operator><name>RestrictInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>rinfo</name><operator>-&gt;</operator><name>contain_outer_query_references</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>join_quals_contain_outer_references</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * Locus type Replicated can only be generated by join operation.
	 * And in the function cdbpathlocus_join there is a rule:
	 * &lt;any locus type&gt; join &lt;Replicated&gt; =&gt; any locus type
	 * Proof by contradiction, it shows that when code arrives here,
	 * is is impossible that any of the two input paths' locus
	 * is Replicated. So we add two asserts here.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>CdbPathLocus_IsReplicated</name><argument_list>(<argument><expr><name><name>outer</name><operator>.</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>CdbPathLocus_IsReplicated</name><argument_list>(<argument><expr><name><name>inner</name><operator>.</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>CdbPathLocus_IsReplicated</name><argument_list>(<argument><expr><name><name>outer</name><operator>.</operator><name>locus</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
		<call><name>CdbPathLocus_IsReplicated</name><argument_list>(<argument><expr><name><name>inner</name><operator>.</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>fail</name>;</goto></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>outer</name><operator>.</operator><name>has_wts</name></name> <operator>=</operator> <call><name>cdbpath_contains_wts</name><argument_list>(<argument><expr><name><name>outer</name><operator>.</operator><name>path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>inner</name><operator>.</operator><name>has_wts</name></name> <operator>=</operator> <call><name>cdbpath_contains_wts</name><argument_list>(<argument><expr><name><name>inner</name><operator>.</operator><name>path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* For now, inner path should not contain WorkTableScan */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>inner</name><operator>.</operator><name>has_wts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If outer rel contains WorkTableScan and inner rel is hash distributed,
	 * unfortunately we have to pretend that inner is randomly distributed,
	 * otherwise we may end up with redistributing outer rel.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>outer</name><operator>.</operator><name>has_wts</name></name> <operator>&amp;&amp;</operator> <name><name>inner</name><operator>.</operator><name>locus</name><operator>.</operator><name>distkey</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>CdbPathLocus_MakeStrewn</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>inner</name><operator>.</operator><name>locus</name></name></expr></argument>,
								<argument><expr><call><name>CdbPathLocus_NumSegments</name><argument_list>(<argument><expr><name><name>inner</name><operator>.</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Caller can specify an ordering for each source path that is the same as
	 * or weaker than the path's existing ordering. Caller may insist that we
	 * do not add motion that would lose the specified ordering property;
	 * otherwise the given ordering is preferred but not required. A required
	 * NIL ordering means no motion is allowed for that path.
	 */</comment>
	<expr_stmt><expr><name><name>outer</name><operator>.</operator><name>require_existing_order</name></name> <operator>=</operator> <name>outer_require_existing_order</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>inner</name><operator>.</operator><name>require_existing_order</name></name> <operator>=</operator> <name>inner_require_existing_order</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Don't consider replicating the preserved rel of an outer join, or the
	 * current-query rel of a join between current query and subquery.
	 *
	 * Path that contains WorkTableScan cannot be replicated.
	 */</comment>
	<comment type="block">/* ok_to_replicate means broadcast */</comment>
	<expr_stmt><expr><name><name>outer</name><operator>.</operator><name>ok_to_replicate</name></name> <operator>=</operator> <operator>!</operator><name><name>outer</name><operator>.</operator><name>has_wts</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>inner</name><operator>.</operator><name>ok_to_replicate</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<switch>switch <condition>(<expr><name>jointype</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>JOIN_INNER</name></expr>:</case>
		<case>case <expr><name>JOIN_UNIQUE_OUTER</name></expr>:</case>
		<case>case <expr><name>JOIN_UNIQUE_INNER</name></expr>:</case>
			<break>break;</break>
		<case>case <expr><name>JOIN_SEMI</name></expr>:</case>
		<case>case <expr><name>JOIN_ANTI</name></expr>:</case>
		<case>case <expr><name>JOIN_LEFT</name></expr>:</case>
		<case>case <expr><name>JOIN_LASJ_NOTIN</name></expr>:</case>
			<expr_stmt><expr><name><name>outer</name><operator>.</operator><name>ok_to_replicate</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>JOIN_RIGHT</name></expr>:</case>
			<expr_stmt><expr><name><name>inner</name><operator>.</operator><name>ok_to_replicate</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>JOIN_FULL</name></expr>:</case>
			<expr_stmt><expr><name><name>outer</name><operator>.</operator><name>ok_to_replicate</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>inner</name><operator>.</operator><name>ok_to_replicate</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>JOIN_DEDUP_SEMI</name></expr>:</case>

			<comment type="block">/*
			 * In this plan type, we generate a unique row ID on the outer
			 * side of the join, perform the join, possibly broadcasting the
			 * outer side, and remove duplicates after the join, so that only
			 * one row for each input outer row remains.
			 *
			 * If the outer input is General or SegmentGeneral, it's available
			 * in all the segments, but we cannot reliably generate a row ID
			 * to distinguish each logical row in that case. So force the
			 * input to a single node first in that case.
			 *
			 * In previous Greenplum versions, we assumed that we can generate
			 * a unique row ID for General paths, by generating the same
			 * sequence of numbers on each segment. That works as long as the
			 * rows are in the same order on each segment, but it seemed like
			 * a risky assumption. And it didn't work on SegmentGeneral paths
			 * (i.e. replicated tables) anyway.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CdbPathLocus_IsPartitioned</name><argument_list>(<argument><expr><name><name>inner</name><operator>.</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<goto>goto <name>fail</name>;</goto></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>CdbPathLocus_IsPartitioned</name><argument_list>(<argument><expr><name><name>outer</name><operator>.</operator><name>locus</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
				<call><name>CdbPathLocus_IsBottleneck</name><argument_list>(<argument><expr><name><name>outer</name><operator>.</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* ok */</comment>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><call><name>CdbPathLocus_IsGeneral</name><argument_list>(<argument><expr><name><name>outer</name><operator>.</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>CdbPathLocus_MakeSingleQE</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>outer</name><operator>.</operator><name>locus</name></name></expr></argument>,
										  <argument><expr><call><name>CdbPathLocus_NumSegments</name><argument_list>(<argument><expr><name><name>inner</name><operator>.</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>outer</name><operator>.</operator><name>path</name><operator>-&gt;</operator><name>locus</name></name> <operator>=</operator> <name><name>outer</name><operator>.</operator><name>locus</name></name></expr>;</expr_stmt>

			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><call><name>CdbPathLocus_IsSegmentGeneral</name><argument_list>(<argument><expr><name><name>outer</name><operator>.</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>CdbPathLocus_MakeSingleQE</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>outer</name><operator>.</operator><name>locus</name></name></expr></argument>,
										  <argument><expr><call><name>CdbPathLocus_CommonSegments</name><argument_list>(<argument><expr><name><name>inner</name><operator>.</operator><name>locus</name></name></expr></argument>,
																	  <argument><expr><name><name>outer</name><operator>.</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>outer</name><operator>.</operator><name>path</name><operator>-&gt;</operator><name>locus</name></name> <operator>=</operator> <name><name>outer</name><operator>.</operator><name>locus</name></name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<goto>goto <name>fail</name>;</goto></block_content></block></else></if_stmt>
			<expr_stmt><expr><name><name>inner</name><operator>.</operator><name>ok_to_replicate</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>outer</name><operator>.</operator><name>path</name></name> <operator>=</operator> <call><name>add_rowid_to_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>outer</name><operator>.</operator><name>path</name></name></expr></argument>, <argument><expr><name>p_rowidexpr_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>p_outer_path</name> <operator>=</operator> <name><name>outer</name><operator>.</operator><name>path</name></name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>JOIN_DEDUP_SEMI_REVERSE</name></expr>:</case>
			<comment type="block">/* same as JOIN_DEDUP_SEMI, but with inner and outer reversed */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CdbPathLocus_IsPartitioned</name><argument_list>(<argument><expr><name><name>outer</name><operator>.</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<goto>goto <name>fail</name>;</goto></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>CdbPathLocus_IsPartitioned</name><argument_list>(<argument><expr><name><name>inner</name><operator>.</operator><name>locus</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
				<call><name>CdbPathLocus_IsBottleneck</name><argument_list>(<argument><expr><name><name>inner</name><operator>.</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* ok */</comment>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><call><name>CdbPathLocus_IsGeneral</name><argument_list>(<argument><expr><name><name>inner</name><operator>.</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>CdbPathLocus_MakeSingleQE</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>inner</name><operator>.</operator><name>locus</name></name></expr></argument>,
										  <argument><expr><call><name>CdbPathLocus_NumSegments</name><argument_list>(<argument><expr><name><name>outer</name><operator>.</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>inner</name><operator>.</operator><name>path</name><operator>-&gt;</operator><name>locus</name></name> <operator>=</operator> <name><name>inner</name><operator>.</operator><name>locus</name></name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><call><name>CdbPathLocus_IsSegmentGeneral</name><argument_list>(<argument><expr><name><name>inner</name><operator>.</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>CdbPathLocus_MakeSingleQE</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>inner</name><operator>.</operator><name>locus</name></name></expr></argument>,
										  <argument><expr><call><name>CdbPathLocus_CommonSegments</name><argument_list>(<argument><expr><name><name>outer</name><operator>.</operator><name>locus</name></name></expr></argument>,
																	  <argument><expr><name><name>inner</name><operator>.</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>inner</name><operator>.</operator><name>path</name><operator>-&gt;</operator><name>locus</name></name> <operator>=</operator> <name><name>inner</name><operator>.</operator><name>locus</name></name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<goto>goto <name>fail</name>;</goto></block_content></block></else></if_stmt>
			<expr_stmt><expr><name><name>outer</name><operator>.</operator><name>ok_to_replicate</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>inner</name><operator>.</operator><name>path</name></name> <operator>=</operator> <call><name>add_rowid_to_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>inner</name><operator>.</operator><name>path</name></name></expr></argument>, <argument><expr><name>p_rowidexpr_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>p_inner_path</name> <operator>=</operator> <name><name>inner</name><operator>.</operator><name>path</name></name></expr>;</expr_stmt>
			<break>break;</break>

		<default>default:</default>

			<comment type="block">/*
			 * The caller should already have transformed
			 * JOIN_UNIQUE_INNER/OUTER into JOIN_INNER
			 */</comment>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected join type %d"</literal></expr></argument>, <argument><expr><name>jointype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>

	<comment type="block">/* Get rel sizes. */</comment>
	<expr_stmt><expr><name><name>outer</name><operator>.</operator><name>bytes</name></name> <operator>=</operator> <name><name>outer</name><operator>.</operator><name>path</name><operator>-&gt;</operator><name>rows</name></name> <operator>*</operator> <name><name>outer</name><operator>.</operator><name>path</name><operator>-&gt;</operator><name>pathtarget</name><operator>-&gt;</operator><name>width</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>inner</name><operator>.</operator><name>bytes</name></name> <operator>=</operator> <name><name>inner</name><operator>.</operator><name>path</name><operator>-&gt;</operator><name>rows</name></name> <operator>*</operator> <name><name>inner</name><operator>.</operator><name>path</name><operator>-&gt;</operator><name>pathtarget</name><operator>-&gt;</operator><name>width</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>join_quals_contain_outer_references</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>CdbPathLocus_IsOuterQuery</name><argument_list>(<argument><expr><name><name>outer</name><operator>.</operator><name>locus</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<call><name>CdbPathLocus_IsOuterQuery</name><argument_list>(<argument><expr><name><name>inner</name><operator>.</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name><name>outer</name><operator>.</operator><name>locus</name></name></expr>;</return></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CdbPathLocus_IsOuterQuery</name><argument_list>(<argument><expr><name><name>outer</name><operator>.</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>CdbPathLocus_MakeOuterQuery</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>outer</name><operator>.</operator><name>move_to</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CdbPathLocus_IsOuterQuery</name><argument_list>(<argument><expr><name><name>inner</name><operator>.</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>CdbPathLocus_MakeOuterQuery</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>inner</name><operator>.</operator><name>move_to</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>CdbPathLocus_IsOuterQuery</name><argument_list>(<argument><expr><name><name>outer</name><operator>.</operator><name>locus</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
			 <call><name>CdbPathLocus_IsOuterQuery</name><argument_list>(<argument><expr><name><name>inner</name><operator>.</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * If one side of the join has "outer query" locus, must bring the
		 * other side there too.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>CdbPathLocus_IsOuterQuery</name><argument_list>(<argument><expr><name><name>outer</name><operator>.</operator><name>locus</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<call><name>CdbPathLocus_IsOuterQuery</name><argument_list>(<argument><expr><name><name>inner</name><operator>.</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name><name>outer</name><operator>.</operator><name>locus</name></name></expr>;</return></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>CdbPathLocus_IsOuterQuery</name><argument_list>(<argument><expr><name><name>outer</name><operator>.</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>inner</name><operator>.</operator><name>move_to</name></name> <operator>=</operator> <name><name>outer</name><operator>.</operator><name>locus</name></name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>outer</name><operator>.</operator><name>move_to</name></name> <operator>=</operator> <name><name>inner</name><operator>.</operator><name>locus</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>CdbPathLocus_IsGeneral</name><argument_list>(<argument><expr><name><name>outer</name><operator>.</operator><name>locus</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
			 <call><name>CdbPathLocus_IsGeneral</name><argument_list>(<argument><expr><name><name>inner</name><operator>.</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Motion not needed if either source is everywhere (e.g. a constant).
		 *
		 * But if a row is everywhere and is preserved in an outer join, we don't
		 * want to preserve it in every qExec process where it is unmatched,
		 * because that would produce duplicate null-augmented rows. So in that
		 * case, bring all the partitions to a single qExec to be joined. CDB
		 * TODO: Can this case be handled without introducing a bottleneck?
		 */</comment>
		<comment type="block">/*
		 * The logic for the join result's locus is (outer's locus is general):
		 *   1. if outer is ok to replicated, then result's locus is the same
		 *      as inner's locus
		 *   2. if outer is not ok to replicated (like left join or wts cases)
		 *      2.1 if inner's locus is hashed or hashOJ, we try to redistribute
		 *          outer as the inner, if fails, make inner singleQE
		 *      2.2 if inner's locus is strewn, we try to redistribute
		 *          outer and inner, if fails, make inner singleQE
		 *      2.3 just return the inner's locus, no motion is needed
		 */</comment>
		<decl_stmt><decl><type><name>CdbpathMfjRel</name> <modifier>*</modifier></type><name>general</name> <init>= <expr><operator>&amp;</operator><name>outer</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>CdbpathMfjRel</name> <modifier>*</modifier></type><name>other</name> <init>= <expr><operator>&amp;</operator><name>inner</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * both are general, the result is general
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>CdbPathLocus_IsGeneral</name><argument_list>(<argument><expr><name><name>outer</name><operator>.</operator><name>locus</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<call><name>CdbPathLocus_IsGeneral</name><argument_list>(<argument><expr><name><name>inner</name><operator>.</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name><name>outer</name><operator>.</operator><name>locus</name></name></expr>;</return></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>CdbPathLocus_IsGeneral</name><argument_list>(<argument><expr><name><name>inner</name><operator>.</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>general</name> <operator>=</operator> <operator>&amp;</operator><name>inner</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>other</name> <operator>=</operator> <operator>&amp;</operator><name>outer</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* numsegments of General locus is always -1 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>CdbPathLocus_NumSegments</name><argument_list>(<argument><expr><name><name>general</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If general can happen everywhere (ok_to_replicate)
		 * then it acts like identity: 
		 *     General join other_locus =&gt; other_locus
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>general</name><operator>-&gt;</operator><name>ok_to_replicate</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name><name>other</name><operator>-&gt;</operator><name>locus</name></name></expr>;</return></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CdbPathLocus_IsPartitioned</name><argument_list>(<argument><expr><name><name>other</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * If general is not ok_to_replicate, for example,
			 * generate_series(1, 10) left join xxxx, only for
			 * some specific locus types general can act as
			 * identity:
			 *    General join other_locus =&gt; other_locus, if and only if
			 *    other_locus in (singleQE, Entry).
			 * Here other's locus:
			 *    - cannot be general (it has already handled)
			 *    - cannot be replicated (assert at the beginning of the function)
			 */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>CdbPathLocus_IsBottleneck</name><argument_list>(<argument><expr><name><name>other</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
				   <call><name>CdbPathLocus_IsSegmentGeneral</name><argument_list>(<argument><expr><name><name>other</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name><name>other</name><operator>-&gt;</operator><name>locus</name></name></expr>;</return>
		</block_content>}</block></if>
		<comment type="block">/*
		 * If other's locus is partitioned, we first try to
		 * add redistribute motion, if fails, we gather other
		 * to singleQE.
		 */</comment>
		<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>try_redistribute</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>general</name></expr></argument>, <argument><expr><name>other</name></expr></argument>, <argument><expr><name>redistribution_clauses</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * FIXME: do we need test other's movable?
			 */</comment>
			<expr_stmt><expr><call><name>CdbPathLocus_MakeSingleQE</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>other</name><operator>-&gt;</operator><name>move_to</name></name></expr></argument>,
									  <argument><expr><call><name>CdbPathLocus_NumSegments</name><argument_list>(<argument><expr><name><name>other</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>CdbPathLocus_IsSegmentGeneral</name><argument_list>(<argument><expr><name><name>outer</name><operator>.</operator><name>locus</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
			 <call><name>CdbPathLocus_IsSegmentGeneral</name><argument_list>(<argument><expr><name><name>inner</name><operator>.</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * the whole branch handles the case that at least
		 * one of the two locus is SegmentGeneral. The logic
		 * is:
		 *   - if both are SegmentGeneral:
		 *       1. if both locus are equal, no motion needed, simply return
		 *       2. For update cases. If resultrelation
		 *          is SegmentGeneral, the update must execute
		 *          on each segment of the resultrelation, if resultrelation's
		 *          numsegments is larger, the only solution is to broadcast
		 *          other
		 *       3. no motion is needed, change both numsegments to common
		 *   - if only one of them is SegmentGeneral :
		 *       1. consider update case, if resultrelation is SegmentGeneral,
		 *          the only solution is to broadcast the other
		 *       2. if other's locus is singleQE or entry, make SegmentGeneral
		 *          to other's locus
		 *       3. the remaining possibility of other's locus is partitioned
		 *          3.1 if SegmentGeneral is not ok_to_replicate, try to
		 *              add redistribute motion, if fails gather each to
		 *              singleQE
		 *          3.2 if SegmentGeneral's numsegments is larger, just return
		 *              other's locus
		 *          3.3 try to add redistribute motion, if fails, gather each
		 *              to singleQE
		 */</comment>
		<decl_stmt><decl><type><name>CdbpathMfjRel</name> <modifier>*</modifier></type><name>segGeneral</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>CdbpathMfjRel</name> <modifier>*</modifier></type><name>other</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>CdbPathLocus_IsSegmentGeneral</name><argument_list>(<argument><expr><name><name>outer</name><operator>.</operator><name>locus</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<call><name>CdbPathLocus_IsSegmentGeneral</name><argument_list>(<argument><expr><name><name>inner</name><operator>.</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * use_common to indicate whether we should
			 * return a segmentgeneral locus with common
			 * numsegments.
			 */</comment>
			<decl_stmt><decl><type><name>bool</name></type> <name>use_common</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
			<comment type="block">/*
			 * Handle the case two same locus
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>CdbPathLocus_NumSegments</name><argument_list>(<argument><expr><name><name>outer</name><operator>.</operator><name>locus</name></name></expr></argument>)</argument_list></call> <operator>==</operator>
				<call><name>CdbPathLocus_NumSegments</name><argument_list>(<argument><expr><name><name>inner</name><operator>.</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name><name>inner</name><operator>.</operator><name>locus</name></name></expr>;</return></block_content></block></if></if_stmt>
			<comment type="block">/*
			 * Now, two locus' numsegments not equal
			 * We should consider update resultrelation
			 * if update,
			 *   - resultrelation's numsegments larger, then
			 *     we should broadcast the other
			 *   - otherwise, results is common
			 * else:
			 *   common
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>root</name><operator>-&gt;</operator><name>upd_del_replicated_table</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>CdbPathLocus_NumSegments</name><argument_list>(<argument><expr><name><name>outer</name><operator>.</operator><name>locus</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator>
					 <call><name>CdbPathLocus_NumSegments</name><argument_list>(<argument><expr><name><name>inner</name><operator>.</operator><name>locus</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator>
					<call><name>bms_is_member</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>upd_del_replicated_table</name></name></expr></argument>,
								  <argument><expr><name><name>outer</name><operator>.</operator><name>path</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					 * the updated resultrelation is replicated table
					 * and its numsegments is larger, we should broadcast
					 * the other path
					 */</comment>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>inner</name><operator>.</operator><name>ok_to_replicate</name></name></expr>)</condition><block type="pseudo"><block_content>
						<goto>goto <name>fail</name>;</goto></block_content></block></if></if_stmt>

					<comment type="block">/*
					 * FIXME: do we need to test inner's movable?
					 */</comment>
					<expr_stmt><expr><call><name>CdbPathLocus_MakeReplicated</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>inner</name><operator>.</operator><name>move_to</name></name></expr></argument>,
												<argument><expr><call><name>CdbPathLocus_NumSegments</name><argument_list>(<argument><expr><name><name>outer</name><operator>.</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>use_common</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><operator>(</operator><call><name>CdbPathLocus_NumSegments</name><argument_list>(<argument><expr><name><name>outer</name><operator>.</operator><name>locus</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator>
						  <call><name>CdbPathLocus_NumSegments</name><argument_list>(<argument><expr><name><name>inner</name><operator>.</operator><name>locus</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator>
						 <call><name>bms_is_member</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>upd_del_replicated_table</name></name></expr></argument>,
									   <argument><expr><name><name>inner</name><operator>.</operator><name>path</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					 * the updated resultrelation is replicated table
					 * and its numsegments is larger, we should broadcast
					 * the other path
					 */</comment>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>outer</name><operator>.</operator><name>ok_to_replicate</name></name></expr>)</condition><block type="pseudo"><block_content>
						<goto>goto <name>fail</name>;</goto></block_content></block></if></if_stmt>

					<comment type="block">/*
					 * FIXME: do we need to test outer's movable?
					 */</comment>
					<expr_stmt><expr><call><name>CdbPathLocus_MakeReplicated</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>outer</name><operator>.</operator><name>move_to</name></name></expr></argument>,
												<argument><expr><call><name>CdbPathLocus_NumSegments</name><argument_list>(<argument><expr><name><name>inner</name><operator>.</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>use_common</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
			
			<if_stmt><if>if <condition>(<expr><name>use_common</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * The statement is not update a replicated table.
				 * Just return the segmentgeneral with a smaller numsegments.
				 */</comment>
				<expr_stmt><expr><name>numsegments</name> <operator>=</operator> <call><name>CdbPathLocus_CommonSegments</name><argument_list>(<argument><expr><name><name>inner</name><operator>.</operator><name>locus</name></name></expr></argument>,
														  <argument><expr><name><name>outer</name><operator>.</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>outer</name><operator>.</operator><name>locus</name><operator>.</operator><name>numsegments</name></name> <operator>=</operator> <name>numsegments</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>inner</name><operator>.</operator><name>locus</name><operator>.</operator><name>numsegments</name></name> <operator>=</operator> <name>numsegments</name></expr>;</expr_stmt>

				<return>return <expr><name><name>inner</name><operator>.</operator><name>locus</name></name></expr>;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>CdbPathLocus_IsSegmentGeneral</name><argument_list>(<argument><expr><name><name>outer</name><operator>.</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>segGeneral</name> <operator>=</operator> <operator>&amp;</operator><name>outer</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>other</name> <operator>=</operator> <operator>&amp;</operator><name>inner</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><name>segGeneral</name> <operator>=</operator> <operator>&amp;</operator><name>inner</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>other</name> <operator>=</operator> <operator>&amp;</operator><name>outer</name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>CdbPathLocus_IsBottleneck</name><argument_list>(<argument><expr><name><name>other</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
				   <call><name>CdbPathLocus_IsPartitioned</name><argument_list>(<argument><expr><name><name>other</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			
			<comment type="block">/*
			 * For UPDATE/DELETE, replicated table can't guarantee a logic row has
			 * same ctid or item pointer on each copy. If we broadcast matched tuples
			 * to all segments, the segments may update the wrong tuples or can't
			 * find a valid tuple according to ctid or item pointer.
			 *
			 * So For UPDATE/DELETE on replicated table, we broadcast other path so
			 * all target tuples can be selected on all copys and then be updated
			 * locally.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>root</name><operator>-&gt;</operator><name>upd_del_replicated_table</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
				<call><name>bms_is_member</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>upd_del_replicated_table</name></name></expr></argument>,
							  <argument><expr><name><name>segGeneral</name><operator>-&gt;</operator><name>path</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * For UPDATE on a replicated table, we have to do it
				 * everywhere so that for each segment, we have to collect
				 * all the information of other that is we should broadcast it
				 */</comment>
				
				<comment type="block">/*
				 * FIXME: do we need to test other's movable?
				 */</comment>
				<expr_stmt><expr><call><name>CdbPathLocus_MakeReplicated</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>other</name><operator>-&gt;</operator><name>move_to</name></name></expr></argument>,
											<argument><expr><call><name>CdbPathLocus_NumSegments</name><argument_list>(<argument><expr><name><name>segGeneral</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><call><name>CdbPathLocus_IsBottleneck</name><argument_list>(<argument><expr><name><name>other</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * if the locus type is equal and segment count is unequal,
				 * we will dispatch the one on more segments to the other
				 */</comment>
				<expr_stmt><expr><name>numsegments</name> <operator>=</operator> <call><name>CdbPathLocus_CommonSegments</name><argument_list>(<argument><expr><name><name>segGeneral</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>,
														  <argument><expr><name><name>other</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>segGeneral</name><operator>-&gt;</operator><name>move_to</name></name> <operator>=</operator> <name><name>other</name><operator>-&gt;</operator><name>locus</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>segGeneral</name><operator>-&gt;</operator><name>move_to</name><operator>.</operator><name>numsegments</name></name> <operator>=</operator> <name>numsegments</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/*
				 * This branch handles for partitioned other locus
				 * hashed, hashoj, strewn
				 */</comment>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>CdbPathLocus_IsPartitioned</name><argument_list>(<argument><expr><name><name>other</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>segGeneral</name><operator>-&gt;</operator><name>ok_to_replicate</name></name></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>try_redistribute</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>segGeneral</name></expr></argument>,
										  <argument><expr><name>other</name></expr></argument>, <argument><expr><name>redistribution_clauses</name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/*
						 * FIXME: do we need to test movable?
						 */</comment>
						<expr_stmt><expr><call><name>CdbPathLocus_MakeSingleQE</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>segGeneral</name><operator>-&gt;</operator><name>move_to</name></name></expr></argument>,
												  <argument><expr><call><name>CdbPathLocus_NumSegments</name><argument_list>(<argument><expr><name><name>segGeneral</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>CdbPathLocus_MakeSingleQE</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>other</name><operator>-&gt;</operator><name>move_to</name></name></expr></argument>,
												  <argument><expr><call><name>CdbPathLocus_NumSegments</name><argument_list>(<argument><expr><name><name>other</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<comment type="block">/*
					 * If all other's segments have segGeneral stored, then no motion
					 * is needed.
					 *
					 * A sql to reach here:
					 *     select * from d2 a join r1 b using (c1);
					 * where d2 is a replicated table on 2 segment,
					 *       r1 is a random table on 1 segments.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><call><name>CdbPathLocus_NumSegments</name><argument_list>(<argument><expr><name><name>segGeneral</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>)</argument_list></call> <operator>&gt;=</operator>
						<call><name>CdbPathLocus_NumSegments</name><argument_list>(<argument><expr><name><name>other</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><name><name>other</name><operator>-&gt;</operator><name>locus</name></name></expr>;</return></block_content></block></if>
					<else>else
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>try_redistribute</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>segGeneral</name></expr></argument>,
											  <argument><expr><name>other</name></expr></argument>, <argument><expr><name>redistribution_clauses</name></expr></argument>)</argument_list></call></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><name>numsegments</name> <operator>=</operator> <call><name>CdbPathLocus_CommonSegments</name><argument_list>(<argument><expr><name><name>segGeneral</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>,
																	  <argument><expr><name><name>other</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<comment type="block">/*
							 * FIXME: do we need to test movable?
							 */</comment>
							<expr_stmt><expr><call><name>CdbPathLocus_MakeSingleQE</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>segGeneral</name><operator>-&gt;</operator><name>move_to</name></name></expr></argument>, <argument><expr><name>numsegments</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><call><name>CdbPathLocus_MakeSingleQE</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>other</name><operator>-&gt;</operator><name>move_to</name></name></expr></argument>, <argument><expr><name>numsegments</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						</block_content>}</block></if></if_stmt>
					</block_content>}</block></else></if_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if>
	<comment type="block">/*
	 * Is either source confined to a single process? NB: Motion to a single
	 * process (qDisp or qExec) is the only motion in which we may use Merge
	 * Receive to preserve an existing ordering.
	 */</comment>
	<if type="elseif">else if <condition>(<expr><call><name>CdbPathLocus_IsBottleneck</name><argument_list>(<argument><expr><name><name>outer</name><operator>.</operator><name>locus</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
			 <call><name>CdbPathLocus_IsBottleneck</name><argument_list>(<argument><expr><name><name>inner</name><operator>.</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>							<comment type="block">/* singleQE or entry db */</comment>
		<decl_stmt><decl><type><name>CdbpathMfjRel</name> <modifier>*</modifier></type><name>single</name> <init>= <expr><operator>&amp;</operator><name>outer</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>CdbpathMfjRel</name> <modifier>*</modifier></type><name>other</name> <init>= <expr><operator>&amp;</operator><name>inner</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>single_immovable</name> <init>= <expr><operator>(</operator><name><name>outer</name><operator>.</operator><name>require_existing_order</name></name> <operator>&amp;&amp;</operator>
										<operator>!</operator><name>outer_pathkeys</name><operator>)</operator> <operator>||</operator> <name><name>outer</name><operator>.</operator><name>has_wts</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>other_immovable</name> <init>= <expr><name><name>inner</name><operator>.</operator><name>require_existing_order</name></name> <operator>&amp;&amp;</operator>
		<operator>!</operator><name>inner_pathkeys</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * If each of the sources has a single-process locus, then assign both
		 * sources and the join to run in the same process, without motion.
		 * The slice will be run on the entry db if either source requires it.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>CdbPathLocus_IsEntry</name><argument_list>(<argument><expr><name><name>single</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>CdbPathLocus_IsBottleneck</name><argument_list>(<argument><expr><name><name>other</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name><name>single</name><operator>-&gt;</operator><name>locus</name></name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>CdbPathLocus_IsSingleQE</name><argument_list>(<argument><expr><name><name>single</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>CdbPathLocus_IsBottleneck</name><argument_list>(<argument><expr><name><name>other</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * Can join directly on one of the common segments.
				 */</comment>
				<expr_stmt><expr><name>numsegments</name> <operator>=</operator> <call><name>CdbPathLocus_CommonSegments</name><argument_list>(<argument><expr><name><name>outer</name><operator>.</operator><name>locus</name></name></expr></argument>,
														  <argument><expr><name><name>inner</name><operator>.</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name><name>other</name><operator>-&gt;</operator><name>locus</name><operator>.</operator><name>numsegments</name></name> <operator>=</operator> <name>numsegments</name></expr>;</expr_stmt>
				<return>return <expr><name><name>other</name><operator>-&gt;</operator><name>locus</name></name></expr>;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>

		<comment type="block">/* Let 'single' be the source whose locus is singleQE or entry. */</comment>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>CdbSwap</name><argument_list>(<argument><expr><name>CdbpathMfjRel</name> <operator>*</operator></expr></argument>, <argument><expr><name>single</name></expr></argument>, <argument><expr><name>other</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>CdbSwap</name><argument_list>(<argument><expr><name>bool</name></expr></argument>, <argument><expr><name>single_immovable</name></expr></argument>, <argument><expr><name>other_immovable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>CdbPathLocus_IsBottleneck</name><argument_list>(<argument><expr><name><name>single</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>CdbPathLocus_IsPartitioned</name><argument_list>(<argument><expr><name><name>other</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* If the bottlenecked rel can't be moved, bring the other rel to it. */</comment>
		<if_stmt><if>if <condition>(<expr><name>single_immovable</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>other_immovable</name></expr>)</condition><block type="pseudo"><block_content>
				<goto>goto <name>fail</name>;</goto></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>other</name><operator>-&gt;</operator><name>move_to</name></name> <operator>=</operator> <name><name>single</name><operator>-&gt;</operator><name>locus</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if>

		<comment type="block">/* Redistribute single rel if joining on other rel's partitioning key */</comment>
		<if type="elseif">else if <condition>(<expr><call><name>cdbpath_match_preds_to_distkey</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
												<argument><expr><name>redistribution_clauses</name></expr></argument>,
												<argument><expr><name><name>other</name><operator>-&gt;</operator><name>path</name></name></expr></argument>,
												<argument><expr><name><name>other</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>,
												<argument><expr><operator>&amp;</operator><name><name>single</name><operator>-&gt;</operator><name>move_to</name></name></expr></argument>)</argument_list></call></expr>)</condition>	<comment type="block">/* OUT */</comment>
		<block>{<block_content>
			<expr_stmt><expr><call><name>AssertEquivalent</name><argument_list>(<argument><expr><call><name>CdbPathLocus_NumSegments</name><argument_list>(<argument><expr><name><name>other</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr></argument>,
							 <argument><expr><call><name>CdbPathLocus_NumSegments</name><argument_list>(<argument><expr><name><name>single</name><operator>-&gt;</operator><name>move_to</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>

		<comment type="block">/* Replicate single rel if cheaper than redistributing both rels. */</comment>
		<if type="elseif">else if <condition>(<expr><name><name>single</name><operator>-&gt;</operator><name>ok_to_replicate</name></name> <operator>&amp;&amp;</operator>
				 <operator>(</operator><name><name>single</name><operator>-&gt;</operator><name>bytes</name></name> <operator>*</operator> <call><name>CdbPathLocus_NumSegments</name><argument_list>(<argument><expr><name><name>other</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator>
				  <name><name>single</name><operator>-&gt;</operator><name>bytes</name></name> <operator>+</operator> <name><name>other</name><operator>-&gt;</operator><name>bytes</name></name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>CdbPathLocus_MakeReplicated</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>single</name><operator>-&gt;</operator><name>move_to</name></name></expr></argument>,
										<argument><expr><call><name>CdbPathLocus_NumSegments</name><argument_list>(<argument><expr><name><name>other</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

		<comment type="block">/*
		 * Redistribute both rels on equijoin cols.
		 *
		 * Redistribute both to the same segments, here we choose the
		 * same segments with other.
		 */</comment>
		<if type="elseif">else if <condition>(<expr><operator>!</operator><name>other_immovable</name> <operator>&amp;&amp;</operator>
				 <call><name>cdbpath_distkeys_from_preds</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
											 <argument><expr><name>redistribution_clauses</name></expr></argument>,
											 <argument><expr><name><name>single</name><operator>-&gt;</operator><name>path</name></name></expr></argument>,
											 <argument><expr><call><name>CdbPathLocus_NumSegments</name><argument_list>(<argument><expr><name><name>other</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr></argument>,
											 <argument><expr><operator>&amp;</operator><name><name>single</name><operator>-&gt;</operator><name>move_to</name></name></expr></argument>,	<comment type="block">/* OUT */</comment>
											 <argument><expr><operator>&amp;</operator><name><name>other</name><operator>-&gt;</operator><name>move_to</name></name></expr></argument>)</argument_list></call></expr>)</condition>	<comment type="block">/* OUT */</comment>
		<block>{<block_content>
			<comment type="block">/* ok */</comment>
		</block_content>}</block></if>

		<comment type="block">/* Broadcast single rel for below cases. */</comment>
		<if type="elseif">else if <condition>(<expr><name><name>single</name><operator>-&gt;</operator><name>ok_to_replicate</name></name> <operator>&amp;&amp;</operator>
				 <operator>(</operator><name>other_immovable</name> <operator>||</operator>
				  <name><name>single</name><operator>-&gt;</operator><name>bytes</name></name> <operator>&lt;</operator> <name><name>other</name><operator>-&gt;</operator><name>bytes</name></name> <operator>||</operator>
				  <name><name>other</name><operator>-&gt;</operator><name>has_wts</name></name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>CdbPathLocus_MakeReplicated</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>single</name><operator>-&gt;</operator><name>move_to</name></name></expr></argument>,
										<argument><expr><call><name>CdbPathLocus_NumSegments</name><argument_list>(<argument><expr><name><name>other</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

		<comment type="block">/* Last resort: If possible, move all partitions of other rel to single QE. */</comment>
		<if type="elseif">else if <condition>(<expr><operator>!</operator><name>other_immovable</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>other</name><operator>-&gt;</operator><name>move_to</name></name> <operator>=</operator> <name><name>single</name><operator>-&gt;</operator><name>locus</name></name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<goto>goto <name>fail</name>;</goto></block_content></block></else></if_stmt>
	</block_content>}</block></if>							<comment type="block">/* singleQE or entry */</comment>

	<comment type="block">/*
	 * No motion if partitioned alike and joining on the partitioning keys.
	 */</comment>
	<if type="elseif">else if <condition>(<expr><call><name>cdbpath_match_preds_to_both_distkeys</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>redistribution_clauses</name></expr></argument>,
												  <argument><expr><name><name>outer</name><operator>.</operator><name>locus</name></name></expr></argument>, <argument><expr><name><name>inner</name><operator>.</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>cdbpathlocus_join</name><argument_list>(<argument><expr><name>jointype</name></expr></argument>, <argument><expr><name><name>outer</name><operator>.</operator><name>locus</name></name></expr></argument>, <argument><expr><name><name>inner</name><operator>.</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>

	<comment type="block">/*
	 * Both sources are partitioned.  Redistribute or replicate one or both.
	 */</comment>
	<else>else
	<block>{<block_content>							<comment type="block">/* partitioned */</comment>
		<decl_stmt><decl><type><name>CdbpathMfjRel</name> <modifier>*</modifier></type><name>large_rel</name> <init>= <expr><operator>&amp;</operator><name>outer</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>CdbpathMfjRel</name> <modifier>*</modifier></type><name>small_rel</name> <init>= <expr><operator>&amp;</operator><name>inner</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Which rel is bigger? */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>large_rel</name><operator>-&gt;</operator><name>bytes</name></name> <operator>&lt;</operator> <name><name>small_rel</name><operator>-&gt;</operator><name>bytes</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>CdbSwap</name><argument_list>(<argument><expr><name>CdbpathMfjRel</name> <operator>*</operator></expr></argument>, <argument><expr><name>large_rel</name></expr></argument>, <argument><expr><name>small_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Both side are distribued in 1 segment, it can join without motion. */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>CdbPathLocus_NumSegments</name><argument_list>(<argument><expr><name><name>large_rel</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator>
			<call><name>CdbPathLocus_NumSegments</name><argument_list>(<argument><expr><name><name>small_rel</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name><name>large_rel</name><operator>-&gt;</operator><name>locus</name></name></expr>;</return></block_content></block></if></if_stmt>

		<comment type="block">/* If joining on larger rel's partitioning key, redistribute smaller. */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>small_rel</name><operator>-&gt;</operator><name>require_existing_order</name></name> <operator>&amp;&amp;</operator>
			<call><name>cdbpath_match_preds_to_distkey</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
										   <argument><expr><name>redistribution_clauses</name></expr></argument>,
										   <argument><expr><name><name>large_rel</name><operator>-&gt;</operator><name>path</name></name></expr></argument>,
										   <argument><expr><name><name>large_rel</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>,
										   <argument><expr><operator>&amp;</operator><name><name>small_rel</name><operator>-&gt;</operator><name>move_to</name></name></expr></argument>)</argument_list></call></expr>)</condition>	<comment type="block">/* OUT */</comment>
		<block>{<block_content>
			<expr_stmt><expr><call><name>AssertEquivalent</name><argument_list>(<argument><expr><call><name>CdbPathLocus_NumSegments</name><argument_list>(<argument><expr><name><name>large_rel</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr></argument>,
							 <argument><expr><call><name>CdbPathLocus_NumSegments</name><argument_list>(<argument><expr><name><name>small_rel</name><operator>-&gt;</operator><name>move_to</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>

		<comment type="block">/*
		 * Replicate smaller rel if cheaper than redistributing larger rel.
		 * But don't replicate a rel that is to be preserved in outer join.
		 */</comment>
		<if type="elseif">else if <condition>(<expr><operator>!</operator><name><name>small_rel</name><operator>-&gt;</operator><name>require_existing_order</name></name> <operator>&amp;&amp;</operator>
				 <name><name>small_rel</name><operator>-&gt;</operator><name>ok_to_replicate</name></name> <operator>&amp;&amp;</operator>
				 <operator>(</operator><name><name>small_rel</name><operator>-&gt;</operator><name>bytes</name></name> <operator>*</operator> <call><name>CdbPathLocus_NumSegments</name><argument_list>(<argument><expr><name><name>large_rel</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator>
				  <name><name>large_rel</name><operator>-&gt;</operator><name>bytes</name></name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>CdbPathLocus_MakeReplicated</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>small_rel</name><operator>-&gt;</operator><name>move_to</name></name></expr></argument>,
										<argument><expr><call><name>CdbPathLocus_NumSegments</name><argument_list>(<argument><expr><name><name>large_rel</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

		<comment type="block">/*
		 * Replicate larger rel if cheaper than redistributing smaller rel.
		 * But don't replicate a rel that is to be preserved in outer join.
		 */</comment>
		<if type="elseif">else if <condition>(<expr><operator>!</operator><name><name>large_rel</name><operator>-&gt;</operator><name>require_existing_order</name></name> <operator>&amp;&amp;</operator>
				 <name><name>large_rel</name><operator>-&gt;</operator><name>ok_to_replicate</name></name> <operator>&amp;&amp;</operator>
				 <operator>(</operator><name><name>large_rel</name><operator>-&gt;</operator><name>bytes</name></name> <operator>*</operator> <call><name>CdbPathLocus_NumSegments</name><argument_list>(<argument><expr><name><name>small_rel</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator>
				  <name><name>small_rel</name><operator>-&gt;</operator><name>bytes</name></name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>CdbPathLocus_MakeReplicated</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>large_rel</name><operator>-&gt;</operator><name>move_to</name></name></expr></argument>,
										<argument><expr><call><name>CdbPathLocus_NumSegments</name><argument_list>(<argument><expr><name><name>small_rel</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

		<comment type="block">/* If joining on smaller rel's partitioning key, redistribute larger. */</comment>
		<if type="elseif">else if <condition>(<expr><operator>!</operator><name><name>large_rel</name><operator>-&gt;</operator><name>require_existing_order</name></name> <operator>&amp;&amp;</operator>
				 <call><name>cdbpath_match_preds_to_distkey</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
												<argument><expr><name>redistribution_clauses</name></expr></argument>,
												<argument><expr><name><name>small_rel</name><operator>-&gt;</operator><name>path</name></name></expr></argument>,
												<argument><expr><name><name>small_rel</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>,
												<argument><expr><operator>&amp;</operator><name><name>large_rel</name><operator>-&gt;</operator><name>move_to</name></name></expr></argument>)</argument_list></call></expr>)</condition>	<comment type="block">/* OUT */</comment>
		<block>{<block_content>
			<expr_stmt><expr><call><name>AssertEquivalent</name><argument_list>(<argument><expr><call><name>CdbPathLocus_NumSegments</name><argument_list>(<argument><expr><name><name>small_rel</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr></argument>,
							 <argument><expr><call><name>CdbPathLocus_NumSegments</name><argument_list>(<argument><expr><name><name>large_rel</name><operator>-&gt;</operator><name>move_to</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>

		<comment type="block">/* Replicate smaller rel if cheaper than redistributing both rels. */</comment>
		<if type="elseif">else if <condition>(<expr><operator>!</operator><name><name>small_rel</name><operator>-&gt;</operator><name>require_existing_order</name></name> <operator>&amp;&amp;</operator>
				 <name><name>small_rel</name><operator>-&gt;</operator><name>ok_to_replicate</name></name> <operator>&amp;&amp;</operator>
				 <operator>(</operator><name><name>small_rel</name><operator>-&gt;</operator><name>bytes</name></name> <operator>*</operator> <call><name>CdbPathLocus_NumSegments</name><argument_list>(<argument><expr><name><name>large_rel</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator>
				  <name><name>small_rel</name><operator>-&gt;</operator><name>bytes</name></name> <operator>+</operator> <name><name>large_rel</name><operator>-&gt;</operator><name>bytes</name></name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>CdbPathLocus_MakeReplicated</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>small_rel</name><operator>-&gt;</operator><name>move_to</name></name></expr></argument>,
										<argument><expr><call><name>CdbPathLocus_NumSegments</name><argument_list>(<argument><expr><name><name>large_rel</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

		<comment type="block">/* Replicate largeer rel if cheaper than redistributing both rels. */</comment>
		<if type="elseif">else if <condition>(<expr><operator>!</operator><name><name>large_rel</name><operator>-&gt;</operator><name>require_existing_order</name></name> <operator>&amp;&amp;</operator>
				 <name><name>large_rel</name><operator>-&gt;</operator><name>ok_to_replicate</name></name> <operator>&amp;&amp;</operator>
				 <operator>(</operator><name><name>large_rel</name><operator>-&gt;</operator><name>bytes</name></name> <operator>*</operator> <call><name>CdbPathLocus_NumSegments</name><argument_list>(<argument><expr><name><name>small_rel</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator>
				  <name><name>large_rel</name><operator>-&gt;</operator><name>bytes</name></name> <operator>+</operator> <name><name>small_rel</name><operator>-&gt;</operator><name>bytes</name></name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>CdbPathLocus_MakeReplicated</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>large_rel</name><operator>-&gt;</operator><name>move_to</name></name></expr></argument>,
										<argument><expr><call><name>CdbPathLocus_NumSegments</name><argument_list>(<argument><expr><name><name>small_rel</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

		<comment type="block">/*
		 * Redistribute both rels on equijoin cols.
		 *
		 * the two results should all be distributed on the same segments,
		 * here we make them the same with common segments for safe
		 * TODO: how about distribute them both to ALL segments?
		 */</comment>
		<if type="elseif">else if <condition>(<expr><operator>!</operator><name><name>small_rel</name><operator>-&gt;</operator><name>require_existing_order</name></name> <operator>&amp;&amp;</operator>
				 <operator>!</operator><name><name>small_rel</name><operator>-&gt;</operator><name>has_wts</name></name> <operator>&amp;&amp;</operator>
				 <operator>!</operator><name><name>large_rel</name><operator>-&gt;</operator><name>require_existing_order</name></name> <operator>&amp;&amp;</operator>
				 <operator>!</operator><name><name>large_rel</name><operator>-&gt;</operator><name>has_wts</name></name> <operator>&amp;&amp;</operator>
				 <call><name>cdbpath_distkeys_from_preds</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
											 <argument><expr><name>redistribution_clauses</name></expr></argument>,
											 <argument><expr><name><name>large_rel</name><operator>-&gt;</operator><name>path</name></name></expr></argument>,
											 <argument><expr><call><name>CdbPathLocus_CommonSegments</name><argument_list>(<argument><expr><name><name>large_rel</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>,
																		 <argument><expr><name><name>small_rel</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr></argument>,
											 <argument><expr><operator>&amp;</operator><name><name>large_rel</name><operator>-&gt;</operator><name>move_to</name></name></expr></argument>,
											 <argument><expr><operator>&amp;</operator><name><name>small_rel</name><operator>-&gt;</operator><name>move_to</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* ok */</comment>
		</block_content>}</block></if>

		<comment type="block">/*
		 * No usable equijoin preds, or couldn't consider the preferred
		 * motion. Replicate one rel if possible. MPP TODO: Consider number of
		 * seg dbs per host.
		 */</comment>
		<if type="elseif">else if <condition>(<expr><operator>!</operator><name><name>small_rel</name><operator>-&gt;</operator><name>require_existing_order</name></name> <operator>&amp;&amp;</operator>
				 <name><name>small_rel</name><operator>-&gt;</operator><name>ok_to_replicate</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>CdbPathLocus_MakeReplicated</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>small_rel</name><operator>-&gt;</operator><name>move_to</name></name></expr></argument>,
										<argument><expr><call><name>CdbPathLocus_NumSegments</name><argument_list>(<argument><expr><name><name>large_rel</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><operator>!</operator><name><name>large_rel</name><operator>-&gt;</operator><name>require_existing_order</name></name> <operator>&amp;&amp;</operator>
				 <name><name>large_rel</name><operator>-&gt;</operator><name>ok_to_replicate</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>CdbPathLocus_MakeReplicated</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>large_rel</name><operator>-&gt;</operator><name>move_to</name></name></expr></argument>,
										<argument><expr><call><name>CdbPathLocus_NumSegments</name><argument_list>(<argument><expr><name><name>small_rel</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

		<comment type="block">/* Last resort: Move both rels to a single qExec. */</comment>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type> <name>numsegments</name> <init>= <expr><call><name>CdbPathLocus_CommonSegments</name><argument_list>(<argument><expr><name><name>outer</name><operator>.</operator><name>locus</name></name></expr></argument>,
														  <argument><expr><name><name>inner</name><operator>.</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>CdbPathLocus_MakeSingleQE</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>outer</name><operator>.</operator><name>move_to</name></name></expr></argument>, <argument><expr><name>numsegments</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>CdbPathLocus_MakeSingleQE</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>inner</name><operator>.</operator><name>move_to</name></name></expr></argument>, <argument><expr><name>numsegments</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></else></if_stmt>							<comment type="block">/* partitioned */</comment>

	<comment type="block">/*
	 * Move outer.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CdbPathLocus_IsNull</name><argument_list>(<argument><expr><name><name>outer</name><operator>.</operator><name>move_to</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>outer</name><operator>.</operator><name>path</name></name> <operator>=</operator> <call><name>cdbpath_create_motion_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
												<argument><expr><name><name>outer</name><operator>.</operator><name>path</name></name></expr></argument>,
												<argument><expr><name>outer_pathkeys</name></expr></argument>,
												<argument><expr><name><name>outer</name><operator>.</operator><name>require_existing_order</name></name></expr></argument>,
												<argument><expr><name><name>outer</name><operator>.</operator><name>move_to</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>outer</name><operator>.</operator><name>path</name></name></expr>)</condition><block type="pseudo"><block_content>		<comment type="block">/* fail if outer motion not feasible */</comment>
			<goto>goto <name>fail</name>;</goto></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>outer</name><operator>.</operator><name>path</name></name></expr></argument>, <argument><expr><name>MaterialPath</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>root</name><operator>-&gt;</operator><name>config</name><operator>-&gt;</operator><name>may_rescan</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * If we are the outer path and can never be rescanned,
			 * we could remove the materialize path.
			 */</comment>
			<decl_stmt><decl><type><name>MaterialPath</name> <modifier>*</modifier></type><name>mpath</name> <init>= <expr><operator>(</operator><name>MaterialPath</name> <operator>*</operator><operator>)</operator> <name><name>outer</name><operator>.</operator><name>path</name></name></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name><name>outer</name><operator>.</operator><name>path</name></name> <operator>=</operator> <name><name>mpath</name><operator>-&gt;</operator><name>subpath</name></name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Move inner.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CdbPathLocus_IsNull</name><argument_list>(<argument><expr><name><name>inner</name><operator>.</operator><name>move_to</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>inner</name><operator>.</operator><name>path</name></name> <operator>=</operator> <call><name>cdbpath_create_motion_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
												<argument><expr><name><name>inner</name><operator>.</operator><name>path</name></name></expr></argument>,
												<argument><expr><name>inner_pathkeys</name></expr></argument>,
												<argument><expr><name><name>inner</name><operator>.</operator><name>require_existing_order</name></name></expr></argument>,
												<argument><expr><name><name>inner</name><operator>.</operator><name>move_to</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>inner</name><operator>.</operator><name>path</name></name></expr>)</condition><block type="pseudo"><block_content>		<comment type="block">/* fail if inner motion not feasible */</comment>
			<goto>goto <name>fail</name>;</goto></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Ok to join.  Give modified subpaths to caller.
	 */</comment>
	<expr_stmt><expr><operator>*</operator><name>p_outer_path</name> <operator>=</operator> <name><name>outer</name><operator>.</operator><name>path</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>p_inner_path</name> <operator>=</operator> <name><name>inner</name><operator>.</operator><name>path</name></name></expr>;</expr_stmt>

	<comment type="block">/* Tell caller where the join will be done. */</comment>
	<return>return <expr><call><name>cdbpathlocus_join</name><argument_list>(<argument><expr><name>jointype</name></expr></argument>, <argument><expr><name><name>outer</name><operator>.</operator><name>path</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>, <argument><expr><name><name>inner</name><operator>.</operator><name>path</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr>;</return>

<label><name>fail</name>:</label>							<comment type="block">/* can't do this join */</comment>
	<expr_stmt><expr><call><name>CdbPathLocus_MakeNull</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>outer</name><operator>.</operator><name>move_to</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name><name>outer</name><operator>.</operator><name>move_to</name></name></expr>;</return>
</block_content>}</block></function>								<comment type="block">/* cdbpath_motion_for_join */</comment>

<comment type="block">/*
 * Does the path contain WorkTableScan?
 */</comment>
<function><type><name>bool</name></type>
<name>cdbpath_contains_wts</name><parameter_list>(<parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>JoinPath</name>   <modifier>*</modifier></type><name>joinPath</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AppendPath</name> <modifier>*</modifier></type><name>appendPath</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsJoinPath</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>joinPath</name> <operator>=</operator> <operator>(</operator><name>JoinPath</name> <operator>*</operator><operator>)</operator> <name>path</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>cdbpath_contains_wts</name><argument_list>(<argument><expr><name><name>joinPath</name><operator>-&gt;</operator><name>outerjoinpath</name></name></expr></argument>)</argument_list></call>
			<operator>||</operator> <call><name>cdbpath_contains_wts</name><argument_list>(<argument><expr><name><name>joinPath</name><operator>-&gt;</operator><name>innerjoinpath</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></else></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>AppendPath</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>appendPath</name> <operator>=</operator> <operator>(</operator><name>AppendPath</name> <operator>*</operator><operator>)</operator> <name>path</name></expr>;</expr_stmt>
		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>appendPath-&gt;subpaths</argument>)</argument_list></macro>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>cdbpath_contains_wts</name><argument_list>(<argument><expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name><name>path</name><operator>-&gt;</operator><name>pathtype</name></name> <operator>==</operator> <name>T_WorkTableScan</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * has_redistributable_clause
 *	  If the restrictinfo's clause is redistributable, return true.
 */</comment>
<function><type><name>bool</name></type>
<name>has_redistributable_clause</name><parameter_list>(<parameter><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>restrictinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name><name>restrictinfo</name><operator>-&gt;</operator><name>hashjoinoperator</name></name> <operator>!=</operator> <name>InvalidOid</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * try_redistribute
 *     helper function for A join B when
 *     - A's locus is general or segmentgeneral
 *     - B's locus is partitioned
 *     it tries to redistribute A to B's locus
 *     or redistribute both A and B to the same
 *     partitioned locus.
 *
 *     return values:
 *     - true: redistributed motion has been added for A
 *     - false: cannot add redistributed motion, caller should
 *       continue to find other solutions.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>try_redistribute</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>CdbpathMfjRel</name> <modifier>*</modifier></type><name>g</name></decl></parameter>, <parameter><decl><type><name>CdbpathMfjRel</name> <modifier>*</modifier></type><name>o</name></decl></parameter>,
				 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>redistribution_clauses</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>g_immovable</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>o_immovable</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>CdbPathLocus_IsGeneral</name><argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
		   <call><name>CdbPathLocus_IsSegmentGeneral</name><argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>CdbPathLocus_IsPartitioned</name><argument_list>(<argument><expr><name><name>o</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * we cannot add motion if requiring order.
	 * has_wts can be true only for general locus
	 * otherwise, it is false and not impact the
	 * value of &lt;x&gt;_immovable.
	 */</comment>
	<expr_stmt><expr><name>g_immovable</name> <operator>=</operator> <operator>(</operator><name><name>g</name><operator>-&gt;</operator><name>require_existing_order</name></name> <operator>&amp;&amp;</operator>
				   <operator>!</operator><name><name>g</name><operator>-&gt;</operator><name>pathkeys</name></name><operator>)</operator> <operator>||</operator> <name><name>g</name><operator>-&gt;</operator><name>has_wts</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * if g cannot be added motion on,
	 * we should return immediately.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>g_immovable</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	
	<expr_stmt><expr><name>o_immovable</name> <operator>=</operator> <operator>(</operator><name><name>o</name><operator>-&gt;</operator><name>require_existing_order</name></name> <operator>&amp;&amp;</operator>
				   <operator>!</operator><name><name>o</name><operator>-&gt;</operator><name>pathkeys</name></name><operator>)</operator> <operator>||</operator> <name><name>o</name><operator>-&gt;</operator><name>has_wts</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>CdbPathLocus_IsHashed</name><argument_list>(<argument><expr><name><name>o</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
		<call><name>CdbPathLocus_IsHashedOJ</name><argument_list>(<argument><expr><name><name>o</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * first try to only redistribute g as o's locus
		 * if fails then try to redistribute both g and o
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>cdbpath_match_preds_to_distkey</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
										   <argument><expr><name>redistribution_clauses</name></expr></argument>,
										   <argument><expr><name><name>o</name><operator>-&gt;</operator><name>path</name></name></expr></argument>,
										   <argument><expr><name><name>o</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>,
										   <argument><expr><operator>&amp;</operator><name><name>g</name><operator>-&gt;</operator><name>move_to</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * both g and o can be added motion on,
			 * we should try each possible case.
			 */</comment>
			<decl_stmt><decl><type><name>int</name></type>			<name>numsegments</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>CdbPathLocus_IsGeneral</name><argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>numsegments</name> <operator>=</operator> <call><name>CdbPathLocus_NumSegments</name><argument_list>(<argument><expr><name><name>o</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>numsegments</name> <operator>=</operator> <call><name>CdbPathLocus_CommonSegments</name><argument_list>(<argument><expr><name><name>o</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>, <argument><expr><name><name>g</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<if_stmt><if>if<condition>(<expr><call><name>cdbpath_distkeys_from_preds</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
										   <argument><expr><name>redistribution_clauses</name></expr></argument>,
										   <argument><expr><name><name>o</name><operator>-&gt;</operator><name>path</name></name></expr></argument>,
										   <argument><expr><name>numsegments</name></expr></argument>,
										   <argument><expr><operator>&amp;</operator><name><name>o</name><operator>-&gt;</operator><name>move_to</name></name></expr></argument>,
										   <argument><expr><operator>&amp;</operator><name><name>g</name><operator>-&gt;</operator><name>move_to</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<return>return <expr><name>true</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * the only possible solution is to
		 * redistributed both g and o, so
		 * both g and o should be movable.
		 */</comment>
		<decl_stmt><decl><type><name>int</name></type>			<name>numsegments</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>CdbPathLocus_IsGeneral</name><argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>numsegments</name> <operator>=</operator> <call><name>CdbPathLocus_NumSegments</name><argument_list>(<argument><expr><name><name>o</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>numsegments</name> <operator>=</operator> <call><name>CdbPathLocus_CommonSegments</name><argument_list>(<argument><expr><name><name>o</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>, <argument><expr><name><name>g</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>o_immovable</name> <operator>&amp;&amp;</operator>
			<call><name>cdbpath_distkeys_from_preds</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
										<argument><expr><name>redistribution_clauses</name></expr></argument>,
										<argument><expr><name><name>o</name><operator>-&gt;</operator><name>path</name></name></expr></argument>,
										<argument><expr><name>numsegments</name></expr></argument>,
										<argument><expr><operator>&amp;</operator><name><name>o</name><operator>-&gt;</operator><name>move_to</name></name></expr></argument>,
										<argument><expr><operator>&amp;</operator><name><name>g</name><operator>-&gt;</operator><name>move_to</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * fail to redistribute, return false
	 * to let caller know.
	 */</comment>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Add a suitable Motion Path so that the input tuples from 'subpath' are
 * distributed correctly for insertion into target table.
 */</comment>
<function><type><name>Path</name> <modifier>*</modifier></type>
<name>create_motion_path_for_ctas</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>GpPolicy</name> <modifier>*</modifier></type><name>policy</name></decl></parameter>, <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>subpath</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>GpPolicyType</name></type>	<name>policyType</name> <init>= <expr><name><name>policy</name><operator>-&gt;</operator><name>ptype</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>policyType</name> <operator>==</operator> <name>POLICYTYPE_PARTITIONED</name> <operator>&amp;&amp;</operator> <name><name>policy</name><operator>-&gt;</operator><name>nattrs</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * If the target table is DISTRIBUTED RANDOMLY, and the input data
		 * is already partitioned, we could let the insertions happen where
		 * they are. But to ensure more random distribution, redistribute.
		 * This is different from create_motion_path_for_insert().
		 */</comment>
		<decl_stmt><decl><type><name>CdbPathLocus</name></type> <name>targetLocus</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>CdbPathLocus_MakeStrewn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>targetLocus</name></expr></argument>, <argument><expr><name><name>policy</name><operator>-&gt;</operator><name>numsegments</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><call><name>cdbpath_create_motion_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>subpath</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>targetLocus</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><call><name>create_motion_path_for_insert</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>policy</name></expr></argument>, <argument><expr><name>subpath</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Add a suitable Motion Path so that the input tuples from 'subpath' are
 * distributed correctly for insertion into target table.
 */</comment>
<function><type><name>Path</name> <modifier>*</modifier></type>
<name>create_motion_path_for_insert</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>GpPolicy</name> <modifier>*</modifier></type><name>policy</name></decl></parameter>,
							  <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>subpath</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>GpPolicyType</name></type>	<name>policyType</name> <init>= <expr><name><name>policy</name><operator>-&gt;</operator><name>ptype</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CdbPathLocus</name></type>	<name>targetLocus</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>policyType</name> <operator>==</operator> <name>POLICYTYPE_PARTITIONED</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * A query to reach here: INSERT INTO t1 VALUES(1).
		 * There is no need to add a motion from General, we could
		 * simply put General on the same segments with target table.
		 */</comment>
		<comment type="block">/* FIXME: also do this for other targetPolicyType? */</comment>
		<comment type="block">/* FIXME: also do this for all the subplans */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>CdbPathLocus_IsGeneral</name><argument_list>(<argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>subpath</name><operator>-&gt;</operator><name>locus</name><operator>.</operator><name>numsegments</name></name> <operator>=</operator> <name><name>policy</name><operator>-&gt;</operator><name>numsegments</name></name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>targetLocus</name> <operator>=</operator> <call><name>cdbpathlocus_for_insert</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>policy</name></expr></argument>, <argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>pathtarget</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>policy</name><operator>-&gt;</operator><name>nattrs</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>CdbPathLocus_IsPartitioned</name><argument_list>(<argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * If the target table is DISTRIBUTED RANDOMLY, we can insert the
			 * rows anywhere. So if the input path is already partitioned, let
			 * the insertions happen where they are.
			 *
			 * If you `explain` the query insert into tab_random select * from tab_partition
			 * there is not Motion node in plan. However, it is not means that the query only
			 * execute in entry db. It is dispatched to QE and do everything well as we expect.
			 *
			 * But, we need to grant a Motion node if target locus' segnumber is different with
			 * subpath.
			 */</comment>
			<if_stmt><if>if<condition>(<expr><name><name>targetLocus</name><operator>.</operator><name>numsegments</name></name> <operator>!=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>locus</name><operator>.</operator><name>numsegments</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>CdbPathLocus_MakeStrewn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>targetLocus</name></expr></argument>, <argument><expr><name><name>policy</name><operator>-&gt;</operator><name>numsegments</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>subpath</name> <operator>=</operator> <call><name>cdbpath_create_motion_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>subpath</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>targetLocus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>CdbPathLocus_IsNull</name><argument_list>(<argument><expr><name>targetLocus</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* could not create DistributionKeys to represent the distribution keys. */</comment>
			<expr_stmt><expr><call><name>CdbPathLocus_MakeStrewn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>targetLocus</name></expr></argument>, <argument><expr><name><name>policy</name><operator>-&gt;</operator><name>numsegments</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>subpath</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>make_motion_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>subpath</name></expr></argument>, <argument><expr><name>targetLocus</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>policy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>subpath</name> <operator>=</operator> <call><name>cdbpath_create_motion_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>subpath</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>targetLocus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>policyType</name> <operator>==</operator> <name>POLICYTYPE_ENTRY</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Query result needs to be brought back to the QD.
		 */</comment>
		<expr_stmt><expr><call><name>CdbPathLocus_MakeEntry</name><argument_list>(<argument><expr><operator>&amp;</operator><name>targetLocus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>subpath</name> <operator>=</operator> <call><name>cdbpath_create_motion_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>subpath</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>targetLocus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>policyType</name> <operator>==</operator> <name>POLICYTYPE_REPLICATED</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* try to optimize insert with no motion introduced into */</comment>
		<if_stmt><if>if <condition>(<expr><name>optimizer_replicated_table_insert</name> <operator>&amp;&amp;</operator>
			<operator>!</operator><call><name>contain_volatile_functions</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name><name>subpath</name><operator>-&gt;</operator><name>pathtarget</name><operator>-&gt;</operator><name>exprs</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<operator>!</operator><call><name>contain_volatile_functions</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name><name>root</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>havingQual</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * CdbLocusType_SegmentGeneral is only used by replicated table
			 * right now, so if both input and target are replicated table,
			 * no need to add a motion.
			 *
			 * Also, to expand a replicated table to new segments, gpexpand
			 * force a data reorganization by a query like:
			 * CREATE TABLE tmp_tab AS SELECT * FROM source_table DISTRIBUTED REPLICATED
			 * Obviously, tmp_tab in new segments can't get data if we don't
			 * add a broadcast here.
			 */</comment>
			<if_stmt><if>if<condition>(<expr><call><name>CdbPathLocus_IsSegmentGeneral</name><argument_list>(<argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
					<name><name>subpath</name><operator>-&gt;</operator><name>locus</name><operator>.</operator><name>numsegments</name></name> <operator>&gt;=</operator> <name><name>policy</name><operator>-&gt;</operator><name>numsegments</name></name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * A query to reach here:
				 *     INSERT INTO d1 SELECT * FROM d1;
				 * There is no need to add a motion from General, we
				 * could simply put General on the same segments with
				 * target table.
				 *
				 * Otherwise a broadcast motion is needed otherwise d2 will
				 * only have data on segment 0.
				 */</comment>
				<expr_stmt><expr><name><name>subpath</name><operator>-&gt;</operator><name>locus</name><operator>.</operator><name>numsegments</name></name> <operator>=</operator> <name><name>policy</name><operator>-&gt;</operator><name>numsegments</name></name></expr>;</expr_stmt>
				<return>return <expr><name>subpath</name></expr>;</return>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* plan's data are available on all segment, no motion needed */</comment>
			<if_stmt><if>if<condition>(<expr><call><name>CdbPathLocus_IsGeneral</name><argument_list>(<argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * A query to reach here: INSERT INTO d1 VALUES(1).
				 * There is no need to add a motion from General, we
				 * could simply put General on the same segments with
				 * target table.
				 */</comment>
				<expr_stmt><expr><name><name>subpath</name><operator>-&gt;</operator><name>locus</name><operator>.</operator><name>numsegments</name></name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>locus</name><operator>.</operator><name>numsegments</name></name></expr></argument>,<argument><expr><name><name>policy</name><operator>-&gt;</operator><name>numsegments</name></name></expr></argument>)</argument_list></call></expr> ;</expr_stmt>
				<return>return <expr><name>subpath</name></expr>;</return>
			</block_content>}</block></if></if_stmt>

		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>subpath</name> <operator>=</operator> <call><name>cdbpath_create_broadcast_motion_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>subpath</name></expr></argument>, <argument><expr><name><name>policy</name><operator>-&gt;</operator><name>numsegments</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized policy type %u"</literal></expr></argument>, <argument><expr><name>policyType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<return>return <expr><name>subpath</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Add a suitable Motion Path for delete and update. If the UPDATE
 * modifies the distribution key columns, use create_split_update_path()
 * instead.
 */</comment>
<function><type><name>Path</name> <modifier>*</modifier></type>
<name>create_motion_path_for_upddel</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Index</name></type> <name>rti</name></decl></parameter>, <parameter><decl><type><name>GpPolicy</name> <modifier>*</modifier></type><name>policy</name></decl></parameter>,
							  <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>subpath</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>GpPolicyType</name></type>	<name>policyType</name> <init>= <expr><name><name>policy</name><operator>-&gt;</operator><name>ptype</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CdbPathLocus</name></type>	<name>targetLocus</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>policyType</name> <operator>==</operator> <name>POLICYTYPE_PARTITIONED</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>can_elide_explicit_motion</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rti</name></expr></argument>, <argument><expr><name>subpath</name></expr></argument>, <argument><expr><name>policy</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>subpath</name></expr>;</return></block_content></block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* GPDB_96_MERGE_FIXME: avoid creating the Explicit Motion in
			 * simple cases, where all the input data is already on the
			 * same segment.
			 *
			 * Is "strewn" correct here? Can we do better?
			 */</comment>
			<expr_stmt><expr><call><name>CdbPathLocus_MakeStrewn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>targetLocus</name></expr></argument>, <argument><expr><name><name>policy</name><operator>-&gt;</operator><name>numsegments</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>subpath</name> <operator>=</operator> <call><name>cdbpath_create_explicit_motion_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
														  <argument><expr><name>subpath</name></expr></argument>,
														  <argument><expr><name>targetLocus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>policyType</name> <operator>==</operator> <name>POLICYTYPE_ENTRY</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Master-only table */</comment>
		<expr_stmt><expr><call><name>CdbPathLocus_MakeEntry</name><argument_list>(<argument><expr><operator>&amp;</operator><name>targetLocus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>subpath</name> <operator>=</operator> <call><name>cdbpath_create_motion_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>subpath</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>targetLocus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>policyType</name> <operator>==</operator> <name>POLICYTYPE_REPLICATED</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * The statement that update or delete on replicated table has to
		 * be dispatched to each segment and executed on each segment. Thus
		 * the targetlist cannot contain volatile functions.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>contain_volatile_functions</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name><name>subpath</name><operator>-&gt;</operator><name>pathtarget</name><operator>-&gt;</operator><name>exprs</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not devise a plan."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized policy type %u"</literal></expr></argument>, <argument><expr><name>policyType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<return>return <expr><name>subpath</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * In Postgres planner, we add a SplitUpdate node at top so that updating on
 * distribution columns could be handled. The SplitUpdate will split each
 * update into delete + insert.
 *
 * There are several important points should be highlighted:
 *
 * First, in order to split each update operation into two operations,
 * delete + insert, we need several junk columns in the subplan's targetlist,
 * in addition to the row's new values:
 *
 * ctid            the tuple id used for deletion
 *
 * gp_segment_id   the segment that the row originates from. Usually the
 *                 current segment where the SplitUpdate runs, but not
 *                 necessarily, if there are multiple joins involved and the
 *                 planner decided redistribute the data.
 *
 * oid             if result relation has oids, the old OID, so that it can be
 *                 preserved in the new row.
 *
 * We will add one more column to the output, the "action". It's an integer
 * that indicates for each row, whether it represents the DELETE or the INSERT
 * of that row. It is generated by the Split Update node.
 *
 * Second, current GPDB executor don't support statement-level update triggers
 * and will skip row-level update triggers because a split-update is actually
 * consist of a delete and insert. So, if the result relation has update
 * triggers, we should reject and error out because it's not functional.
 *
 * GPDB_96_MERGE_FIXME: the below comment is obsolete. Nowadays, SplitUpdate
 * computes the new row's hash, and the corresponding. target segment. The
 * old segment comes from the gp_segment_id junk column. But ORCA still
 * does it the old way!
 *
 * Third, to support deletion, and hash delete operation to correct segment,
 * we need to get attributes of OLD tuple. The old attributes must therefore
 * be present in the subplan's target list. That is handled earlier in the
 * planner, in expand_targetlist().
 *
 * For example, a typical plan would be as following for statement:
 * update foo set id = l.v + 1 from dep l where foo.v = l.id:
 *
 * |-- join ( targetlist: [ l.v + 1, foo.v, foo.id, foo.ctid, foo.gp_segment_id ] )
 *       |
 *       |-- motion ( targetlist: [l.id, l.v] )
 *       |    |
 *       |    |-- seqscan on dep ....
 *       |
 *       |-- hash (targetlist [ v, foo.ctid, foo.gp_segment_id ] )
 *            |
 *            |-- seqscan on foo (targetlist: [ v, foo.id, foo.ctid, foo.gp_segment_id ] )
 *
 * From the plan above, the target foo.id is assigned as l.v + 1, and expand_targetlist()
 * ensured that the old value of id, is also available, even though it would not otherwise
 * be needed.
 *
 * 'rti' is the UPDATE target relation.
 */</comment>
<function><type><name>Path</name> <modifier>*</modifier></type>
<name>create_split_update_path</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Index</name></type> <name>rti</name></decl></parameter>, <parameter><decl><type><name>GpPolicy</name> <modifier>*</modifier></type><name>policy</name></decl></parameter>, <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>subpath</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>GpPolicyType</name></type>	<name>policyType</name> <init>= <expr><name><name>policy</name><operator>-&gt;</operator><name>ptype</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CdbPathLocus</name></type>	<name>targetLocus</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>policyType</name> <operator>==</operator> <name>POLICYTYPE_PARTITIONED</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * If any of the distribution key columns are being changed,
		 * the UPDATE might move tuples from one segment to another.
		 * Create a Split Update node to deal with that.
		 *
		 * If the input is a dummy plan that cannot return any rows,
		 * e.g. because the input was eliminated by constraint
		 * exclusion, we can skip it.
		 */</comment>
		<expr_stmt><expr><name>targetLocus</name> <operator>=</operator> <call><name>cdbpathlocus_for_insert</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>policy</name></expr></argument>, <argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>pathtarget</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>subpath</name> <operator>=</operator> <operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <call><name>make_splitupdate_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>subpath</name></expr></argument>, <argument><expr><name>rti</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>subpath</name> <operator>=</operator> <call><name>cdbpath_create_explicit_motion_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
													  <argument><expr><name>subpath</name></expr></argument>,
													  <argument><expr><name>targetLocus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>policyType</name> <operator>==</operator> <name>POLICYTYPE_ENTRY</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Master-only table */</comment>
		<expr_stmt><expr><call><name>CdbPathLocus_MakeEntry</name><argument_list>(<argument><expr><operator>&amp;</operator><name>targetLocus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>subpath</name> <operator>=</operator> <call><name>cdbpath_create_motion_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>subpath</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>targetLocus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>policyType</name> <operator>==</operator> <name>POLICYTYPE_REPLICATED</name></expr>)</condition>
	<block>{<block_content>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized policy type %u"</literal></expr></argument>, <argument><expr><name>policyType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<return>return <expr><name>subpath</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * turn_volatile_seggen_to_singleqe
 *
 * This function is the key tool to build correct plan
 * for general or segmentgeneral locus paths that contain
 * volatile functions.
 *
 * If we find such a pattern:
 *    1. if we are update or delete statement on replicated table
 *       simply reject the query
 *    2. if it is general locus, simply change it to singleQE
 *    3. if it is segmentgeneral, use a motion to bring it to
 *       singleQE and then create a projection path
 *
 * If we do not find the pattern, simply return the input path.
 *
 * The last parameter of this function is the part that we want to
 * check volatile functions.
 */</comment>
<function><type><name>Path</name> <modifier>*</modifier></type>
<name>turn_volatile_seggen_to_singleqe</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>CdbPathLocus_IsSegmentGeneral</name><argument_list>(<argument><expr><name><name>path</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>CdbPathLocus_IsGeneral</name><argument_list>(<argument><expr><name><name>path</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator>
		<operator>(</operator><call><name>contain_volatile_functions</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>LimitPath</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>CdbPathLocus</name></type>     <name>singleQE</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Path</name>            <modifier>*</modifier></type><name>mpath</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ProjectionPath</name>  <modifier>*</modifier></type><name>ppath</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>root</name><operator>-&gt;</operator><name>upd_del_replicated_table</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
			<call><name>bms_is_member</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>upd_del_replicated_table</name></name></expr></argument>,
						  <argument><expr><name><name>path</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not devise a plan"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>CdbPathLocus_IsGeneral</name><argument_list>(<argument><expr><name><name>path</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>CdbPathLocus_MakeSingleQE</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>path</name><operator>-&gt;</operator><name>locus</name></name><operator>)</operator></expr></argument>,
									  <argument><expr><call><name>getgpsegmentCount</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>path</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>CdbPathLocus_MakeSingleQE</name><argument_list>(<argument><expr><operator>&amp;</operator><name>singleQE</name></expr></argument>,
								  <argument><expr><call><name>CdbPathLocus_NumSegments</name><argument_list>(<argument><expr><name><name>path</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>mpath</name> <operator>=</operator> <call><name>cdbpath_create_motion_path</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>singleQE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/*
		 * mpath might be NULL, like path contain outer Params
		 * See Github Issue 13532 for details.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>mpath</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>path</name></expr>;</return></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>ppath</name> <operator>=</operator>  <call><name>create_projection_path_with_quals</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>mpath</name><operator>-&gt;</operator><name>parent</name></name></expr></argument>, <argument><expr><name>mpath</name></expr></argument>,
												   <argument><expr><name><name>mpath</name><operator>-&gt;</operator><name>pathtarget</name></name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ppath</name><operator>-&gt;</operator><name>force</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<return>return <expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <name>ppath</name></expr>;</return>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><name>path</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>SplitUpdatePath</name> <modifier>*</modifier></type>
<name>make_splitupdate_path</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>subpath</name></decl></parameter>, <parameter><decl><type><name>Index</name></type> <name>rti</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RangeTblEntry</name>  <modifier>*</modifier></type><name>rte</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PathTarget</name>		<modifier>*</modifier></type><name>splitUpdatePathTarget</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SplitUpdatePath</name>	<modifier>*</modifier></type><name>splitupdatepath</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DMLActionExpr</name>	<modifier>*</modifier></type><name>actionExpr</name></decl>;</decl_stmt>

	<comment type="block">/* Suppose we already hold locks before caller */</comment>
	<expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>planner_rt_fetch</name><argument_list>(<argument><expr><name>rti</name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Firstly, Trigger is not supported officially by Greenplum.
	 *
	 * Secondly, the update trigger is processed in ExecUpdate.
	 * however, splitupdate will execute ExecSplitUpdate_Insert
	 * or ExecDelete instead of ExecUpdate. So the update trigger
	 * will not be triggered in a split plan.
	 *
	 * PostgreSQL fires the row-level DELETE, INSERT, and BEFORE
	 * UPDATE triggers, but not row-level AFTER UPDATE triggers,
	 * if you UPDATE a partitioning key column.
	 * Doing a similar thing doesn't help Greenplum likely, the
	 * behavior would be uncertain since some triggers happen on
	 * segments and they may require cross segments data changes.
	 *
	 * So an update trigger is not allowed when updating the
	 * distribution key.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>has_update_triggers</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_GP_FEATURE_NOT_YET</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"UPDATE on distributed key column not allowed on relation with update triggers"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Add action column at the end of targetlist */</comment>
	<expr_stmt><expr><name>actionExpr</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>DMLActionExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>splitUpdatePathTarget</name> <operator>=</operator> <call><name>copy_pathtarget</name><argument_list>(<argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>pathtarget</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>add_column_to_pathtarget</name><argument_list>(<argument><expr><name>splitUpdatePathTarget</name></expr></argument>, <argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>actionExpr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* populate information generated above into splitupdate node */</comment>
	<expr_stmt><expr><name>splitupdatepath</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>SplitUpdatePath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>splitupdatepath</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtype</name></name> <operator>=</operator> <name>T_SplitUpdate</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>splitupdatepath</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parent</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>parent</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>splitupdatepath</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathtarget</name></name> <operator>=</operator> <name>splitUpdatePathTarget</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>splitupdatepath</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>param_info</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>splitupdatepath</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_aware</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>splitupdatepath</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_safe</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>parallel_safe</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>splitupdatepath</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>parallel_workers</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>parallel_workers</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>splitupdatepath</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>rows</name></name> <operator>=</operator> <literal type="number">2</literal> <operator>*</operator> <name><name>subpath</name><operator>-&gt;</operator><name>rows</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>splitupdatepath</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>startup_cost</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>startup_cost</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>splitupdatepath</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>total_cost</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>total_cost</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>splitupdatepath</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>pathkeys</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>pathkeys</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>splitupdatepath</name><operator>-&gt;</operator><name>path</name><operator>.</operator><name>locus</name></name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>locus</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>splitupdatepath</name><operator>-&gt;</operator><name>subpath</name></name> <operator>=</operator> <name>subpath</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>splitupdatepath</name><operator>-&gt;</operator><name>resultRelation</name></name> <operator>=</operator> <name>rti</name></expr>;</expr_stmt>

	<return>return <expr><name>splitupdatepath</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>can_elide_explicit_motion</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Index</name></type> <name>rti</name></decl></parameter>, <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>subpath</name></decl></parameter>,
						  <parameter><decl><type><name>GpPolicy</name> <modifier>*</modifier></type><name>policy</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * If there are no Motions between scan of the target relation and here,
	 * no motion is required.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>bms_is_member</name><argument_list>(<argument><expr><name>rti</name></expr></argument>, <argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>sameslice_relids</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CdbPathLocus_IsStrewn</name><argument_list>(<argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>CdbPathLocus</name></type>    <name>resultrelation_locus</name> <init>= <expr><call><name>cdbpathlocus_from_policy</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rti</name></expr></argument>, <argument><expr><name>policy</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<return>return <expr><call><name>cdbpathlocus_equal</name><argument_list>(<argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>, <argument><expr><name>resultrelation_locus</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>
</unit>
