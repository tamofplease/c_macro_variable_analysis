<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/backend/cdb/cdbpathlocus.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * cdbpathlocus.c
 *
 * Portions Copyright (c) 2005-2008, Greenplum inc
 * Portions Copyright (c) 2012-Present VMware, Inc. or its affiliates.
 *
 *
 * IDENTIFICATION
 *	    src/backend/cdb/cdbpathlocus.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/gp_distribution_policy.h"</cpp:file></cpp:include>	<comment type="block">/* GpPolicy */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbhash.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbpullup.h"</cpp:file></cpp:include>		<comment type="block">/* cdbpullup_findEclassInTargetList() */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>	<comment type="block">/* makeVar() */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodeFuncs.h"</cpp:file></cpp:include>	<comment type="block">/* exprType() and exprTypmod() */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/pathnodes.h"</cpp:file></cpp:include>	<comment type="block">/* RelOptInfo */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/plannodes.h"</cpp:file></cpp:include>	<comment type="block">/* Plan */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/clauses.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/optimizer.h"</cpp:file></cpp:include> <comment type="block">/* contain_volatile_functions() */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/pathnode.h"</cpp:file></cpp:include> <comment type="block">/* Path */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/paths.h"</cpp:file></cpp:include>	<comment type="block">/* cdb_make_distkey_for_expr() */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/tlist.h"</cpp:file></cpp:include>	<comment type="block">/* tlist_member() */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parsetree.h"</cpp:file></cpp:include>	<comment type="block">/* rt_fetch() */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbpath.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbutil.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbvars.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbpathlocus.h"</cpp:file></cpp:include>	<comment type="block">/* me */</comment>

<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>cdb_build_distribution_keys</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
										 <parameter><decl><type><name>Index</name></type> <name>rti</name></decl></parameter>,
										 <parameter><decl><type><name>GpPolicy</name> <modifier>*</modifier></type><name>policy</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * cdbpathlocus_equal
 *
 *    - Returns false if locus a or locus b is "strewn", meaning that it
 *      cannot be determined whether it is equal to another partitioned
 *      distribution.
 *
 *    - Returns true if a and b have the same 'locustype' and 'numsegments',
 *      and distribution keys that contain the same equivalence classes.
 *
 *    - Returns false otherwise.
 */</comment>
<function><type><name>bool</name></type>
<name>cdbpathlocus_equal</name><parameter_list>(<parameter><decl><type><name>CdbPathLocus</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>CdbPathLocus</name></type> <name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>acell</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>bcell</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>a_ec_cell</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>b_ec_cell</name></decl>;</decl_stmt>

	<comment type="block">/* Unless a and b have the same numsegments the result is always false */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>CdbPathLocus_NumSegments</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> <operator>!=</operator>
		<call><name>CdbPathLocus_NumSegments</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>CdbPathLocus_IsStrewn</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> <operator>||</operator>
		<call><name>CdbPathLocus_IsStrewn</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>CdbPathLocus_IsEqual</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>a</name><operator>.</operator><name>distkey</name></name> <operator>==</operator> <name>NIL</name> <operator>||</operator>
		<name><name>b</name><operator>.</operator><name>distkey</name></name> <operator>==</operator> <name>NIL</name> <operator>||</operator>
		<call><name>list_length</name><argument_list>(<argument><expr><name><name>a</name><operator>.</operator><name>distkey</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>b</name><operator>.</operator><name>distkey</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>CdbPathLocus_IsHashed</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>CdbPathLocus_IsHashedOJ</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator>
		<operator>(</operator><call><name>CdbPathLocus_IsHashed</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>CdbPathLocus_IsHashedOJ</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<macro><name>forboth</name><argument_list>(<argument>acell</argument>, <argument>a.distkey</argument>, <argument>bcell</argument>, <argument>b.distkey</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>DistributionKey</name> <modifier>*</modifier></type><name>adistkey</name> <init>= <expr><operator>(</operator><name>DistributionKey</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>acell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>DistributionKey</name> <modifier>*</modifier></type><name>bdistkey</name> <init>= <expr><operator>(</operator><name>DistributionKey</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>bcell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>adistkey</name><operator>-&gt;</operator><name>dk_opfamily</name></name> <operator>!=</operator> <name><name>bdistkey</name><operator>-&gt;</operator><name>dk_opfamily</name></name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

			<macro><name>foreach</name><argument_list>(<argument>b_ec_cell</argument>, <argument>bdistkey-&gt;dk_eclasses</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>EquivalenceClass</name> <modifier>*</modifier></type><name>b_ec</name> <init>= <expr><operator>(</operator><name>EquivalenceClass</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>b_ec_cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>list_member_ptr</name><argument_list>(<argument><expr><name><name>adistkey</name><operator>-&gt;</operator><name>dk_eclasses</name></name></expr></argument>, <argument><expr><name>b_ec</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
			</block_content>}</block>
			<macro><name>foreach</name><argument_list>(<argument>a_ec_cell</argument>, <argument>adistkey-&gt;dk_eclasses</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>EquivalenceClass</name> <modifier>*</modifier></type><name>a_ec</name> <init>= <expr><operator>(</operator><name>EquivalenceClass</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>a_ec_cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>list_member_ptr</name><argument_list>(<argument><expr><name><name>bdistkey</name><operator>-&gt;</operator><name>dk_eclasses</name></name></expr></argument>, <argument><expr><name>a_ec</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
			</block_content>}</block>
		</block_content>}</block>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>								<comment type="block">/* cdbpathlocus_equal */</comment>

<comment type="block">/*
 * cdb_build_distribution_keys
 *	  Build DistributionKeys that match the policy of the given relation.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>cdb_build_distribution_keys</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Index</name></type> <name>rti</name></decl></parameter>, <parameter><decl><type><name>GpPolicy</name> <modifier>*</modifier></type><name>policy</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><call><name>planner_rt_fetch</name><argument_list>(<argument><expr><name>rti</name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>retval</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>policy</name><operator>-&gt;</operator><name>nattrs</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>DistributionKey</name> <modifier>*</modifier></type><name>cdistkey</name></decl>;</decl_stmt>

		<comment type="block">/* Find or create a Var node that references the specified column. */</comment>
		<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>expr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>typeoid</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int32</name></type>		<name>type_mod</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>varcollid</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>eqopoid</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>opfamily</name> <init>= <expr><call><name>get_opclass_family</name><argument_list>(<argument><expr><name><name>policy</name><operator>-&gt;</operator><name>opclasses</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>opcintype</name> <init>= <expr><call><name>get_opclass_input_type</name><argument_list>(<argument><expr><name><name>policy</name><operator>-&gt;</operator><name>opclasses</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>mergeopfamilies</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>EquivalenceClass</name> <modifier>*</modifier></type><name>eclass</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>get_atttypetypmodcoll</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name><name>policy</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typeoid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>type_mod</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>varcollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>expr</name> <operator>=</operator> <call><name>makeVar</name><argument_list>(<argument><expr><name>rti</name></expr></argument>, <argument><expr><name><name>policy</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>typeoid</name></expr></argument>, <argument><expr><name>type_mod</name></expr></argument>, <argument><expr><name>varcollid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Look up the equality operator corresponding to the distribution
		 * opclass.
		 */</comment>
		<expr_stmt><expr><name>eqopoid</name> <operator>=</operator> <call><name>get_opfamily_member</name><argument_list>(<argument><expr><name>opfamily</name></expr></argument>, <argument><expr><name>opcintype</name></expr></argument>, <argument><expr><name>opcintype</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Get Oid of the sort operator that would be used for a sort-merge
		 * equijoin on a pair of exprs of the same type.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>eqopoid</name> <operator>==</operator> <name>InvalidOid</name> <operator>||</operator> <operator>!</operator><call><name>op_mergejoinable</name><argument_list>(<argument><expr><name>eqopoid</name></expr></argument>, <argument><expr><name>typeoid</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * It's in principle possible that there is no b-tree operator family
			 * that's compatible with the hash opclass's equality operator. However,
			 * we cannot construct an EquivalenceClass without the b-tree operator
			 * family, and therefore cannot build a DistributionKey to represent it.
			 * Bail out. (That makes the distribution key rather useless.)
			 */</comment>
			<return>return <expr><name>NIL</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>mergeopfamilies</name> <operator>=</operator> <call><name>get_mergejoin_opfamilies</name><argument_list>(<argument><expr><name>eqopoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>eclass</name> <operator>=</operator> <call><name>get_eclass_for_sort_expr</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>,
										  <argument><expr><name>NULL</name></expr></argument>, <comment type="block">/* nullable_relids */</comment> <comment type="block">/* GPDB_94_MERGE_FIXME: is NULL ok here? */</comment>
										  <argument><expr><name>mergeopfamilies</name></expr></argument>,
										  <argument><expr><name>opcintype</name></expr></argument>,
										  <argument><expr><call><name>exprCollation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>)</argument_list></call></expr></argument>,
										  <argument><expr><literal type="number">0</literal></expr></argument>,
										  <argument><expr><call><name>bms_make_singleton</name><argument_list>(<argument><expr><name>rti</name></expr></argument>)</argument_list></call></expr></argument>,
										  <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Create a distribution key for it. */</comment>
		<expr_stmt><expr><name>cdistkey</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>DistributionKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cdistkey</name><operator>-&gt;</operator><name>dk_opfamily</name></name> <operator>=</operator> <name>opfamily</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cdistkey</name><operator>-&gt;</operator><name>dk_eclasses</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>eclass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>retval</name></expr></argument>, <argument><expr><name>cdistkey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>retval</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * cdbpathlocus_for_insert
 *	  Build DistributionKeys that match the policy of the given relation.
 *
 * This is used for INSERT or split UPDATE, where 'pathtarget' the target list of
 * subpath that's producing the rows to be inserted/updated.
 *
 * As a side-effect, this assigns sortgrouprefs to any volatile expressions
 * that are used in the distribution keys.
 *
 * If the target table is distributed, but the distribution keys cannot be
 * represented as Equivalence Classes (because a datatype is missing merge
 * opfamilies), returns a NULL locus.
 *
 * Currently, this function is only invoked  by `create_motion_path_for_insert`
 * and `create_split_update_path`, and under the condition that policy type
 * is always partitioned type.
 */</comment>
<function><type><name>CdbPathLocus</name></type>
<name>cdbpathlocus_for_insert</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>GpPolicy</name> <modifier>*</modifier></type><name>policy</name></decl></parameter>,
						<parameter><decl><type><name>PathTarget</name> <modifier>*</modifier></type><name>pathtarget</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CdbPathLocus</name></type> <name>targetLocus</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>policy</name><operator>-&gt;</operator><name>ptype</name></name> <operator>==</operator> <name>POLICYTYPE_PARTITIONED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* rows are distributed by hashing on specified columns */</comment>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>distkeys</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Index</name></type>		<name>maxRef</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>failed</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>pathtarget</name><operator>-&gt;</operator><name>exprs</name></name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name>maxRef</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name>maxRef</name></expr></argument>, <argument><expr><name><name>pathtarget</name><operator>-&gt;</operator><name>sortgrouprefs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>policy</name><operator>-&gt;</operator><name>nattrs</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>attno</name> <init>= <expr><name><name>policy</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DistributionKey</name> <modifier>*</modifier></type><name>cdistkey</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>expr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>typeoid</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>eqopoid</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>opfamily</name> <init>= <expr><call><name>get_opclass_family</name><argument_list>(<argument><expr><name><name>policy</name><operator>-&gt;</operator><name>opclasses</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>opcintype</name> <init>= <expr><call><name>get_opclass_input_type</name><argument_list>(<argument><expr><name><name>policy</name><operator>-&gt;</operator><name>opclasses</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>mergeopfamilies</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>EquivalenceClass</name> <modifier>*</modifier></type><name>eclass</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>expr</name> <operator>=</operator> <call><name>list_nth</name><argument_list>(<argument><expr><name><name>pathtarget</name><operator>-&gt;</operator><name>exprs</name></name></expr></argument>, <argument><expr><name>attno</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>typeoid</name> <operator>=</operator> <call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Look up the equality operator corresponding to the distribution
		 * opclass.
		 */</comment>
		<expr_stmt><expr><name>eqopoid</name> <operator>=</operator> <call><name>get_opfamily_member</name><argument_list>(<argument><expr><name>opfamily</name></expr></argument>, <argument><expr><name>opcintype</name></expr></argument>, <argument><expr><name>opcintype</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>pathtarget</name><operator>-&gt;</operator><name>sortgrouprefs</name><index>[<expr><name>attno</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
			<call><name>contain_volatile_functions</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * GPDB_96_MERGE_FIXME: this modifies the subpath's targetlist in place.
			 * That's a bit ugly.
			 */</comment>
			<expr_stmt><expr><name><name>pathtarget</name><operator>-&gt;</operator><name>sortgrouprefs</name><index>[<expr><name>attno</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>++</operator><name>maxRef</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Get Oid of the sort operator that would be used for a sort-merge
		 * equijoin on a pair of exprs of the same type.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>failed</name> <operator>||</operator> <name>eqopoid</name> <operator>==</operator> <name>InvalidOid</name> <operator>||</operator> <operator>!</operator><call><name>op_mergejoinable</name><argument_list>(<argument><expr><name>eqopoid</name></expr></argument>, <argument><expr><name>typeoid</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * It's in principle possible that there is no b-tree operator family
			 * that's compatible with the hash opclass's equality operator. However,
			 * we cannot construct an EquivalenceClass without the b-tree operator
			 * family, and therefore cannot build a DistributionKey to represent it.
			 * Bail out. (That makes the distribution key rather useless.)
			 */</comment>
			<expr_stmt><expr><name>failed</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>mergeopfamilies</name> <operator>=</operator> <call><name>get_mergejoin_opfamilies</name><argument_list>(<argument><expr><name>eqopoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>eclass</name> <operator>=</operator> <call><name>get_eclass_for_sort_expr</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>,
										  <argument><expr><name>NULL</name></expr></argument>, <comment type="block">/* nullable_relids */</comment> <comment type="block">/* GPDB_94_MERGE_FIXME: is NULL ok here? */</comment>
										  <argument><expr><name>mergeopfamilies</name></expr></argument>,
										  <argument><expr><name>opcintype</name></expr></argument>,
										  <argument><expr><call><name>exprCollation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>)</argument_list></call></expr></argument>,
										  <argument><expr><name><name>pathtarget</name><operator>-&gt;</operator><name>sortgrouprefs</name><index>[<expr><name>attno</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>,
										  <argument><expr><name>NULL</name></expr></argument>,
										  <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Create a distribution key for it. */</comment>
		<expr_stmt><expr><name>cdistkey</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>DistributionKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cdistkey</name><operator>-&gt;</operator><name>dk_opfamily</name></name> <operator>=</operator> <name>opfamily</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cdistkey</name><operator>-&gt;</operator><name>dk_eclasses</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>eclass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>distkeys</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>distkeys</name></expr></argument>, <argument><expr><name>cdistkey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><name>failed</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>CdbPathLocus_MakeNull</name><argument_list>(<argument><expr><operator>&amp;</operator><name>targetLocus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>distkeys</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>CdbPathLocus_MakeHashed</name><argument_list>(<argument><expr><operator>&amp;</operator><name>targetLocus</name></expr></argument>, <argument><expr><name>distkeys</name></expr></argument>, <argument><expr><name><name>policy</name><operator>-&gt;</operator><name>numsegments</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
			<comment type="block">/* DISTRIBUTED RANDOMLY */</comment>
		<expr_stmt><expr><call><name>CdbPathLocus_MakeStrewn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>targetLocus</name></expr></argument>, <argument><expr><name><name>policy</name><operator>-&gt;</operator><name>numsegments</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>targetLocus</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * cdbpathlocus_from_policy
 *
 * Returns a locus describing the distribution of a policy
 */</comment>
<function><type><name>CdbPathLocus</name></type>
<name>cdbpathlocus_from_policy</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>PlannerInfo</name></name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Index</name></type> <name>rti</name></decl></parameter>, <parameter><decl><type><name>GpPolicy</name> <modifier>*</modifier></type><name>policy</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CdbPathLocus</name></type> <name>result</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>Gp_role</name> <operator>!=</operator> <name>GP_ROLE_DISPATCH</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>CdbPathLocus_MakeEntry</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>result</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>GpPolicyIsPartitioned</name><argument_list>(<argument><expr><name>policy</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Are the rows distributed by hashing on specified columns? */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>policy</name><operator>-&gt;</operator><name>nattrs</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>distkeys</name> <init>= <expr><call><name>cdb_build_distribution_keys</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
															   <argument><expr><name>rti</name></expr></argument>,
															   <argument><expr><name>policy</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>distkeys</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>CdbPathLocus_MakeHashed</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>, <argument><expr><name>distkeys</name></expr></argument>, <argument><expr><name><name>policy</name><operator>-&gt;</operator><name>numsegments</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/*
				 * It's possible that we fail to build a DistributionKey
				 * representation for the distribution policy.
				 */</comment>
				<expr_stmt><expr><call><name>CdbPathLocus_MakeStrewn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>, <argument><expr><name><name>policy</name><operator>-&gt;</operator><name>numsegments</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if>

		<comment type="block">/* Rows are distributed on an unknown criterion (uniformly, we hope!) */</comment>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>CdbPathLocus_MakeStrewn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>, <argument><expr><name><name>policy</name><operator>-&gt;</operator><name>numsegments</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>GpPolicyIsReplicated</name><argument_list>(<argument><expr><name>policy</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>CdbPathLocus_MakeSegmentGeneral</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>, <argument><expr><name><name>policy</name><operator>-&gt;</operator><name>numsegments</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<comment type="block">/* Normal catalog access */</comment>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>CdbPathLocus_MakeEntry</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>								<comment type="block">/* cdbpathlocus_from_baserel */</comment>

<comment type="block">/*
 * cdbpathlocus_from_baserel
 *
 * Returns a locus describing the distribution of a base relation.
 */</comment>
<function><type><name>CdbPathLocus</name></type>
<name>cdbpathlocus_from_baserel</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>PlannerInfo</name></name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
						  <parameter><decl><type><name><name>struct</name> <name>RelOptInfo</name></name> <modifier>*</modifier></type><name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>cdbpathlocus_from_policy</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>cdbpolicy</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>								<comment type="block">/* cdbpathlocus_from_baserel */</comment>


<comment type="block">/*
 * cdbpathlocus_from_exprs
 *
 * Returns a locus specifying hashed distribution on a list of exprs.
 */</comment>
<function><type><name>CdbPathLocus</name></type>
<name>cdbpathlocus_from_exprs</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>PlannerInfo</name></name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
						<parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>,
						<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>hash_on_exprs</name></decl></parameter>,
						<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>hash_opfamilies</name></decl></parameter>,
						<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>hash_sortrefs</name></decl></parameter>,
						<parameter><decl><type><name>int</name></type> <name>numsegments</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CdbPathLocus</name></type> <name>locus</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>distkeys</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>le</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>lof</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>lsr</name></decl>;</decl_stmt>

	<macro><name>forthree</name><argument_list>(<argument>le</argument>, <argument>hash_on_exprs</argument>, <argument>lof</argument>, <argument>hash_opfamilies</argument>, <argument>lsr</argument>, <argument>hash_sortrefs</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>le</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>opfamily</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>lof</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>sortref</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>lsr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>DistributionKey</name> <modifier>*</modifier></type><name>distkey</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>distkey</name> <operator>=</operator> <call><name>cdb_make_distkey_for_expr</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name>opfamily</name></expr></argument>, <argument><expr><name>sortref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>distkeys</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>distkeys</name></expr></argument>, <argument><expr><name>distkey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>CdbPathLocus_MakeHashed</name><argument_list>(<argument><expr><operator>&amp;</operator><name>locus</name></expr></argument>, <argument><expr><name>distkeys</name></expr></argument>, <argument><expr><name>numsegments</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>locus</name></expr>;</return>
</block_content>}</block></function>								<comment type="block">/* cdbpathlocus_from_exprs */</comment>

<comment type="block">/*
 * cdbpathlocus_from_subquery
 *
 * Returns a locus describing the distribution of a subquery.
 * The subquery plan should have been generated already.
 *
 * 'subqplan' is the subquery plan.
 * 'subqrelid' is the subquery RTE index in the current query level, for
 *      building Var nodes that reference the subquery's result columns.
 */</comment>
<function><type><name>CdbPathLocus</name></type>
<name>cdbpathlocus_from_subquery</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>PlannerInfo</name></name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
						   <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>,
						   <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>subpath</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CdbPathLocus</name></type> <name>locus</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>CdbPathLocus_IsHashed</name><argument_list>(<argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
		<call><name>CdbPathLocus_IsHashedOJ</name><argument_list>(<argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type>		<name>failed</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>distkeys</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>numsegments</name> <init>= <expr><name><name>subpath</name><operator>-&gt;</operator><name>locus</name><operator>.</operator><name>numsegments</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>dk_cell</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>usable_subtlist</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>new_vars</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc2</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>parentrel</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * If the subquery we're pulling up is a child of an append rel,
		 * the pathkey should refer to the parent rel's Vars, not the child.
		 * Normally, the planner puts the parent and child expressions in an
		 * equivalence class for any potentially useful expressions, but that's
		 * done earlier in the planning already.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>reloptkind</name></name> <operator>==</operator> <name>RELOPT_OTHER_MEMBER_REL</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>root</name><operator>-&gt;</operator><name>append_rel_array</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>root</name><operator>-&gt;</operator><name>append_rel_array</name><index>[<expr><name><name>rel</name><operator>-&gt;</operator><name>relid</name></name></expr>]</index></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> 
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"child rel %u not found in append_rel_array"</literal></expr></argument>, <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/* Direct looking for AppendRelInfos by relid in the append_rel_array */</comment>
			<decl_stmt><decl><type><name>AppendRelInfo</name> <modifier>*</modifier></type><name>appendrel</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>append_rel_array</name><index>[<expr><name><name>rel</name><operator>-&gt;</operator><name>relid</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Index</name></type> <name>parent_relid</name> <init>= <expr><name><name>appendrel</name><operator>-&gt;</operator><name>parent_relid</name></name></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name>parentrel</name> <operator>=</operator> <name><name>root</name><operator>-&gt;</operator><name>simple_rel_array</name><index>[<expr><name>parent_relid</name></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>parentrel</name><operator>-&gt;</operator><name>reltarget</name><operator>-&gt;</operator><name>exprs</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>reltarget</name><operator>-&gt;</operator><name>exprs</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>parentrel</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>lc2</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name><name>parentrel</name><operator>-&gt;</operator><name>reltarget</name><operator>-&gt;</operator><name>exprs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>rel-&gt;reltarget-&gt;exprs</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>var</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>subexpr</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>parentexpr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>parentrel</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>parentexpr</name> <operator>=</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>lc2</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>lc2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>var</name> <operator>=</operator> <operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr>;</expr_stmt>

			<comment type="block">/* ignore whole-row vars */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>subexpr</name> <operator>=</operator> <call><name>list_nth</name><argument_list>(<argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>pathtarget</name><operator>-&gt;</operator><name>exprs</name></name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>usable_subtlist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>usable_subtlist</name></expr></argument>,
									  <argument><expr><call><name>makeTargetEntry</name><argument_list>(<argument><expr><name>subexpr</name></expr></argument>,
													  <argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>usable_subtlist</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
													  <argument><expr><name>NULL</name></expr></argument>,
													  <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>new_vars</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>new_vars</name></expr></argument>, <argument><expr><ternary><condition><expr><name>parentrel</name></expr> ?</condition><then> <expr><name>parentexpr</name></expr> </then><else>: <expr><name>expr</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<macro><name>foreach</name> <argument_list>(<argument>dk_cell</argument>, <argument>subpath-&gt;locus.distkey</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>DistributionKey</name> <modifier>*</modifier></type><name>sub_dk</name> <init>= <expr><operator>(</operator><name>DistributionKey</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>dk_cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>ec_cell</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>DistributionKey</name> <modifier>*</modifier></type><name>outer_dk</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

			<macro><name>foreach</name> <argument_list>(<argument>ec_cell</argument>, <argument>sub_dk-&gt;dk_eclasses</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>EquivalenceClass</name> <modifier>*</modifier></type><name>sub_ec</name> <init>= <expr><operator>(</operator><name>EquivalenceClass</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>ec_cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>EquivalenceClass</name> <modifier>*</modifier></type><name>outer_ec</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>outer_ec</name> <operator>=</operator> <call><name>cdb_pull_up_eclass</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
											  <argument><expr><name>sub_ec</name></expr></argument>,
											  <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>,
											  <argument><expr><name>usable_subtlist</name></expr></argument>,
											  <argument><expr><name>new_vars</name></expr></argument>,
											  <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument> <comment type="block">/* not used */</comment>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>outer_ec</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>outer_dk</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>DistributionKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>outer_dk</name><operator>-&gt;</operator><name>dk_eclasses</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>outer_ec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>outer_dk</name><operator>-&gt;</operator><name>dk_opfamily</name></name> <operator>=</operator> <name><name>sub_dk</name><operator>-&gt;</operator><name>dk_opfamily</name></name></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block>

			<if_stmt><if>if <condition>(<expr><name>outer_dk</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>failed</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>distkeys</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>distkeys</name></expr></argument>, <argument><expr><name>outer_dk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<if_stmt><if>if <condition>(<expr><name>failed</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>CdbPathLocus_MakeStrewn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>locus</name></expr></argument>, <argument><expr><name>numsegments</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>CdbPathLocus_IsHashed</name><argument_list>(<argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>CdbPathLocus_MakeHashed</name><argument_list>(<argument><expr><operator>&amp;</operator><name>locus</name></expr></argument>, <argument><expr><name>distkeys</name></expr></argument>, <argument><expr><name>numsegments</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>CdbPathLocus_IsHashedOJ</name><argument_list>(<argument><expr><name><name>subpath</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>CdbPathLocus_MakeHashedOJ</name><argument_list>(<argument><expr><operator>&amp;</operator><name>locus</name></expr></argument>, <argument><expr><name>distkeys</name></expr></argument>, <argument><expr><name>numsegments</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>locus</name> <operator>=</operator> <name><name>subpath</name><operator>-&gt;</operator><name>locus</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<return>return <expr><name>locus</name></expr>;</return>
</block_content>}</block></function>								<comment type="block">/* cdbpathlocus_from_subquery */</comment>


<comment type="block">/*
 * cdbpathlocus_get_distkey_exprs
 *
 * Returns a List with one Expr for each distkey column.  Each item either is
 * in the given targetlist, or has no Var nodes that are not in the targetlist;
 * and uses only rels in the given set of relids.  Returns NIL if the
 * distkey cannot be expressed in terms of the given relids and targetlist.
 */</comment>
<function><type><name>void</name></type>
<name>cdbpathlocus_get_distkey_exprs</name><parameter_list>(<parameter><decl><type><name>CdbPathLocus</name></type> <name>locus</name></decl></parameter>,
							   <parameter><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>relids</name></decl></parameter>,
							   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>targetlist</name></decl></parameter>,
							   <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>exprs_p</name></decl></parameter>,
							   <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>opfamilies_p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>result_exprs</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>result_opfamilies</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>distkeycell</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>cdbpathlocus_is_valid</name><argument_list>(<argument><expr><name>locus</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>exprs_p</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>opfamilies_p</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>CdbPathLocus_IsHashed</name><argument_list>(<argument><expr><name>locus</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>CdbPathLocus_IsHashedOJ</name><argument_list>(<argument><expr><name>locus</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<macro><name>foreach</name><argument_list>(<argument>distkeycell</argument>, <argument>locus.distkey</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>DistributionKey</name> <modifier>*</modifier></type><name>distkey</name> <init>= <expr><operator>(</operator><name>DistributionKey</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>distkeycell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>ec_cell</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>item</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

			<macro><name>foreach</name><argument_list>(<argument>ec_cell</argument>, <argument>distkey-&gt;dk_eclasses</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>EquivalenceClass</name> <modifier>*</modifier></type><name>dk_eclass</name> <init>= <expr><operator>(</operator><name>EquivalenceClass</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>ec_cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name>item</name> <operator>=</operator> <call><name>cdbpullup_findEclassInTargetList</name><argument_list>(<argument><expr><name>dk_eclass</name></expr></argument>, <argument><expr><name>targetlist</name></expr></argument>,
														<argument><expr><name><name>distkey</name><operator>-&gt;</operator><name>dk_opfamily</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name>item</name></expr>)</condition><block type="pseudo"><block_content>
					<break>break;</break></block_content></block></if></if_stmt>
			</block_content>}</block>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>item</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return;</return></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>result_exprs</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>result_exprs</name></expr></argument>, <argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>result_opfamilies</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>result_opfamilies</name></expr></argument>, <argument><expr><name><name>distkey</name><operator>-&gt;</operator><name>dk_opfamily</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
		<expr_stmt><expr><operator>*</operator><name>exprs_p</name> <operator>=</operator> <name>result_exprs</name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>opfamilies_p</name> <operator>=</operator> <name>result_opfamilies</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>								<comment type="block">/* cdbpathlocus_get_distkey_exprs */</comment>


<comment type="block">/*
 * cdbpathlocus_pull_above_projection
 *
 * Given a targetlist, and a locus evaluable before the projection is
 * applied, returns an equivalent locus evaluable after the projection.
 * Returns a strewn locus if the necessary inputs are not projected.
 *
 * 'relids' is the set of relids that may occur in the targetlist exprs.
 * 'targetlist' specifies the projection.  It is a List of TargetEntry
 *      or merely a List of Expr.
 * 'newvarlist' is an optional List of Expr, in 1-1 correspondence with
 *      'targetlist'.  If specified, instead of creating a Var node to
 *      reference a targetlist item, we plug in a copy of the corresponding
 *      newvarlist item.
 * 'newrelid' is the RTE index of the projected result, for finding or
 *      building Var nodes that reference the projected columns.
 *      Ignored if 'newvarlist' is specified.
 */</comment>
<function><type><name>CdbPathLocus</name></type>
<name>cdbpathlocus_pull_above_projection</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>PlannerInfo</name></name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
								   <parameter><decl><type><name>CdbPathLocus</name></type> <name>locus</name></decl></parameter>,
								   <parameter><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>relids</name></decl></parameter>,
								   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>targetlist</name></decl></parameter>,
								   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>newvarlist</name></decl></parameter>,
								   <parameter><decl><type><name>Index</name></type> <name>newrelid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CdbPathLocus</name></type> <name>newlocus</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>cdbpathlocus_is_valid</name><argument_list>(<argument><expr><name>locus</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>CdbPathLocus_IsHashed</name><argument_list>(<argument><expr><name>locus</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>CdbPathLocus_IsHashedOJ</name><argument_list>(<argument><expr><name>locus</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>distkeycell</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>newdistkeys</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>numsegments</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Keep the numsegments unchanged.
		 */</comment>
		<expr_stmt><expr><name>numsegments</name> <operator>=</operator> <call><name>CdbPathLocus_NumSegments</name><argument_list>(<argument><expr><name>locus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* For each column of the distribution key... */</comment>
		<macro><name>foreach</name><argument_list>(<argument>distkeycell</argument>, <argument>locus.distkey</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>DistributionKey</name> <modifier>*</modifier></type><name>olddistkey</name> <init>= <expr><operator>(</operator><name>DistributionKey</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>distkeycell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>DistributionKey</name> <modifier>*</modifier></type><name>newdistkey</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

			<comment type="block">/* Get DistributionKey for key expr rewritten in terms of projection cols. */</comment>
			<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>ec_cell</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>EquivalenceClass</name> <modifier>*</modifier></type><name>new_ec</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

			<macro><name>foreach</name><argument_list>(<argument>ec_cell</argument>, <argument>olddistkey-&gt;dk_eclasses</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>EquivalenceClass</name> <modifier>*</modifier></type><name>old_ec</name> <init>= <expr><operator>(</operator><name>EquivalenceClass</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>ec_cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name>new_ec</name> <operator>=</operator> <call><name>cdb_pull_up_eclass</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
											<argument><expr><name>old_ec</name></expr></argument>,
											<argument><expr><name>relids</name></expr></argument>,
											<argument><expr><name>targetlist</name></expr></argument>,
											<argument><expr><name>newvarlist</name></expr></argument>,
											<argument><expr><name>newrelid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>new_ec</name></expr>)</condition><block type="pseudo"><block_content>
					<break>break;</break></block_content></block></if></if_stmt>
			</block_content>}</block>

			<comment type="block">/*
			 * NB: Targetlist might include columns from both sides of outer
			 * join "=" comparison, in which case cdb_pull_up_distribution_keys might
			 * succeed on keys from more than one distkeylist. The
			 * pulled-up locus could then be a HashedOJ locus, perhaps saving
			 * a Motion when an outer join is followed by UNION ALL followed
			 * by a join or aggregate.  For now, don't bother.
			 */</comment>

			<comment type="block">/*
			 * Fail if can't evaluate distribution key in the context of this
			 * targetlist.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>new_ec</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>CdbPathLocus_MakeStrewn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>newlocus</name></expr></argument>, <argument><expr><name>numsegments</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>newlocus</name></expr>;</return>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><name>newdistkey</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>DistributionKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>newdistkey</name><operator>-&gt;</operator><name>dk_eclasses</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>new_ec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>newdistkey</name><operator>-&gt;</operator><name>dk_opfamily</name></name> <operator>=</operator> <name><name>olddistkey</name><operator>-&gt;</operator><name>dk_opfamily</name></name></expr>;</expr_stmt>

			<comment type="block">/* Assemble new distkeys. */</comment>
			<expr_stmt><expr><name>newdistkeys</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>newdistkeys</name></expr></argument>, <argument><expr><name>newdistkey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<comment type="block">/* Build new locus. */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>CdbPathLocus_IsHashed</name><argument_list>(<argument><expr><name>locus</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>CdbPathLocus_MakeHashed</name><argument_list>(<argument><expr><operator>&amp;</operator><name>newlocus</name></expr></argument>, <argument><expr><name>newdistkeys</name></expr></argument>, <argument><expr><name>numsegments</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>CdbPathLocus_MakeHashedOJ</name><argument_list>(<argument><expr><operator>&amp;</operator><name>newlocus</name></expr></argument>, <argument><expr><name>newdistkeys</name></expr></argument>, <argument><expr><name>numsegments</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<return>return <expr><name>newlocus</name></expr>;</return>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><name>locus</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>								<comment type="block">/* cdbpathlocus_pull_above_projection */</comment>


<comment type="block">/*
 * cdbpathlocus_join
 *
 * Determine locus to describe the result of a join.  Any necessary Motion has
 * already been applied to the sources.
 */</comment>
<function><type><name>CdbPathLocus</name></type>
<name>cdbpathlocus_join</name><parameter_list>(<parameter><decl><type><name>JoinType</name></type> <name>jointype</name></decl></parameter>, <parameter><decl><type><name>CdbPathLocus</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>CdbPathLocus</name></type> <name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>acell</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>bcell</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CdbPathLocus</name></type> <name>resultlocus</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numsegments</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>cdbpathlocus_is_valid</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>cdbpathlocus_is_valid</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Do both input rels have same locus? */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>cdbpathlocus_equal</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>a</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * SingleQE may have different segment counts.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>CdbPathLocus_IsSingleQE</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<call><name>CdbPathLocus_IsSingleQE</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>CdbPathLocus_MakeSingleQE</name><argument_list>(<argument><expr><operator>&amp;</operator><name>resultlocus</name></expr></argument>,
								  <argument><expr><call><name>CdbPathLocus_CommonSegments</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>resultlocus</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>CdbPathLocus_IsGeneral</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>b</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>CdbPathLocus_IsGeneral</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>a</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If one rel is replicated, result stays with the other rel,
	 * but need to ensure the result is on the common segments.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>CdbPathLocus_IsReplicated</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>b</name><operator>.</operator><name>numsegments</name></name> <operator>=</operator> <call><name>CdbPathLocus_CommonSegments</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>b</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>CdbPathLocus_IsReplicated</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>a</name><operator>.</operator><name>numsegments</name></name> <operator>=</operator> <call><name>CdbPathLocus_CommonSegments</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>a</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If one rel is segmentgeneral, result stays with the other rel,
	 * but need to ensure the result is on the common segments.
	 *
	 * NB: the code check SegmentGeneral and replicated is quite similar,
	 * but we have to put check-segmentgeneral below. Consider one
	 * is segmentgeneral and the other is replicated, only by this order
	 * we can be sure that this function never return a locus of
	 * Replicated.
	 * update a replicated table join with a partitioned locus table will
	 * reach here.
	 */</comment>

	<if_stmt><if>if <condition>(<expr><call><name>CdbPathLocus_IsSegmentGeneral</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>b</name><operator>.</operator><name>numsegments</name></name> <operator>=</operator> <call><name>CdbPathLocus_CommonSegments</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>b</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>CdbPathLocus_IsSegmentGeneral</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>a</name><operator>.</operator><name>numsegments</name></name> <operator>=</operator> <call><name>CdbPathLocus_CommonSegments</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>a</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Both sides must be Hashed (or HashedOJ), then. And the distribution
	 * keys should be compatible; otherwise the caller should not be building
	 * a join directly between these two rels (a Motion would be needed).
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><call><name>CdbPathLocus_IsHashed</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>CdbPathLocus_IsHashedOJ</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not be construct join with non-hashed path"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><call><name>CdbPathLocus_IsHashed</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>CdbPathLocus_IsHashedOJ</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not be construct join with non-hashed path"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>a</name><operator>.</operator><name>distkey</name></name> <operator>==</operator> <name>NIL</name> <operator>||</operator>
		<call><name>list_length</name><argument_list>(<argument><expr><name><name>a</name><operator>.</operator><name>distkey</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>b</name><operator>.</operator><name>distkey</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not construct hashed join locus with incompatible distribution keys"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>CdbPathLocus_NumSegments</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>CdbPathLocus_NumSegments</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not construct hashed join locus with different number of segments"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>numsegments</name> <operator>=</operator> <call><name>CdbPathLocus_NumSegments</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * For a LEFT/RIGHT OUTER JOIN, we can use key of the outer, non-nullable
	 * side as is. There should not be any more joins with the nullable side
	 * above this join rel, so the inner side's keys are not interesting above
	 * this.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>jointype</name> <operator>==</operator> <name>JOIN_LEFT</name> <operator>||</operator>
		<name>jointype</name> <operator>==</operator> <name>JOIN_LASJ_NOTIN</name> <operator>||</operator>
		<name>jointype</name> <operator>==</operator> <name>JOIN_ANTI</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>resultlocus</name> <operator>=</operator> <name>a</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>jointype</name> <operator>==</operator> <name>JOIN_RIGHT</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>resultlocus</name> <operator>=</operator> <name>b</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * Not a LEFT/RIGHT JOIN. We don't usually get here with INNER JOINs
		 * either, because if you have an INNER JOIN on a equality predicate,
		 * they should form an EquivalenceClass, so that the distribution keys
		 * on both sides of the join refer to the same EquivalenceClass, and
		 * we exit already at the top of this function, at the
		 * "if(cdbpathlocus_equal(a, b)" test. The usual case that we get here
		 * is a FULL JOIN.
		 *
		 * I'm not sure what non-FULL corner cases there are that lead here.
		 * But it's safe to create a HashedOJ locus for them, anyway, because
		 * the promise of a HashedOJ is weaker than Hashed.
		 */</comment>

		<comment type="block">/* Zip the two distkey lists together to make a HashedOJ locus. */</comment>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>newdistkeys</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

		<macro><name>forboth</name><argument_list>(<argument>acell</argument>, <argument>a.distkey</argument>, <argument>bcell</argument>, <argument>b.distkey</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>DistributionKey</name> <modifier>*</modifier></type><name>adistkey</name> <init>= <expr><operator>(</operator><name>DistributionKey</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>acell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>DistributionKey</name> <modifier>*</modifier></type><name>bdistkey</name> <init>= <expr><operator>(</operator><name>DistributionKey</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>bcell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>DistributionKey</name> <modifier>*</modifier></type><name>newdistkey</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>adistkey</name><operator>-&gt;</operator><name>dk_opfamily</name></name> <operator>==</operator> <name><name>bdistkey</name><operator>-&gt;</operator><name>dk_opfamily</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>newdistkey</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>DistributionKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>newdistkey</name><operator>-&gt;</operator><name>dk_eclasses</name></name> <operator>=</operator> <call><name>list_union_ptr</name><argument_list>(<argument><expr><name><name>adistkey</name><operator>-&gt;</operator><name>dk_eclasses</name></name></expr></argument>,
													 <argument><expr><name><name>bdistkey</name><operator>-&gt;</operator><name>dk_eclasses</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>newdistkey</name><operator>-&gt;</operator><name>dk_opfamily</name></name> <operator>=</operator> <name><name>adistkey</name><operator>-&gt;</operator><name>dk_opfamily</name></name></expr>;</expr_stmt>

			<expr_stmt><expr><name>newdistkeys</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>newdistkeys</name></expr></argument>, <argument><expr><name>newdistkey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
		<expr_stmt><expr><call><name>CdbPathLocus_MakeHashedOJ</name><argument_list>(<argument><expr><operator>&amp;</operator><name>resultlocus</name></expr></argument>, <argument><expr><name>newdistkeys</name></expr></argument>, <argument><expr><name>numsegments</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>cdbpathlocus_is_valid</name><argument_list>(<argument><expr><name>resultlocus</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>resultlocus</name></expr>;</return>
</block_content>}</block></function>								<comment type="block">/* cdbpathlocus_join */</comment>

<comment type="block">/*
 * cdbpathlocus_is_hashed_on_exprs
 *
 * This function tests whether grouping on a given set of exprs can be done
 * in place without motion.
 *
 * For a hashed locus, returns false if the distkey has a column whose
 * equivalence class contains no expr belonging to the given list.
 *
 * If 'ignore_constants' is true, any constants in the locus are ignored.
 */</comment>
<function><type><name>bool</name></type>
<name>cdbpathlocus_is_hashed_on_exprs</name><parameter_list>(<parameter><decl><type><name>CdbPathLocus</name></type> <name>locus</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>exprlist</name></decl></parameter>,
								   <parameter><decl><type><name>bool</name></type> <name>ignore_constants</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>distkeycell</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>cdbpathlocus_is_valid</name><argument_list>(<argument><expr><name>locus</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>CdbPathLocus_IsHashed</name><argument_list>(<argument><expr><name>locus</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>CdbPathLocus_IsHashedOJ</name><argument_list>(<argument><expr><name>locus</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<macro><name>foreach</name><argument_list>(<argument>distkeycell</argument>, <argument>locus.distkey</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>DistributionKey</name> <modifier>*</modifier></type><name>distkey</name> <init>= <expr><operator>(</operator><name>DistributionKey</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>distkeycell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>distkeyeccell</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

			<macro><name>foreach</name><argument_list>(<argument>distkeyeccell</argument>, <argument>distkey-&gt;dk_eclasses</argument>)</argument_list></macro>
			<block>{<block_content>
				<comment type="block">/* Does some expr in distkey match some item in exprlist? */</comment>
				<decl_stmt><decl><type><name>EquivalenceClass</name> <modifier>*</modifier></type><name>dk_eclass</name> <init>= <expr><operator>(</operator><name>EquivalenceClass</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>distkeyeccell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>i</name></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name>ignore_constants</name> <operator>&amp;&amp;</operator> <call><name>CdbEquivClassIsConstant</name><argument_list>(<argument><expr><name>dk_eclass</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>

				<macro><name>foreach</name><argument_list>(<argument>i</argument>, <argument>dk_eclass-&gt;ec_members</argument>)</argument_list></macro>
				<block>{<block_content>
					<decl_stmt><decl><type><name>EquivalenceMember</name> <modifier>*</modifier></type><name>em</name> <init>= <expr><operator>(</operator><name>EquivalenceMember</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><call><name>list_member</name><argument_list>(<argument><expr><name>exprlist</name></expr></argument>, <argument><expr><name><name>em</name><operator>-&gt;</operator><name>em_expr</name></name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
						<break>break;</break>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block>
				<if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition><block type="pseudo"><block_content>
					<break>break;</break></block_content></block></if></if_stmt>
			</block_content>}</block>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block>
		<comment type="block">/* Every column of the distkey contains an expr in exprlist. */</comment>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><operator>!</operator><call><name>CdbPathLocus_IsStrewn</name><argument_list>(<argument><expr><name>locus</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>								<comment type="block">/* cdbpathlocus_is_hashed_on_exprs */</comment>

<comment type="block">/*
 * cdbpathlocus_is_hashed_on_eclasses
 *
 * This function tests whether grouping on a given set of exprs can be done
 * in place without motion.
 *
 * For a hashed locus, returns false if the distribution key has any column whose
 * equivalence class is not in 'eclasses' list.
 *
 * If 'ignore_constants' is true, any constants in the locus are ignored.
 */</comment>
<function><type><name>bool</name></type>
<name>cdbpathlocus_is_hashed_on_eclasses</name><parameter_list>(<parameter><decl><type><name>CdbPathLocus</name></type> <name>locus</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>eclasses</name></decl></parameter>,
								   <parameter><decl><type><name>bool</name></type> <name>ignore_constants</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>distkeycell</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>cdbpathlocus_is_valid</name><argument_list>(<argument><expr><name>locus</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>CdbPathLocus_IsHashed</name><argument_list>(<argument><expr><name>locus</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>CdbPathLocus_IsHashedOJ</name><argument_list>(<argument><expr><name>locus</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<macro><name>foreach</name><argument_list>(<argument>distkeycell</argument>, <argument>locus.distkey</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>DistributionKey</name> <modifier>*</modifier></type><name>distkey</name> <init>= <expr><operator>(</operator><name>DistributionKey</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>distkeycell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>distkeyeccell</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

			<macro><name>foreach</name><argument_list>(<argument>distkeyeccell</argument>, <argument>distkey-&gt;dk_eclasses</argument>)</argument_list></macro>
			<block>{<block_content>
				<comment type="block">/* Does distkey have an eclass that's not in 'eclasses'? */</comment>
				<decl_stmt><decl><type><name>EquivalenceClass</name> <modifier>*</modifier></type><name>dk_ec</name> <init>= <expr><operator>(</operator><name>EquivalenceClass</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>distkeyeccell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>eccell</name></decl>;</decl_stmt>

				<while>while <condition>(<expr><name><name>dk_ec</name><operator>-&gt;</operator><name>ec_merged</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>dk_ec</name> <operator>=</operator> <name><name>dk_ec</name><operator>-&gt;</operator><name>ec_merged</name></name></expr>;</expr_stmt></block_content></block></while>

				<if_stmt><if>if <condition>(<expr><name>ignore_constants</name> <operator>&amp;&amp;</operator> <call><name>CdbEquivClassIsConstant</name><argument_list>(<argument><expr><name>dk_ec</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>

				<macro><name>foreach</name><argument_list>(<argument>eccell</argument>, <argument>eclasses</argument>)</argument_list></macro>
				<block>{<block_content>
					<decl_stmt><decl><type><name>EquivalenceClass</name> <modifier>*</modifier></type><name>ec</name> <init>= <expr><operator>(</operator><name>EquivalenceClass</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>eccell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<while>while <condition>(<expr><name><name>ec</name><operator>-&gt;</operator><name>ec_merged</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>ec</name> <operator>=</operator> <name><name>ec</name><operator>-&gt;</operator><name>ec_merged</name></name></expr>;</expr_stmt></block_content></block></while>

					<if_stmt><if>if <condition>(<expr><name>ec</name> <operator>==</operator> <name>dk_ec</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
						<break>break;</break>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block>
				<if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition><block type="pseudo"><block_content>
					<break>break;</break></block_content></block></if></if_stmt>
			</block_content>}</block>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block>
		<comment type="block">/* Every column of the distribution key contains an expr in exprlist. */</comment>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><operator>!</operator><call><name>CdbPathLocus_IsStrewn</name><argument_list>(<argument><expr><name>locus</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>								<comment type="block">/* cdbpathlocus_is_hashed_on_exprs */</comment>

<comment type="block">/*
 * cdbpathlocus_is_hashed_on_tlist
 *
 * This function tests whether grouping on a given set of exprs can be done
 * in place without motion.
 *
 * For a hashed locus, returns false if the distkey has a column whose
 * equivalence class contains no expr belonging to the given list.
 *
 * If 'ignore_constants' is true, any constants in the locus are ignored.
 */</comment>
<function><type><name>bool</name></type>
<name>cdbpathlocus_is_hashed_on_tlist</name><parameter_list>(<parameter><decl><type><name>CdbPathLocus</name></type> <name>locus</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>tlist</name></decl></parameter>,
								<parameter><decl><type><name>bool</name></type> <name>ignore_constants</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>distkeycell</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>cdbpathlocus_is_valid</name><argument_list>(<argument><expr><name>locus</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>CdbPathLocus_IsHashed</name><argument_list>(<argument><expr><name>locus</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>CdbPathLocus_IsHashedOJ</name><argument_list>(<argument><expr><name>locus</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<macro><name>foreach</name><argument_list>(<argument>distkeycell</argument>, <argument>locus.distkey</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>DistributionKey</name> <modifier>*</modifier></type><name>distkey</name> <init>= <expr><operator>(</operator><name>DistributionKey</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>distkeycell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>distkeyeccell</name></decl>;</decl_stmt>

			<macro><name>foreach</name><argument_list>(<argument>distkeyeccell</argument>, <argument>distkey-&gt;dk_eclasses</argument>)</argument_list></macro>
			<block>{<block_content>
				<comment type="block">/* Does some expr in distkey match some item in exprlist? */</comment>
				<decl_stmt><decl><type><name>EquivalenceClass</name> <modifier>*</modifier></type><name>dk_eclass</name> <init>= <expr><operator>(</operator><name>EquivalenceClass</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>distkeyeccell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>i</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>bool</name></type>		<name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name>ignore_constants</name> <operator>&amp;&amp;</operator> <call><name>CdbEquivClassIsConstant</name><argument_list>(<argument><expr><name>dk_eclass</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<continue>continue;</continue>
				</block_content>}</block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>dk_eclass</name><operator>-&gt;</operator><name>ec_sortref</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<macro><name>foreach</name><argument_list>(<argument>i</argument>, <argument>tlist</argument>)</argument_list></macro>
					<block>{<block_content>
						<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

						<if_stmt><if>if <condition>(<expr><name><name>tle</name><operator>-&gt;</operator><name>ressortgroupref</name></name> <operator>==</operator> <name><name>dk_eclass</name><operator>-&gt;</operator><name>ec_sortref</name></name></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
							<break>break;</break>
						</block_content>}</block></if></if_stmt>
					</block_content>}</block>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<macro><name>foreach</name><argument_list>(<argument>i</argument>, <argument>dk_eclass-&gt;ec_members</argument>)</argument_list></macro>
					<block>{<block_content>
						<decl_stmt><decl><type><name>EquivalenceMember</name> <modifier>*</modifier></type><name>em</name> <init>= <expr><operator>(</operator><name>EquivalenceMember</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
						<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>ltl</name></decl>;</decl_stmt>

						<macro><name>foreach</name><argument_list>(<argument>ltl</argument>, <argument>tlist</argument>)</argument_list></macro>
						<block>{<block_content>
							<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>ltl</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

							<if_stmt><if>if <condition>(<expr><call><name>equal</name><argument_list>(<argument><expr><name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name><name>em</name><operator>-&gt;</operator><name>em_expr</name></name></expr></argument>)</argument_list></call></expr>)</condition>
							<block>{<block_content>
								<expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
								<break>break;</break>
							</block_content>}</block></if></if_stmt>
						</block_content>}</block>
						<if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition><block type="pseudo"><block_content>
							<break>break;</break></block_content></block></if></if_stmt>
					</block_content>}</block>
				</block_content>}</block></else></if_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
			</block_content>}</block>
		</block_content>}</block>
		<comment type="block">/* Every column of the distkey contains an expr in exprlist. */</comment>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><operator>!</operator><call><name>CdbPathLocus_IsStrewn</name><argument_list>(<argument><expr><name>locus</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * cdbpathlocus_is_hashed_on_relids
 *
 * Used when a subquery predicate (such as "x IN (SELECT ...)") has been
 * flattened into a join with the tables of the current query.  A row of
 * the cross-product of the current query's tables might join with more
 * than one row from the subquery and thus be duplicated.  Removing such
 * duplicates after the join is called deduping.  If a row's duplicates
 * might occur in more than one partition, a Motion operator will be
 * needed to bring them together.  This function tests whether the join
 * result (whose locus is given) can be deduped in place without motion.
 *
 * For a hashed locus, returns false if the distkey has a column whose
 * equivalence class contains no Var node belonging to the given set of
 * relids.  Caller should specify the relids of the non-subquery tables.
 */</comment>
<function><type><name>bool</name></type>
<name>cdbpathlocus_is_hashed_on_relids</name><parameter_list>(<parameter><decl><type><name>CdbPathLocus</name></type> <name>locus</name></decl></parameter>, <parameter><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>relids</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>cdbpathlocus_is_valid</name><argument_list>(<argument><expr><name>locus</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>CdbPathLocus_IsHashed</name><argument_list>(<argument><expr><name>locus</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>CdbPathLocus_IsHashedOJ</name><argument_list>(<argument><expr><name>locus</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc1</name></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>lc1</argument>, <argument>locus.distkey</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>DistributionKey</name> <modifier>*</modifier></type><name>distkey</name> <init>= <expr><operator>(</operator><name>DistributionKey</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc2</name></decl>;</decl_stmt>

			<macro><name>foreach</name><argument_list>(<argument>lc2</argument>, <argument>distkey-&gt;dk_eclasses</argument>)</argument_list></macro>
			<block>{<block_content>
				<comment type="block">/* Does distribution key contain a Var whose varno is in relids? */</comment>
				<decl_stmt><decl><type><name>EquivalenceClass</name> <modifier>*</modifier></type><name>dk_eclass</name> <init>= <expr><operator>(</operator><name>EquivalenceClass</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc3</name></decl>;</decl_stmt>

				<macro><name>foreach</name><argument_list>(<argument>lc3</argument>, <argument>dk_eclass-&gt;ec_members</argument>)</argument_list></macro>
				<block>{<block_content>
					<decl_stmt><decl><type><name>EquivalenceMember</name> <modifier>*</modifier></type><name>em</name> <init>= <expr><operator>(</operator><name>EquivalenceMember</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc3</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>em</name><operator>-&gt;</operator><name>em_expr</name></name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>bms_is_subset</name><argument_list>(<argument><expr><name><name>em</name><operator>-&gt;</operator><name>em_relids</name></name></expr></argument>, <argument><expr><name>relids</name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
						<break>break;</break>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block>
				<if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition><block type="pseudo"><block_content>
					<break>break;</break></block_content></block></if></if_stmt>
			</block_content>}</block>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block>

		<comment type="block">/*
		 * Every column of the distkey contains a Var whose varno is in
		 * relids.
		 */</comment>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><operator>!</operator><call><name>CdbPathLocus_IsStrewn</name><argument_list>(<argument><expr><name>locus</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>								<comment type="block">/* cdbpathlocus_is_hashed_on_relids */</comment>


<comment type="block">/*
 * cdbpathlocus_is_valid
 *
 * Returns true if locus appears structurally valid.
 */</comment>
<function><type><name>bool</name></type>
<name>cdbpathlocus_is_valid</name><parameter_list>(<parameter><decl><type><name>CdbPathLocus</name></type> <name>locus</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>distkeycell</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CdbLocusType_IsValid</name><argument_list>(<argument><expr><name><name>locus</name><operator>.</operator><name>locustype</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>bad</name>;</goto></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CdbPathLocus_IsHashed</name><argument_list>(<argument><expr><name>locus</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>CdbPathLocus_IsHashedOJ</name><argument_list>(<argument><expr><name>locus</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>locus</name><operator>.</operator><name>distkey</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>bad</name>;</goto></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>CdbPathLocus_IsHashed</name><argument_list>(<argument><expr><name>locus</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>CdbPathLocus_IsHashedOJ</name><argument_list>(<argument><expr><name>locus</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>locus</name><operator>.</operator><name>distkey</name></name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>bad</name>;</goto></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name><name>locus</name><operator>.</operator><name>distkey</name></name></expr></argument>, <argument><expr><name>List</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>bad</name>;</goto></block_content></block></if></if_stmt>
		<macro><name>foreach</name><argument_list>(<argument>distkeycell</argument>, <argument>locus.distkey</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>DistributionKey</name> <modifier>*</modifier></type><name>item</name> <init>= <expr><operator>(</operator><name>DistributionKey</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>distkeycell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>item</name> <operator>||</operator> <operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>item</name></expr></argument>, <argument><expr><name>DistributionKey</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<goto>goto <name>bad</name>;</goto></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>dk_opfamily</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<goto>goto <name>bad</name>;</goto></block_content></block></if></if_stmt>
		</block_content>}</block>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Check that 'numsegments' is valid */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CdbPathLocus_IsGeneral</name><argument_list>(<argument><expr><name>locus</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<operator>!</operator><call><name>CdbPathLocus_IsEntry</name><argument_list>(<argument><expr><name>locus</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<operator>!</operator><call><name>CdbPathLocus_IsOuterQuery</name><argument_list>(<argument><expr><name>locus</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<name><name>locus</name><operator>.</operator><name>numsegments</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>bad</name>;</goto></block_content></block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>

<label><name>bad</name>:</label>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>								<comment type="block">/* cdbpathlocus_is_valid */</comment>
</unit>
