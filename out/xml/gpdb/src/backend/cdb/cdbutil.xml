<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/backend/cdb/cdbutil.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * cdbutil.c
 *	  Internal utility support functions for Greenplum Database/PostgreSQL.
 *
 * Portions Copyright (c) 2005-2011, Greenplum inc
 * Portions Copyright (c) 2012-Present VMware, Inc. or its affiliates.
 *
 *
 * IDENTIFICATION
 *	    src/backend/cdb/cdbutil.c
 *
 * NOTES
 *
 *	- According to src/backend/executor/execHeapScan.c
 *		"tuples returned by heap_getnext() are pointers onto disk
 *		pages and were not created with palloc() and so should not
 *		be pfree()'d"
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_SYS_RESOURCE_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/time.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/resource.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/param.h&gt;</cpp:file></cpp:include>			<comment type="block">/* for MAXHOSTNAMELEN */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/genam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/gp_segment_configuration.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/ip.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/fmgroids.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/gp_id.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/indexing.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbhash.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbutil.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbmotion.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbvars.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbgang.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbdisp_query.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/ml_ipc.h"</cpp:file></cpp:include>			<comment type="block">/* listener_setup */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbtm.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq-fe.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq-int.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbconn.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbfts.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/ipc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/proc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/fts.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/postmaster.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/namespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/gpexpand.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_CACHED_1_GANGS</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INCR_COUNT</name><parameter_list>(<parameter><type><name>cdbinfo</name></type></parameter>, <parameter><type><name>arg</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>(cdbinfo)-&gt;arg++; \
	(cdbinfo)-&gt;cdbs-&gt;arg++;</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DECR_COUNT</name><parameter_list>(<parameter><type><name>cdbinfo</name></type></parameter>, <parameter><type><name>arg</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>(cdbinfo)-&gt;arg--; \
	(cdbinfo)-&gt;cdbs-&gt;arg--; \
	Assert((cdbinfo)-&gt;arg &gt;= 0); \
	Assert((cdbinfo)-&gt;cdbs-&gt;arg &gt;= 0); \

#define GPSEGCONFIGDUMPFILE "gpsegconfig_dump"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GPSEGCONFIGDUMPFILETMP</name></cpp:macro> <cpp:value>"gpsegconfig_dump_tmp"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GPSEGCONFIGNUMATTR</name></cpp:macro> <cpp:value>9</cpp:value></cpp:define> 

<decl_stmt><decl><type><name>MemoryContext</name></type> <name>CdbComponentsContext</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>CdbComponentDatabases</name> <modifier>*</modifier></type><name>cdb_component_dbs</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Helper Functions
 */</comment>
<function_decl><type><specifier>static</specifier> <name>CdbComponentDatabases</name> <modifier>*</modifier></type><name>getCdbComponentInfo</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>cleanupComponentIdleQEs</name><parameter_list>(<parameter><decl><type><name>CdbComponentDatabaseInfo</name> <modifier>*</modifier></type><name>cdi</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>includeWriter</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>CdbComponentDatabaseInfoCompare</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>p1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>p2</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>GpSegConfigEntry</name> <modifier>*</modifier></type> <name>readGpSegConfigFromCatalog</name><parameter_list>(<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>total_dbs</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>GpSegConfigEntry</name> <modifier>*</modifier></type> <name>readGpSegConfigFromFTSFiles</name><parameter_list>(<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>total_dbs</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>getAddressesForDBid</name><parameter_list>(<parameter><decl><type><name>GpSegConfigEntry</name> <modifier>*</modifier></type><name>c</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>HTAB</name> <modifier>*</modifier></type><name>hostPrimaryCountHashTableInit</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>nextQEIdentifer</name><parameter_list>(<parameter><decl><type><name>CdbComponentDatabases</name> <modifier>*</modifier></type><name>cdbs</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>Datum</name></type> <name>gp_get_suboverflowed_backends</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><specifier>static</specifier> <name>HTAB</name> <modifier>*</modifier></type><name>segment_ip_cache_htab</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>numsegmentsFromQD</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<typedef>typedef <type><struct>struct <name>SegIpEntry</name>
<block>{
	<decl_stmt><decl><type><name>char</name></type>		<name><name>key</name><index>[<expr><name>NAMEDATALEN</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>hostinfo</name><index>[<expr><name>NI_MAXHOST</name></expr>]</index></name></decl>;</decl_stmt>
}</block></struct></type> <name>SegIpEntry</name>;</typedef>

<typedef>typedef <type><struct>struct <name>HostPrimaryCountEntry</name>
<block>{
	<decl_stmt><decl><type><name>char</name></type>		<name><name>hostname</name><index>[<expr><name>MAXHOSTNAMELEN</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>segmentCount</name></decl>;</decl_stmt>
}</block></struct></type> <name>HostPrimaryCountEntry</name>;</typedef>

<comment type="block">/*
 * Helper functions for fetching latest gp_segment_configuration outside of
 * the transaction.
 *
 * In phase 2 of 2PC, current xact has been marked to TRANS_COMMIT/ABORT, 
 * COMMIT_PREPARED or ABORT_PREPARED DTM are performed, if they failed,
 * dispather disconnect and destroy all gangs and fetch the latest segment
 * configurations to do RETRY_COMMIT_PREPARED or RETRY_ABORT_PREPARED,
 * however, postgres disallow catalog lookups outside of xacts.
 *
 * readGpSegConfigFromFTSFiles() notify FTS to dump the configs from catalog
 * to a flat file and then read configurations from that file.
 */</comment>
<function><type><specifier>static</specifier> <name>GpSegConfigEntry</name> <modifier>*</modifier></type>
<name>readGpSegConfigFromFTSFiles</name><parameter_list>(<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>total_dbs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FILE</name>	<modifier>*</modifier></type><name>fd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>		<name>idx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>		<name>array_size</name> <init>= <expr><literal type="number">500</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GpSegConfigEntry</name> <modifier>*</modifier></type><name>configs</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GpSegConfigEntry</name> <modifier>*</modifier></type><name>config</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>char</name></type>	<name><name>hostname</name><index>[<expr><name>MAXHOSTNAMELEN</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>	<name><name>address</name><index>[<expr><name>MAXHOSTNAMELEN</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>	<name><name>buf</name><index>[<expr><name>MAXHOSTNAMELEN</name> <operator>*</operator> <literal type="number">2</literal> <operator>+</operator> <literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>IsTransactionState</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* notify and wait FTS to finish a probe and update the dump file */</comment>
	<expr_stmt><expr><call><name>FtsNotifyProber</name><argument_list>()</argument_list></call></expr>;</expr_stmt>	

	<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>AllocateFile</name><argument_list>(<argument><expr><name>GPSEGCONFIGDUMPFILE</name></expr></argument>, <argument><expr><literal type="string">"r"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>fd</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not open gp_segment_configutation dump file:%s:%m"</literal></expr></argument>, <argument><expr><name>GPSEGCONFIGDUMPFILE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>configs</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>GpSegConfigEntry</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>array_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

	<while>while <condition>(<expr><call><name>fgets</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content> 
		<expr_stmt><expr><name>config</name> <operator>=</operator> <operator>&amp;</operator><name><name>configs</name><index>[<expr><name>idx</name></expr>]</index></name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>sscanf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%d %d %c %c %c %c %d %s %s"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>config</name><operator>-&gt;</operator><name>dbid</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>config</name><operator>-&gt;</operator><name>segindex</name></name></expr></argument>,
				   <argument><expr><operator>&amp;</operator><name><name>config</name><operator>-&gt;</operator><name>role</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>config</name><operator>-&gt;</operator><name>preferred_role</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>config</name><operator>-&gt;</operator><name>mode</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>config</name><operator>-&gt;</operator><name>status</name></name></expr></argument>,
				   <argument><expr><operator>&amp;</operator><name><name>config</name><operator>-&gt;</operator><name>port</name></name></expr></argument>, <argument><expr><name>hostname</name></expr></argument>, <argument><expr><name>address</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>GPSEGCONFIGNUMATTR</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>FreeFile</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid data in gp_segment_configuration dump file: %s:%m"</literal></expr></argument>, <argument><expr><name>GPSEGCONFIGDUMPFILE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name><name>config</name><operator>-&gt;</operator><name>hostname</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>hostname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>config</name><operator>-&gt;</operator><name>address</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>address</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>idx</name><operator>++</operator></expr>;</expr_stmt>
		<comment type="block">/*
		 * Expand CdbComponentDatabaseInfo array if we've used up
		 * currently allocated space
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>idx</name> <operator>&gt;=</operator> <name>array_size</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>array_size</name> <operator>=</operator> <name>array_size</name> <operator>*</operator> <literal type="number">2</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>configs</name> <operator>=</operator> <operator>(</operator><name>GpSegConfigEntry</name> <operator>*</operator><operator>)</operator>
				<call><name>repalloc</name><argument_list>(<argument><expr><name>configs</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>GpSegConfigEntry</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>array_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>FreeFile</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>total_dbs</name> <operator>=</operator> <name>idx</name></expr>;</expr_stmt>
	<return>return <expr><name>configs</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * writeGpSegConfigToFTSFiles() dump gp_segment_configuration to the file
 * GPSEGCONFIGDUMPFILE, in $PGDATA, only FTS process can use this function.
 *
 * write contents to GPSEGCONFIGDUMPFILETMP first, then rename it to
 * GPSEGCONFIGDUMPFILE, it makes lockless read and write concurrently.
 */</comment>
<function><type><name>void</name></type>
<name>writeGpSegConfigToFTSFiles</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FILE</name>	<modifier>*</modifier></type><name>fd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>		<name>idx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>		<name>total_dbs</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GpSegConfigEntry</name> <modifier>*</modifier></type><name>configs</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GpSegConfigEntry</name> <modifier>*</modifier></type><name>config</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsTransactionState</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>am_ftsprobe</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>AllocateFile</name><argument_list>(<argument><expr><name>GPSEGCONFIGDUMPFILETMP</name></expr></argument>, <argument><expr><literal type="string">"w+"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>fd</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not create tmp file: %s: %m"</literal></expr></argument>, <argument><expr><name>GPSEGCONFIGDUMPFILETMP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>configs</name> <operator>=</operator> <call><name>readGpSegConfigFromCatalog</name><argument_list>(<argument><expr><operator>&amp;</operator><name>total_dbs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

	<for>for <control>(<init><expr><name>idx</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>idx</name> <operator>&lt;</operator> <name>total_dbs</name></expr>;</condition> <incr><expr><name>idx</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>config</name> <operator>=</operator> <operator>&amp;</operator><name><name>configs</name><index>[<expr><name>idx</name></expr>]</index></name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><literal type="string">"%d %d %c %c %c %c %d %s %s\n"</literal></expr></argument>, <argument><expr><name><name>config</name><operator>-&gt;</operator><name>dbid</name></name></expr></argument>, <argument><expr><name><name>config</name><operator>-&gt;</operator><name>segindex</name></name></expr></argument>,
					<argument><expr><name><name>config</name><operator>-&gt;</operator><name>role</name></name></expr></argument>, <argument><expr><name><name>config</name><operator>-&gt;</operator><name>preferred_role</name></name></expr></argument>, <argument><expr><name><name>config</name><operator>-&gt;</operator><name>mode</name></name></expr></argument>, <argument><expr><name><name>config</name><operator>-&gt;</operator><name>status</name></name></expr></argument>,
					<argument><expr><name><name>config</name><operator>-&gt;</operator><name>port</name></name></expr></argument>, <argument><expr><name><name>config</name><operator>-&gt;</operator><name>hostname</name></name></expr></argument>, <argument><expr><name><name>config</name><operator>-&gt;</operator><name>address</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>FreeFile</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not dump gp_segment_configuration to file: %s: %m"</literal></expr></argument>, <argument><expr><name>GPSEGCONFIGDUMPFILE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>FreeFile</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* rename tmp file to permanent file */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>rename</name><argument_list>(<argument><expr><name>GPSEGCONFIGDUMPFILETMP</name></expr></argument>, <argument><expr><name>GPSEGCONFIGDUMPFILE</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not rename file %s to file %s: %m"</literal></expr></argument>,
			 <argument><expr><name>GPSEGCONFIGDUMPFILETMP</name></expr></argument>, <argument><expr><name>GPSEGCONFIGDUMPFILE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>GpSegConfigEntry</name> <modifier>*</modifier></type>
<name>readGpSegConfigFromCatalog</name><parameter_list>(<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>total_dbs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>					<name>idx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>					<name>array_size</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>				<name>isNull</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>				<name>attr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>			<name>gp_seg_config_rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>			<name>gp_seg_config_tuple</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type>			<name>gp_seg_config_scan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GpSegConfigEntry</name>	<modifier>*</modifier></type><name>configs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GpSegConfigEntry</name>	<modifier>*</modifier></type><name>config</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>array_size</name> <operator>=</operator> <literal type="number">500</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>configs</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>GpSegConfigEntry</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>array_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>gp_seg_config_rel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>GpSegmentConfigRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>gp_seg_config_scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>gp_seg_config_rel</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
											<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>gp_seg_config_tuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>gp_seg_config_scan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>config</name> <operator>=</operator> <operator>&amp;</operator><name><name>configs</name><index>[<expr><name>idx</name></expr>]</index></name></expr>;</expr_stmt>

		<comment type="block">/* dbid */</comment>
		<expr_stmt><expr><name>attr</name> <operator>=</operator> <call><name>heap_getattr</name><argument_list>(<argument><expr><name>gp_seg_config_tuple</name></expr></argument>, <argument><expr><name>Anum_gp_segment_configuration_dbid</name></expr></argument>, <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>gp_seg_config_rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>config</name><operator>-&gt;</operator><name>dbid</name></name> <operator>=</operator> <call><name>DatumGetInt16</name><argument_list>(<argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* content */</comment>
		<expr_stmt><expr><name>attr</name> <operator>=</operator> <call><name>heap_getattr</name><argument_list>(<argument><expr><name>gp_seg_config_tuple</name></expr></argument>, <argument><expr><name>Anum_gp_segment_configuration_content</name></expr></argument>, <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>gp_seg_config_rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>config</name><operator>-&gt;</operator><name>segindex</name></name><operator>=</operator> <call><name>DatumGetInt16</name><argument_list>(<argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* role */</comment>
		<expr_stmt><expr><name>attr</name> <operator>=</operator> <call><name>heap_getattr</name><argument_list>(<argument><expr><name>gp_seg_config_tuple</name></expr></argument>, <argument><expr><name>Anum_gp_segment_configuration_role</name></expr></argument>, <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>gp_seg_config_rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>config</name><operator>-&gt;</operator><name>role</name></name> <operator>=</operator> <call><name>DatumGetChar</name><argument_list>(<argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* preferred-role */</comment>
		<expr_stmt><expr><name>attr</name> <operator>=</operator> <call><name>heap_getattr</name><argument_list>(<argument><expr><name>gp_seg_config_tuple</name></expr></argument>, <argument><expr><name>Anum_gp_segment_configuration_preferred_role</name></expr></argument>, <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>gp_seg_config_rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>config</name><operator>-&gt;</operator><name>preferred_role</name></name> <operator>=</operator> <call><name>DatumGetChar</name><argument_list>(<argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* mode */</comment>
		<expr_stmt><expr><name>attr</name> <operator>=</operator> <call><name>heap_getattr</name><argument_list>(<argument><expr><name>gp_seg_config_tuple</name></expr></argument>, <argument><expr><name>Anum_gp_segment_configuration_mode</name></expr></argument>, <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>gp_seg_config_rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>config</name><operator>-&gt;</operator><name>mode</name></name> <operator>=</operator> <call><name>DatumGetChar</name><argument_list>(<argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* status */</comment>
		<expr_stmt><expr><name>attr</name> <operator>=</operator> <call><name>heap_getattr</name><argument_list>(<argument><expr><name>gp_seg_config_tuple</name></expr></argument>, <argument><expr><name>Anum_gp_segment_configuration_status</name></expr></argument>, <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>gp_seg_config_rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>config</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <call><name>DatumGetChar</name><argument_list>(<argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* hostname */</comment>
		<expr_stmt><expr><name>attr</name> <operator>=</operator> <call><name>heap_getattr</name><argument_list>(<argument><expr><name>gp_seg_config_tuple</name></expr></argument>, <argument><expr><name>Anum_gp_segment_configuration_hostname</name></expr></argument>, <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>gp_seg_config_rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>config</name><operator>-&gt;</operator><name>hostname</name></name> <operator>=</operator> <call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* address */</comment>
		<expr_stmt><expr><name>attr</name> <operator>=</operator> <call><name>heap_getattr</name><argument_list>(<argument><expr><name>gp_seg_config_tuple</name></expr></argument>, <argument><expr><name>Anum_gp_segment_configuration_address</name></expr></argument>, <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>gp_seg_config_rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>config</name><operator>-&gt;</operator><name>address</name></name> <operator>=</operator> <call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* port */</comment>
		<expr_stmt><expr><name>attr</name> <operator>=</operator> <call><name>heap_getattr</name><argument_list>(<argument><expr><name>gp_seg_config_tuple</name></expr></argument>, <argument><expr><name>Anum_gp_segment_configuration_port</name></expr></argument>, <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>gp_seg_config_rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>config</name><operator>-&gt;</operator><name>port</name></name> <operator>=</operator> <call><name>DatumGetInt32</name><argument_list>(<argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* datadir is not dumped*/</comment>

		<expr_stmt><expr><name>idx</name><operator>++</operator></expr>;</expr_stmt>

		<comment type="block">/*
		 * Expand CdbComponentDatabaseInfo array if we've used up
		 * currently allocated space
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>idx</name> <operator>&gt;=</operator> <name>array_size</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>array_size</name> <operator>=</operator> <name>array_size</name> <operator>*</operator> <literal type="number">2</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>configs</name> <operator>=</operator> <operator>(</operator><name>GpSegConfigEntry</name> <operator>*</operator><operator>)</operator>
				<call><name>repalloc</name><argument_list>(<argument><expr><name>configs</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>GpSegConfigEntry</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>array_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>

	<comment type="block">/*
	 * We're done with the catalog config, clean them up, closing all the
	 * relations we opened.
	 */</comment>
	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>gp_seg_config_scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>gp_seg_config_rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>total_dbs</name> <operator>=</operator> <name>idx</name></expr>;</expr_stmt>
	<return>return <expr><name>configs</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *  Internal function to initialize each component info
 */</comment>
<function><type><specifier>static</specifier> <name>CdbComponentDatabases</name> <modifier>*</modifier></type>
<name>getCdbComponentInfo</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldContext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CdbComponentDatabaseInfo</name> <modifier>*</modifier></type><name>cdbInfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CdbComponentDatabases</name> <modifier>*</modifier></type><name>component_databases</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GpSegConfigEntry</name> <modifier>*</modifier></type><name>configs</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>x</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>total_dbs</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HostPrimaryCountEntry</name> <modifier>*</modifier></type><name>hsEntry</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>CdbComponentsContext</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>CdbComponentsContext</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>, <argument><expr><literal type="string">"cdb components Context"</literal></expr></argument>,
								<argument><expr><name>ALLOCSET_DEFAULT_MINSIZE</name></expr></argument>,
								<argument><expr><name>ALLOCSET_DEFAULT_INITSIZE</name></expr></argument>,
								<argument><expr><name>ALLOCSET_DEFAULT_MAXSIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>oldContext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>CdbComponentsContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>HTAB</name>	   <modifier>*</modifier></type><name>hostPrimaryCountHash</name> <init>= <expr><call><name>hostPrimaryCountHashTableInit</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsTransactionState</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>configs</name> <operator>=</operator> <call><name>readGpSegConfigFromCatalog</name><argument_list>(<argument><expr><operator>&amp;</operator><name>total_dbs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>configs</name> <operator>=</operator> <call><name>readGpSegConfigFromFTSFiles</name><argument_list>(<argument><expr><operator>&amp;</operator><name>total_dbs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name>component_databases</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>CdbComponentDatabases</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>component_databases</name><operator>-&gt;</operator><name>numActiveQEs</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>component_databases</name><operator>-&gt;</operator><name>numIdleQEs</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>component_databases</name><operator>-&gt;</operator><name>qeCounter</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>component_databases</name><operator>-&gt;</operator><name>freeCounterList</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>component_databases</name><operator>-&gt;</operator><name>segment_db_info</name></name> <operator>=</operator>
		<operator>(</operator><name>CdbComponentDatabaseInfo</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>CdbComponentDatabaseInfo</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>total_dbs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>component_databases</name><operator>-&gt;</operator><name>entry_db_info</name></name> <operator>=</operator>
		<operator>(</operator><name>CdbComponentDatabaseInfo</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>CdbComponentDatabaseInfo</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>total_dbs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>CdbComponentDatabaseInfo</name>	<modifier>*</modifier></type><name>pRow</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>GpSegConfigEntry</name>	<modifier>*</modifier></type><name>config</name> <init>= <expr><operator>&amp;</operator><name><name>configs</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>config</name><operator>-&gt;</operator><name>hostname</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>config</name><operator>-&gt;</operator><name>hostname</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>MAXHOSTNAMELEN</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * We should never reach here, but add sanity check
			 * The reason we check length is we find MAXHOSTNAMELEN might be
			 * smaller than the ones defined in /etc/hosts. Those are rare cases.
			 */</comment>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				 <argument><expr><literal type="string">"Invalid length (%d) of hostname (%s)"</literal></expr></argument>,
				 <argument><expr><ternary><condition><expr><name><name>config</name><operator>-&gt;</operator><name>hostname</name></name> <operator>==</operator> <name>NULL</name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>config</name><operator>-&gt;</operator><name>hostname</name></name></expr></argument>)</argument_list></call></expr></else></ternary></expr></argument>,
				 <argument><expr><ternary><condition><expr><name><name>config</name><operator>-&gt;</operator><name>hostname</name></name> <operator>==</operator> <name>NULL</name></expr> ?</condition><then> <expr><literal type="string">""</literal></expr> </then><else>: <expr><name><name>config</name><operator>-&gt;</operator><name>hostname</name></name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* lookup hostip/hostaddrs cache */</comment>
		<expr_stmt><expr><name><name>config</name><operator>-&gt;</operator><name>hostip</name></name><operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>getAddressesForDBid</name><argument_list>(<argument><expr><name>config</name></expr></argument>, <argument><expr><ternary><condition><expr><operator>!</operator><name>am_ftsprobe</name></expr>?</condition><then> <expr><name>ERROR</name></expr> </then><else>: <expr><name>LOG</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * We make sure we get a valid hostip for primary here,
		 * if hostip for mirrors can not be get, ignore the error.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>config</name><operator>-&gt;</operator><name>hostaddrs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
			<name><name>config</name><operator>-&gt;</operator><name>role</name></name> <operator>==</operator> <name>GP_SEGMENT_CONFIGURATION_ROLE_PRIMARY</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><ternary><condition><expr><operator>!</operator><name>am_ftsprobe</name></expr> ?</condition><then> <expr><name>ERROR</name></expr> </then><else>: <expr><name>LOG</name></expr></else></ternary></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CONNECTION_FAILURE</name></expr></argument>)</argument_list></call><operator>,</operator>
					<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot resolve network address for dbid=%d"</literal></expr></argument>, <argument><expr><name><name>config</name><operator>-&gt;</operator><name>dbid</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>config</name><operator>-&gt;</operator><name>hostaddrs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>config</name><operator>-&gt;</operator><name>hostip</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name><name>config</name><operator>-&gt;</operator><name>hostaddrs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>AssertImply</name><argument_list>(<argument><expr><name><name>config</name><operator>-&gt;</operator><name>hostip</name></name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>config</name><operator>-&gt;</operator><name>hostip</name></name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <name>INET6_ADDRSTRLEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Determine which array to place this rows data in: entry or segment,
		 * based on the content field.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>config</name><operator>-&gt;</operator><name>segindex</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>pRow</name> <operator>=</operator> <operator>&amp;</operator><name><name>component_databases</name><operator>-&gt;</operator><name>segment_db_info</name><index>[<expr><name><name>component_databases</name><operator>-&gt;</operator><name>total_segment_dbs</name></name></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>component_databases</name><operator>-&gt;</operator><name>total_segment_dbs</name></name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>pRow</name> <operator>=</operator> <operator>&amp;</operator><name><name>component_databases</name><operator>-&gt;</operator><name>entry_db_info</name><index>[<expr><name><name>component_databases</name><operator>-&gt;</operator><name>total_entry_dbs</name></name></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>component_databases</name><operator>-&gt;</operator><name>total_entry_dbs</name></name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name><name>pRow</name><operator>-&gt;</operator><name>cdbs</name></name> <operator>=</operator> <name>component_databases</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pRow</name><operator>-&gt;</operator><name>config</name></name> <operator>=</operator> <name>config</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pRow</name><operator>-&gt;</operator><name>freelist</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pRow</name><operator>-&gt;</operator><name>activelist</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pRow</name><operator>-&gt;</operator><name>numIdleQEs</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pRow</name><operator>-&gt;</operator><name>numActiveQEs</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>config</name><operator>-&gt;</operator><name>role</name></name> <operator>!=</operator> <name>GP_SEGMENT_CONFIGURATION_ROLE_PRIMARY</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>hsEntry</name> <operator>=</operator> <operator>(</operator><name>HostPrimaryCountEntry</name> <operator>*</operator><operator>)</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>hostPrimaryCountHash</name></expr></argument>, <argument><expr><name><name>config</name><operator>-&gt;</operator><name>hostname</name></name></expr></argument>, <argument><expr><name>HASH_ENTER</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>hsEntry</name><operator>-&gt;</operator><name>segmentCount</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>hsEntry</name><operator>-&gt;</operator><name>segmentCount</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Validate that there exists at least one entry and one segment database
	 * in the configuration
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>component_databases</name><operator>-&gt;</operator><name>total_segment_dbs</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CARDINALITY_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"number of segment databases cannot be 0"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>component_databases</name><operator>-&gt;</operator><name>total_entry_dbs</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CARDINALITY_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"number of entry databases cannot be 0"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Now sort the data by segindex, isprimary desc
	 */</comment>
	<expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><name><name>component_databases</name><operator>-&gt;</operator><name>segment_db_info</name></name></expr></argument>,
		  <argument><expr><name><name>component_databases</name><operator>-&gt;</operator><name>total_segment_dbs</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>CdbComponentDatabaseInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>,
		  <argument><expr><name>CdbComponentDatabaseInfoCompare</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><name><name>component_databases</name><operator>-&gt;</operator><name>entry_db_info</name></name></expr></argument>,
		  <argument><expr><name><name>component_databases</name><operator>-&gt;</operator><name>total_entry_dbs</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>CdbComponentDatabaseInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>,
		  <argument><expr><name>CdbComponentDatabaseInfoCompare</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Now count the number of distinct segindexes. Since it's sorted, this is
	 * easy.
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>component_databases</name><operator>-&gt;</operator><name>total_segment_dbs</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
			<operator>(</operator><name><name>component_databases</name><operator>-&gt;</operator><name>segment_db_info</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>config</name><operator>-&gt;</operator><name>segindex</name></name> <operator>!=</operator> <name><name>component_databases</name><operator>-&gt;</operator><name>segment_db_info</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name><name>config</name><operator>-&gt;</operator><name>segindex</name></name><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>component_databases</name><operator>-&gt;</operator><name>total_segments</name></name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Now validate that our identity is present in the entry databases
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>component_databases</name><operator>-&gt;</operator><name>total_entry_dbs</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>cdbInfo</name> <operator>=</operator> <operator>&amp;</operator><name><name>component_databases</name><operator>-&gt;</operator><name>entry_db_info</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>cdbInfo</name><operator>-&gt;</operator><name>config</name><operator>-&gt;</operator><name>dbid</name></name> <operator>==</operator> <name><name>GpIdentity</name><operator>.</operator><name>dbid</name></name> <operator>&amp;&amp;</operator> <name><name>cdbInfo</name><operator>-&gt;</operator><name>config</name><operator>-&gt;</operator><name>segindex</name></name> <operator>==</operator> <name><name>GpIdentity</name><operator>.</operator><name>segindex</name></name></expr>)</condition>
		<block>{<block_content>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
	<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <name><name>component_databases</name><operator>-&gt;</operator><name>total_entry_dbs</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATA_EXCEPTION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot locate entry database"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Entry database represented by this db in gp_segment_configuration: dbid %d content %d"</literal></expr></argument>,
						   <argument><expr><name><name>GpIdentity</name><operator>.</operator><name>dbid</name></name></expr></argument>, <argument><expr><name><name>GpIdentity</name><operator>.</operator><name>segindex</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Now validate that the segindexes for the segment databases are between
	 * 0 and (numsegments - 1) inclusive, and that we hit them all.
	 * Since it's sorted, this is relatively easy.
	 */</comment>
	<expr_stmt><expr><name>x</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>component_databases</name><operator>-&gt;</operator><name>total_segments</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>this_segindex</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

		<while>while <condition>(<expr><name>x</name> <operator>&lt;</operator> <name><name>component_databases</name><operator>-&gt;</operator><name>total_segment_dbs</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>this_segindex</name> <operator>=</operator> <name><name>component_databases</name><operator>-&gt;</operator><name>segment_db_info</name><index>[<expr><name>x</name></expr>]</index></name><operator>.</operator><name><name>config</name><operator>-&gt;</operator><name>segindex</name></name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>this_segindex</name> <operator>&lt;</operator> <name>i</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>x</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><name>this_segindex</name> <operator>==</operator> <name>i</name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><name>this_segindex</name> <operator>&gt;</operator> <name>i</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATA_EXCEPTION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"content values not valid in %s table"</literal></expr></argument>,
								<argument><expr><name>GpSegmentConfigRelationName</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Content values must be in the range 0 to %d inclusive."</literal></expr></argument>,
								   <argument><expr><name><name>component_databases</name><operator>-&gt;</operator><name>total_segments</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></while>
		<if_stmt><if>if <condition>(<expr><name>this_segindex</name> <operator>!=</operator> <name>i</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATA_EXCEPTION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"content values not valid in %s table"</literal></expr></argument>,
							<argument><expr><name>GpSegmentConfigRelationName</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Content values must be in the range 0 to %d inclusive"</literal></expr></argument>,
							   <argument><expr><name><name>component_databases</name><operator>-&gt;</operator><name>total_segments</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>component_databases</name><operator>-&gt;</operator><name>total_segment_dbs</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>cdbInfo</name> <operator>=</operator> <operator>&amp;</operator><name><name>component_databases</name><operator>-&gt;</operator><name>segment_db_info</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>cdbInfo</name><operator>-&gt;</operator><name>config</name><operator>-&gt;</operator><name>role</name></name> <operator>!=</operator> <name>GP_SEGMENT_CONFIGURATION_ROLE_PRIMARY</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>hsEntry</name> <operator>=</operator> <operator>(</operator><name>HostPrimaryCountEntry</name> <operator>*</operator><operator>)</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>hostPrimaryCountHash</name></expr></argument>, <argument><expr><name><name>cdbInfo</name><operator>-&gt;</operator><name>config</name><operator>-&gt;</operator><name>hostname</name></name></expr></argument>, <argument><expr><name>HASH_FIND</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cdbInfo</name><operator>-&gt;</operator><name>hostPrimaryCount</name></name> <operator>=</operator> <name><name>hsEntry</name><operator>-&gt;</operator><name>segmentCount</name></name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>component_databases</name><operator>-&gt;</operator><name>total_entry_dbs</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>cdbInfo</name> <operator>=</operator> <operator>&amp;</operator><name><name>component_databases</name><operator>-&gt;</operator><name>entry_db_info</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>cdbInfo</name><operator>-&gt;</operator><name>config</name><operator>-&gt;</operator><name>role</name></name> <operator>!=</operator> <name>GP_SEGMENT_CONFIGURATION_ROLE_PRIMARY</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>hsEntry</name> <operator>=</operator> <operator>(</operator><name>HostPrimaryCountEntry</name> <operator>*</operator><operator>)</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>hostPrimaryCountHash</name></expr></argument>, <argument><expr><name><name>cdbInfo</name><operator>-&gt;</operator><name>config</name><operator>-&gt;</operator><name>hostname</name></name></expr></argument>, <argument><expr><name>HASH_FIND</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cdbInfo</name><operator>-&gt;</operator><name>hostPrimaryCount</name></name> <operator>=</operator> <name><name>hsEntry</name><operator>-&gt;</operator><name>segmentCount</name></name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>hash_destroy</name><argument_list>(<argument><expr><name>hostPrimaryCountHash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>component_databases</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Helper function to clean up the idle segdbs list of
 * a segment component.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>cleanupComponentIdleQEs</name><parameter_list>(<parameter><decl><type><name>CdbComponentDatabaseInfo</name> <modifier>*</modifier></type><name>cdi</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>includeWriter</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SegmentDatabaseDescriptor</name>	<modifier>*</modifier></type><name>segdbDesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type>				<name>oldContext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> 					<modifier>*</modifier></type><name>curItem</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>					<modifier>*</modifier></type><name>nextItem</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> 					<modifier>*</modifier></type><name>prevItem</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>CdbComponentsContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>oldContext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>CdbComponentsContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>curItem</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name><name>cdi</name><operator>-&gt;</operator><name>freelist</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><name>curItem</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>segdbDesc</name> <operator>=</operator> <operator>(</operator><name>SegmentDatabaseDescriptor</name> <operator>*</operator><operator>)</operator><call><name>lfirst</name><argument_list>(<argument><expr><name>curItem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>nextItem</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>curItem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>segdbDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>segdbDesc</name><operator>-&gt;</operator><name>isWriter</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name>includeWriter</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>prevItem</name> <operator>=</operator> <name>curItem</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>curItem</name> <operator>=</operator> <name>nextItem</name></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name><name>cdi</name><operator>-&gt;</operator><name>freelist</name></name> <operator>=</operator> <call><name>list_delete_cell</name><argument_list>(<argument><expr><name><name>cdi</name><operator>-&gt;</operator><name>freelist</name></name></expr></argument>, <argument><expr><name>curItem</name></expr></argument>, <argument><expr><name>prevItem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
		<expr_stmt><expr><call><name>DECR_COUNT</name><argument_list>(<argument><expr><name>cdi</name></expr></argument>, <argument><expr><name>numIdleQEs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>cdbconn_termSegmentDescriptor</name><argument_list>(<argument><expr><name>segdbDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>curItem</name> <operator>=</operator> <name>nextItem</name></expr>;</expr_stmt>

	</block_content>}</block></while>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>cdbcomponent_cleanupIdleQEs</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>includeWriter</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CdbComponentDatabases</name>	<modifier>*</modifier></type><name>cdbs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>						<name>i</name></decl>;</decl_stmt>

	<comment type="block">/* use cdb_component_dbs directly */</comment>
	<expr_stmt><expr><name>cdbs</name> <operator>=</operator> <name>cdb_component_dbs</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>cdbs</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>		
		<return>return;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>cdbs</name><operator>-&gt;</operator><name>segment_db_info</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>cdbs</name><operator>-&gt;</operator><name>total_segment_dbs</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>CdbComponentDatabaseInfo</name> <modifier>*</modifier></type><name>cdi</name> <init>= <expr><operator>&amp;</operator><name><name>cdbs</name><operator>-&gt;</operator><name>segment_db_info</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>cleanupComponentIdleQEs</name><argument_list>(<argument><expr><name>cdi</name></expr></argument>, <argument><expr><name>includeWriter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>cdbs</name><operator>-&gt;</operator><name>entry_db_info</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>cdbs</name><operator>-&gt;</operator><name>total_entry_dbs</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>CdbComponentDatabaseInfo</name> <modifier>*</modifier></type><name>cdi</name> <init>= <expr><operator>&amp;</operator><name><name>cdbs</name><operator>-&gt;</operator><name>entry_db_info</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>cleanupComponentIdleQEs</name><argument_list>(<argument><expr><name>cdi</name></expr></argument>, <argument><expr><name>includeWriter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>

	<return>return;</return>
</block_content>}</block></function>

<comment type="block">/* 
 * This function is called when a transaction is started and the snapshot of
 * segments info will not changed until the end of transaction
 */</comment>
<function><type><name>void</name></type>
<name>cdbcomponent_updateCdbComponents</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint8</name></type> <name>ftsVersion</name><init>= <expr><call><name>getFtsVersion</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>expandVersion</name> <init>= <expr><call><name>GetGpExpandVersion</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * FTS takes responsibility for updating gp_segment_configuration, in each
	 * fts probe cycle, FTS firstly gets a copy of current configuration, then
	 * probe the segments based on it and finally free the copy in the end. In
	 * the probe stage, FTS might start/close transactions many times, so FTS
	 * should not update current copy of gp_segment_configuration when a new
	 * transaction is started.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>am_ftsprobe</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>cdb_component_dbs</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>cdb_component_dbs</name> <operator>=</operator> <call><name>getCdbComponentInfo</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>cdb_component_dbs</name><operator>-&gt;</operator><name>fts_version</name></name> <operator>=</operator> <name>ftsVersion</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>cdb_component_dbs</name><operator>-&gt;</operator><name>expand_version</name></name> <operator>=</operator> <call><name>GetGpExpandVersion</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><operator>(</operator><name><name>cdb_component_dbs</name><operator>-&gt;</operator><name>fts_version</name></name> <operator>!=</operator> <name>ftsVersion</name> <operator>||</operator>
				 <name><name>cdb_component_dbs</name><operator>-&gt;</operator><name>expand_version</name></name> <operator>!=</operator> <name>expandVersion</name><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>TempNamespaceOidIsValid</name><argument_list>()</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * Do not update here, otherwise, temp files will be lost 
				 * in segments;
				 */</comment>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><call><name>ELOG_DISPATCHER_DEBUG</name><argument_list>(<argument><expr><literal type="string">"FTS rescanned, get new component databases info."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>cdbcomponent_destroyCdbComponents</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>cdb_component_dbs</name> <operator>=</operator> <call><name>getCdbComponentInfo</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>cdb_component_dbs</name><operator>-&gt;</operator><name>fts_version</name></name> <operator>=</operator> <name>ftsVersion</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>cdb_component_dbs</name><operator>-&gt;</operator><name>expand_version</name></name> <operator>=</operator> <name>expandVersion</name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<expr_stmt><expr><call><name>FtsNotifyProber</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>cdb_component_dbs</name><operator>-&gt;</operator><name>numActiveQEs</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * cdbcomponent_getCdbComponents 
 *
 *
 * Storage for the SegmentInstances block and all subsidiary
 * structures are allocated from the caller's context.
 */</comment>
<function><type><name>CdbComponentDatabases</name> <modifier>*</modifier></type>
<name>cdbcomponent_getCdbComponents</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>cdb_component_dbs</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>cdb_component_dbs</name> <operator>=</operator> <call><name>getCdbComponentInfo</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>cdb_component_dbs</name><operator>-&gt;</operator><name>fts_version</name></name> <operator>=</operator> <call><name>getFtsVersion</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>cdb_component_dbs</name><operator>-&gt;</operator><name>expand_version</name></name> <operator>=</operator> <call><name>GetGpExpandVersion</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>FtsNotifyProber</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>cdb_component_dbs</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * cdbcomponet_destroyCdbComponents 
 *
 * Disconnect and destroy all idle QEs, releases the memory
 * occupied by the CdbComponentDatabases
 *
 * callers must clean up QEs used by dispatcher states.
 */</comment>
<function><type><name>void</name></type>
<name>cdbcomponent_destroyCdbComponents</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* caller must clean up all segdbs used by dispatcher states */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>cdbcomponent_activeQEsExist</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>hash_destroy</name><argument_list>(<argument><expr><name>segment_ip_cache_htab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>segment_ip_cache_htab</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/* disconnect and destroy idle QEs include writers */</comment>
	<expr_stmt><expr><call><name>cdbcomponent_cleanupIdleQEs</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* delete the memory context */</comment>
	<if_stmt><if>if <condition>(<expr><name>CdbComponentsContext</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name>CdbComponentsContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>	
	<expr_stmt><expr><name>CdbComponentsContext</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>cdb_component_dbs</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Allocated a segdb
 *
 * If there is idle segdb in the freelist, return it, otherwise, initialize
 * a new segdb.
 *
 * idle segdbs has an established connection with segment, but new segdb is
 * not setup yet, callers need to establish the connection by themselves.
 */</comment>
<function><type><name>SegmentDatabaseDescriptor</name> <modifier>*</modifier></type>
<name>cdbcomponent_allocateIdleQE</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>contentId</name></decl></parameter>, <parameter><decl><type><name>SegmentType</name></type> <name>segmentType</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SegmentDatabaseDescriptor</name>	<modifier>*</modifier></type><name>segdbDesc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CdbComponentDatabaseInfo</name>	<modifier>*</modifier></type><name>cdbinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> 					<modifier>*</modifier></type><name>curItem</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> 					<modifier>*</modifier></type><name>nextItem</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>					<modifier>*</modifier></type><name>prevItem</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> 				<name>oldContext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>						<name>isWriter</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>cdbinfo</name> <operator>=</operator> <call><name>cdbcomponent_getComponentInfo</name><argument_list>(<argument><expr><name>contentId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	

	<expr_stmt><expr><name>oldContext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>CdbComponentsContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Always try to pop from the head.  Make sure to push them back to head
	 * in cdbcomponent_recycleIdleQE().
	 */</comment>
	<expr_stmt><expr><name>curItem</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name><name>cdbinfo</name><operator>-&gt;</operator><name>freelist</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>curItem</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SegmentDatabaseDescriptor</name> <modifier>*</modifier></type><name>tmp</name> <init>=
				<expr><operator>(</operator><name>SegmentDatabaseDescriptor</name> <operator>*</operator><operator>)</operator><call><name>lfirst</name><argument_list>(<argument><expr><name>curItem</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>nextItem</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>curItem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>segmentType</name> <operator>==</operator> <name>SEGMENTTYPE_EXPLICT_WRITER</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>tmp</name><operator>-&gt;</operator><name>isWriter</name></name><operator>)</operator> <operator>||</operator>
			<operator>(</operator><name>segmentType</name> <operator>==</operator> <name>SEGMENTTYPE_EXPLICT_READER</name> <operator>&amp;&amp;</operator> <name><name>tmp</name><operator>-&gt;</operator><name>isWriter</name></name><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>prevItem</name> <operator>=</operator> <name>curItem</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>curItem</name> <operator>=</operator> <name>nextItem</name></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name><name>cdbinfo</name><operator>-&gt;</operator><name>freelist</name></name> <operator>=</operator> <call><name>list_delete_cell</name><argument_list>(<argument><expr><name><name>cdbinfo</name><operator>-&gt;</operator><name>freelist</name></name></expr></argument>, <argument><expr><name>curItem</name></expr></argument>, <argument><expr><name>prevItem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
		<comment type="block">/* update numIdleQEs */</comment>
		<expr_stmt><expr><call><name>DECR_COUNT</name><argument_list>(<argument><expr><name>cdbinfo</name></expr></argument>, <argument><expr><name>numIdleQEs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>segdbDesc</name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>
		<break>break;</break>
	</block_content>}</block></while>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>segdbDesc</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * 1. for entrydb, it's never be writer.
		 * 2. for first QE, it must be a writer.
		 */</comment>
		<expr_stmt><expr><name>isWriter</name> <operator>=</operator> <ternary><condition><expr><name>contentId</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr> ?</condition><then> <expr><name>false</name></expr></then><else>: <expr><operator>(</operator><name><name>cdbinfo</name><operator>-&gt;</operator><name>numIdleQEs</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>cdbinfo</name><operator>-&gt;</operator><name>numActiveQEs</name></name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr></else></ternary></expr>;</expr_stmt>
		<expr_stmt><expr><name>segdbDesc</name> <operator>=</operator> <call><name>cdbconn_createSegmentDescriptor</name><argument_list>(<argument><expr><name>cdbinfo</name></expr></argument>, <argument><expr><call><name>nextQEIdentifer</name><argument_list>(<argument><expr><name><name>cdbinfo</name><operator>-&gt;</operator><name>cdbs</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>isWriter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>cdbconn_setQEIdentifier</name><argument_list>(<argument><expr><name>segdbDesc</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>cdbinfo</name><operator>-&gt;</operator><name>activelist</name></name> <operator>=</operator> <call><name>lcons</name><argument_list>(<argument><expr><name>segdbDesc</name></expr></argument>, <argument><expr><name><name>cdbinfo</name><operator>-&gt;</operator><name>activelist</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>INCR_COUNT</name><argument_list>(<argument><expr><name>cdbinfo</name></expr></argument>, <argument><expr><name>numActiveQEs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>segdbDesc</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>cleanupQE</name><parameter_list>(<parameter><decl><type><name>SegmentDatabaseDescriptor</name> <modifier>*</modifier></type><name>segdbDesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>segdbDesc</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FAULT_INJECTOR</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><call><name>SIMPLE_FAULT_INJECTOR</name><argument_list>(<argument><expr><literal type="string">"cleanup_qe"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>FaultInjectorTypeSkip</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/*
	 * if the process is in the middle of blowing up... then we don't do
	 * anything here.  making libpq and other calls can definitely result in
	 * things getting HUNG.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>proc_exit_inprogress</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>cdbconn_isBadConnection</name><argument_list>(<argument><expr><name>segdbDesc</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* if segment is down, the gang can not be reused */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>FtsIsSegmentDown</name><argument_list>(<argument><expr><name><name>segdbDesc</name><operator>-&gt;</operator><name>segment_database_info</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt> 

	<comment type="block">/* If a reader exceed the cached memory limitation, destroy it */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>segdbDesc</name><operator>-&gt;</operator><name>isWriter</name></name> <operator>&amp;&amp;</operator>
		<operator>(</operator><name><name>segdbDesc</name><operator>-&gt;</operator><name>conn</name><operator>-&gt;</operator><name>mop_high_watermark</name></name> <operator>&gt;&gt;</operator> <literal type="number">20</literal><operator>)</operator> <operator>&gt;</operator> <name>gp_vmem_protect_gang_cache_limit</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Note, we cancel all "still running" queries */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>cdbconn_discardResults</name><argument_list>(<argument><expr><name>segdbDesc</name></expr></argument>, <argument><expr><literal type="number">20</literal></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"cleaning up seg%d while it is still busy"</literal></expr></argument>, <argument><expr><name><name>segdbDesc</name><operator>-&gt;</operator><name>segindex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* QE is no longer associated with a slice. */</comment>
	<expr_stmt><expr><call><name>cdbconn_setQEIdentifier</name><argument_list>(<argument><expr><name>segdbDesc</name></expr></argument>, <comment type="block">/* slice index */</comment> <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>	

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>cdbcomponent_recycleIdleQE</name><parameter_list>(<parameter><decl><type><name>SegmentDatabaseDescriptor</name> <modifier>*</modifier></type><name>segdbDesc</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>forceDestroy</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CdbComponentDatabaseInfo</name>	<modifier>*</modifier></type><name>cdbinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type>				<name>oldContext</name></decl>;</decl_stmt>	
	<decl_stmt><decl><type><name>int</name></type>							<name>maxLen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>						<name>isWriter</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>cdb_component_dbs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>CdbComponentsContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>cdbinfo</name> <operator>=</operator> <name><name>segdbDesc</name><operator>-&gt;</operator><name>segment_database_info</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>isWriter</name> <operator>=</operator> <name><name>segdbDesc</name><operator>-&gt;</operator><name>isWriter</name></name></expr>;</expr_stmt>

	<comment type="block">/* update num of active QEs */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_member_ptr</name><argument_list>(<argument><expr><name><name>cdbinfo</name><operator>-&gt;</operator><name>activelist</name></name></expr></argument>, <argument><expr><name>segdbDesc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cdbinfo</name><operator>-&gt;</operator><name>activelist</name></name> <operator>=</operator> <call><name>list_delete_ptr</name><argument_list>(<argument><expr><name><name>cdbinfo</name><operator>-&gt;</operator><name>activelist</name></name></expr></argument>, <argument><expr><name>segdbDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>DECR_COUNT</name><argument_list>(<argument><expr><name>cdbinfo</name></expr></argument>, <argument><expr><name>numActiveQEs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>oldContext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>CdbComponentsContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>forceDestroy</name> <operator>||</operator> <operator>!</operator><call><name>cleanupQE</name><argument_list>(<argument><expr><name>segdbDesc</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>destroy_segdb</name>;</goto></block_content></block></if></if_stmt>

	<comment type="block">/* If freelist length exceed gp_cached_gang_threshold, destroy it */</comment>
	<expr_stmt><expr><name>maxLen</name> <operator>=</operator> <ternary><condition><expr><name><name>segdbDesc</name><operator>-&gt;</operator><name>segindex</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr> ?</condition><then>
					<expr><name>MAX_CACHED_1_GANGS</name></expr> </then><else>: <expr><name>gp_cached_gang_threshold</name></expr></else></ternary></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isWriter</name> <operator>&amp;&amp;</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>cdbinfo</name><operator>-&gt;</operator><name>freelist</name></name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <name>maxLen</name></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>destroy_segdb</name>;</goto></block_content></block></if></if_stmt>

	<comment type="block">/* Recycle the QE, put it to freelist */</comment>
	<if_stmt><if>if <condition>(<expr><name>isWriter</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* writer is always the header of freelist */</comment>
		<expr_stmt><expr><name><name>segdbDesc</name><operator>-&gt;</operator><name>segment_database_info</name><operator>-&gt;</operator><name>freelist</name></name> <operator>=</operator>
			<call><name>lcons</name><argument_list>(<argument><expr><name>segdbDesc</name></expr></argument>, <argument><expr><name><name>segdbDesc</name><operator>-&gt;</operator><name>segment_database_info</name><operator>-&gt;</operator><name>freelist</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lastWriter</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * In cdbcomponent_allocateIdleQE() readers are always popped from the
		 * head, so to restore the original order we must pushed them back to
		 * the head, and keep in mind readers must be put after the writers.
		 */</comment>

		<for>for <control>(<init><expr><name>cell</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name><name>segdbDesc</name><operator>-&gt;</operator><name>segment_database_info</name><operator>-&gt;</operator><name>freelist</name></name></expr></argument>)</argument_list></call></expr>;</init>
			 <condition><expr><name>cell</name> <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name>SegmentDatabaseDescriptor</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>isWriter</name></expr>;</condition>
			 <incr><expr><name>lastWriter</name> <operator>=</operator> <name>cell</name></expr><operator>,</operator> <expr><name>cell</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></incr>)</control><block type="pseudo"><block_content> <empty_stmt>;</empty_stmt></block_content></block></for>

		<if_stmt><if>if <condition>(<expr><name>lastWriter</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>lappend_cell</name><argument_list>(<argument><expr><name><name>segdbDesc</name><operator>-&gt;</operator><name>segment_database_info</name><operator>-&gt;</operator><name>freelist</name></name></expr></argument>,
						 <argument><expr><name>lastWriter</name></expr></argument>, <argument><expr><name>segdbDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>segdbDesc</name><operator>-&gt;</operator><name>segment_database_info</name><operator>-&gt;</operator><name>freelist</name></name> <operator>=</operator>
				<call><name>lcons</name><argument_list>(<argument><expr><name>segdbDesc</name></expr></argument>, <argument><expr><name><name>segdbDesc</name><operator>-&gt;</operator><name>segment_database_info</name><operator>-&gt;</operator><name>freelist</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>INCR_COUNT</name><argument_list>(<argument><expr><name>cdbinfo</name></expr></argument>, <argument><expr><name>numIdleQEs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return;</return>

<label><name>destroy_segdb</name>:</label>

	<expr_stmt><expr><call><name>cdbconn_termSegmentDescriptor</name><argument_list>(<argument><expr><name>segdbDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>isWriter</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>markCurrentGxactWriterGangLost</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>nextQEIdentifer</name><parameter_list>(<parameter><decl><type><name>CdbComponentDatabases</name> <modifier>*</modifier></type><name>cdbs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>result</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>cdbs</name><operator>-&gt;</operator><name>freeCounterList</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name><name>cdbs</name><operator>-&gt;</operator><name>qeCounter</name></name><operator>++</operator></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>linitial_int</name><argument_list>(<argument><expr><name><name>cdbs</name><operator>-&gt;</operator><name>freeCounterList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cdbs</name><operator>-&gt;</operator><name>freeCounterList</name></name> <operator>=</operator> <call><name>list_delete_first</name><argument_list>(<argument><expr><name><name>cdbs</name><operator>-&gt;</operator><name>freeCounterList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>cdbcomponent_qesExist</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><ternary><condition><expr><operator>!</operator><name>cdb_component_dbs</name></expr> ?</condition><then> <expr><name>false</name></expr> </then><else>:
			<expr><operator>(</operator><name><name>cdb_component_dbs</name><operator>-&gt;</operator><name>numIdleQEs</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>cdb_component_dbs</name><operator>-&gt;</operator><name>numActiveQEs</name></name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>cdbcomponent_activeQEsExist</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><ternary><condition><expr><operator>!</operator><name>cdb_component_dbs</name></expr> ?</condition><then> <expr><name>false</name></expr> </then><else>: <expr><name><name>cdb_component_dbs</name><operator>-&gt;</operator><name>numActiveQEs</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Find CdbComponentDatabaseInfo in the array by segment index.
 */</comment>
<function><type><name>CdbComponentDatabaseInfo</name> <modifier>*</modifier></type>
<name>cdbcomponent_getComponentInfo</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>contentId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CdbComponentDatabaseInfo</name> <modifier>*</modifier></type><name>cdbInfo</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CdbComponentDatabases</name> <modifier>*</modifier></type><name>cdbs</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>cdbs</name> <operator>=</operator> <call><name>cdbcomponent_getCdbComponents</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>contentId</name> <operator>&lt;</operator> <operator>-</operator><literal type="number">1</literal> <operator>||</operator> <name>contentId</name> <operator>&gt;=</operator> <name><name>cdbs</name><operator>-&gt;</operator><name>total_segments</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATA_EXCEPTION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unexpected content id %d, should be [-1, %d]"</literal></expr></argument>,
						<argument><expr><name>contentId</name></expr></argument>, <argument><expr><name><name>cdbs</name><operator>-&gt;</operator><name>total_segments</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<comment type="block">/* entry db */</comment>
	<if_stmt><if>if <condition>(<expr><name>contentId</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>cdbInfo</name> <operator>=</operator> <operator>&amp;</operator><name><name>cdbs</name><operator>-&gt;</operator><name>entry_db_info</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>	
		<return>return <expr><name>cdbInfo</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* no mirror, segment_db_info is sorted by content id */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>cdbs</name><operator>-&gt;</operator><name>total_segment_dbs</name></name> <operator>==</operator> <name><name>cdbs</name><operator>-&gt;</operator><name>total_segments</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>cdbInfo</name> <operator>=</operator> <operator>&amp;</operator><name><name>cdbs</name><operator>-&gt;</operator><name>segment_db_info</name><index>[<expr><name>contentId</name></expr>]</index></name></expr>;</expr_stmt>
		<return>return <expr><name>cdbInfo</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* with mirror, segment_db_info is sorted by content id */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>cdbs</name><operator>-&gt;</operator><name>total_segment_dbs</name></name> <operator>!=</operator> <name><name>cdbs</name><operator>-&gt;</operator><name>total_segments</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>cdbs</name><operator>-&gt;</operator><name>total_segment_dbs</name></name> <operator>==</operator> <name><name>cdbs</name><operator>-&gt;</operator><name>total_segments</name></name> <operator>*</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>cdbInfo</name> <operator>=</operator> <operator>&amp;</operator><name><name>cdbs</name><operator>-&gt;</operator><name>segment_db_info</name><index>[<expr><literal type="number">2</literal> <operator>*</operator> <name>contentId</name></expr>]</index></name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SEGMENT_IS_ACTIVE_PRIMARY</name><argument_list>(<argument><expr><name>cdbInfo</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>cdbInfo</name> <operator>=</operator> <operator>&amp;</operator><name><name>cdbs</name><operator>-&gt;</operator><name>segment_db_info</name><index>[<expr><literal type="number">2</literal> <operator>*</operator> <name>contentId</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<return>return <expr><name>cdbInfo</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>cdbInfo</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ensureInterconnectAddress</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * If the address type is wildcard, there is no need to populate an unicast
	 * address in interconnect_address.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>Gp_interconnect_address_type</name> <operator>==</operator> <name>INTERCONNECT_ADDRESS_TYPE_WILDCARD</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>interconnect_address</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>Gp_interconnect_address_type</name> <operator>==</operator> <name>INTERCONNECT_ADDRESS_TYPE_UNICAST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* If the unicast address has already been assigned, exit early. */</comment>
	<if_stmt><if>if <condition>(<expr><name>interconnect_address</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Retrieve the segment's gp_segment_configuration.address value, in order
	 * to setup interconnect_address
	 */</comment>

	<if_stmt><if>if <condition>(<expr><name><name>GpIdentity</name><operator>.</operator><name>segindex</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_EXECUTE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>MyProcPort</name><operator>-&gt;</operator><name>laddr</name><operator>.</operator><name>addr</name><operator>.</operator><name>ss_family</name></name> <operator>==</operator> <name>AF_INET</name>
				<operator>||</operator> <name><name>MyProcPort</name><operator>-&gt;</operator><name>laddr</name><operator>.</operator><name>addr</name><operator>.</operator><name>ss_family</name></name> <operator>==</operator> <name>AF_INET6</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/*
		 * We assume that the QD, using the address in gp_segment_configuration
		 * as its destination IP address, connects to the segment/QE.
		 * So, the local address in the PORT can be used for interconnect.
		 */</comment>
		<decl_stmt><decl><type><name>char</name></type> <name><name>local_addr</name><index>[<expr><name>NI_MAXHOST</name></expr>]</index></name></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>getnameinfo</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> struct <name>sockaddr</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>MyProcPort</name><operator>-&gt;</operator><name>laddr</name><operator>.</operator><name>addr</name></name></expr></argument>,
					<argument><expr><name><name>MyProcPort</name><operator>-&gt;</operator><name>laddr</name><operator>.</operator><name>salen</name></name></expr></argument>,
					<argument><expr><name>local_addr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>local_addr</name></expr></argument>)</argument_list></sizeof></expr></argument>,
					<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NI_NUMERICHOST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>interconnect_address</name> <operator>=</operator> <call><name>MemoryContextStrdup</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>, <argument><expr><name>local_addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Here, we can only retrieve the ADDRESS in gp_segment_configuration
		 * from `cdbcomponent*`. We couldn't get it in a way as the QEs.
		 */</comment>
		<decl_stmt><decl><type><name>CdbComponentDatabaseInfo</name> <modifier>*</modifier></type><name>qdInfo</name></decl>;</decl_stmt>
		<expr_stmt><expr><name>qdInfo</name> <operator>=</operator> <call><name>cdbcomponent_getComponentInfo</name><argument_list>(<argument><expr><name>MASTER_CONTENT_ID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>interconnect_address</name> <operator>=</operator> <call><name>MemoryContextStrdup</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>, <argument><expr><name><name>qdInfo</name><operator>-&gt;</operator><name>config</name><operator>-&gt;</operator><name>hostip</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>qdHostname</name> <operator>&amp;&amp;</operator> <name><name>qdHostname</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_EXECUTE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/*
		 * QE on the master can't get its interconnect address like that on the primary.
		 * The QD connects to its postmaster via the unix domain socket.
		 */</comment>
		<expr_stmt><expr><name>interconnect_address</name> <operator>=</operator> <name>qdHostname</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>interconnect_address</name> <operator>&amp;&amp;</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>interconnect_address</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<comment type="block">/*
 * performs all necessary setup required for Greenplum Database mode.
 *
 * This includes cdblink_setup() and initializing the Motion Layer.
 */</comment>
<function><type><name>void</name></type>
<name>cdb_setup</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"Initializing Greenplum components..."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>Gp_role</name> <operator>!=</operator> <name>GP_ROLE_UTILITY</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ensureInterconnectAddress</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Initialize the Motion Layer IPC subsystem. */</comment>
		<expr_stmt><expr><call><name>InitMotionLayerIPC</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Backend process requires consistent state, it cannot proceed until
	 * dtx recovery process finish up the recovery of distributed transactions.
	 *
	 * Ignore background worker because bgworker_should_start_mpp() already did
	 * the check.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>IsBackgroundWorker</name> <operator>&amp;&amp;</operator>
		<name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name> <operator>&amp;&amp;</operator>
		<operator>!</operator><operator>*</operator><name>shmDtmStarted</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CANNOT_CONNECT_NOW</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><name>POSTMASTER_IN_RECOVERY_MSG</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"waiting for distributed transaction recovery to complete"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * performs all necessary cleanup required when leaving Greenplum
 * Database mode.  This is also called when the process exits.
 *
 * NOTE: the arguments to this function are here only so that we can
 *		 register it with on_proc_exit().  These parameters should not
 *		 be used since there are some callers to this that pass them
 *		 as NULL.
 *
 */</comment>
<decl_stmt><decl><type><name>void</name></type>
<name>cdb_cleanup</name><argument_list>(<argument><expr><name>int</name> <name>code</name> <call><name>pg_attribute_unused</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>Datum</name> <name>arg</name>
						<call><name>pg_attribute_unused</name><argument_list>()</argument_list></call></expr></argument>)</argument_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"Cleaning up Greenplum components..."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>DisconnectAndDestroyAllGangs</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>cdb_total_plans</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"session dispatched %d plans %d slices (%f), largest plan %d"</literal></expr></argument>,
				 <argument><expr><name>cdb_total_plans</name></expr></argument>, <argument><expr><name>cdb_total_slices</name></expr></argument>,
				 <argument><expr><operator>(</operator><operator>(</operator><name>double</name><operator>)</operator> <name>cdb_total_slices</name> <operator>/</operator> <operator>(</operator><name>double</name><operator>)</operator> <name>cdb_total_plans</name><operator>)</operator></expr></argument>,
				 <argument><expr><name>cdb_max_slices</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>Gp_role</name> <operator>!=</operator> <name>GP_ROLE_UTILITY</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* shutdown our listener socket */</comment>
		<expr_stmt><expr><call><name>CleanUpMotionLayerIPC</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></decl></decl_stmt>

<comment type="block">/*
 * CdbComponentDatabaseInfoCompare:
 * A compare function for CdbComponentDatabaseInfo structs
 * that compares based on , isprimary desc
 * for use with qsort.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>CdbComponentDatabaseInfoCompare</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>p1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>p2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>CdbComponentDatabaseInfo</name> <modifier>*</modifier></type><name>obj1</name> <init>= <expr><operator>(</operator><name>CdbComponentDatabaseInfo</name> <operator>*</operator><operator>)</operator> <name>p1</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>CdbComponentDatabaseInfo</name> <modifier>*</modifier></type><name>obj2</name> <init>= <expr><operator>(</operator><name>CdbComponentDatabaseInfo</name> <operator>*</operator><operator>)</operator> <name>p2</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>int</name></type>			<name>cmp</name> <init>= <expr><name><name>obj1</name><operator>-&gt;</operator><name>config</name><operator>-&gt;</operator><name>segindex</name></name> <operator>-</operator> <name><name>obj2</name><operator>-&gt;</operator><name>config</name><operator>-&gt;</operator><name>segindex</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>cmp</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>obj2cmp</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>obj1cmp</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>SEGMENT_IS_ACTIVE_PRIMARY</name><argument_list>(<argument><expr><name>obj2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>obj2cmp</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>SEGMENT_IS_ACTIVE_PRIMARY</name><argument_list>(<argument><expr><name>obj1</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>obj1cmp</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>cmp</name> <operator>=</operator> <name>obj2cmp</name> <operator>-</operator> <name>obj1cmp</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>cmp</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Maintain a cache of names.
 *
 * The keys are all NAMEDATALEN long.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>getDnsCachedAddress</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>port</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>use_cache</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SegIpEntry</name>	   <modifier>*</modifier></type><name>e</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>			<name><name>hostinfo</name><index>[<expr><name>NI_MAXHOST</name></expr>]</index></name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>use_cache</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>segment_ip_cache_htab</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>HASHCTL</name></type>		<name>hash_ctl</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hash_ctl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>hash_ctl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>hash_ctl</name><operator>.</operator><name>keysize</name></name> <operator>=</operator> <name>NAMEDATALEN</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>hash_ctl</name><operator>.</operator><name>entrysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>SegIpEntry</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

			<expr_stmt><expr><name>segment_ip_cache_htab</name> <operator>=</operator> <call><name>hash_create</name><argument_list>(<argument><expr><literal type="string">"segment_dns_cache"</literal></expr></argument>,
												<argument><expr><literal type="number">256</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>hash_ctl</name></expr></argument>, <argument><expr><name>HASH_ELEM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>e</name> <operator>=</operator> <operator>(</operator><name>SegIpEntry</name> <operator>*</operator><operator>)</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>segment_ip_cache_htab</name></expr></argument>,
										   <argument><expr><name>name</name></expr></argument>, <argument><expr><name>HASH_FIND</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>e</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name><name>e</name><operator>-&gt;</operator><name>hostinfo</name></name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * The name is either not in our cache, or we've been instructed to not
	 * use the cache. Perform the name lookup.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>use_cache</name> <operator>||</operator> <operator>(</operator><name>use_cache</name> <operator>&amp;&amp;</operator> <name>e</name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldContext</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>ret</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>portNumberStr</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>service</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name><name>struct</name> <name>addrinfo</name></name> <modifier>*</modifier></type><name>addrs</name> <init>= <expr><name>NULL</name></expr></init></decl>,
				   <decl><type ref="prev"><modifier>*</modifier></type><name>addr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name><name>struct</name> <name>addrinfo</name></name></type> <name>hint</name></decl>;</decl_stmt>

		<comment type="block">/* Initialize hint structure */</comment>
		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hint</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>hint</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>hint</name><operator>.</operator><name>ai_socktype</name></name> <operator>=</operator> <name>SOCK_STREAM</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>hint</name><operator>.</operator><name>ai_family</name></name> <operator>=</operator> <name>AF_UNSPEC</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>portNumberStr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>portNumberStr</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><name>port</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>service</name> <operator>=</operator> <name>portNumberStr</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>pg_getaddrinfo_all</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>service</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hint</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>addrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>||</operator> <operator>!</operator><name>addrs</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>addrs</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>pg_freeaddrinfo_all</name><argument_list>(<argument><expr><name><name>hint</name><operator>.</operator><name>ai_family</name></name></expr></argument>, <argument><expr><name>addrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * If a host name is unknown, whether it is an error depends on its role:
			 * - if it is a primary then it's an error;
			 * - if it is a mirror then it's just a warning;
			 * but we do not know the role information here, so always treat it as a
			 * warning, the callers should check the role and decide what to do.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>!=</operator> <name>EAI_FAIL</name> <operator>&amp;&amp;</operator> <name>elevel</name> <operator>==</operator> <name>ERROR</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>elevel</name> <operator>=</operator> <name>WARNING</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not translate host name \"%s\", port \"%d\" to address: %s"</literal></expr></argument>,
							<argument><expr><name>name</name></expr></argument>, <argument><expr><name>port</name></expr></argument>, <argument><expr><call><name>gai_strerror</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<return>return <expr><name>NULL</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* save in the cache context */</comment>
		<if_stmt><if>if <condition>(<expr><name>use_cache</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>oldContext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>hostinfo</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>addr</name> <operator>=</operator> <name>addrs</name></expr>;</init> <condition><expr><name>addr</name></expr>;</condition> <incr><expr><name>addr</name> <operator>=</operator> <name><name>addr</name><operator>-&gt;</operator><name>ai_next</name></name></expr></incr>)</control>
		<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_UNIX_SOCKETS</name></cpp:ifdef>
			<comment type="block">/* Ignore AF_UNIX sockets, if any are returned. */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>addr</name><operator>-&gt;</operator><name>ai_family</name></name> <operator>==</operator> <name>AF_UNIX</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<if_stmt><if>if <condition>(<expr><name><name>addr</name><operator>-&gt;</operator><name>ai_family</name></name> <operator>==</operator> <name>AF_INET</name></expr>)</condition> <comment type="block">/* IPv4 address */</comment>
			<block>{<block_content>
				<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>hostinfo</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>hostinfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>pg_getnameinfo_all</name><argument_list>(<argument><expr><operator>(</operator>struct <name>sockaddr_storage</name> <operator>*</operator><operator>)</operator> <name><name>addr</name><operator>-&gt;</operator><name>ai_addr</name></name></expr></argument>, <argument><expr><name><name>addr</name><operator>-&gt;</operator><name>ai_addrlen</name></name></expr></argument>,
								   <argument><expr><name>hostinfo</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>hostinfo</name></expr></argument>)</argument_list></sizeof></expr></argument>,
								   <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
								   <argument><expr><name>NI_NUMERICHOST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name>use_cache</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* Insert into our cache htab */</comment>
					<expr_stmt><expr><name>e</name> <operator>=</operator> <operator>(</operator><name>SegIpEntry</name> <operator>*</operator><operator>)</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>segment_ip_cache_htab</name></expr></argument>,
												   <argument><expr><name>name</name></expr></argument>, <argument><expr><name>HASH_ENTER</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>e</name><operator>-&gt;</operator><name>hostinfo</name></name></expr></argument>, <argument><expr><name>hostinfo</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>hostinfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_IPV6</name></cpp:ifdef>

		<comment type="block">/*
		 * IPv6 probably would work fine, we'd just need to make sure all the
		 * data structures are big enough for the IPv6 address.  And on some
		 * broken systems, you can get an IPv6 address, but not be able to
		 * bind to it because IPv6 is disabled or missing in the kernel, so
		 * we'd only want to use the IPv6 address if there isn't an IPv4
		 * address.  All we really need to do is test this.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><operator>!</operator><name>use_cache</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>hostinfo</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>use_cache</name> <operator>&amp;&amp;</operator> <name>e</name> <operator>==</operator> <name>NULL</name><operator>)</operator><operator>)</operator>
			<operator>&amp;&amp;</operator> <name><name>addrs</name><operator>-&gt;</operator><name>ai_family</name></name> <operator>==</operator> <name>AF_INET6</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>addr</name> <operator>=</operator> <name>addrs</name></expr>;</expr_stmt>
			<comment type="block">/* Get a text representation of the IP address */</comment>
			<expr_stmt><expr><call><name>pg_getnameinfo_all</name><argument_list>(<argument><expr><operator>(</operator>struct <name>sockaddr_storage</name> <operator>*</operator><operator>)</operator> <name><name>addr</name><operator>-&gt;</operator><name>ai_addr</name></name></expr></argument>, <argument><expr><name><name>addr</name><operator>-&gt;</operator><name>ai_addrlen</name></name></expr></argument>,
							   <argument><expr><name>hostinfo</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>hostinfo</name></expr></argument>)</argument_list></sizeof></expr></argument>,
							   <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
							   <argument><expr><name>NI_NUMERICHOST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>use_cache</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Insert into our cache htab */</comment>
				<expr_stmt><expr><name>e</name> <operator>=</operator> <operator>(</operator><name>SegIpEntry</name> <operator>*</operator><operator>)</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>segment_ip_cache_htab</name></expr></argument>,
											   <argument><expr><name>name</name></expr></argument>, <argument><expr><name>HASH_ENTER</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>e</name><operator>-&gt;</operator><name>hostinfo</name></name></expr></argument>, <argument><expr><name>hostinfo</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>hostinfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

		<if_stmt><if>if <condition>(<expr><name>use_cache</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>pg_freeaddrinfo_all</name><argument_list>(<argument><expr><name><name>hint</name><operator>.</operator><name>ai_family</name></name></expr></argument>, <argument><expr><name>addrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* return a pointer to our cache. */</comment>
	<if_stmt><if>if <condition>(<expr><name>use_cache</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name><name>e</name><operator>-&gt;</operator><name>hostinfo</name></name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><call><name>pstrdup</name><argument_list>(<argument><expr><name>hostinfo</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * getDnsAddress
 *
 * same as getDnsCachedAddress, but without using the cache. A non-cached
 * version was used inline inside of cdbgang.c, and since it is needed now
 * elsewhere, it is available externally.
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>getDnsAddress</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>hostname</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>port</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>getDnsCachedAddress</name><argument_list>(<argument><expr><name>hostname</name></expr></argument>, <argument><expr><name>port</name></expr></argument>, <argument><expr><name>elevel</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Given a component-db in the system, find the addresses at which it
 * can be reached, appropriately populate the argument-structure, and
 * maintain the ip-lookup-cache.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>getAddressesForDBid</name><parameter_list>(<parameter><decl><type><name>GpSegConfigEntry</name> <modifier>*</modifier></type><name>c</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>c</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Use hostname */</comment>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>hostaddrs</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>COMPONENT_DBS_MAX_ADDRS</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FAULT_INJECTOR</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><name>am_ftsprobe</name> <operator>&amp;&amp;</operator>
		<call><name>SIMPLE_FAULT_INJECTOR</name><argument_list>(<argument><expr><literal type="string">"get_dns_cached_address"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>FaultInjectorTypeSkip</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* inject a dns error for primary of segment 0 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>segindex</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
				<name><name>c</name><operator>-&gt;</operator><name>preferred_role</name></name> <operator>==</operator> <name>GP_SEGMENT_CONFIGURATION_ROLE_PRIMARY</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>address</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><literal type="string">"dnserrordummyaddress"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
			<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>hostname</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><literal type="string">"dnserrordummyaddress"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/*
	 * add an entry, using the first the "address" and then the "hostname" as
	 * fallback.
	 */</comment>
	<expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>getDnsCachedAddress</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>address</name></name></expr></argument>, <argument><expr><name><name>c</name><operator>-&gt;</operator><name>port</name></name></expr></argument>, <argument><expr><name>elevel</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>name</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>hostaddrs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* now the hostname. */</comment>
	<expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>getDnsCachedAddress</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>hostname</name></name></expr></argument>, <argument><expr><name><name>c</name><operator>-&gt;</operator><name>port</name></name></expr></argument>, <argument><expr><name>elevel</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>name</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>hostaddrs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>hostaddrs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return;</return>
</block_content>}</block></function>

<comment type="block">/*
 * hostPrimaryCountHashTableInit()
 *    Construct a hash table of HostPrimaryCountEntry
 */</comment>
<function><type><specifier>static</specifier> <name>HTAB</name> <modifier>*</modifier></type>
<name>hostPrimaryCountHashTableInit</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HASHCTL</name></type>		<name>info</name></decl>;</decl_stmt>

	<comment type="block">/* Set key and entry sizes. */</comment>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>info</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>info</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>info</name><operator>.</operator><name>keysize</name></name> <operator>=</operator> <name>MAXHOSTNAMELEN</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>info</name><operator>.</operator><name>entrysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>HostPrimaryCountEntry</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

	<return>return <expr><call><name>hash_create</name><argument_list>(<argument><expr><literal type="string">"HostSegs"</literal></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>info</name></expr></argument>, <argument><expr><name>HASH_ELEM</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Given total number of primary segment databases and a number of
 * segments to "skip" - this routine creates a boolean map (array) the
 * size of total number of segments and randomly selects several
 * entries (total number of total_to_skip) to be marked as
 * "skipped". This is used for external tables with the 'gpfdist'
 * protocol where we want to get a number of *random* segdbs to
 * connect to a gpfdist client.
 *
 * Caller of this function should pfree skip_map when done with it.
 */</comment>
<function><type><name>bool</name> <modifier>*</modifier></type>
<name>makeRandomSegMap</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>total_primaries</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>total_to_skip</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>randint</name></decl>;</decl_stmt>		<comment type="block">/* some random int representing a seg    */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>skipped</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>	<comment type="block">/* num segs already marked to be skipped */</comment>
	<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>skip_map</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>skip_map</name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>total_primaries</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>skip_map</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>total_primaries</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><name>total_to_skip</name> <operator>!=</operator> <name>skipped</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * create a random int between 0 and (total_primaries - 1).
		 */</comment>
		<expr_stmt><expr><name>randint</name> <operator>=</operator> <call><name>cdbhashrandomseg</name><argument_list>(<argument><expr><name>total_primaries</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * mark this random index 'true' in the skip map (marked to be
		 * skipped) unless it was already marked.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>skip_map</name><index>[<expr><name>randint</name></expr>]</index></name> <operator>==</operator> <name>false</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>skip_map</name><index>[<expr><name>randint</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>skipped</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>

	<return>return <expr><name>skip_map</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Determine the dbid for the master standby
 */</comment>
<function><type><name>int16</name></type>
<name>master_standby_dbid</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int16</name></type>		<name>dbid</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>scankey</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Can only run on a master node, this restriction is due to the reliance
	 * on the gp_segment_configuration table.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IS_QUERY_DISPATCHER</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"master_standby_dbid() executed on execution segment"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * SELECT * FROM gp_segment_configuration WHERE content = -1 AND role =
	 * GP_SEGMENT_CONFIGURATION_ROLE_MIRROR
	 */</comment>
	<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>GpSegmentConfigRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scankey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_gp_segment_configuration_content</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_INT2EQ</name></expr></argument>,
				<argument><expr><call><name>Int16GetDatum</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scankey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_gp_segment_configuration_role</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_CHAREQ</name></expr></argument>,
				<argument><expr><call><name>CharGetDatum</name><argument_list>(<argument><expr><name>GP_SEGMENT_CONFIGURATION_ROLE_MIRROR</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* no index */</comment>
	<expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
							  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>scankey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tup</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>dbid</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Form_gp_segment_configuration</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>dbid</name></expr>;</expr_stmt>
		<comment type="block">/* We expect a single result, assert this */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* no need to hold the lock, it's a catalog */</comment>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>dbid</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>GpSegConfigEntry</name> <modifier>*</modifier></type>
<name>dbid_get_dbinfo</name><parameter_list>(<parameter><decl><type><name>int16</name></type> <name>dbid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name>scankey</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GpSegConfigEntry</name> <modifier>*</modifier></type><name>i</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Can only run on a master node, this restriction is due to the reliance
	 * on the gp_segment_configuration table.  This may be able to be relaxed
	 * by switching to a different method of checking.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IS_QUERY_DISPATCHER</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"dbid_get_dbinfo() executed on execution segment"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>GpSegmentConfigRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* SELECT * FROM gp_segment_configuration WHERE dbid = :1 */</comment>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>scankey</name></expr></argument>,
				<argument><expr><name>Anum_gp_segment_configuration_dbid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_INT2EQ</name></expr></argument>,
				<argument><expr><call><name>Int16GetDatum</name><argument_list>(<argument><expr><name>dbid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>GpSegmentConfigDbidIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
							  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>scankey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>attr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>isNull</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>i</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>GpSegConfigEntry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * dbid
		 */</comment>
		<expr_stmt><expr><name>attr</name> <operator>=</operator> <call><name>heap_getattr</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>Anum_gp_segment_configuration_dbid</name></expr></argument>,
							<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>i</name><operator>-&gt;</operator><name>dbid</name></name> <operator>=</operator> <call><name>DatumGetInt16</name><argument_list>(<argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * content
		 */</comment>
		<expr_stmt><expr><name>attr</name> <operator>=</operator> <call><name>heap_getattr</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>Anum_gp_segment_configuration_content</name></expr></argument>,
							<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>i</name><operator>-&gt;</operator><name>segindex</name></name> <operator>=</operator> <call><name>DatumGetInt16</name><argument_list>(<argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * role
		 */</comment>
		<expr_stmt><expr><name>attr</name> <operator>=</operator> <call><name>heap_getattr</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>Anum_gp_segment_configuration_role</name></expr></argument>,
							<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>i</name><operator>-&gt;</operator><name>role</name></name> <operator>=</operator> <call><name>DatumGetChar</name><argument_list>(<argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * preferred-role
		 */</comment>
		<expr_stmt><expr><name>attr</name> <operator>=</operator> <call><name>heap_getattr</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>,
							<argument><expr><name>Anum_gp_segment_configuration_preferred_role</name></expr></argument>,
							<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>i</name><operator>-&gt;</operator><name>preferred_role</name></name> <operator>=</operator> <call><name>DatumGetChar</name><argument_list>(<argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * mode
		 */</comment>
		<expr_stmt><expr><name>attr</name> <operator>=</operator> <call><name>heap_getattr</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>Anum_gp_segment_configuration_mode</name></expr></argument>,
							<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>i</name><operator>-&gt;</operator><name>mode</name></name> <operator>=</operator> <call><name>DatumGetChar</name><argument_list>(<argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * status
		 */</comment>
		<expr_stmt><expr><name>attr</name> <operator>=</operator> <call><name>heap_getattr</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>Anum_gp_segment_configuration_status</name></expr></argument>,
							<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>i</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <call><name>DatumGetChar</name><argument_list>(<argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * hostname
		 */</comment>
		<expr_stmt><expr><name>attr</name> <operator>=</operator> <call><name>heap_getattr</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>Anum_gp_segment_configuration_hostname</name></expr></argument>,
							<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>i</name><operator>-&gt;</operator><name>hostname</name></name> <operator>=</operator> <call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * address
		 */</comment>
		<expr_stmt><expr><name>attr</name> <operator>=</operator> <call><name>heap_getattr</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>Anum_gp_segment_configuration_address</name></expr></argument>,
							<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>i</name><operator>-&gt;</operator><name>address</name></name> <operator>=</operator> <call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * port
		 */</comment>
		<expr_stmt><expr><name>attr</name> <operator>=</operator> <call><name>heap_getattr</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>Anum_gp_segment_configuration_port</name></expr></argument>,
							<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>i</name><operator>-&gt;</operator><name>port</name></name> <operator>=</operator> <call><name>DatumGetInt32</name><argument_list>(<argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* should be only 1 */</comment>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not find configuration entry for dbid %i"</literal></expr></argument>, <argument><expr><name>dbid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>i</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Obtain the dbid of a of a segment at a given segment index (i.e., content id)
 * currently fulfilling the role specified. This means that the segment is
 * really performing the role of primary or mirror, irrespective of their
 * preferred role.
 */</comment>
<function><type><name>int16</name></type>
<name>contentid_get_dbid</name><parameter_list>(<parameter><decl><type><name>int16</name></type> <name>contentid</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>role</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>getPreferredRoleNotCurrentRole</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int16</name></type>		<name>dbid</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>scankey</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tup</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Can only run on a master node, this restriction is due to the reliance
	 * on the gp_segment_configuration table.  This may be able to be relaxed
	 * by switching to a different method of checking.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IS_QUERY_DISPATCHER</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"contentid_get_dbid() executed on execution segment"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>GpSegmentConfigRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* XXX XXX: CHECK THIS  XXX jic 2011/12/09 */</comment>
	<if_stmt><if>if <condition>(<expr><name>getPreferredRoleNotCurrentRole</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * SELECT * FROM gp_segment_configuration WHERE content = :1 AND
		 * preferred_role = :2
		 */</comment>
		<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scankey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
					<argument><expr><name>Anum_gp_segment_configuration_content</name></expr></argument>,
					<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_INT2EQ</name></expr></argument>,
					<argument><expr><call><name>Int16GetDatum</name><argument_list>(<argument><expr><name>contentid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scankey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,
					<argument><expr><name>Anum_gp_segment_configuration_preferred_role</name></expr></argument>,
					<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_CHAREQ</name></expr></argument>,
					<argument><expr><call><name>CharGetDatum</name><argument_list>(<argument><expr><name>role</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>GpSegmentConfigContentPreferred_roleIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
								  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>scankey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * SELECT * FROM gp_segment_configuration WHERE content = :1 AND role
		 * = :2
		 */</comment>
		<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scankey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
					<argument><expr><name>Anum_gp_segment_configuration_content</name></expr></argument>,
					<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_INT2EQ</name></expr></argument>,
					<argument><expr><call><name>Int16GetDatum</name><argument_list>(<argument><expr><name>contentid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scankey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,
					<argument><expr><name>Anum_gp_segment_configuration_role</name></expr></argument>,
					<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_CHAREQ</name></expr></argument>,
					<argument><expr><call><name>CharGetDatum</name><argument_list>(<argument><expr><name>role</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* no index */</comment>
		<expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
								  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>scankey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>tup</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>dbid</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Form_gp_segment_configuration</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>dbid</name></expr>;</expr_stmt>
		<comment type="block">/* We expect a single result, assert this */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* should be only 1 */</comment>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* no need to hold the lock, it's a catalog */</comment>
	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>dbid</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>List</name> <modifier>*</modifier></type>
<name>cdbcomponent_getCdbComponentsList</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CdbComponentDatabases</name> <modifier>*</modifier></type><name>cdbs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>segments</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>cdbs</name> <operator>=</operator> <call><name>cdbcomponent_getCdbComponents</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>cdbs</name><operator>-&gt;</operator><name>total_segments</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>segments</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>segments</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>segments</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * return the number of total segments for current snapshot of
 * segments info
 */</comment>
<function><type><name>int</name></type>
<name>getgpsegmentCount</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* 1 represents a singleton postgresql in utility mode */</comment>
	<decl_stmt><decl><type><name>int32</name></type> <name>numsegments</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>numsegments</name> <operator>=</operator> <call><name>cdbcomponent_getCdbComponents</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>total_segments</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_EXECUTE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>numsegments</name> <operator>=</operator> <name>numsegmentsFromQD</name></expr>;</expr_stmt></block_content></block></if>
	<comment type="block">/*
	 * If we are in 'Utility &amp; Binary Upgrade' mode, it must be launched
	 * by the pg_upgrade, so we give it an correct numsegments to make
	 * sure the pg_upgrade can run normally.
	 * Only Utility QD process have the entire information in the
	 * gp_segment_configuration, so we count the segments count in this
	 * process.
	 */</comment>
	<if type="elseif">else if <condition>(<expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_UTILITY</name> <operator>&amp;&amp;</operator>
			 <name>IsBinaryUpgrade</name> <operator>&amp;&amp;</operator>
			 <call><name>IS_QUERY_DISPATCHER</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>numsegments</name> <operator>=</operator> <call><name>cdbcomponent_getCdbComponents</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>total_segments</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>numsegments</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * IsOnConflictUpdate
 * Return true if a plannedstmt is an upsert: insert ... on conflict do update
 */</comment>
<function><type><name>bool</name></type>
<name>IsOnConflictUpdate</name><parameter_list>(<parameter><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>ps</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Plan</name>      <modifier>*</modifier></type><name>plan</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>ps</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>ps</name><operator>-&gt;</operator><name>commandType</name></name> <operator>!=</operator> <name>CMD_INSERT</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>plan</name> <operator>=</operator> <name><name>ps</name><operator>-&gt;</operator><name>planTree</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>plan</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><name>Motion</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>plan</name> <operator>=</operator> <call><name>outerPlan</name><argument_list>(<argument><expr><name>plan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>plan</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><name>ModifyTable</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><operator>(</operator><operator>(</operator><name>ModifyTable</name> <operator>*</operator><operator>)</operator><name>plan</name><operator>)</operator><operator>-&gt;</operator><name>onConflictAction</name> <operator>==</operator> <name>ONCONFLICT_UPDATE</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Avoid core file generation for this PANIC. It helps to avoid
 * filling up disks during tests and also saves time.
 */</comment>
<function><type><name>void</name></type>
<name>AvoidCorefileGeneration</name><parameter_list>()</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_GETRLIMIT</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>RLIMIT_CORE</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<decl_stmt><decl><type><name><name>struct</name> <name>rlimit</name></name></type> <name>lim</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>getrlimit</name><argument_list>(<argument><expr><name>RLIMIT_CORE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>lim</name><operator>.</operator><name>rlim_cur</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>setrlimit</name><argument_list>(<argument><expr><name>RLIMIT_CORE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lim</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>save_errno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>,
			 <argument><expr><literal type="string">"setrlimit failed for RLIMIT_CORE soft limit to zero. errno: %d (%m)."</literal></expr></argument>,
			 <argument><expr><name>save_errno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>gp_get_suboverflowed_backends</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<comment type="block">/*
 * Find the backends where subtransaction overflowed.
 */</comment>
<function><type><name>Datum</name></type>
<name>gp_get_suboverflowed_backends</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> 			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ArrayBuildState</name> <modifier>*</modifier></type><name>astate</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>ProcArrayLock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>ProcGlobal</name><operator>-&gt;</operator><name>allProcCount</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>ProcGlobal</name><operator>-&gt;</operator><name>allPgXact</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>overflowed</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>astate</name> <operator>=</operator> <call><name>accumArrayResult</name><argument_list>(<argument><expr><name>astate</name></expr></argument>,
									  <argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><name><name>ProcGlobal</name><operator>-&gt;</operator><name>allProcs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pid</name></expr></argument>)</argument_list></call></expr></argument>,
									  <argument><expr><name>false</name></expr></argument>, <argument><expr><name>INT4OID</name></expr></argument>, <argument><expr><name>CurrentMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ProcArrayLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>astate</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_DATUM</name><argument_list>(<argument><expr><call><name>makeArrayResult</name><argument_list>(<argument><expr><name>astate</name></expr></argument>,
											<argument><expr><name>CurrentMemoryContext</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function></unit>
