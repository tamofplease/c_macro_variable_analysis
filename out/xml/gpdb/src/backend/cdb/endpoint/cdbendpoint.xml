<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/backend/cdb/endpoint/cdbendpoint.c"><comment type="block">/*-------------------------------------------------------------------------
 * cdbendpoint.c
 *
 * An endpoint is a query result source for a parallel retrieve cursor on a
 * dedicated QE. One parallel retrieve cursor could have multiple endpoints
 * on different QEs to allow retrieving in parallel.
 *
 * This file implements the sender part of an endpoint.
 *
 * Endpoints may exist on the coordinator or segments, depending on the query
 * of the PARALLEL RETRIEVE CURSOR:
 * (1) An endpoint is on QD only if the query of the parallel cursor needs to
 *     be finally gathered by the master. e.g.:
 *     &gt; DECLARE c1 PARALLEL RETRIEVE CURSOR FOR SELECT * FROM T1 ORDER BY C1;
 * (2) The endpoints are on specific segments node if the direct dispatch happens.
 *	   e.g.:
 *     &gt; DECLARE c1 PARALLEL RETRIEVE CURSOR FOR SELECT * FROM T1 WHERE C1=1;
 * (3) The endpoints are on all segments node. e.g:
 *     &gt; DECLARE c1 PARALLEL RETRIEVE CURSOR FOR SELECT * FROM T1;
 *
 * When a parallel retrieve cursor is declared, the query plan will be
 * dispatched to the corresponding QEs. Before the query execution, endpoints
 * will be created first on QEs. An instance of Endpoint struct in the shared
 * memory represents the endpoint. Through the Endpoint, the client could know
 * the endpoint's identification (endpoint name), location (dbid, host, port
 * and session id), and the state for the retrieve session. All of this
 * information can be obtained on QD by UDF gp_get_endpoints() via dispatching
 * endpoint queries or on QE's retrieve session by UDF gp_get_segment_endpoints().
 *
 * Instead of returning the query result to QD through a normal dest receiver,
 * endpoints write the results to TQueueDestReceiver which is a shared memory
 * queue and can be retrieved from a different process. See
 * SetupEndpointExecState(). The information about the message queue
 * is also stored in the Endpoint so that the retrieve session on the same QE
 * can know.
 *
 * The token is stored in a different structure EndpointTokenEntry to make the
 * tokens same for all backends within the same session under the same postmaster.
 * The token is created on each QE after plan get dispatched.
 *
 * DECLARE returns only when endpoint and token are ready and query starts
 * execution. See WaitEndpointsReady().
 *
 * When the query finishes, the endpoint won't be destroyed immediately since we
 * may still want to check its state on QD. In the implementation, the
 * DestroyEndpointExecState() is blocked until the parallel retrieve cursor
 * is closed explicitly through CLOSE statement or error happens.
 *
 * UDF gp_wait_parallel_retrieve_cursor() is supplied as helper function
 * to monitor the retrieve state. They should be run in the declare transaction
 * block on QD.
 *
 * Copyright (c) 2020-Present VMware, Inc. or its affiliates
 *
 * IDENTIFICATION
 *		src/backend/cdb/cdbendpoint.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/session.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/tupdesc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/async.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/hashfn.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq-fe.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq/libpq.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq/pqformat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgstat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"port/atomics.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/ipc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/latch.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/procsignal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/backend_cancel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/faultinjector.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/guc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbdisp_query.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbdispatchresult.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbendpoint.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdbendpoint_private.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbsrlz.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbvars.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WAIT_ENDPOINT_TIMEOUT_MS</name></cpp:macro>	<cpp:value>100</cpp:value></cpp:define>

<comment type="block">/*
 * The size of endpoint tuple queue in bytes.
 * This value refers upstream PARALLEL_TUPLE_QUEUE_SIZE
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ENDPOINT_TUPLE_QUEUE_SIZE</name></cpp:macro>		<cpp:value>65536</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SHMEM_ENDPOINTS_ENTRIES</name></cpp:macro>			<cpp:value>"SharedMemoryEndpointEntries"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SHMEM_ENPOINTS_SESSION_INFO</name></cpp:macro>		<cpp:value>"EndpointsSessionInfosHashtable"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SHMEM_PARALLEL_CURSOR_COUNT</name></cpp:macro>		<cpp:value>"ParallelCursorCount"</cpp:value></cpp:define>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FAULT_INJECTOR</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DUMMY_ENDPOINT_NAME</name></cpp:macro> <cpp:value>"DUMMYENDPOINTNAME"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DUMMY_CURSOR_NAME</name></cpp:macro>	<cpp:value>"DUMMYCURSORNAME"</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><specifier>static</specifier> <name>EndpointExecState</name> <modifier>*</modifier></type> <name>CurrentEndpointExecState</name></decl>;</decl_stmt>

<typedef>typedef <type><struct>struct <name>EndpointTokenTag</name>
<block>{
	<decl_stmt><decl><type><name>int</name></type>			<name>sessionID</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>userID</name></decl>;</decl_stmt>
}</block></struct></type>			<name>EndpointTokenTag</name>;</typedef>

<comment type="block">/*
 * EndpointTokenHash is located in shared memory on each segment for
 * authentication purpose.
 */</comment>
<typedef>typedef <type><struct>struct <name>EndpointTokenEntry</name>
<block>{
	<decl_stmt><decl><type><name>EndpointTokenTag</name></type> <name>tag</name></decl>;</decl_stmt>

	<comment type="block">/* The auth token for this session. */</comment>
	<decl_stmt><decl><type><name>int8</name></type>		<name><name>token</name><index>[<expr><name>ENDPOINT_TOKEN_ARR_LEN</name></expr>]</index></name></decl>;</decl_stmt>

	<comment type="block">/* How many endpoints are referred to this entry. */</comment>
	<decl_stmt><decl><type><name>uint16</name></type>		<name>refCount</name></decl>;</decl_stmt>

}</block></struct></type>			<name>EndpointTokenEntry</name>;</typedef>

<comment type="block">/* Shared hash table for session infos */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>HTAB</name> <modifier>*</modifier></type><name>EndpointTokenHash</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* Point to Endpoint entries in shared memory */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>EndpointData</name></name> <modifier>*</modifier></type><name>sharedEndpoints</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<comment type="block">/* Point to parallel cursors count in shared memory */</comment>
<decl_stmt><decl><type><specifier>volatile</specifier> <name>uint32</name> <modifier>*</modifier></type><name>parallelCursorCount</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* Init helper functions */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>InitSharedEndpoints</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Token utility functions */</comment>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>int8</name> <modifier>*</modifier></type><name>create_endpoint_token</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Endpoint helper function */</comment>
<function_decl><type><specifier>static</specifier> <name>Endpoint</name> <modifier>*</modifier></type><name>alloc_endpoint</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cursorName</name></decl></parameter>, <parameter><decl><type><name>dsm_handle</name></type> <name>dsmHandle</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>free_endpoint</name><parameter_list>(<parameter><decl><type><name>Endpoint</name> <modifier>*</modifier></type><name>endpoint</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>create_and_connect_mq</name><parameter_list>(<parameter><decl><type><name>TupleDesc</name></type> <name>tupleDesc</name></decl></parameter>,
								  <parameter><decl><type><name>dsm_segment</name> <modifier>*</modifier><modifier>*</modifier></type><name>mqSeg</name></decl></parameter> <comment type="block">/* out */</comment> ,
								  <parameter><decl><type><name>shm_mq_handle</name> <modifier>*</modifier><modifier>*</modifier></type><name>mqHandle</name></decl></parameter> <comment type="block">/* out */</comment> )</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>detach_mq</name><parameter_list>(<parameter><decl><type><name>dsm_segment</name> <modifier>*</modifier></type><name>dsmSeg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>setup_endpoint_token_entry</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>wait_receiver</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>unset_endpoint_sender_pid</name><parameter_list>(<parameter><decl><type><name>Endpoint</name> <modifier>*</modifier></type><name>endPoint</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>abort_endpoint</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>wait_parallel_retrieve_close</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * Calculate the shared memory size for PARALLEL RETRIEVE CURSOR execute.
 */</comment>
<function><type><name>Size</name></type>
<name>EndpointShmemSize</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Size</name></type>		<name>size</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><call><name>mul_size</name><argument_list>(<argument><expr><name>MAX_ENDPOINT_SIZE</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>EndpointData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Maximum parallel retrieve cursor session number should be no more than
	 * the maximum endpoint number, so use MAX_ENDPOINT_SIZE here.
	 */</comment>
	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(
					<argument><expr><name>size</name></expr></argument>, <argument><expr><call><name>hash_estimate_size</name><argument_list>(<argument><expr><name>MAX_ENDPOINT_SIZE</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>EndpointTokenEntry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>size</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Initialize shared memory for PARALLEL RETRIEVE CURSOR.
 */</comment>
<function><type><name>void</name></type>
<name>EndpointShmemInit</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HASHCTL</name></type>		<name>hctl</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>sharedEndpoints</name> <operator>=</operator> <operator>(</operator><name>Endpoint</name> <operator>*</operator><operator>)</operator>
		<call><name>ShmemInitStruct</name><argument_list>(<argument><expr><name>SHMEM_ENDPOINTS_ENTRIES</name></expr></argument>,
						<argument><expr><call><name>MAXALIGN</name><argument_list>(<argument><expr><call><name>mul_size</name><argument_list>(<argument><expr><name>MAX_ENDPOINT_SIZE</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>EndpointData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>InitSharedEndpoints</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hctl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>hctl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hctl</name><operator>.</operator><name>keysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>EndpointTokenTag</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hctl</name><operator>.</operator><name>entrysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>EndpointTokenEntry</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hctl</name><operator>.</operator><name>hash</name></name> <operator>=</operator> <name>tag_hash</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>EndpointTokenHash</name> <operator>=</operator>
		<call><name>ShmemInitHash</name><argument_list>(<argument><expr><name>SHMEM_ENPOINTS_SESSION_INFO</name></expr></argument>, <argument><expr><name>MAX_ENDPOINT_SIZE</name></expr></argument>,
					  <argument><expr><name>MAX_ENDPOINT_SIZE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hctl</name></expr></argument>, <argument><expr><name>HASH_ELEM</name> <operator>|</operator> <name>HASH_FUNCTION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Calculate the shared memory size for PARALLEL RETRIEVE CURSOR count.
 */</comment>
<function><type><name>Size</name></type>
<name>ParallelCursorCountSize</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>parallelCursorCount</name></expr></argument>)</argument_list></sizeof></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ParallelCursorCountInit</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>	<name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name>parallelCursorCount</name> <operator>=</operator> <operator>(</operator><name>uint32</name> <operator>*</operator><operator>)</operator> <call><name>ShmemInitStruct</name><argument_list>(<argument><expr><name>SHMEM_PARALLEL_CURSOR_COUNT</name></expr></argument>, <argument><expr><call><name>ParallelCursorCountSize</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>NULL</name> <operator>!=</operator> <name>parallelCursorCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pg_atomic_init_u32</name><argument_list>(<argument><expr><operator>(</operator><name>pg_atomic_uint32</name> <operator>*</operator><operator>)</operator> <name>parallelCursorCount</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Initialize shared memory Endpoint array.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>InitSharedEndpoints</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Endpoint</name>	<modifier>*</modifier></type><name>endpoints</name> <init>= <expr><name>sharedEndpoints</name></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>MAX_ENDPOINT_SIZE</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>endpoints</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>name</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>endpoints</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>cursorName</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>endpoints</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>databaseID</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>endpoints</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>senderPid</name> <operator>=</operator> <name>InvalidPid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>endpoints</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>receiverPid</name> <operator>=</operator> <name>InvalidPid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>endpoints</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>mqDsmHandle</name> <operator>=</operator> <name>DSM_HANDLE_INVALID</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>endpoints</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sessionDsmHandle</name> <operator>=</operator> <name>DSM_HANDLE_INVALID</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>endpoints</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sessionID</name> <operator>=</operator> <name>InvalidEndpointSessionId</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>endpoints</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>userID</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>endpoints</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>state</name> <operator>=</operator> <name>ENDPOINTSTATE_INVALID</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>endpoints</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>empty</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>InitSharedLatch</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>endpoints</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ackDone</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * Get the endpoint location. Currently used in EXPLAIN only.
 */</comment>
<function><type><name><name>enum</name> <name>EndPointExecPosition</name></name></type>
<name>GetParallelCursorEndpointPosition</name><parameter_list>(<parameter><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>plan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>plan</name><operator>-&gt;</operator><name>planTree</name><operator>-&gt;</operator><name>flow</name><operator>-&gt;</operator><name>flotype</name></name> <operator>==</operator> <name>FLOW_SINGLETON</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>plan</name><operator>-&gt;</operator><name>planTree</name><operator>-&gt;</operator><name>flow</name><operator>-&gt;</operator><name>locustype</name></name> <operator>==</operator> <name>CdbLocusType_SegmentGeneral</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>ENDPOINT_ON_SINGLE_QE</name></expr>;</return></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<return>return <expr><name>ENDPOINT_ON_ENTRY_DB</name></expr>;</return></block_content></block></else></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>plan</name><operator>-&gt;</operator><name>slices</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name><name>directDispatch</name><operator>.</operator><name>isDirectDispatch</name></name> <operator>&amp;&amp;</operator>
			 <name><name>plan</name><operator>-&gt;</operator><name>slices</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name><name>directDispatch</name><operator>.</operator><name>contentIds</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>ENDPOINT_ON_SOME_QE</name></expr>;</return>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><name>ENDPOINT_ON_ALL_QE</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * QD waits until the cursor ready for retrieve on the related segments.
 */</comment>
<function><type><name>void</name></type>
<name>WaitEndpointsReady</name><parameter_list>(<parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>CdbDispatcherState</name> <modifier>*</modifier></type><name>ds</name> <init>= <expr><name><name>estate</name><operator>-&gt;</operator><name>dispatcherState</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>cdbdisp_checkDispatchAckMessage</name><argument_list>(<argument><expr><name>ds</name></expr></argument>, <argument><expr><name>ENDPOINT_READY_ACK_MSG</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>check_parallel_retrieve_cursor_errors</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Get or create a authentication token for current session.
 */</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>int8</name> <modifier>*</modifier></type>
<name>create_endpoint_token</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>sessionId</name> <init>= <expr><name>InvalidEndpointSessionId</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>int8</name></type> <name><name>currentToken</name><index>[<expr><name>ENDPOINT_TOKEN_ARR_LEN</name></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Generate a new token only if gp_session_id has changed */</comment>
	<if_stmt><if>if <condition>(<expr><name>sessionId</name> <operator>!=</operator> <name>gp_session_id</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>sessionId</name> <operator>=</operator> <name>gp_session_id</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pg_strong_random</name><argument_list>(<argument><expr><name>currentToken</name></expr></argument>, <argument><expr><name>ENDPOINT_TOKEN_ARR_LEN</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"failed to generate a new random token for session id %d"</literal></expr></argument>, <argument><expr><name>sessionId</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>currentToken</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Send acknowledge message to QD.
 */</comment>
<function><type><name>void</name></type>
<name>EndpointNotifyQD</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>message</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>NotifyMyFrontEnd</name><argument_list>(<argument><expr><name>CDB_NOTIFY_ENDPOINT_ACK</name></expr></argument>, <argument><expr><name>message</name></expr></argument>, <argument><expr><name>MyProcPid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pq_flush</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Allocate and initialize an endpoint and then create a dest receiver for
 * PARALLEL RETRIEVE CURSOR. The dest receiver is based on shm_mq that is used
 * by the upstream parallel work.
 */</comment>
<function><type><name>void</name></type>
<name>SetupEndpointExecState</name><parameter_list>(<parameter><decl><type><name>TupleDesc</name></type> <name>tupleDesc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cursorName</name></decl></parameter>,
						<parameter><decl><type><name>CmdType</name></type> <name>operation</name></decl></parameter>, <parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier><modifier>*</modifier></type><name>endpointDest</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>shm_mq_handle</name> <modifier>*</modifier></type><name>shmMqHandle</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>allocEndpointExecState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * The message queue needs to be created first since the dsm_handle has to
	 * be ready when create EndpointDesc entry.
	 */</comment>
	<expr_stmt><expr><call><name>create_and_connect_mq</name><argument_list>(<argument><expr><name>tupleDesc</name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>CurrentEndpointExecState</name><operator>-&gt;</operator><name>dsmSeg</name></name><operator>)</operator></expr></argument>, <argument><expr><operator>&amp;</operator><name>shmMqHandle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Alloc endpoint and set it as the active one for sender.
	 */</comment>
	<expr_stmt><expr><name><name>CurrentEndpointExecState</name><operator>-&gt;</operator><name>endpoint</name></name> <operator>=</operator>
		<call><name>alloc_endpoint</name><argument_list>(<argument><expr><name>cursorName</name></expr></argument>, <argument><expr><call><name>dsm_segment_handle</name><argument_list>(<argument><expr><name><name>CurrentEndpointExecState</name><operator>-&gt;</operator><name>dsmSeg</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>setup_endpoint_token_entry</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>CurrentEndpointExecState</name><operator>-&gt;</operator><name>dest</name></name> <operator>=</operator> <call><name>CreateTupleQueueDestReceiver</name><argument_list>(<argument><expr><name>shmMqHandle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>(</operator><name><name>CurrentEndpointExecState</name><operator>-&gt;</operator><name>dest</name><operator>-&gt;</operator><name>rStartup</name></name><operator>)</operator><operator>(</operator><name><name>CurrentEndpointExecState</name><operator>-&gt;</operator><name>dest</name></name><operator>,</operator> <name>operation</name><operator>,</operator> <name>tupleDesc</name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>endpointDest</name> <operator>=</operator> <name><name>CurrentEndpointExecState</name><operator>-&gt;</operator><name>dest</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Wait until the endpoint finishes and then clean up.
 *
 * If the queue is large enough for tuples to send, must wait for a receiver
 * to attach the message queue before endpoint detaches the message queue.
 * Cause if the queue gets detached before receiver attaches, the queue
 * will never be attached by a receiver.
 *
 * Should also clean all other endpoint info here.
 */</comment>
<function><type><name>void</name></type>
<name>DestroyEndpointExecState</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>endpointDest</name> <init>= <expr><name><name>CurrentEndpointExecState</name><operator>-&gt;</operator><name>dest</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>CurrentEndpointExecState</name><operator>-&gt;</operator><name>endpoint</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>CurrentEndpointExecState</name><operator>-&gt;</operator><name>dsmSeg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * wait for receiver to start tuple retrieving. ackDone latch will be
	 * reset to be re-used when retrieving finished. See notify_sender()
	 * callers.
	 */</comment>
	<expr_stmt><expr><call><name>wait_receiver</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * tqueueShutdownReceiver() (rShutdown callback) will call
	 * shm_mq_detach(), so need to call it before detach_mq(). Retrieving
	 * session will set ackDone latch again after shm_mq_detach() called here.
	 */</comment>
	<expr_stmt><expr><call>(<modifier>*</modifier><name><name>endpointDest</name><operator>-&gt;</operator><name>rShutdown</name></name>) <argument_list>(<argument><expr><name>endpointDest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call>(<modifier>*</modifier><name><name>endpointDest</name><operator>-&gt;</operator><name>rDestroy</name></name>) <argument_list>(<argument><expr><name>endpointDest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>CurrentEndpointExecState</name><operator>-&gt;</operator><name>dest</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Wait until all data is retrieved by receiver. This is needed because
	 * when the endpoint sends all data to shared message queue. The retrieve
	 * session may still not get all data.
	 */</comment>
	<expr_stmt><expr><call><name>wait_receiver</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>ParallelCursorEndpointLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>unset_endpoint_sender_pid</name><argument_list>(<argument><expr><name><name>CurrentEndpointExecState</name><operator>-&gt;</operator><name>endpoint</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ParallelCursorEndpointLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Notify QD */</comment>
	<expr_stmt><expr><call><name>EndpointNotifyQD</name><argument_list>(<argument><expr><name>ENDPOINT_FINISHED_ACK_MSG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If all data get sent, hang the process and wait for QD to close it. The
	 * purpose is to not clean up Endpoint entry until CLOSE/COMMIT/ABORT
	 * (i.e. PortalCleanup get executed). So user can still see the finished
	 * endpoint status through the gp_get_endpoints() UDF. This is needed because
	 * pg_cursor view can still see the PARALLEL RETRIEVE CURSOR
	 */</comment>
	<expr_stmt><expr><call><name>wait_parallel_retrieve_close</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>ParallelCursorEndpointLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free_endpoint</name><argument_list>(<argument><expr><name><name>CurrentEndpointExecState</name><operator>-&gt;</operator><name>endpoint</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ParallelCursorEndpointLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>CurrentEndpointExecState</name><operator>-&gt;</operator><name>endpoint</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>detach_mq</name><argument_list>(<argument><expr><name><name>CurrentEndpointExecState</name><operator>-&gt;</operator><name>dsmSeg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>CurrentEndpointExecState</name><operator>-&gt;</operator><name>dsmSeg</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>CurrentEndpointExecState</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Allocate an Endpoint entry in shared memory.
 *
 * cursorName - the parallel retrieve cursor name.
 * dsmHandle  - dsm handle of shared memory message queue.
 */</comment>
<function><type><specifier>static</specifier> <name>Endpoint</name>
<modifier>*</modifier></type><name>alloc_endpoint</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cursorName</name></decl></parameter>, <parameter><decl><type><name>dsm_handle</name></type> <name>dsmHandle</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>foundIdx</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Endpoint</name>	<modifier>*</modifier></type><name>ret</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>dsm_handle</name></type>	<name>session_dsm_handle</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>session_dsm_handle</name> <operator>=</operator> <call><name>GetSessionDsmHandle</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>session_dsm_handle</name> <operator>==</operator> <name>DSM_HANDLE_INVALID</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"failed to create the per-session DSM segment."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>ParallelCursorEndpointLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FAULT_INJECTOR</name></cpp:ifdef>
	<comment type="block">/* inject fault "skip" to set end-point shared memory slot full */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>SIMPLE_FAULT_INJECTOR</name><argument_list>(<argument><expr><literal type="string">"alloc_endpoint_slot_full"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>FaultInjectorTypeSkip</name></expr>)</condition>
	<block>{<block_content>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>MAX_ENDPOINT_SIZE</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>sharedEndpoints</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>empty</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* pretend to set a valid endpoint */</comment>
				<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name><name>sharedEndpoints</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>,
						 <argument><expr><name>DUMMY_ENDPOINT_NAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name><name>sharedEndpoints</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>cursorName</name></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>,
						 <argument><expr><name>DUMMY_CURSOR_NAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>sharedEndpoints</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>databaseID</name> <operator>=</operator> <name>MyDatabaseId</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>sharedEndpoints</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>mqDsmHandle</name> <operator>=</operator> <name>DSM_HANDLE_INVALID</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>sharedEndpoints</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sessionDsmHandle</name> <operator>=</operator> <name>DSM_HANDLE_INVALID</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>sharedEndpoints</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sessionID</name> <operator>=</operator> <name>gp_session_id</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>sharedEndpoints</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>userID</name> <operator>=</operator> <call><name>GetSessionUserId</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>sharedEndpoints</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>senderPid</name> <operator>=</operator> <name>InvalidPid</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>sharedEndpoints</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>receiverPid</name> <operator>=</operator> <name>InvalidPid</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>sharedEndpoints</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>empty</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>SIMPLE_FAULT_INJECTOR</name><argument_list>(<argument><expr><literal type="string">"alloc_endpoint_slot_full_reset"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>FaultInjectorTypeSkip</name></expr>)</condition>
	<block>{<block_content>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>MAX_ENDPOINT_SIZE</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>endpoint_name_equals</name><argument_list>(<argument><expr><name><name>sharedEndpoints</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>,
									 <argument><expr><name>DUMMY_ENDPOINT_NAME</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>sharedEndpoints</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>mqDsmHandle</name> <operator>=</operator> <name>DSM_HANDLE_INVALID</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>sharedEndpoints</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>empty</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/* find an available slot */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>MAX_ENDPOINT_SIZE</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>sharedEndpoints</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>empty</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>foundIdx</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><name>foundIdx</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROGRAM_LIMIT_EXCEEDED</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"failed to allocate endpoint for session id %d"</literal></expr></argument>, <argument><expr><name>gp_session_id</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>generate_endpoint_name</name><argument_list>(<argument><expr><name><name>sharedEndpoints</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>, <argument><expr><name>cursorName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>StrNCpy</name><argument_list>(<argument><expr><name><name>sharedEndpoints</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>cursorName</name></expr></argument>, <argument><expr><name>cursorName</name></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sharedEndpoints</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>databaseID</name> <operator>=</operator> <name>MyDatabaseId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sharedEndpoints</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sessionID</name> <operator>=</operator> <name>gp_session_id</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sharedEndpoints</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>userID</name> <operator>=</operator> <call><name>GetSessionUserId</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sharedEndpoints</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>senderPid</name> <operator>=</operator> <name>MyProcPid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sharedEndpoints</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>receiverPid</name> <operator>=</operator> <name>InvalidPid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sharedEndpoints</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>state</name> <operator>=</operator> <name>ENDPOINTSTATE_READY</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sharedEndpoints</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>empty</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sharedEndpoints</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>mqDsmHandle</name> <operator>=</operator> <name>dsmHandle</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sharedEndpoints</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sessionDsmHandle</name> <operator>=</operator> <name>session_dsm_handle</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>OwnLatch</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>sharedEndpoints</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ackDone</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ret</name> <operator>=</operator> <operator>&amp;</operator><name><name>sharedEndpoints</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ParallelCursorEndpointLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Create and setup the shared memory message queue.
 *
 * Create a dsm which contains a TOC(table of content). It has 3 parts:
 * 1. Tuple's TupleDesc length.
 * 2. Tuple's TupleDesc.
 * 3. Shared memory message queue.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>create_and_connect_mq</name><parameter_list>(<parameter><decl><type><name>TupleDesc</name></type> <name>tupleDesc</name></decl></parameter>, <parameter><decl><type><name>dsm_segment</name> <modifier>*</modifier><modifier>*</modifier></type><name>mqSeg</name></decl></parameter> <comment type="block">/* out */</comment> ,
					  <parameter><decl><type><name>shm_mq_handle</name> <modifier>*</modifier><modifier>*</modifier></type><name>mqHandle</name></decl></parameter> <comment type="block">/* out */</comment> )</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>shm_toc</name>		<modifier>*</modifier></type><name>toc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>shm_mq</name>		<modifier>*</modifier></type><name>mq</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>shm_toc_estimator</name></type>	<name>tocEst</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		 <name>tocSize</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			 <name>tupdescLen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>		<modifier>*</modifier></type><name>tupdescSer</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>		<modifier>*</modifier></type><name>tdlenSpace</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>		<modifier>*</modifier></type><name>tupdescSpace</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDescNode</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>TupleDescNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>elogif</name><argument_list>(<argument><expr><name>gp_log_endpoints</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"CDB_ENDPOINT: create and setup the shared memory message queue"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Serialize TupleDesc */</comment>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>natts</name></name> <operator>=</operator> <name><name>tupleDesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>tuple</name></name> <operator>=</operator> <name>tupleDesc</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>tupdescSer</name> <operator>=</operator>
		<call><name>serializeNode</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tupdescLen</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument> <comment type="block">/* uncompressed_size */</comment> )</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Estimate the dsm size */</comment>
	<expr_stmt><expr><call><name>shm_toc_initialize_estimator</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tocEst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>shm_toc_estimate_chunk</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tocEst</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>tupdescLen</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>shm_toc_estimate_chunk</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tocEst</name></expr></argument>, <argument><expr><name>tupdescLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>shm_toc_estimate_chunk</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tocEst</name></expr></argument>, <argument><expr><name>ENDPOINT_TUPLE_QUEUE_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>shm_toc_estimate_keys</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tocEst</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tocSize</name> <operator>=</operator> <call><name>shm_toc_estimate</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tocEst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Create dsm and initialize toc. */</comment>
	<expr_stmt><expr><operator>*</operator><name>mqSeg</name> <operator>=</operator> <call><name>dsm_create</name><argument_list>(<argument><expr><name>tocSize</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Make sure the dsm sticks around up until session exit */</comment>
	<expr_stmt><expr><call><name>dsm_pin_mapping</name><argument_list>(<argument><expr><operator>*</operator><name>mqSeg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>toc</name> <operator>=</operator> <call><name>shm_toc_create</name><argument_list>(<argument><expr><name>ENDPOINT_MSG_QUEUE_MAGIC</name></expr></argument>, <argument><expr><call><name>dsm_segment_address</name><argument_list>(<argument><expr><operator>*</operator><name>mqSeg</name></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><name>tocSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tdlenSpace</name> <operator>=</operator> <call><name>shm_toc_allocate</name><argument_list>(<argument><expr><name>toc</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>tupdescLen</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>tdlenSpace</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tupdescLen</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>tupdescLen</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>shm_toc_insert</name><argument_list>(<argument><expr><name>toc</name></expr></argument>, <argument><expr><name>ENDPOINT_KEY_TUPLE_DESC_LEN</name></expr></argument>, <argument><expr><name>tdlenSpace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tupdescSpace</name> <operator>=</operator> <call><name>shm_toc_allocate</name><argument_list>(<argument><expr><name>toc</name></expr></argument>, <argument><expr><name>tupdescLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>tupdescSpace</name></expr></argument>, <argument><expr><name>tupdescSer</name></expr></argument>, <argument><expr><name>tupdescLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>shm_toc_insert</name><argument_list>(<argument><expr><name>toc</name></expr></argument>, <argument><expr><name>ENDPOINT_KEY_TUPLE_DESC</name></expr></argument>, <argument><expr><name>tupdescSpace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>mq</name> <operator>=</operator> <call><name>shm_mq_create</name><argument_list>(<argument><expr><call><name>shm_toc_allocate</name><argument_list>(<argument><expr><name>toc</name></expr></argument>, <argument><expr><name>ENDPOINT_TUPLE_QUEUE_SIZE</name></expr></argument>)</argument_list></call></expr></argument>,
					   <argument><expr><name>ENDPOINT_TUPLE_QUEUE_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>shm_toc_insert</name><argument_list>(<argument><expr><name>toc</name></expr></argument>, <argument><expr><name>ENDPOINT_KEY_TUPLE_QUEUE</name></expr></argument>, <argument><expr><name>mq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>shm_mq_set_sender</name><argument_list>(<argument><expr><name>mq</name></expr></argument>, <argument><expr><name>MyProc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>mqHandle</name> <operator>=</operator> <call><name>shm_mq_attach</name><argument_list>(<argument><expr><name>mq</name></expr></argument>, <argument><expr><operator>*</operator><name>mqSeg</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>mqHandle</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"attach to endpoint shared message queue failed"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Create/reuse EndpointTokenEntry for current session in shared memory.
 * EndpointTokenEntry is used for authentication in the retrieve sessions.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>setup_endpoint_token_entry</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>EndpointTokenEntry</name> <modifier>*</modifier></type><name>infoEntry</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>EndpointTokenTag</name></type> <name>tag</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>int8</name> <modifier>*</modifier></type><name>token</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>tag</name><operator>.</operator><name>sessionID</name></name> <operator>=</operator> <name>gp_session_id</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tag</name><operator>.</operator><name>userID</name></name> <operator>=</operator> <call><name>GetSessionUserId</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>ParallelCursorEndpointLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>infoEntry</name> <operator>=</operator> <operator>(</operator><name>EndpointTokenEntry</name> <operator>*</operator><operator>)</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>EndpointTokenHash</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tag</name></expr></argument>, <argument><expr><name>HASH_ENTER</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>elogif</name><argument_list>(<argument><expr><name>gp_log_endpoints</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"CDB_ENDPOINT: Finish endpoint init. Found EndpointTokenEntry? %d"</literal></expr></argument>, <argument><expr><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Save the token if it is the first time we create endpoint in current
	 * session. One session will be mapped to one token only.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>create_endpoint_token</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>infoEntry</name><operator>-&gt;</operator><name>token</name></name></expr></argument>, <argument><expr><name>token</name></expr></argument>, <argument><expr><name>ENDPOINT_TOKEN_ARR_LEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>infoEntry</name><operator>-&gt;</operator><name>refCount</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>infoEntry</name><operator>-&gt;</operator><name>refCount</name></name><operator>++</operator></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>infoEntry</name><operator>-&gt;</operator><name>refCount</name></name> <operator>&lt;=</operator> <name>MAX_ENDPOINT_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ParallelCursorEndpointLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * check if QD connection still alive.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>checkQDConnectionAlive</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ssize_t</name></type>		<name>ret</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>buf</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>MyProcPort</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>MyProcPort</name><operator>-&gt;</operator><name>sock</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
	<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>recv</name><argument_list>(<argument><expr><name><name>MyProcPort</name><operator>-&gt;</operator><name>sock</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>MSG_PEEK</name> <operator>|</operator> <name>MSG_DONTWAIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>recv</name><argument_list>(<argument><expr><name><name>MyProcPort</name><operator>-&gt;</operator><name>sock</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>MSG_PEEK</name> <operator>|</operator> <name>MSG_PARTIAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>				<comment type="block">/* socket has been closed. EOF */</comment>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>				<comment type="block">/* data waiting on socket, it must be OK. */</comment>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>				<comment type="block">/* error, or would be block. */</comment>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>EAGAIN</name> <operator>||</operator> <name>errno</name> <operator>==</operator> <name>EINPROGRESS</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if>		<comment type="block">/* connection intact, no data available */</comment>
		<else>else<block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* not reached */</comment>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * wait_receiver - wait receiver to retrieve at least once from the
 * shared memory message queue.
 *
 * If the queue only attached by the sender and the queue is large enough
 * for all tuples, sender should wait receiver. Cause if sender detached
 * from the queue, the queue will be not available for receiver.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>wait_receiver</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>EndpointExecState</name> <modifier>*</modifier></type> <name>state</name> <init>= <expr><name>CurrentEndpointExecState</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>elogif</name><argument_list>(<argument><expr><name>gp_log_endpoints</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"CDB_ENDPOINT: wait receiver"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>true</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>wr</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>QueryFinishPending</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>elogif</name><argument_list>(<argument><expr><name>gp_log_endpoints</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"CDB_ENDPOINT: sender wait latch in wait_receiver()"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>wr</name> <operator>=</operator> <call><name>WaitLatchOrSocket</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>endpoint</name><operator>-&gt;</operator><name>ackDone</name></name></expr></argument>,
							   <argument><expr><name>WL_LATCH_SET</name> <operator>|</operator> <name>WL_POSTMASTER_DEATH</name> <operator>|</operator> <name>WL_TIMEOUT</name> <operator>|</operator> <name>WL_SOCKET_READABLE</name></expr></argument>,
							   <argument><expr><name><name>MyProcPort</name><operator>-&gt;</operator><name>sock</name></name></expr></argument>,
							   <argument><expr><name>WAIT_ENDPOINT_TIMEOUT_MS</name></expr></argument>,
							   <argument><expr><name>PG_WAIT_PARALLEL_RETRIEVE_CURSOR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>wr</name> <operator>&amp;</operator> <name>WL_SOCKET_READABLE</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>checkQDConnectionAlive</name><argument_list>()</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"CDB_ENDPOINT: sender found that the connection to QD is broken: %m"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>abort_endpoint</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>proc_exit</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>wr</name> <operator>&amp;</operator> <name>WL_POSTMASTER_DEATH</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>abort_endpoint</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"CDB_ENDPOINT: postmaster exit, close shared memory message queue"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>proc_exit</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>wr</name> <operator>&amp;</operator> <name>WL_LATCH_SET</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>elogif</name><argument_list>(<argument><expr><name>gp_log_endpoints</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"CDB_ENDPOINT: sender reset latch in wait_receiver()"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ResetLatch</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>endpoint</name><operator>-&gt;</operator><name>ackDone</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/*
 * Detach the shared memory message queue.
 * This should happen after free endpoint, otherwise endpoint-&gt;mq_dsm_handle
 * becomes invalid pointer.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>detach_mq</name><parameter_list>(<parameter><decl><type><name>dsm_segment</name> <modifier>*</modifier></type><name>dsmSeg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>elogif</name><argument_list>(<argument><expr><name>gp_log_endpoints</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"CDB_ENDPOINT: sender message queue detaching. '%p'"</literal></expr></argument>,
		 <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>dsmSeg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>dsmSeg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>dsm_detach</name><argument_list>(<argument><expr><name>dsmSeg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Unset endpoint sender pid.
 *
 * Clean the Endpoint entry sender pid when endpoint finish it's
 * job or abort.
 * Needs to be called with exclusive lock on ParallelCursorEndpointLock.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>unset_endpoint_sender_pid</name><parameter_list>(<parameter><decl><type><name>Endpoint</name> <modifier>*</modifier></type><name>endpoint</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>endpoint</name><operator>-&gt;</operator><name>empty</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>elogif</name><argument_list>(<argument><expr><name>gp_log_endpoints</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"CDB_ENDPOINT: unset endpoint sender pid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Only the endpoint QE/entry DB execute this unset sender pid function.
	 * The sender pid in Endpoint entry must be MyProcPid or InvalidPid.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>MyProcPid</name> <operator>==</operator> <name><name>endpoint</name><operator>-&gt;</operator><name>senderPid</name></name> <operator>||</operator>
		   <name><name>endpoint</name><operator>-&gt;</operator><name>senderPid</name></name> <operator>==</operator> <name>InvalidPid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>am_cursor_retrieve_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>endpoint</name><operator>-&gt;</operator><name>senderPid</name></name> <operator>=</operator> <name>InvalidPid</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * abort_endpoint - xact abort routine for endpoint
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>abort_endpoint</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>EndpointExecState</name> <modifier>*</modifier></type> <name>state</name> <init>= <expr><name>CurrentEndpointExecState</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>dest</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * rShutdown callback will call shm_mq_detach(), so need to call it
		 * before detach_mq() to clean up.
		 */</comment>
		<decl_stmt><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>endpointDest</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>dest</name></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call>(<modifier>*</modifier><name><name>endpointDest</name><operator>-&gt;</operator><name>rShutdown</name></name>) <argument_list>(<argument><expr><name>endpointDest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call>(<modifier>*</modifier><name><name>endpointDest</name><operator>-&gt;</operator><name>rDestroy</name></name>) <argument_list>(<argument><expr><name>endpointDest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>dest</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>endpoint</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>ParallelCursorEndpointLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * These two better be called in one lock section. So retriever abort
		 * will not execute extra works.
		 */</comment>
		<expr_stmt><expr><call><name>unset_endpoint_sender_pid</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>endpoint</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>free_endpoint</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>endpoint</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ParallelCursorEndpointLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Notify QD */</comment>
		<expr_stmt><expr><call><name>EndpointNotifyQD</name><argument_list>(<argument><expr><name>ENDPOINT_FINISHED_ACK_MSG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>endpoint</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * During xact abort, should make sure the endpoint_cleanup called first.
	 * Cause if call detach_mq to detach the message queue first, the
	 * retriever may read NULL from message queue, then retrieve mark itself
	 * down.
	 *
	 * So here, need to make sure signal retrieve abort first before endpoint
	 * detach message queue.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>dsmSeg</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>detach_mq</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>dsmSeg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>dsmSeg</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Wait for PARALLEL RETRIEVE CURSOR cleanup after the endpoint sends all data.
 *
 * If all data get sent, hang the process and wait for QD to close it.
 * The purpose is to not clean up Endpoint entry until
 * CLOSE/COMMIT/ABORT (ie. PortalCleanup get executed).
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>wait_parallel_retrieve_close</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>ResetLatch</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>MyProc</name><operator>-&gt;</operator><name>procLatch</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>true</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>wr</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>QueryFinishPending</name> <operator>||</operator> <name>QueryCancelPending</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>elogif</name><argument_list>(<argument><expr><name>gp_log_endpoints</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"CDB_ENDPOINT: wait for parallel retrieve cursor close"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>wr</name> <operator>=</operator> <call><name>WaitLatchOrSocket</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>MyProc</name><operator>-&gt;</operator><name>procLatch</name></name></expr></argument>,
							   <argument><expr><name>WL_LATCH_SET</name> <operator>|</operator> <name>WL_POSTMASTER_DEATH</name> <operator>|</operator> <name>WL_TIMEOUT</name> <operator>|</operator> <name>WL_SOCKET_READABLE</name></expr></argument>,
							   <argument><expr><name><name>MyProcPort</name><operator>-&gt;</operator><name>sock</name></name></expr></argument>,
							   <argument><expr><name>WAIT_ENDPOINT_TIMEOUT_MS</name></expr></argument>,
							   <argument><expr><name>PG_WAIT_PARALLEL_RETRIEVE_CURSOR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>wr</name> <operator>&amp;</operator> <name>WL_POSTMASTER_DEATH</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"CDB_ENDPOINT: postmaster exit, close shared memory message queue"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>proc_exit</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>wr</name> <operator>&amp;</operator> <name>WL_SOCKET_READABLE</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>checkQDConnectionAlive</name><argument_list>()</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"CDB_ENDPOINT: sender found that the connection to QD is broken: %m"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>proc_exit</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>wr</name> <operator>&amp;</operator> <name>WL_LATCH_SET</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ResetLatch</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>MyProc</name><operator>-&gt;</operator><name>procLatch</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/*
 * free_endpoint - Frees the given endpoint.
 *
 * Needs to be called with exclusive lock on ParallelCursorEndpointLock.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>free_endpoint</name><parameter_list>(<parameter><decl><type><name>Endpoint</name> <modifier>*</modifier></type><name>endpoint</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>EndpointTokenTag</name></type> <name>tag</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>EndpointTokenEntry</name> <modifier>*</modifier></type><name>infoEntry</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>	<name>found</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>endpoint</name><operator>-&gt;</operator><name>empty</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>elogif</name><argument_list>(<argument><expr><name>gp_log_endpoints</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"CDB_ENDPOINT: free endpoint '%s'"</literal></expr></argument>, <argument><expr><name><name>endpoint</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>endpoint</name><operator>-&gt;</operator><name>databaseID</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>endpoint</name><operator>-&gt;</operator><name>mqDsmHandle</name></name> <operator>=</operator> <name>DSM_HANDLE_INVALID</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>endpoint</name><operator>-&gt;</operator><name>sessionDsmHandle</name></name> <operator>=</operator> <name>DSM_HANDLE_INVALID</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>endpoint</name><operator>-&gt;</operator><name>empty</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name><name>endpoint</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name><name>endpoint</name><operator>-&gt;</operator><name>cursorName</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ResetLatch</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>endpoint</name><operator>-&gt;</operator><name>ackDone</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>DisownLatch</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>endpoint</name><operator>-&gt;</operator><name>ackDone</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>tag</name><operator>.</operator><name>sessionID</name></name> <operator>=</operator> <name><name>endpoint</name><operator>-&gt;</operator><name>sessionID</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tag</name><operator>.</operator><name>userID</name></name> <operator>=</operator> <name><name>endpoint</name><operator>-&gt;</operator><name>userID</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>infoEntry</name> <operator>=</operator> <operator>(</operator><name>EndpointTokenEntry</name> <operator>*</operator><operator>)</operator> <call><name>hash_search</name><argument_list>(
												 <argument><expr><name>EndpointTokenHash</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tag</name></expr></argument>, <argument><expr><name>HASH_FIND</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>infoEntry</name><operator>-&gt;</operator><name>refCount</name></name><operator>--</operator></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>infoEntry</name><operator>-&gt;</operator><name>refCount</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>hash_search</name><argument_list>(<argument><expr><name>EndpointTokenHash</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tag</name></expr></argument>, <argument><expr><name>HASH_REMOVE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>endpoint</name><operator>-&gt;</operator><name>sessionID</name></name> <operator>=</operator> <name>InvalidEndpointSessionId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>endpoint</name><operator>-&gt;</operator><name>userID</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Endpoint</name>
<modifier>*</modifier></type><name>get_endpointdesc_by_index</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>index</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>index</name> <operator>&gt;</operator> <operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>index</name> <operator>&lt;</operator> <name>MAX_ENDPOINT_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><operator>&amp;</operator><name><name>sharedEndpoints</name><index>[<expr><name>index</name></expr>]</index></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *
 * find_endpoint - Find the endpoint by given endpoint name and session id.
 *
 * For the endpoint, the session_id is the gp_session_id since it is the same
 * with the session which created the parallel retrieve cursor.
 * For the retriever, the session_id is picked by the token when perform the
 * authentication.
 *
 * The caller is responsible for acquiring ParallelCursorEndpointLock lock.
 */</comment>
<function><type><name>Endpoint</name>
<modifier>*</modifier></type><name>find_endpoint</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>endpointName</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sessionID</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Endpoint</name>	<modifier>*</modifier></type><name>res</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>endpointName</name> <operator>&amp;&amp;</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>endpointName</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>LWLockHeldByMe</name><argument_list>(<argument><expr><name>ParallelCursorEndpointLock</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>sessionID</name> <operator>!=</operator> <name>InvalidEndpointSessionId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>MAX_ENDPOINT_SIZE</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>sharedEndpoints</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>empty</name> <operator>&amp;&amp;</operator>
			<name><name>sharedEndpoints</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sessionID</name> <operator>==</operator> <name>sessionID</name> <operator>&amp;&amp;</operator>
			<call><name>endpoint_name_equals</name><argument_list>(<argument><expr><name><name>sharedEndpoints</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>, <argument><expr><name>endpointName</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<name><name>sharedEndpoints</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>databaseID</name> <operator>==</operator> <name>MyDatabaseId</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>res</name> <operator>=</operator> <operator>&amp;</operator><name><name>sharedEndpoints</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Find the token from the hash table based on given session id and user.
 */</comment>
<function><type><name>void</name></type>
<name>get_token_from_session_hashtable</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>sessionId</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>userID</name></decl></parameter>, <parameter><decl><type><name>int8</name> <modifier>*</modifier></type><name>token</name></decl></parameter> <comment type="block">/* out */</comment> )</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>EndpointTokenEntry</name> <modifier>*</modifier></type><name>infoEntry</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>EndpointTokenTag</name></type> <name>tag</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>tag</name><operator>.</operator><name>sessionID</name></name> <operator>=</operator> <name>sessionId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tag</name><operator>.</operator><name>userID</name></name> <operator>=</operator> <name>userID</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>ParallelCursorEndpointLock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>infoEntry</name> <operator>=</operator> <operator>(</operator><name>EndpointTokenEntry</name> <operator>*</operator><operator>)</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>EndpointTokenHash</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tag</name></expr></argument>,
												 <argument><expr><name>HASH_FIND</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>infoEntry</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"token for user id: %u, session: %d doesn't exist"</literal></expr></argument>,
							   <argument><expr><name><name>tag</name><operator>.</operator><name>userID</name></name></expr></argument>, <argument><expr><name>sessionId</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><name><name>infoEntry</name><operator>-&gt;</operator><name>token</name></name></expr></argument>, <argument><expr><name>ENDPOINT_TOKEN_ARR_LEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ParallelCursorEndpointLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Get the corresponding session id by the given token.
 */</comment>
<function><type><name>int</name></type>
<name>get_session_id_from_token</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>userID</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int8</name> <modifier>*</modifier></type><name>token</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>sessionId</name> <init>= <expr><name>InvalidEndpointSessionId</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>EndpointTokenEntry</name> <modifier>*</modifier></type><name>infoEntry</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HASH_SEQ_STATUS</name></type> <name>status</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>ParallelCursorEndpointLock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>hash_seq_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>, <argument><expr><name>EndpointTokenHash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>infoEntry</name> <operator>=</operator> <operator>(</operator><name>EndpointTokenEntry</name> <operator>*</operator><operator>)</operator> <call><name>hash_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>endpoint_token_hex_equals</name><argument_list>(<argument><expr><name><name>infoEntry</name><operator>-&gt;</operator><name>token</name></name></expr></argument>, <argument><expr><name>token</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<name>userID</name> <operator>==</operator> <name><name>infoEntry</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>userID</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>sessionId</name> <operator>=</operator> <name><name>infoEntry</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>sessionID</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>hash_seq_term</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ParallelCursorEndpointLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>sessionId</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Called during xaction abort.
 */</comment>
<function><type><name>void</name></type>
<name>AtAbort_EndpointExecState</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>EndpointExecState</name> <modifier>*</modifier></type><name>state</name> <init>= <expr><name>CurrentEndpointExecState</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>state</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>abort_endpoint</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>CurrentEndpointExecState</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* allocate new EndpointExecState and set it to CurrentEndpointExecState */</comment>
<function><type><name>void</name></type>
<name>allocEndpointExecState</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>EndpointExecState</name> <modifier>*</modifier></type><name>endpointExecState</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

	<comment type="block">/* Previous endpoint estate should be cleaned up. */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>CurrentEndpointExecState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>endpointExecState</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>EndpointExecState</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>CurrentEndpointExecState</name> <operator>=</operator> <name>endpointExecState</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
