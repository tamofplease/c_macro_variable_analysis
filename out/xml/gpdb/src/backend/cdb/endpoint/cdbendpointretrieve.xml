<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/backend/cdb/endpoint/cdbendpointretrieve.c"><comment type="block">/*-------------------------------------------------------------------------
 * cdbendpointretrieve.c
 *
 * This file includes code of the RETRIEVE operation for the PARALLEL RETRIEVE
 * CURSOR, Once a PARALLEL RETRIEVE CURSOR is declared, the QE backends start
 * to send query results to so-called endpoints (see cdbendpoint.c). The
 * results can be retrieved through dedicated retrieve sessions in shared
 * memory via the shared-memory base message queue mechanism. A retrieve
 * session is a special session that can executes the RETRIEVE statement only.
 *
 * To start a retrieve session, the endpoint's token is needed as the password
 * for authentication. The token could be obtained via some endpoint related
 * UDFs. The user should be the same as the one who declares the parallel
 * retrieve cursor. The guc gp_retrieve_conn=true needs to be set to start the
 * retrieve session. The guc "gp_retrieve_conn=true" imples utility mode
 * connection.
 *
 * Once a retrieve session has attached to an endpoint, no other retrieve
 * session can attach to that endpoint.  It is possible to retrieve multiple
 * endpoints from the same retrieve session if they share the same token. In
 * other words, one retrieve session can attach and retrieve from multiple
 * endpoints.
 *
 * Copyright (c) 2020-Present VMware, Inc. or its affiliates
 *
 * IDENTIFICATION
 *		src/backend/cdb/cdbendpointretrieve.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/session.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/hashfn.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/ipc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/backend_cancel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/dynahash.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/elog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/faultinjector.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/guc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdbendpoint_private.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbendpoint.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbsrlz.h"</cpp:file></cpp:include>

<comment type="block">/* Is this the utility-mode backend for RETRIEVE? */</comment>
<decl_stmt><decl><type><name>bool</name></type>		<name>am_cursor_retrieve_handler</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Was the utility-mode connection retrieve connection authenticated? Just used
 * for sanity-checking.
 */</comment>
<decl_stmt><decl><type><name>bool</name></type>		<name>retrieve_conn_authenticated</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* Retrieve role state. */</comment>
<enum>enum <name>RetrieveState</name>
<block>{
	<decl><name>RETRIEVE_STATE_INIT</name></decl>,
	<decl><name>RETRIEVE_STATE_ATTACHED</name></decl>,
	<decl><name>RETRIEVE_STATE_RECEIVING</name></decl>,
	<decl><name>RETRIEVE_STATE_FINISHED</name></decl>,
}</block>;</enum>

<comment type="block">/*
 * For receiver, we have a hash table to store connected endpoint's shared
 * message queue. So that we can retrieve from different endpoints in the same
 * retriever and switch between different endpoints.
 *
 * For endpoint, only keep one entry to track current message queue.
 */</comment>
<typedef>typedef <type><struct>struct <name>RetrieveExecEntry</name>
<block>{
	<comment type="block">/* The name of endpoint to be retrieved, also behave as hash key */</comment>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>endpointName</name><index>[<expr><name>NAMEDATALEN</name></expr>]</index></name></decl>;</decl_stmt>
	<comment type="block">/* The endpoint to be retrieved */</comment>
	<decl_stmt><decl><type><name>Endpoint</name>	<modifier>*</modifier></type><name>endpoint</name></decl>;</decl_stmt>
	<comment type="block">/* The dsm handle which contains shared memory message queue */</comment>
	<decl_stmt><decl><type><name>dsm_segment</name> <modifier>*</modifier></type><name>mqSeg</name></decl>;</decl_stmt>
	<comment type="block">/* Shared memory message queue */</comment>
	<decl_stmt><decl><type><name>shm_mq_handle</name> <modifier>*</modifier></type><name>mqHandle</name></decl>;</decl_stmt>
	<comment type="block">/* tuple slot used for retrieve data */</comment>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>retrieveTs</name></decl>;</decl_stmt>
	<comment type="block">/* TupleQueueReader to read tuple from message queue */</comment>
	<decl_stmt><decl><type><name>TupleQueueReader</name> <modifier>*</modifier></type><name>tqReader</name></decl>;</decl_stmt>
	<comment type="block">/* Track retrieve state */</comment>
	<decl_stmt><decl><type><name><name>enum</name> <name>RetrieveState</name></name></type> <name>retrieveState</name></decl>;</decl_stmt>
}</block></struct></type>			<name>RetrieveExecEntry</name>;</typedef>

<comment type="block">/*
 * Local structure to the current retrieve operation.
 */</comment>
<typedef>typedef <type><struct>struct <name>RetrieveControl</name>
<block>{
	<comment type="block">/*
	 * Track current retrieve entry in executor. Multiple entries are allowed
	 * to be in one retrieve session but only one entry is active.
	 */</comment>
	<decl_stmt><decl><type><name>RetrieveExecEntry</name> <modifier>*</modifier></type><name>current_entry</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Hash table to cache tuple descriptors for all endpoint_names which have
	 * been retrieved in this retrieve session.
	 */</comment>
	<decl_stmt><decl><type><name>HTAB</name>	   <modifier>*</modifier></type><name>RetrieveExecEntryHTB</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * The endpoint sessionID of the current retrieve entry. Assigned after
	 * authentication.
	 */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>sessionID</name></decl>;</decl_stmt>
}</block></struct></type>			<name>RetrieveControl</name>;</typedef>

<decl_stmt><decl><type><specifier>static</specifier> <name>RetrieveControl</name></type> <name>RetrieveCtl</name> <init>=
<expr><block>{
	<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>InvalidEndpointSessionId</name></expr>
}</block></expr></init></decl>;</decl_stmt>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>init_retrieve_exec_entry</name><parameter_list>(<parameter><decl><type><name>RetrieveExecEntry</name> <modifier>*</modifier></type> <name>entry</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Endpoint</name> <modifier>*</modifier></type><name>get_endpoint_from_retrieve_exec_entry</name><parameter_list>(<parameter><decl><type><name>RetrieveExecEntry</name> <modifier>*</modifier></type><name>entry</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>noError</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>start_retrieve</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>endpointName</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>validate_retrieve_endpoint</name><parameter_list>(<parameter><decl><type><name>Endpoint</name> <modifier>*</modifier></type><name>endpointDesc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>endpointName</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>finish_retrieve</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>resetPID</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>attach_receiver_mq</name><parameter_list>(<parameter><decl><type><name>dsm_handle</name></type> <name>dsmHandle</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>detach_receiver_mq</name><parameter_list>(<parameter><decl><type><name>RetrieveExecEntry</name> <modifier>*</modifier></type><name>entry</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>notify_sender</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>finished</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>retrieve_cancel_action</name><parameter_list>(<parameter><decl><type><name>RetrieveExecEntry</name> <modifier>*</modifier></type><name>entry</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>msg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>retrieve_exit_callback</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>code</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>retrieve_xact_callback</name><parameter_list>(<parameter><decl><type><name>XactEvent</name></type> <name>ev</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>retrieve_subxact_callback</name><parameter_list>(<parameter><decl><type><name>SubXactEvent</name></type> <name>event</name></decl></parameter>,
									  <parameter><decl><type><name>SubTransactionId</name></type> <name>mySubid</name></decl></parameter>,
									  <parameter><decl><type><name>SubTransactionId</name></type> <name>parentSubid</name></decl></parameter>,
									  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type><name>retrieve_next_tuple</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * AuthEndpoint - Authenticate for retrieve connection.
 *
 * Return true if authentication passes.
 */</comment>
<function><type><name>bool</name></type>
<name>AuthEndpoint</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>userID</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tokenStr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int8</name></type>		<name><name>token</name><index>[<expr><name>ENDPOINT_TOKEN_ARR_LEN</name></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>endpoint_token_str2arr</name><argument_list>(<argument><expr><name>tokenStr</name></expr></argument>, <argument><expr><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>RetrieveCtl</name><operator>.</operator><name>sessionID</name></name> <operator>=</operator> <call><name>get_session_id_from_token</name><argument_list>(<argument><expr><name>userID</name></expr></argument>, <argument><expr><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>RetrieveCtl</name><operator>.</operator><name>sessionID</name></name> <operator>!=</operator> <name>InvalidEndpointSessionId</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>before_shmem_exit</name><argument_list>(<argument><expr><name>retrieve_exit_callback</name></expr></argument>, <argument><expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>RegisterSubXactCallback</name><argument_list>(<argument><expr><name>retrieve_subxact_callback</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>RegisterXactCallback</name><argument_list>(<argument><expr><name>retrieve_xact_callback</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>found</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * GetRetrieveStmtTupleDesc - Gets TupleDesc for the given retrieve statement.
 *
 * This function calls start_retrieve() to initialize related data structure
 * and returns the tuple descriptor.
 */</comment>
<function><type><name>TupleDesc</name></type>
<name>GetRetrieveStmtTupleDesc</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RetrieveStmt</name> <modifier>*</modifier></type> <name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>start_retrieve</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>endpoint_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>RetrieveCtl</name><operator>.</operator><name>current_entry</name><operator>-&gt;</operator><name>retrieveTs</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ExecRetrieveStmt - Execute the given RetrieveStmt.
 *
 * This function tries to use the endpoint name in the RetrieveStmt to find the
 * attached endpoint in this retrieve session. If the endpoint can be found,
 * then read from the message queue to feed the active portal's tuplestore. And
 * mark the endpoint as detached before returning.
 */</comment>
<function><type><name>void</name></type>
<name>ExecRetrieveStmt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RetrieveStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>, <parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type>		<name>retrieveCount</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>RetrieveCtl</name><operator>.</operator><name>current_entry</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"endpoint %s is not attached"</literal></expr></argument>,
							   <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>endpoint_name</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>retrieveCount</name> <operator>=</operator> <name><name>stmt</name><operator>-&gt;</operator><name>count</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>retrieveCount</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>stmt</name><operator>-&gt;</operator><name>is_all</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"RETRIEVE statement only supports forward scan, "</literal>
							   <literal type="string">"count should not be: %ld"</literal></expr></argument>,
							   <argument><expr><name>retrieveCount</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>dest</name><operator>-&gt;</operator><name>mydest</name></name> <operator>==</operator> <name>DestTuplestore</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>RetrieveCtl</name><operator>.</operator><name>current_entry</name><operator>-&gt;</operator><name>retrieveState</name></name> <operator>&gt;</operator> <name>RETRIEVE_STATE_INIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>RetrieveCtl</name><operator>.</operator><name>current_entry</name><operator>-&gt;</operator><name>retrieveState</name></name> <operator>&lt;</operator> <name>RETRIEVE_STATE_FINISHED</name></expr>)</condition>
	<block>{<block_content>
		<while>while <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>is_all</name></name> <operator>||</operator> <name>retrieveCount</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>retrieve_next_tuple</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>result</name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>

			<expr_stmt><expr><call>(<modifier>*</modifier><name><name>dest</name><operator>-&gt;</operator><name>receiveSlot</name></name>) <argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>stmt</name><operator>-&gt;</operator><name>is_all</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>retrieveCount</name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></while>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* All tuples have already been retrieved. Nothing to do */</comment>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>finish_retrieve</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * init_retrieve_exec_entry - Initialize RetrieveExecEntry.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>init_retrieve_exec_entry</name><parameter_list>(<parameter><decl><type><name>RetrieveExecEntry</name> <modifier>*</modifier></type> <name>entry</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>mqSeg</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>endpoint</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>mqHandle</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>retrieveTs</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>retrieveState</name></name> <operator>=</operator> <name>RETRIEVE_STATE_INIT</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * get_endpoint_from_retrieve_exec_entry
 *
 * Get endpoint from the entry if exists and validate the endpoint slot
 * still belong to current entry since it may get reused by other endpoints.
 *
 * if there is something wrong during validation, warn or error out, depending
 * on the parameter noError.
 */</comment>
<function><type><specifier>static</specifier> <name>Endpoint</name><modifier>*</modifier></type>
<name>get_endpoint_from_retrieve_exec_entry</name><parameter_list>(<parameter><decl><type><name>RetrieveExecEntry</name> <modifier>*</modifier></type> <name>entry</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>noError</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>LWLockHeldByMe</name><argument_list>(<argument><expr><name>ParallelCursorEndpointLock</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Sanity check and error out if needed. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>endpoint</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>endpoint</name><operator>-&gt;</operator><name>empty</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><ternary><condition><expr><name>noError</name></expr> ?</condition><then> <expr><name>WARNING</name></expr> </then><else>: <expr><name>ERROR</name></expr></else></ternary></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"endpoint is not available because the parallel "</literal>
							<literal type="string">"retrieve cursor was aborted"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>endpoint</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><operator>!</operator><operator>(</operator><call><name>endpoint_name_equals</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>endpoint</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>endpointName</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
				   <name><name>RetrieveCtl</name><operator>.</operator><name>sessionID</name></name> <operator>==</operator> <name><name>entry</name><operator>-&gt;</operator><name>endpoint</name><operator>-&gt;</operator><name>sessionID</name></name><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><ternary><condition><expr><name>noError</name></expr> ?</condition><then> <expr><name>WARNING</name></expr> </then><else>: <expr><name>ERROR</name></expr></else></ternary></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"endpoint slot in RetrieveExecEntry is reused by others"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"endpoint name (%s vs %s), session ID (%d vs %d)"</literal></expr></argument>,
							   <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>endpoint</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>endpointName</name></name></expr></argument>,
							   <argument><expr><name><name>RetrieveCtl</name><operator>.</operator><name>sessionID</name></name></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>endpoint</name><operator>-&gt;</operator><name>sessionID</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>endpoint</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name><name>entry</name><operator>-&gt;</operator><name>endpoint</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Initialize a hashtable, its key is the endpoint's name, its value is
 * RetrieveExecEntry
*/</comment>
<function><type><name>void</name></type> <name>InitRetrieveCtl</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
		<decl_stmt><decl><type><name>HASHCTL</name></type>		<name>ctl</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>RetrieveCtl</name><operator>.</operator><name>RetrieveExecEntryHTB</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return;</return></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ctl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ctl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ctl</name><operator>.</operator><name>keysize</name></name> <operator>=</operator> <name>NAMEDATALEN</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ctl</name><operator>.</operator><name>entrysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>RetrieveExecEntry</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ctl</name><operator>.</operator><name>hash</name></name> <operator>=</operator> <name>string_hash</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>RetrieveCtl</name><operator>.</operator><name>RetrieveExecEntryHTB</name></name> <operator>=</operator> <call><name>hash_create</name><argument_list>(<argument><expr><literal type="string">"retrieve hash"</literal></expr></argument>, <argument><expr><name>MAX_ENDPOINT_SIZE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ctl</name></expr></argument>,
													   <argument><expr><operator>(</operator><name>HASH_ELEM</name> <operator>|</operator> <name>HASH_FUNCTION</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>RetrieveCtl</name><operator>.</operator><name>current_entry</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * start_retrieve - start to retrieve an endpoint.
 *
 * Initialize current retrieve RetrieveExecEntry for the given
 * endpoint if it's the first time to retrieve the endpoint.
 * Attach to the endpoint's shm_mq.
 *
 * Set the endpoint status to ENDPOINTSTATE_RETRIEVING.
 *
 * When call RETRIEVE statement in PQprepare() &amp; PQexecPrepared(), this func will
 * be called 2 times.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>start_retrieve</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>endpointName</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HTAB</name>	   <modifier>*</modifier></type><name>entryHTB</name> <init>= <expr><name><name>RetrieveCtl</name><operator>.</operator><name>RetrieveExecEntryHTB</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RetrieveExecEntry</name> <modifier>*</modifier></type><name>entry</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Endpoint</name>	<modifier>*</modifier></type><name>endpoint</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>dsm_handle</name></type>	<name>handle</name> <init>= <expr><name>DSM_HANDLE_INVALID</name></expr></init></decl>;</decl_stmt>


	<expr_stmt><expr><name>entry</name> <operator>=</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>entryHTB</name></expr></argument>, <argument><expr><name>endpointName</name></expr></argument>, <argument><expr><name>HASH_FIND</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>ParallelCursorEndpointLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>endpoint</name> <operator>=</operator> <call><name>get_endpoint_from_retrieve_exec_entry</name><argument_list>(<argument><expr><name>entry</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>endpoint</name> <operator>=</operator> <call><name>find_endpoint</name><argument_list>(<argument><expr><name>endpointName</name></expr></argument>, <argument><expr><name><name>RetrieveCtl</name><operator>.</operator><name>sessionID</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>endpoint</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
							<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"the endpoint %s does not exist for session id %d"</literal></expr></argument>,
								   <argument><expr><name>endpointName</name></expr></argument>, <argument><expr><name><name>RetrieveCtl</name><operator>.</operator><name>sessionID</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>validate_retrieve_endpoint</name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>, <argument><expr><name>endpointName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>endpoint</name><operator>-&gt;</operator><name>receiverPid</name></name> <operator>=</operator> <name>MyProcPid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>handle</name> <operator>=</operator> <name><name>endpoint</name><operator>-&gt;</operator><name>mqDsmHandle</name></name></expr>;</expr_stmt>

		<comment type="block">/* insert it into hashtable */</comment>
		<expr_stmt><expr><name>entry</name> <operator>=</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>entryHTB</name></expr></argument>, <argument><expr><name>endpointName</name></expr></argument>, <argument><expr><name>HASH_ENTER</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>init_retrieve_exec_entry</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* begins to retrieve tuples from endpoint if still have data to retrieve. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>endpoint</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>ENDPOINTSTATE_READY</name> <operator>||</operator>
		<name><name>endpoint</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>ENDPOINTSTATE_ATTACHED</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>endpoint</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>ENDPOINTSTATE_RETRIEVING</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ParallelCursorEndpointLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>endpoint</name></name> <operator>=</operator> <name>endpoint</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>RetrieveCtl</name><operator>.</operator><name>current_entry</name></name> <operator>=</operator> <name>entry</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>attach_receiver_mq</name><argument_list>(<argument><expr><name>handle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>CurrentSession</name><operator>-&gt;</operator><name>segment</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>AttachSession</name><argument_list>(<argument><expr><name><name>endpoint</name><operator>-&gt;</operator><name>sessionDsmHandle</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * validate_retrieve_endpoint - after finding the retrieve endpoint,
 * validate whether it meets the requirement.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>validate_retrieve_endpoint</name><parameter_list>(<parameter><decl><type><name>Endpoint</name> <modifier>*</modifier></type><name>endpoint</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>endpointName</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>endpoint</name><operator>-&gt;</operator><name>mqDsmHandle</name></name> <operator>!=</operator> <name>DSM_HANDLE_INVALID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>endpoint</name><operator>-&gt;</operator><name>userID</name></name> <operator>!=</operator> <call><name>GetSessionUserId</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_PRIVILEGE</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"the PARALLEL RETRIEVE CURSOR was created by "</literal>
							   <literal type="string">"a different user"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Use the same user as the PARALLEL "</literal>
								<literal type="string">"RETRIEVE CURSOR creator to retrieve."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<switch>switch <condition>(<expr><name><name>endpoint</name><operator>-&gt;</operator><name>state</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>ENDPOINTSTATE_FINISHED</name></expr>:</case>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"another session (pid: %d) used the endpoint and "</literal>
							<literal type="string">"completed retrieving"</literal></expr></argument>,
							<argument><expr><name><name>endpoint</name><operator>-&gt;</operator><name>receiverPid</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>				<comment type="block">/* make compiler happy */</comment>
		<case>case <expr><name>ENDPOINTSTATE_READY</name></expr>:</case>
		<case>case <expr><name>ENDPOINTSTATE_ATTACHED</name></expr>:</case>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"endpoint %s (state: %s) was used by another retrieve session (pid: %d)"</literal></expr></argument>,
							<argument><expr><name>endpointName</name></expr></argument>,
							<argument><expr><call><name>state_enum_to_string</name><argument_list>(<argument><expr><name><name>endpoint</name><operator>-&gt;</operator><name>state</name></name></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><name><name>endpoint</name><operator>-&gt;</operator><name>receiverPid</name></name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"If pid is -1, that session has been detached."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>

	<if_stmt><if>if <condition>(<expr><name><name>endpoint</name><operator>-&gt;</operator><name>receiverPid</name></name> <operator>!=</operator> <name>InvalidPid</name> <operator>&amp;&amp;</operator> <name><name>endpoint</name><operator>-&gt;</operator><name>receiverPid</name></name> <operator>!=</operator> <name>MyProcPid</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"endpoint %s was already attached by receiver(pid: %d)"</literal></expr></argument>,
						<argument><expr><name>endpointName</name></expr></argument>, <argument><expr><name><name>endpoint</name><operator>-&gt;</operator><name>receiverPid</name></name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"An endpoint can only be attached by one retrieving session."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Attach to the endpoint's shared memory message queue.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>attach_receiver_mq</name><parameter_list>(<parameter><decl><type><name>dsm_handle</name></type> <name>dsmHandle</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>td</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDescNode</name> <modifier>*</modifier></type><name>tupdescnode</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>shm_toc</name>    <modifier>*</modifier></type><name>toc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>void</name>	   <modifier>*</modifier></type><name>lookup_space</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>td_len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RetrieveExecEntry</name> <modifier>*</modifier></type><name>entry</name> <init>= <expr><name><name>RetrieveCtl</name><operator>.</operator><name>current_entry</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>entry</name><operator>-&gt;</operator><name>mqSeg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>entry</name><operator>-&gt;</operator><name>mqHandle</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>retrieveState</name></name> <operator>==</operator> <name>RETRIEVE_STATE_INIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Store the result slot all the retrieve mode QE life cycle, we only have
	 * one chance to build it.
	 */</comment>
	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>elogif</name><argument_list>(<argument><expr><name>gp_log_endpoints</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"CDB_ENDPOINT: init message queue conn for receiver"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>mqSeg</name></name> <operator>=</operator> <call><name>dsm_attach</name><argument_list>(<argument><expr><name>dsmHandle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>mqSeg</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"attach to endpoint shared message queue failed"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>dsm_pin_mapping</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>mqSeg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>toc</name> <operator>=</operator> <call><name>shm_toc_attach</name><argument_list>(<argument><expr><name>ENDPOINT_MSG_QUEUE_MAGIC</name></expr></argument>, <argument><expr><call><name>dsm_segment_address</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>mqSeg</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>toc</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid magic number in dynamic shared memory segment"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Find the shared mq for tuple receiving from 'toc' and set up the
	 * connection.
	 */</comment>
	<decl_stmt><decl><type><name>shm_mq</name>	   <modifier>*</modifier></type><name>mq</name> <init>= <expr><call><name>shm_toc_lookup</name><argument_list>(<argument><expr><name>toc</name></expr></argument>, <argument><expr><name>ENDPOINT_KEY_TUPLE_QUEUE</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>shm_mq_set_receiver</name><argument_list>(<argument><expr><name>mq</name></expr></argument>, <argument><expr><name>MyProc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>mqHandle</name></name> <operator>=</operator> <call><name>shm_mq_attach</name><argument_list>(<argument><expr><name>mq</name></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>mqSeg</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Find the tuple descritpr information from 'toc' and set the tuple
	 * descriptor.
	 */</comment>
	<expr_stmt><expr><name>lookup_space</name> <operator>=</operator> <call><name>shm_toc_lookup</name><argument_list>(<argument><expr><name>toc</name></expr></argument>, <argument><expr><name>ENDPOINT_KEY_TUPLE_DESC_LEN</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>td_len</name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <name>lookup_space</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>lookup_space</name> <operator>=</operator> <call><name>shm_toc_lookup</name><argument_list>(<argument><expr><name>toc</name></expr></argument>, <argument><expr><name>ENDPOINT_KEY_TUPLE_DESC</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tupdescnode</name> <operator>=</operator> <operator>(</operator><name>TupleDescNode</name> <operator>*</operator><operator>)</operator> <call><name>deserializeNode</name><argument_list>(<argument><expr><name>lookup_space</name></expr></argument>, <argument><expr><name>td_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>td</name> <operator>=</operator> <name><name>tupdescnode</name><operator>-&gt;</operator><name>tuple</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>retrieveTs</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>retrieveTs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>retrieveTs</name></name> <operator>=</operator> <call><name>MakeTupleTableSlot</name><argument_list>(<argument><expr><name>td</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>TTSOpsHeapTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* Create the tuple queue reader. */</comment>
	<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>tqReader</name></name> <operator>=</operator> <call><name>CreateTupleQueueReader</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>mqHandle</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>retrieveState</name></name> <operator>=</operator> <name>RETRIEVE_STATE_ATTACHED</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Detach from the endpoint's message queue.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>detach_receiver_mq</name><parameter_list>(<parameter><decl><type><name>RetrieveExecEntry</name> <modifier>*</modifier></type> <name>entry</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>shm_mq_detach</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>mqHandle</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>mqHandle</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>dsm_detach</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>mqSeg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>mqSeg</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Notify the sender to stop waiting on the ackDone latch.
 *
 * If current endpoint get freed, it means the endpoint aborted.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>notify_sender</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>finished</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Endpoint</name>	<modifier>*</modifier></type><name>endpoint</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>ParallelCursorEndpointLock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>endpoint</name> <operator>=</operator> <call><name>get_endpoint_from_retrieve_exec_entry</name><argument_list>(<argument><expr><name><name>RetrieveCtl</name><operator>.</operator><name>current_entry</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>finished</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>endpoint</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>ENDPOINTSTATE_FINISHED</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>SetLatch</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>endpoint</name><operator>-&gt;</operator><name>ackDone</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ParallelCursorEndpointLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Read a tuple from shared memory message queue.
 *
 * When reading all tuples, should tell sender that retrieve is done.
 */</comment>
<function><type><specifier>static</specifier> <name>TupleTableSlot</name> <modifier>*</modifier></type>
<name>retrieve_next_tuple</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tup</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>readerdone</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RetrieveExecEntry</name> <modifier>*</modifier></type><name>entry</name> <init>= <expr><name><name>RetrieveCtl</name><operator>.</operator><name>current_entry</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* at the first time to retrieve data */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>retrieveState</name></name> <operator>==</operator> <name>RETRIEVE_STATE_ATTACHED</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * try to receive data with nowait, so that empty result will not hang
		 * here
		 */</comment>
		<expr_stmt><expr><name>tup</name> <operator>=</operator> <call><name>TupleQueueReaderNext</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>tqReader</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>readerdone</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>retrieveState</name></name> <operator>=</operator> <name>RETRIEVE_STATE_RECEIVING</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * at the first time to retrieve data, tell sender not to wait at
		 * wait_receiver()
		 */</comment>
		<expr_stmt><expr><call><name>elogif</name><argument_list>(<argument><expr><name>gp_log_endpoints</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"CDB_ENDPOINT: receiver notifies sender in "</literal>
			   <literal type="string">"retrieve_next_tuple() when retrieving data for the first time"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>notify_sender</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>SIMPLE_FAULT_INJECTOR</name><argument_list>(<argument><expr><literal type="string">"fetch_tuples_from_endpoint"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * re-retrieve data in wait mode if not the first time retrieve data or if
	 * the first time retrieve an invalid data, but not finish
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>readerdone</name> <operator>==</operator> <name>false</name> <operator>&amp;&amp;</operator> <name>tup</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>tup</name> <operator>=</operator> <call><name>TupleQueueReaderNext</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>tqReader</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>readerdone</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* readerdone returns true only after sender detached message queue */</comment>
	<if_stmt><if>if <condition>(<expr><name>readerdone</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>DestroyTupleQueueReader</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>tqReader</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>tqReader</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * dsm_detach will send SIGUSR1 to sender which may interrupt the
		 * procLatch. But sender will wait on procLatch after finishing
		 * sending. So dsm_detach has to be called earlier to ensure the
		 * SIGUSR1 is coming from the CLOSE CURSOR.
		 */</comment>
		<expr_stmt><expr><call><name>detach_receiver_mq</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * We do not call DetachSession() here since we still need that for
		 * the transient record tuples.
		 */</comment>
		<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>retrieveState</name></name> <operator>=</operator> <name>RETRIEVE_STATE_FINISHED</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>notify_sender</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>retrieveTs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>entry</name><operator>-&gt;</operator><name>retrieveTs</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ExecStoreHeapTuple</name><argument_list>(<argument><expr><name>tup</name></expr></argument>, <comment type="block">/* tuple to store */</comment>
						   <argument><expr><name>result</name></expr></argument>,	<comment type="block">/* slot in which to store the tuple */</comment>
						   <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* slot should not pfree tuple */</comment>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * finish_retrieve - Finish a retrieve statement.
 *
 * If current retrieve statement retrieve all tuples from endpoint. Set
 * endpoint state to ENDPOINTSTATE_FINISHED.  Otherwise, set endpoint's status
 * from ENDPOINTSTATE_RETRIEVING to ENDPOINTSTATE_ATTACHED.
 *
 * Note: don't drop the result slot, we only have one chance to built it.
 * Errors in these function is not expected to be raised.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>finish_retrieve</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>resetPID</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Endpoint</name>	<modifier>*</modifier></type><name>endpoint</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RetrieveExecEntry</name> <modifier>*</modifier></type><name>entry</name> <init>= <expr><name><name>RetrieveCtl</name><operator>.</operator><name>current_entry</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>ParallelCursorEndpointLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>endpoint</name> <operator>=</operator> <call><name>get_endpoint_from_retrieve_exec_entry</name><argument_list>(<argument><expr><name>entry</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>endpoint</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * The endpoint has already cleaned up the Endpoint entry, or during
		 * the retrieve abort stage, sender cleaned the Endpoint entry. And
		 * another endpoint gets allocated just after the cleanup, which will
		 * occupy current endpoint entry.
		 * remove the entry from RetrieveCtl.RetrieveExecEntryHTB also.
		 * to avoid next statement in start_retrieve can get entry from RetrieveCtl.RetrieveExecEntryHTB,
		 * however, can not get endpoint through get_endpoint_from_retrieve_exec_entry.
		 */</comment>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ParallelCursorEndpointLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>elogif</name><argument_list>(<argument><expr><name>gp_log_endpoints</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"the Endpoint entry %s has already been cleaned, \
			   remove from RetrieveCtl.RetrieveExecEntryHTB hash table"</literal></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>endpointName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>hash_search</name><argument_list>(<argument><expr><name><name>RetrieveCtl</name><operator>.</operator><name>RetrieveExecEntryHTB</name></name></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>endpointName</name></name></expr></argument>, <argument><expr><name>HASH_REMOVE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>RetrieveCtl</name><operator>.</operator><name>current_entry</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If the receiver pid get retrieve_cancel_action, the receiver pid is
	 * invalid.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>endpoint</name><operator>-&gt;</operator><name>receiverPid</name></name> <operator>!=</operator> <name>MyProcPid</name> <operator>&amp;&amp;</operator> <name><name>endpoint</name><operator>-&gt;</operator><name>receiverPid</name></name> <operator>!=</operator> <name>InvalidPid</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unmatched pid, expected %d but it's %d"</literal></expr></argument>, <argument><expr><name>MyProcPid</name></expr></argument>,
						<argument><expr><name><name>endpoint</name><operator>-&gt;</operator><name>receiverPid</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>resetPID</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>endpoint</name><operator>-&gt;</operator><name>receiverPid</name></name> <operator>=</operator> <name>InvalidPid</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Don't set if ENDPOINTSTATE_FINISHED */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>endpoint</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>ENDPOINTSTATE_RETRIEVING</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * If finish retrieving, set the endpoint to FINISHED, otherwise set
		 * the endpoint to ATTACHED.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>retrieveState</name></name> <operator>==</operator> <name>RETRIEVE_STATE_FINISHED</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>endpoint</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>ENDPOINTSTATE_FINISHED</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>endpoint</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>ENDPOINTSTATE_ATTACHED</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ParallelCursorEndpointLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>RetrieveCtl</name><operator>.</operator><name>current_entry</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * When retrieve role exit with error, let endpoint/sender know exception
 * happened.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>retrieve_cancel_action</name><parameter_list>(<parameter><decl><type><name>RetrieveExecEntry</name> <modifier>*</modifier></type> <name>entry</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>msg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Endpoint</name>	<modifier>*</modifier></type><name>endpoint</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>ParallelCursorEndpointLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>endpoint</name> <operator>=</operator> <call><name>get_endpoint_from_retrieve_exec_entry</name><argument_list>(<argument><expr><name>entry</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>endpoint</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
		<name><name>endpoint</name><operator>-&gt;</operator><name>receiverPid</name></name> <operator>==</operator> <name>MyProcPid</name> <operator>&amp;&amp;</operator>
		<name><name>endpoint</name><operator>-&gt;</operator><name>state</name></name> <operator>!=</operator> <name>ENDPOINTSTATE_FINISHED</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>endpoint</name><operator>-&gt;</operator><name>receiverPid</name></name> <operator>=</operator> <name>InvalidPid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>endpoint</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>ENDPOINTSTATE_RELEASED</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>endpoint</name><operator>-&gt;</operator><name>senderPid</name></name> <operator>!=</operator> <name>InvalidPid</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>elogif</name><argument_list>(<argument><expr><name>gp_log_endpoints</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"CDB_ENDPOINT: signal sender to abort"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>SetBackendCancelMessage</name><argument_list>(<argument><expr><name><name>endpoint</name><operator>-&gt;</operator><name>senderPid</name></name></expr></argument>, <argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>kill</name><argument_list>(<argument><expr><name><name>endpoint</name><operator>-&gt;</operator><name>senderPid</name></name></expr></argument>, <argument><expr><name>SIGINT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ParallelCursorEndpointLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Callback when retrieve role on proc exit, before shmem exit.
 *
 * For Process Exists:
 * If a retrieve session has been retrieved from more than one endpoint, all of
 * the endpoints and their message queues in this session have to be detached when
 * process exits. In this case, the active RetrieveExecEntry will be detached
 * first in retrieve_exit_callback. Thus, no need to detach it again in
 * retrieve_xact_callback.
 *
 * shmem_exit()
 * --&gt; ... (other before shmem callback if exists)
 * --&gt; retrieve_exit_callback
 *	   --&gt; cancel sender if needed.
 *	   --&gt; detach all message queue dsm
 * --&gt; ShutdownPostgres (the last before shmem callback)
 *	   --&gt; AbortOutOfAnyTransaction
 *		   --&gt; AbortTransaction
 *			   --&gt; CallXactCallbacks
 *				   --&gt; retrieve_xact_callback
 *		   --&gt; CleanupTransaction
 * --&gt; dsm_backend_shutdown
 *
 * For Normal Transaction Aborts:
 * Retriever clean up job will be done in xact abort callback
 * retrieve_xact_callback which will only clean the active
 * RetrieveExecEntry.
 *
 * Question:
 * Is it better to detach the dsm we created/attached before dsm_backend_shutdown?
 * Or we can let dsm_backend_shutdown do the detach for us, so we don't need
 * register call back in before_shmem_exit.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>retrieve_exit_callback</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>code</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HASH_SEQ_STATUS</name></type> <name>status</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RetrieveExecEntry</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HTAB</name>	   <modifier>*</modifier></type><name>entryHTB</name> <init>= <expr><name><name>RetrieveCtl</name><operator>.</operator><name>RetrieveExecEntryHTB</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>elogif</name><argument_list>(<argument><expr><name>gp_log_endpoints</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"CDB_ENDPOINT: retrieve exit callback"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Nothing to do if the hashtable is not ready. */</comment>
	<if_stmt><if>if <condition>(<expr><name>entryHTB</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* If the current retrieve statement has not fnished in this run. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>RetrieveCtl</name><operator>.</operator><name>current_entry</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>finish_retrieve</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Cancel all partially retrieved endpoints in this session. */</comment>
	<expr_stmt><expr><call><name>hash_seq_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>, <argument><expr><name>entryHTB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>entry</name> <operator>=</operator> <operator>(</operator><name>RetrieveExecEntry</name> <operator>*</operator><operator>)</operator> <call><name>hash_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>retrieveState</name></name> <operator>!=</operator> <name>RETRIEVE_STATE_FINISHED</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>retrieve_cancel_action</name><argument_list>(<argument><expr><name>entry</name></expr></argument>, <argument><expr><literal type="string">"Endpoint retrieve session is "</literal>
								   <literal type="string">"quitting. All unfinished parallel retrieve "</literal>
								   <literal type="string">"cursors on the session will be terminated."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>mqSeg</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>detach_receiver_mq</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></while>
	<expr_stmt><expr><name>entryHTB</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>CurrentSession</name><operator>-&gt;</operator><name>segment</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>DetachSession</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Retrieve role xact abort callback.
 *
 * If normal abort, finish_retrieve() and retrieve_cancel_action() will be
 * called once in current function for current endpoint_name. but if it's proc
 * exit, these two methods will be called twice for current endpoint_name,
 * since we call these two methods before dsm detach.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>void</name></type>
<name>retrieve_xact_callback</name><argument_list>(<argument><expr><name>XactEvent</name> <name>ev</name></expr></argument>, <argument><expr><name>void</name> <operator>*</operator><name>arg</name> <call><name>pg_attribute_unused</name><argument_list>()</argument_list></call></expr></argument>)</argument_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>ev</name> <operator>==</operator> <name>XACT_EVENT_ABORT</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elogif</name><argument_list>(<argument><expr><name>gp_log_endpoints</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"CDB_ENDPOINT: retrieve xact abort callback"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>RetrieveCtl</name><operator>.</operator><name>sessionID</name></name> <operator>!=</operator> <name>InvalidEndpointSessionId</name> <operator>&amp;&amp;</operator>
			<name><name>RetrieveCtl</name><operator>.</operator><name>current_entry</name></name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>RetrieveCtl</name><operator>.</operator><name>current_entry</name><operator>-&gt;</operator><name>retrieveState</name></name> <operator>!=</operator> <name>RETRIEVE_STATE_FINISHED</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>retrieve_cancel_action</name><argument_list>(<argument><expr><name><name>RetrieveCtl</name><operator>.</operator><name>current_entry</name></name></expr></argument>,
									   <argument><expr><literal type="string">"Endpoint retrieve statement aborted"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>finish_retrieve</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>CurrentSession</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>CurrentSession</name><operator>-&gt;</operator><name>segment</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>DetachSession</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></decl></decl_stmt>

<comment type="block">/*
 * Callback for retrieve role's sub-xact abort .
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>void</name></type>
<name>retrieve_subxact_callback</name><argument_list>(<argument><expr><name>SubXactEvent</name> <name>event</name></expr></argument>,
						  <argument><expr><name>SubTransactionId</name> <name>mySubid</name> <call><name>pg_attribute_unused</name><argument_list>()</argument_list></call></expr></argument>,
						  <argument><expr><name>SubTransactionId</name> <name>parentSubid</name> <call><name>pg_attribute_unused</name><argument_list>()</argument_list></call></expr></argument>,
						  <argument><expr><name>void</name> <operator>*</operator><name>arg</name> <call><name>pg_attribute_unused</name><argument_list>()</argument_list></call></expr></argument>)</argument_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>event</name> <operator>==</operator> <name>SUBXACT_EVENT_ABORT_SUB</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>retrieve_xact_callback</name><argument_list>(<argument><expr><name>XACT_EVENT_ABORT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></decl></decl_stmt>
</unit>
