<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/backend/cdb/cdbappendonlystoragewrite.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * cdbappendonlystoragewrite.c
 *
 * Portions Copyright (c) 2007-2009, Greenplum inc
 * Portions Copyright (c) 2012-Present VMware, Inc. or its affiliates.
 *
 *
 * IDENTIFICATION
 *	    src/backend/cdb/cdbappendonlystoragewrite.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/fcntl.h&gt;</cpp:file></cpp:include>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;io.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/file.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/catalog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/heap.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_compression.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbappendonlystorageread.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbappendonlystorage.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbappendonlystoragelayer.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbappendonlystorageformat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbappendonlystoragewrite.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbappendonlyxlog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/relpath.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgstat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/gp_compress.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/faultinjector.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/guc.h"</cpp:file></cpp:include>


<comment type="block">/*----------------------------------------------------------------
 * Initialization
 *----------------------------------------------------------------
 */</comment>

<comment type="block">/*
 * Initialize AppendOnlyStorageWrite.
 *
 * The AppendOnlyStorageWrite data structure is initialized once for an
 * append "session" and can be used to add Append-Only Storage Blocks to 1
 * or more segment files.
 *
 * The current file to write to is opened with the
 * AppendOnlyStorageWrite_OpenFile routine.
 *
 * storageWrite		- data structure to initialize
 * memoryContext	- memory context to use for buffers and other memory
 *					  needs. When NULL, the current memory context is used.
 * maxBufferLen		- maximum Append-Only Storage Block length including all
 *					  storage headers.
 * relationName		- name of the relation to use in log and error messages.
 * title			- A phrase that better describes the purpose of this open.
 *					  The caller manages the storage for this.
 * storageAttributes - Append-Only Storage Attributes from relation creation.
 */</comment>
<function><type><name>void</name></type>
<name>AppendOnlyStorageWrite_Init</name><parameter_list>(<parameter><decl><type><name>AppendOnlyStorageWrite</name> <modifier>*</modifier></type><name>storageWrite</name></decl></parameter>,
							<parameter><decl><type><name>MemoryContext</name></type> <name>memoryContext</name></decl></parameter>,
							<parameter><decl><type><name>int32</name></type> <name>maxBufferLen</name></decl></parameter>,
							<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>relationName</name></decl></parameter>,
							<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>title</name></decl></parameter>,
							<parameter><decl><type><name>AppendOnlyStorageAttributes</name> <modifier>*</modifier></type><name>storageAttributes</name></decl></parameter>,
							<parameter><decl><type><name>bool</name></type> <name>needsWAL</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint8</name>	   <modifier>*</modifier></type><name>memory</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>memoryLen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldMemoryContext</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>storageWrite</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* UNDONE: Range check maxBufferLen */</comment>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>relationName</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>storageAttributes</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* UNDONE: Range check fields in storageAttributes */</comment>

	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>storageWrite</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>AppendOnlyStorageWrite</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>maxBufferLen</name></name> <operator>=</operator> <name>maxBufferLen</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>memoryContext</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>memoryContext</name></name> <operator>=</operator> <name>CurrentMemoryContext</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>memoryContext</name></name> <operator>=</operator> <name>memoryContext</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name>oldMemoryContext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>memoryContext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>memcpy</name><argument_list>(
		   <argument><expr><operator>&amp;</operator><name><name>storageWrite</name><operator>-&gt;</operator><name>storageAttributes</name></name></expr></argument>,
		   <argument><expr><name>storageAttributes</name></expr></argument>,
		   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>AppendOnlyStorageAttributes</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Determine the fixed header length based on the checksum flag.
	 */</comment>
	<expr_stmt><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>regularHeaderLen</name></name> <operator>=</operator> <name>AoHeader_RegularSize</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>storageWrite</name><operator>-&gt;</operator><name>storageAttributes</name><operator>.</operator><name>checksum</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>regularHeaderLen</name></name> <operator>+=</operator> <literal type="number">2</literal> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>pg_crc32</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>relationName</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>relationName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>title</name></name> <operator>=</operator> <name>title</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Set up extra buffers for compression.
	 */</comment>
	<expr_stmt><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>compressionOverrunLen</name></name> <operator>=</operator> <name><name>storageAttributes</name><operator>-&gt;</operator><name>overflowSize</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"Requested compression overflow bytes = %d."</literal></expr></argument>, <argument><expr><name><name>storageAttributes</name><operator>-&gt;</operator><name>overflowSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>storageWrite</name><operator>-&gt;</operator><name>storageAttributes</name><operator>.</operator><name>compress</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>uncompressedBuffer</name></name> <operator>=</operator> <operator>(</operator><name>uint8</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>maxBufferLen</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint8</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>uncompressedBuffer</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Now that we have determined the compression overrun, we can initialize
	 * BufferedAppend with the correct maxBufferLen + compressionOverrunLen.
	 */</comment>
	<expr_stmt><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>maxBufferWithCompressionOverrrunLen</name></name> <operator>=</operator>
		<name><name>storageWrite</name><operator>-&gt;</operator><name>maxBufferLen</name></name> <operator>+</operator> <name><name>storageWrite</name><operator>-&gt;</operator><name>compressionOverrunLen</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>maxLargeWriteLen</name></name> <operator>=</operator> <literal type="number">2</literal> <operator>*</operator> <name><name>storageWrite</name><operator>-&gt;</operator><name>maxBufferLen</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>maxBufferWithCompressionOverrrunLen</name></name> <operator>&lt;=</operator> <name><name>storageWrite</name><operator>-&gt;</operator><name>maxLargeWriteLen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>memoryLen</name> <operator>=</operator> <call><name>BufferedAppendMemoryLen</name>
		<argument_list>(
		 <argument><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>maxBufferWithCompressionOverrrunLen</name></name></expr></argument>, <comment type="block">/* maxBufferLen */</comment>
		 <argument><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>maxLargeWriteLen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>memory</name> <operator>=</operator> <operator>(</operator><name>uint8</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>memoryLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>BufferedAppendInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>storageWrite</name><operator>-&gt;</operator><name>bufferedAppend</name></name></expr></argument>,
					   <argument><expr><name>memory</name></expr></argument>,
					   <argument><expr><name>memoryLen</name></expr></argument>,
					   <argument><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>maxBufferWithCompressionOverrrunLen</name></name></expr></argument>,
					   <argument><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>maxLargeWriteLen</name></name></expr></argument>,
					   <argument><expr><name>relationName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>elogif</name><argument_list>(<argument><expr><name>Debug_appendonly_print_insert</name> <operator>||</operator> <name>Debug_appendonly_print_append_block</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>,
		   <argument><expr><literal type="string">"Append-Only Storage Write initialize for table '%s' (compression = %s, compression level %d, maximum buffer length %d, large write length %d)"</literal></expr></argument>,
		   <argument><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>relationName</name></name></expr></argument>,
		   <argument><expr><operator>(</operator><ternary><condition><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>storageAttributes</name><operator>.</operator><name>compress</name></name></expr> ?</condition><then> <expr><literal type="string">"true"</literal></expr> </then><else>: <expr><literal type="string">"false"</literal></expr></else></ternary><operator>)</operator></expr></argument>,
		   <argument><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>storageAttributes</name><operator>.</operator><name>compressLevel</name></name></expr></argument>,
		   <argument><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>maxBufferWithCompressionOverrrunLen</name></name></expr></argument>,
		   <argument><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>maxLargeWriteLen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * When doing VerifyBlock, allocate the extra buffers.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>gp_appendonly_verify_write_block</name> <operator>&amp;&amp;</operator> <name><name>storageWrite</name><operator>-&gt;</operator><name>storageAttributes</name><operator>.</operator><name>compress</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>verifyWriteBuffer</name></name> <operator>=</operator> <operator>(</operator><name>uint8</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>maxBufferLen</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint8</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>verifyWriteBuffer</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>file</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>formatVersion</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>needsWAL</name></name> <operator>=</operator> <name>needsWAL</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>isActive</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Finish using the AppendOnlyStorageWrite session created with ~Init.
 */</comment>
<function><type><name>void</name></type>
<name>AppendOnlyStorageWrite_FinishSession</name><parameter_list>(<parameter><decl><type><name>AppendOnlyStorageWrite</name> <modifier>*</modifier></type><name>storageWrite</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldMemoryContext</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>storageWrite</name><operator>-&gt;</operator><name>isActive</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>oldMemoryContext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>memoryContext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * UNDONE: This expects the MemoryContent to be what was used for the
	 * 'memory' in ~Init
	 */</comment>
	<expr_stmt><expr><call><name>BufferedAppendFinish</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>storageWrite</name><operator>-&gt;</operator><name>bufferedAppend</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>storageWrite</name><operator>-&gt;</operator><name>relationName</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>relationName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>relationName</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>storageWrite</name><operator>-&gt;</operator><name>uncompressedBuffer</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>uncompressedBuffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>uncompressedBuffer</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>storageWrite</name><operator>-&gt;</operator><name>verifyWriteBuffer</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>verifyWriteBuffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>verifyWriteBuffer</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>storageWrite</name><operator>-&gt;</operator><name>segmentFileName</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>segmentFileName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>segmentFileName</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>storageWrite</name><operator>-&gt;</operator><name>compression_functions</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>callCompressionDestructor</name><argument_list>(<argument><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>compression_functions</name><index>[<expr><name>COMPRESSION_DESTRUCTOR</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>compressionState</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>storageWrite</name><operator>-&gt;</operator><name>compressionState</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>compressionState</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>compressionState</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>storageWrite</name><operator>-&gt;</operator><name>verifyWriteCompressionState</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>callCompressionDestructor</name><argument_list>(<argument><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>compression_functions</name><index>[<expr><name>COMPRESSION_DESTRUCTOR</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>verifyWriteCompressionState</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>verifyWriteCompressionState</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Deallocation is done.      Go back to caller memory-context. */</comment>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>isActive</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

</block_content>}</block></function>

<comment type="block">/*----------------------------------------------------------------
 * Open and FlushAndClose
 *----------------------------------------------------------------
 */</comment>

<comment type="block">/*
 * Creates an on-demand Append-Only segment file under transaction.
 */</comment>
<function><type><name>void</name></type>
<name>AppendOnlyStorageWrite_TransactionCreateFile</name><parameter_list>(<parameter><decl><type><name>AppendOnlyStorageWrite</name> <modifier>*</modifier></type><name>storageWrite</name></decl></parameter>,
											 <parameter><decl><type><name>RelFileNodeBackend</name> <modifier>*</modifier></type><name>relFileNode</name></decl></parameter>,
											 <parameter><decl><type><name>int32</name></type> <name>segmentFileNum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>segmentFileNum</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* The file might already exist. that's OK */</comment>
	<comment type="line">// WALREP_FIXME: Pass isRedo == true, so that you don't get an error if it</comment>
	<comment type="line">// exists already. That's currently OK, but in the future, other things</comment>
	<comment type="line">// might depend on the isRedo flag, like whether to WAL-log the creation.</comment>
	<expr_stmt><expr><call><name>smgrcreate_ao</name><argument_list>(<argument><expr><operator>*</operator><name>relFileNode</name></expr></argument>, <argument><expr><name>segmentFileNum</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Create a WAL record, so that the segfile is also created after crash or
	 * in possible standby server. Not strictly necessarily, because a 0-length
	 * segfile and a non-existent segfile are treated the same. But the
	 * gp_replica_check tool, to compare primary and mirror, will complain if
	 * a file exists in master but not in mirror, even if it's empty.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>storageWrite</name><operator>-&gt;</operator><name>needsWAL</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>xlog_ao_insert</name><argument_list>(<argument><expr><name><name>relFileNode</name><operator>-&gt;</operator><name>node</name></name></expr></argument>, <argument><expr><name>segmentFileNum</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Opens the next segment file to write.  The file must already exist.
 *
 * This routine is responsible for seeking to the proper write location given
 * the logical EOF.
 *
 * filePathName		- name of the segment file to open.
 * version			- AO table format version the file is in.
 * logicalEof		- last committed write transaction's EOF value to use as
 *					  the end of the segment file.
 */</comment>
<function><type><name>void</name></type>
<name>AppendOnlyStorageWrite_OpenFile</name><parameter_list>(<parameter><decl><type><name>AppendOnlyStorageWrite</name> <modifier>*</modifier></type><name>storageWrite</name></decl></parameter>,
								<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>filePathName</name></decl></parameter>,
								<parameter><decl><type><name>int</name></type> <name>version</name></decl></parameter>,
								<parameter><decl><type><name>int64</name></type> <name>logicalEof</name></decl></parameter>,
								<parameter><decl><type><name>int64</name></type> <name>fileLen_uncompressed</name></decl></parameter>,
								<parameter><decl><type><name>RelFileNodeBackend</name> <modifier>*</modifier></type><name>relFileNode</name></decl></parameter>,
								<parameter><decl><type><name>int32</name></type> <name>segmentFileNum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>File</name></type>		<name>file</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldMemoryContext</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>storageWrite</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>isActive</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>filePathName</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Assume that we only write in the current latest format. (it's redundant
	 * to pass the version number as argument, currently)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>version</name> <operator>!=</operator> <call><name>AORelationVersion_GetLatest</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot write append-only table version %d"</literal></expr></argument>, <argument><expr><name>version</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Open or create the file for write.
	 */</comment>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>path</name> <init>= <expr><call><name>aorelpath</name><argument_list>(<argument><expr><operator>*</operator><name>relFileNode</name></expr></argument>, <argument><expr><name>segmentFileNum</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>int</name></type>			<name>fileFlags</name> <init>= <expr><name>O_RDWR</name> <operator>|</operator> <name>PG_BINARY</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name>file</name> <operator>=</operator> <call><name>PathNameOpenFile</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>fileFlags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>file</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Append-only Storage Write could not open segment file %s \"%s\" for relation \"%s\": %m"</literal></expr></argument>,
						<argument><expr><name>path</name></expr></argument>, <argument><expr><name>filePathName</name></expr></argument>,
						<argument><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>relationName</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Seek to the logical EOF write position.
	 */</comment>
	<expr_stmt><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>file</name></name> <operator>=</operator> <name>file</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>formatVersion</name></name> <operator>=</operator> <name>version</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>startEof</name></name> <operator>=</operator> <name>logicalEof</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>relFileNode</name></name> <operator>=</operator> <operator>*</operator><name>relFileNode</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>segmentFileNum</name></name> <operator>=</operator> <name>segmentFileNum</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * When writing multiple segment files, we throw away the old segment file
	 * name strings.
	 */</comment>
	<expr_stmt><expr><name>oldMemoryContext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>memoryContext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>storageWrite</name><operator>-&gt;</operator><name>segmentFileName</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>segmentFileName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>segmentFileName</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>filePathName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Allocation is done.  Go back to caller memory-context. */</comment>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Tell the BufferedAppend module about the file we just opened.
	 */</comment>
	<expr_stmt><expr><call><name>BufferedAppendSetFile</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>storageWrite</name><operator>-&gt;</operator><name>bufferedAppend</name></name></expr></argument>,
						  <argument><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>file</name></name></expr></argument>,
						  <argument><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>relFileNode</name></name></expr></argument>,
						  <argument><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>segmentFileNum</name></name></expr></argument>,
						  <argument><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>segmentFileName</name></name></expr></argument>,
						  <argument><expr><name>logicalEof</name></expr></argument>,
						  <argument><expr><name>fileLen_uncompressed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Optionally pad out to next page boundary.
 *
 * Since we do not do typical recovery processing of append-only file-system
 * pages, we pad out the last file-system byte with zeroes. The number of
 * bytes that are padded with zero's is determined by safefswritesize.
 * This function pads with 0's of length padLen or pads the whole remainder
 * of the safefswritesize size with 0's if padLen is -1.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>AppendOnlyStorageWrite_DoPadOutRemainder</name><parameter_list>(<parameter><decl><type><name>AppendOnlyStorageWrite</name> <modifier>*</modifier></type><name>storageWrite</name></decl></parameter>,
										 <parameter><decl><type><name>int32</name></type> <name>padLen</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int64</name></type>		<name>nextWritePosition</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type>		<name>nextBoundaryPosition</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>safeWrite</name> <init>= <expr><name><name>storageWrite</name><operator>-&gt;</operator><name>storageAttributes</name><operator>.</operator><name>safeFSWriteSize</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>safeWriteRemainder</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>doPad</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint8</name>	   <modifier>*</modifier></type><name>buffer</name></decl>;</decl_stmt>

	<comment type="block">/* early exit if no pad needed */</comment>
	<if_stmt><if>if <condition>(<expr><name>safeWrite</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>nextWritePosition</name> <operator>=</operator> <call><name>BufferedAppendNextBufferPosition</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>storageWrite</name><operator>-&gt;</operator><name>bufferedAppend</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>nextBoundaryPosition</name> <operator>=</operator>
		<operator>(</operator><operator>(</operator><name>nextWritePosition</name> <operator>+</operator> <name>safeWrite</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator> <name>safeWrite</name><operator>)</operator> <operator>*</operator> <name>safeWrite</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>safeWriteRemainder</name> <operator>=</operator> <operator>(</operator><name>int32</name><operator>)</operator> <operator>(</operator><name>nextBoundaryPosition</name> <operator>-</operator> <name>nextWritePosition</name><operator>)</operator></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>safeWriteRemainder</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>doPad</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>padLen</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Pad to end of page.
		 */</comment>
		<expr_stmt><expr><name>doPad</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>doPad</name> <operator>=</operator> <operator>(</operator><name>safeWriteRemainder</name> <operator>&lt;</operator> <name>padLen</name><operator>)</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>doPad</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Get buffer of the remainder to pad.
		 */</comment>
		<expr_stmt><expr><name>buffer</name> <operator>=</operator> <call><name>BufferedAppendGetBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>storageWrite</name><operator>-&gt;</operator><name>bufferedAppend</name></name></expr></argument>,
										 <argument><expr><name>safeWriteRemainder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>buffer</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"We do not expect files to be have a maximum length"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>safeWriteRemainder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>BufferedAppendFinishBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>storageWrite</name><operator>-&gt;</operator><name>bufferedAppend</name></name></expr></argument>,
								   <argument><expr><name>safeWriteRemainder</name></expr></argument>,
								   <argument><expr><name>safeWriteRemainder</name></expr></argument>,
								   <argument><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>needsWAL</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>elogif</name><argument_list>(<argument><expr><name>Debug_appendonly_print_insert</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>,
			   <argument><expr><literal type="string">"Append-only insert zero padded safeWriteRemainder for table '%s' (nextWritePosition = "</literal> <name>INT64_FORMAT</name> <literal type="string">", safeWriteRemainder = %d)"</literal></expr></argument>,
			   <argument><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>relationName</name></name></expr></argument>,
			   <argument><expr><name>nextWritePosition</name></expr></argument>,
			   <argument><expr><name>safeWriteRemainder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Flush and close the current segment file.
 *
 * No error if the current is already closed.
 *
 * The new EOF of the segment file is returend in *newLogicalEof.
 */</comment>
<function><type><name>void</name></type>
<name>AppendOnlyStorageWrite_FlushAndCloseFile</name><parameter_list>(
										 <parameter><decl><type><name>AppendOnlyStorageWrite</name> <modifier>*</modifier></type><name>storageWrite</name></decl></parameter>,
										 <parameter><decl><type><name>int64</name> <modifier>*</modifier></type><name>newLogicalEof</name></decl></parameter>,
										 <parameter><decl><type><name>int64</name> <modifier>*</modifier></type><name>fileLen_uncompressed</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>storageWrite</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>isActive</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>storageWrite</name><operator>-&gt;</operator><name>file</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>newLogicalEof</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>fileLen_uncompressed</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * We pad out append commands to the page boundary.
	 */</comment>
	<expr_stmt><expr><call><name>AppendOnlyStorageWrite_DoPadOutRemainder</name><argument_list>(
											 <argument><expr><name>storageWrite</name></expr></argument>,
											  <comment type="block">/* indicate till end of page */</comment> <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Have the BufferedAppend module let go, but this does not close the
	 * file.
	 */</comment>
	<expr_stmt><expr><call><name>BufferedAppendCompleteFile</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>storageWrite</name><operator>-&gt;</operator><name>bufferedAppend</name></name></expr></argument>,
							   <argument><expr><name>newLogicalEof</name></expr></argument>,
							   <argument><expr><name>fileLen_uncompressed</name></expr></argument>,
							   <argument><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>needsWAL</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We must take care of fsynching to disk ourselves since a fsync request
	 * is not enqueued for an AO segment file that is written to disk on
	 * primary.  Temp tables are not crash safe, no need to fsync them.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RelFileNodeBackendIsTemp</name><argument_list>(<argument><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>relFileNode</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<call><name>FileSync</name><argument_list>(<argument><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>file</name></name></expr></argument>, <argument><expr><name>WAIT_EVENT_DATA_FILE_SYNC</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Could not flush (fsync) Append-Only segment file '%s' to disk for relation '%s': %m"</literal></expr></argument>,
						<argument><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>segmentFileName</name></name></expr></argument>,
						<argument><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>relationName</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>FileClose</name><argument_list>(<argument><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>file</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>file</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>formatVersion</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>storageWrite</name><operator>-&gt;</operator><name>relFileNode</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RelFileNode</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>segmentFileNum</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Flush and close the current segment file under a transaction.
 *
 * Handles mirror loss end transaction work.
 *
 * No error if the current is already closed.
 *
 * The new EOF of the segment file is returned in *newLogicalEof.
 */</comment>
<function><type><name>void</name></type>
<name>AppendOnlyStorageWrite_TransactionFlushAndCloseFile</name><parameter_list>(<parameter><decl><type><name>AppendOnlyStorageWrite</name> <modifier>*</modifier></type><name>storageWrite</name></decl></parameter>,
													<parameter><decl><type><name>int64</name> <modifier>*</modifier></type><name>newLogicalEof</name></decl></parameter>,
													<parameter><decl><type><name>int64</name> <modifier>*</modifier></type><name>fileLen_uncompressed</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>storageWrite</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>isActive</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>storageWrite</name><operator>-&gt;</operator><name>file</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>newLogicalEof</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>fileLen_uncompressed</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>AppendOnlyStorageWrite_FlushAndCloseFile</name><argument_list>(<argument><expr><name>storageWrite</name></expr></argument>,
											 <argument><expr><name>newLogicalEof</name></expr></argument>,
											 <argument><expr><name>fileLen_uncompressed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*----------------------------------------------------------------
 * Usable Block Length
 *----------------------------------------------------------------
 */</comment>

<comment type="block">/*
 * When writing "short" content intended to stay within the maxBufferLen (also
 * known as blocksize), some of the buffer will be used for the Append-Only
 * Block Header.  This function returns that overhead length.
 *
 * Isn't the length of the Append-Only Storage Block constant? NO.
 *
 * Currently, there are two things that can make it longer.  When checksums
 * are configured, we add checksum data to the header.  And there is optional
 * header data (e.g. firstRowNum).
 *
 * We call the header portion with the optional checksums the fixed header
 * because we need to be able to read and evaluate the checksums before we can
 * interpret flags in the fixed header that indicate there is more header
 * information.
 *
 * The complete header length is the fixed header plus optional information.
 */</comment>

<comment type="block">/*
 * Returns the Append-Only Storage Block complete header length in bytes.
 *
 * Call this routine after specifying all optional header information for the current block
 * begin written.
 */</comment>
<function><type><name>int32</name></type>
<name>AppendOnlyStorageWrite_CompleteHeaderLen</name><parameter_list>(<parameter><decl><type><name>AppendOnlyStorageWrite</name> <modifier>*</modifier></type><name>storageWrite</name></decl></parameter>,
										 <parameter><decl><type><name>AoHeaderKind</name></type> <name>aoHeaderKind</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int32</name></type>		<name>completeHeaderLen</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>storageWrite</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>isActive</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>completeHeaderLen</name> <operator>=</operator> <name><name>storageWrite</name><operator>-&gt;</operator><name>regularHeaderLen</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>AoHeader_IsLong</name><argument_list>(<argument><expr><name>aoHeaderKind</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>completeHeaderLen</name> <operator>+=</operator> <operator>(</operator><name>AoHeader_LongSize</name> <operator>-</operator> <name>AoHeader_RegularSize</name><operator>)</operator></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>storageWrite</name><operator>-&gt;</operator><name>isFirstRowNumSet</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>completeHeaderLen</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int64</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>completeHeaderLen</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Returns the Append-Only Storage large content metadata header length in
 * bytes.
 *
 * Call this routine after specifying all optional header information for the
 * current block begin written.
 */</comment>
<function><type><specifier>static</specifier> <name>int32</name></type>
<name>AppendOnlyStorageWrite_LargeContentHeaderLen</name><parameter_list>(<parameter><decl><type><name>AppendOnlyStorageWrite</name> <modifier>*</modifier></type><name>storageWrite</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int32</name></type>		<name>completeHeaderLen</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>storageWrite</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>isActive</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>completeHeaderLen</name> <operator>=</operator> <name><name>storageWrite</name><operator>-&gt;</operator><name>regularHeaderLen</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>storageWrite</name><operator>-&gt;</operator><name>isFirstRowNumSet</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>completeHeaderLen</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int64</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* UNDONE: Right alignment? */</comment>

	<return>return <expr><name>completeHeaderLen</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>char</name> <modifier>*</modifier></type>
<name>AppendOnlyStorageWrite_ContextStr</name><parameter_list>(<parameter><decl><type><name>AppendOnlyStorageWrite</name> <modifier>*</modifier></type><name>storageWrite</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int64</name></type>		<name>headerOffsetInFile</name> <init>=
		<expr><call><name>BufferedAppendCurrentBufferPosition</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>storageWrite</name><operator>-&gt;</operator><name>bufferedAppend</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"%s. Append-Only segment file '%s', header offset in file "</literal> <name>INT64_FORMAT</name></expr></argument>,
					<argument><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>title</name></name></expr></argument>,
					<argument><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>segmentFileName</name></name></expr></argument>,
					<argument><expr><name>headerOffsetInFile</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>AppendOnlyStorageWrite_BlockHeaderStr</name><parameter_list>(<parameter><decl><type><name>AppendOnlyStorageWrite</name> <modifier>*</modifier></type><name>storageWrite</name></decl></parameter>,
									  <parameter><decl><type><name>uint8</name> <modifier>*</modifier></type><name>header</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>AppendOnlyStorageFormat_BlockHeaderStr</name><argument_list>(<argument><expr><name>header</name></expr></argument>,
												  <argument><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>storageAttributes</name><operator>.</operator><name>checksum</name></name></expr></argument>,
												  <argument><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>formatVersion</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>AppendOnlyStorageWrite_LogBlockHeader</name><parameter_list>(<parameter><decl><type><name>AppendOnlyStorageWrite</name> <modifier>*</modifier></type><name>storageWrite</name></decl></parameter>,
									  <parameter><decl><type><name>int64</name></type> <name>headerOffsetInFile</name></decl></parameter>,
									  <parameter><decl><type><name>uint8</name> <modifier>*</modifier></type><name>header</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>blockHeaderStr</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>blockHeaderStr</name> <operator>=</operator> <call><name>AppendOnlyStorageWrite_BlockHeaderStr</name><argument_list>(<argument><expr><name>storageWrite</name></expr></argument>,
														   <argument><expr><name>header</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s. Append-Only segment file '%s', header offset in file "</literal> <name>INT64_FORMAT</name> <literal type="string">". %s"</literal></expr></argument>,
					<argument><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>title</name></name></expr></argument>,
					<argument><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>segmentFileName</name></name></expr></argument>,
					<argument><expr><name>headerOffsetInFile</name></expr></argument>,
					<argument><expr><name>blockHeaderStr</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>blockHeaderStr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*----------------------------------------------------------------
 * errcontext and errdetail
 *----------------------------------------------------------------
 */</comment>

<comment type="block">/*
 * errcontext_appendonly_write_storage_block
 *
 * Add an errcontext() line showing the table, segment file, offset in file,
 * block count of the storage block being read.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>errcontext_appendonly_write_storage_block</name><parameter_list>(<parameter><decl><type><name>AppendOnlyStorageWrite</name> <modifier>*</modifier></type><name>storageWrite</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int64</name></type>		<name>headerOffsetInFile</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>headerOffsetInFile</name> <operator>=</operator> <call><name>BufferedAppendCurrentBufferPosition</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>storageWrite</name><operator>-&gt;</operator><name>bufferedAppend</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>errcontext</name><argument_list>(<argument><expr><literal type="string">"Append-Only table '%s', segment file '%s', block header offset in file = "</literal> <name>INT64_FORMAT</name> <literal type="string">", bufferCount "</literal> <name>INT64_FORMAT</name> <literal type="string">")"</literal></expr></argument>,
			   <argument><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>relationName</name></name></expr></argument>,
			   <argument><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>segmentFileName</name></name></expr></argument>,
			   <argument><expr><name>headerOffsetInFile</name></expr></argument>,
			   <argument><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>bufferCount</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * errdetail_appendonly_write_storage_block_header
 *
 * Add an errdetail() line showing the Append-Only Storage header being written.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>errdetail_appendonly_write_storage_block_header</name><parameter_list>(<parameter><decl><type><name>AppendOnlyStorageWrite</name> <modifier>*</modifier></type><name>storageWrite</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint8</name>	   <modifier>*</modifier></type><name>header</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>checksum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>version</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>header</name> <operator>=</operator> <call><name>BufferedAppendGetCurrentBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>storageWrite</name><operator>-&gt;</operator><name>bufferedAppend</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>checksum</name> <operator>=</operator> <name><name>storageWrite</name><operator>-&gt;</operator><name>storageAttributes</name><operator>.</operator><name>checksum</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>version</name> <operator>=</operator> <name><name>storageWrite</name><operator>-&gt;</operator><name>formatVersion</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>errdetail_appendonly_storage_smallcontent_header</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr><name>checksum</name></expr></argument>,
													 <argument><expr><name>version</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*----------------------------------------------------------------
 * Writing Small Content Efficiently that is not being Bulk Compressed
 *----------------------------------------------------------------
 */</comment>

<comment type="block">/*
 * This section describes for writing content that is less than or equal to
 * the blocksize (e.g. 32k) bytes that is not being bulk compressed by the
 * Append-Only Storage Layer.
 *
 * Actually, the content is limited to blocksize minus the Append-Only header
 * size (see the AppendOnlyStorageWrite_HeaderLen routine).
 */</comment>

<comment type="block">/*
 * Get a pointer to next maximum length buffer space for
 * appending small content.
 *
 * You must decide whether you are supplying the optional first row number
 * BEFORE calling this routine!
 *
 * NOTE: The maximum length buffer space =
 *				maxBufferLen +
 *				AppendOnlyStorageWrite_CompleteHeaderLen(...)
 *
 * When compression is not being used, this interface provides a pointer
 * directly into the write buffer for efficient data generation.  Otherwise,
 * a pointer to a temporary buffer to collect the uncompressed contents will
 * be provided.
 *
 * Returns NULL when the current file does not have enough room for another
 * buffer.
 */</comment>
<function><type><name>uint8</name> <modifier>*</modifier></type>
<name>AppendOnlyStorageWrite_GetBuffer</name><parameter_list>(<parameter><decl><type><name>AppendOnlyStorageWrite</name> <modifier>*</modifier></type><name>storageWrite</name></decl></parameter>,
								 <parameter><decl><type><name>int</name></type> <name>aoHeaderKind</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>storageWrite</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>isActive</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>aoHeaderKind</name> <operator>==</operator> <name>AoHeaderKind_SmallContent</name> <operator>||</operator>
		   <name>aoHeaderKind</name> <operator>==</operator> <name>AoHeaderKind_NonBulkDenseContent</name> <operator>||</operator>
		   <name>aoHeaderKind</name> <operator>==</operator> <name>AoHeaderKind_BulkDenseContent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>getBufferAoHeaderKind</name></name> <operator>=</operator> <name>aoHeaderKind</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Both headers (Small and NonBulkDense) have the same length. BulkDense
	 * is a long header.
	 */</comment>
	<expr_stmt><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>currentCompleteHeaderLen</name></name> <operator>=</operator>
		<call><name>AppendOnlyStorageWrite_CompleteHeaderLen</name><argument_list>(
												 <argument><expr><name>storageWrite</name></expr></argument>,
												 <argument><expr><name>aoHeaderKind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


	<comment type="block">/*
	 * If compression configured, the supply the temporary buffer instead.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>storageWrite</name><operator>-&gt;</operator><name>storageAttributes</name><operator>.</operator><name>compress</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>currentBuffer</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

		<return>return <expr><name><name>storageWrite</name><operator>-&gt;</operator><name>uncompressedBuffer</name></name></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>currentBuffer</name></name> <operator>=</operator>
			<call><name>BufferedAppendGetMaxBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>storageWrite</name><operator>-&gt;</operator><name>bufferedAppend</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return <expr><operator>&amp;</operator><name><name>storageWrite</name><operator>-&gt;</operator><name>currentBuffer</name><index>[<expr><name><name>storageWrite</name><operator>-&gt;</operator><name>currentCompleteHeaderLen</name></name></expr>]</index></name></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Test if a buffer is currently allocated.
 */</comment>
<function><type><name>bool</name></type>
<name>AppendOnlyStorageWrite_IsBufferAllocated</name><parameter_list>(<parameter><decl><type><name>AppendOnlyStorageWrite</name> <modifier>*</modifier></type><name>storageWrite</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>storageWrite</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>isActive</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><name><name>storageWrite</name><operator>-&gt;</operator><name>currentCompleteHeaderLen</name></name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Return the beginning of the last write position of the write buffer.
 */</comment>
<function><type><name>int64</name></type>
<name>AppendOnlyStorageWrite_LogicalBlockStartOffset</name><parameter_list>(<parameter><decl><type><name>AppendOnlyStorageWrite</name> <modifier>*</modifier></type><name>storageWrite</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name><name>storageWrite</name><operator>-&gt;</operator><name>logicalBlockStartOffset</name></name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>AppendOnlyStorageWrite_VerifyWriteBlock</name><parameter_list>(<parameter><decl><type><name>AppendOnlyStorageWrite</name> <modifier>*</modifier></type><name>storageWrite</name></decl></parameter>,
										<parameter><decl><type><name>int64</name></type> <name>headerOffsetInFile</name></decl></parameter>,
										<parameter><decl><type><name>int32</name></type> <name>bufferLen</name></decl></parameter>,
										<parameter><decl><type><name>uint8</name> <modifier>*</modifier></type><name>expectedContent</name></decl></parameter>,
										<parameter><decl><type><name>int32</name></type> <name>expectedUncompressedLen</name></decl></parameter>,
										<parameter><decl><type><name>int</name></type> <name>expectedExecutorBlockKind</name></decl></parameter>,
										<parameter><decl><type><name>int</name></type> <name>expectedRowCount</name></decl></parameter>,
										<parameter><decl><type><name>int32</name></type> <name>expectedCompressedLen</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint8</name>	   <modifier>*</modifier></type><name>header</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>AOHeaderCheckError</name></type> <name>checkError</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AoHeaderKind</name></type> <name>headerKind</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>actualHeaderLen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>offset</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>uncompressedLen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isCompressed</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>overallBlockLen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>compressedLen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>executorBlockKind</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>hasFirstRowNum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type>		<name>firstRowNum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>rowCount</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pg_crc32</name></type>	<name>storedChecksum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pg_crc32</name></type>	<name>computedChecksum</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>storageWrite</name><operator>-&gt;</operator><name>storageAttributes</name><operator>.</operator><name>compress</name></name> <operator>&amp;&amp;</operator> <name><name>storageWrite</name><operator>-&gt;</operator><name>verifyWriteBuffer</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>					<comment type="block">/* GUC must have been turned on
								 * mid-transaction. */</comment>

	<if_stmt><if>if <condition>(<expr><name>gp_appendonly_verify_write_block</name> <operator>==</operator> <name>false</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"The GUC gp_appendonly_verify_write_block is false. Compressed write not checked."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>header</name> <operator>=</operator> <call><name>BufferedAppendGetCurrentBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>storageWrite</name><operator>-&gt;</operator><name>bufferedAppend</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Code is similar to that in getNextStorageBlockInFile routine.
	 */</comment>

	<comment type="block">/*----------
	 * Proceed very carefully:
	 * [ 1. Verify header checksum ]
	 *	 2. Examine (basic) header.
	 *	 3. Examine specific header.
	 * [ 4. Verify the block checksum ]
	 *----------
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>storageWrite</name><operator>-&gt;</operator><name>storageAttributes</name><operator>.</operator><name>checksum</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AppendOnlyStorageFormat_VerifyHeaderChecksum</name><argument_list>(
														  <argument><expr><name>header</name></expr></argument>,
														  <argument><expr><operator>&amp;</operator><name>storedChecksum</name></expr></argument>,
														  <argument><expr><operator>&amp;</operator><name>computedChecksum</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Verify block during write found header checksum does not match.  Expected 0x%08X and found 0x%08X"</literal></expr></argument>,
							<argument><expr><name>storedChecksum</name></expr></argument>,
							<argument><expr><name>computedChecksum</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail_appendonly_write_storage_block_header</name><argument_list>(<argument><expr><name>storageWrite</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errcontext_appendonly_write_storage_block</name><argument_list>(<argument><expr><name>storageWrite</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Check the (basic) header information.
	 */</comment>
	<expr_stmt><expr><name>checkError</name> <operator>=</operator> <call><name>AppendOnlyStorageFormat_GetHeaderInfo</name><argument_list>(
													   <argument><expr><name>header</name></expr></argument>,
													   <argument><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>storageAttributes</name><operator>.</operator><name>checksum</name></name></expr></argument>,
													   <argument><expr><operator>&amp;</operator><name>headerKind</name></expr></argument>,
													   <argument><expr><operator>&amp;</operator><name>actualHeaderLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>checkError</name> <operator>!=</operator> <name>AOHeaderCheckOk</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Verify block during write found bad append-only storage header. Header check error %d, detail '%s'"</literal></expr></argument>,
						<argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>checkError</name></expr></argument>,
						<argument><expr><call><name>AppendOnlyStorageFormat_GetHeaderCheckErrorStr</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail_appendonly_write_storage_block_header</name><argument_list>(<argument><expr><name>storageWrite</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errcontext_appendonly_write_storage_block</name><argument_list>(<argument><expr><name>storageWrite</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<switch>switch <condition>(<expr><name>headerKind</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>AoHeaderKind_SmallContent</name></expr>:</case>

			<comment type="block">/*
			 * Check the Block header information.
			 */</comment>
			<expr_stmt><expr><name>checkError</name> <operator>=</operator> <call><name>AppendOnlyStorageFormat_GetSmallContentHeaderInfo</name><argument_list>(<argument><expr><name>header</name></expr></argument>,
																		   <argument><expr><name>actualHeaderLen</name></expr></argument>,
																		   <argument><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>storageAttributes</name><operator>.</operator><name>checksum</name></name></expr></argument>,
																		   <argument><expr><name>bufferLen</name></expr></argument>,
																		   <argument><expr><operator>&amp;</operator><name>overallBlockLen</name></expr></argument>,
																		   <argument><expr><operator>&amp;</operator><name>offset</name></expr></argument>, <comment type="line">//Offset to data.</comment>
																		   <argument><expr><operator>&amp;</operator> <name>uncompressedLen</name></expr></argument>,
																		   <argument><expr><operator>&amp;</operator><name>executorBlockKind</name></expr></argument>,
																		   <argument><expr><operator>&amp;</operator><name>hasFirstRowNum</name></expr></argument>,
																		   <argument><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>formatVersion</name></name></expr></argument>,
																		   <argument><expr><operator>&amp;</operator><name>firstRowNum</name></expr></argument>,
																		   <argument><expr><operator>&amp;</operator><name>rowCount</name></expr></argument>,
																		   <argument><expr><operator>&amp;</operator><name>isCompressed</name></expr></argument>,
																		   <argument><expr><operator>&amp;</operator><name>compressedLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>AoHeaderKind_LargeContent</name></expr>:</case>

			<comment type="block">/*
			 * Check the LargeContent header information.
			 */</comment>
			<expr_stmt><expr><name>checkError</name> <operator>=</operator> <call><name>AppendOnlyStorageFormat_GetLargeContentHeaderInfo</name><argument_list>(<argument><expr><name>header</name></expr></argument>,
																		   <argument><expr><name>actualHeaderLen</name></expr></argument>,
																		   <argument><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>storageAttributes</name><operator>.</operator><name>checksum</name></name></expr></argument>,
																		   <argument><expr><operator>&amp;</operator><name>uncompressedLen</name></expr></argument>,
																		   <argument><expr><operator>&amp;</operator><name>executorBlockKind</name></expr></argument>,
																		   <argument><expr><operator>&amp;</operator><name>hasFirstRowNum</name></expr></argument>,
																		   <argument><expr><operator>&amp;</operator><name>firstRowNum</name></expr></argument>,
																		   <argument><expr><operator>&amp;</operator><name>rowCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AoHeaderKind_NonBulkDenseContent</name></expr>:</case>
			<expr_stmt><expr><name>checkError</name> <operator>=</operator> <call><name>AppendOnlyStorageFormat_GetNonBulkDenseContentHeaderInfo</name><argument_list>(<argument><expr><name>header</name></expr></argument>,
																				  <argument><expr><name>actualHeaderLen</name></expr></argument>,
																				  <argument><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>storageAttributes</name><operator>.</operator><name>checksum</name></name></expr></argument>,
																				  <argument><expr><name>bufferLen</name></expr></argument>,
																				  <argument><expr><operator>&amp;</operator><name>overallBlockLen</name></expr></argument>,
																				  <argument><expr><operator>&amp;</operator><name>offset</name></expr></argument>, <comment type="line">//Offset to data.</comment>
																				  <argument><expr><operator>&amp;</operator><name>uncompressedLen</name></expr></argument>,
																				  <argument><expr><operator>&amp;</operator><name>executorBlockKind</name></expr></argument>,
																				  <argument><expr><operator>&amp;</operator><name>hasFirstRowNum</name></expr></argument>,
																				  <argument><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>formatVersion</name></name></expr></argument>,
																				  <argument><expr><operator>&amp;</operator><name>firstRowNum</name></expr></argument>,
																				  <argument><expr><operator>&amp;</operator><name>rowCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AoHeaderKind_BulkDenseContent</name></expr>:</case>
			<expr_stmt><expr><name>checkError</name> <operator>=</operator> <call><name>AppendOnlyStorageFormat_GetBulkDenseContentHeaderInfo</name><argument_list>(<argument><expr><name>header</name></expr></argument>,
																			   <argument><expr><name>actualHeaderLen</name></expr></argument>,
																			   <argument><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>storageAttributes</name><operator>.</operator><name>checksum</name></name></expr></argument>,
																			   <argument><expr><name>bufferLen</name></expr></argument>,
																			   <argument><expr><operator>&amp;</operator><name>overallBlockLen</name></expr></argument>,
																			   <argument><expr><operator>&amp;</operator><name>offset</name></expr></argument>, <comment type="line">//Offset to data.</comment>
																			   <argument><expr><operator>&amp;</operator><name>uncompressedLen</name></expr></argument>,
																			   <argument><expr><operator>&amp;</operator><name>executorBlockKind</name></expr></argument>,
																			   <argument><expr><operator>&amp;</operator><name>hasFirstRowNum</name></expr></argument>,
																			   <argument><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>formatVersion</name></name></expr></argument>,
																			   <argument><expr><operator>&amp;</operator><name>firstRowNum</name></expr></argument>,
																			   <argument><expr><operator>&amp;</operator><name>rowCount</name></expr></argument>,
																			   <argument><expr><operator>&amp;</operator><name>isCompressed</name></expr></argument>,
																			   <argument><expr><operator>&amp;</operator><name>compressedLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Unexpected Append-Only header kind %d"</literal></expr></argument>,
				 <argument><expr><name>headerKind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
	<if_stmt><if>if <condition>(<expr><name>checkError</name> <operator>!=</operator> <name>AOHeaderCheckOk</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Verify block during write found bad append-only storage block header. Block type: %d "</literal>
						<literal type="string">"Header check error %d, detail '%s'"</literal></expr></argument>,
						<argument><expr><name>headerKind</name></expr></argument>,
						<argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>checkError</name></expr></argument>,
				   <argument><expr><call><name>AppendOnlyStorageFormat_GetHeaderCheckErrorStr</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
		<call><name>errdetail_appendonly_write_storage_block_header</name><argument_list>(<argument><expr><name>storageWrite</name></expr></argument>)</argument_list></call><operator>,</operator>
		   <call><name>errcontext_appendonly_write_storage_block</name><argument_list>(<argument><expr><name>storageWrite</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>uncompressedLen</name> <operator>!=</operator> <name>expectedUncompressedLen</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Verify block during write found append-only storage block header. "</literal>
					<literal type="string">"DataLen %d does not equal expected length %d, "</literal></expr></argument>,
						<argument><expr><name>uncompressedLen</name></expr></argument>,
						<argument><expr><name>expectedUncompressedLen</name></expr></argument>)</argument_list></call><operator>,</operator>
		<call><name>errdetail_appendonly_write_storage_block_header</name><argument_list>(<argument><expr><name>storageWrite</name></expr></argument>)</argument_list></call><operator>,</operator>
		   <call><name>errcontext_appendonly_write_storage_block</name><argument_list>(<argument><expr><name>storageWrite</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


	<if_stmt><if>if <condition>(<expr><name>compressedLen</name> <operator>!=</operator> <name>expectedCompressedLen</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Verify block during write found append-only storage block header. "</literal>
				<literal type="string">"CompressedLen %d does not equal expected length %d"</literal></expr></argument>,
						<argument><expr><name>compressedLen</name></expr></argument>,
						<argument><expr><name>expectedCompressedLen</name></expr></argument>)</argument_list></call><operator>,</operator>
		<call><name>errdetail_appendonly_write_storage_block_header</name><argument_list>(<argument><expr><name>storageWrite</name></expr></argument>)</argument_list></call><operator>,</operator>
		   <call><name>errcontext_appendonly_write_storage_block</name><argument_list>(<argument><expr><name>storageWrite</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Now verify the executor portion of the block.
	 */</comment>

	<if_stmt><if>if <condition>(<expr><name>executorBlockKind</name> <operator>!=</operator> <name>expectedExecutorBlockKind</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Verify block during write found append-only storage block header. "</literal>
			<literal type="string">"ExecutorBlockKind %d does not equal expected value %d."</literal></expr></argument>,
						<argument><expr><name>executorBlockKind</name></expr></argument>,
						<argument><expr><name>expectedExecutorBlockKind</name></expr></argument>)</argument_list></call><operator>,</operator>
		<call><name>errdetail_appendonly_write_storage_block_header</name><argument_list>(<argument><expr><name>storageWrite</name></expr></argument>)</argument_list></call><operator>,</operator>
		   <call><name>errcontext_appendonly_write_storage_block</name><argument_list>(<argument><expr><name>storageWrite</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* UNDONE: Check hasFirstRowNum */</comment>

	<if_stmt><if>if <condition>(<expr><name>rowCount</name> <operator>!=</operator> <name>expectedRowCount</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Verify block during write found append-only storage block header. "</literal>
					  <literal type="string">"RowCount %d does not equal expected value %d"</literal></expr></argument>,
						<argument><expr><name>rowCount</name></expr></argument>,
						<argument><expr><name>expectedRowCount</name></expr></argument>)</argument_list></call><operator>,</operator>
		<call><name>errdetail_appendonly_write_storage_block_header</name><argument_list>(<argument><expr><name>storageWrite</name></expr></argument>)</argument_list></call><operator>,</operator>
		   <call><name>errcontext_appendonly_write_storage_block</name><argument_list>(<argument><expr><name>storageWrite</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>Debug_appendonly_print_verify_write_block</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>AppendOnlyStorageWrite_LogBlockHeader</name><argument_list>(<argument><expr><name>storageWrite</name></expr></argument>,
											  <argument><expr><name>headerOffsetInFile</name></expr></argument>,
											  <argument><expr><name>header</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>


	<if_stmt><if>if <condition>(<expr><name>isCompressed</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>test</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PGFunction</name></type>	<name>decompressor</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PGFunction</name> <modifier>*</modifier></type><name>cfns</name> <init>= <expr><name><name>storageWrite</name><operator>-&gt;</operator><name>compression_functions</name></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>gp_appendonly_verify_write_block</name> <operator>==</operator> <name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>verifyWriteCompressionState</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>cfns</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"decompression information missing"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>decompressor</name> <operator>=</operator> <name><name>cfns</name><index>[<expr><name>COMPRESSION_DECOMPRESS</name></expr>]</index></name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>gp_decompress</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>header</name><index>[<expr><name>offset</name></expr>]</index></name></expr></argument>, <comment type="line">//Compressed data in block.</comment>
					  <argument><expr><name>compressedLen</name></expr></argument>,
					  <argument><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>verifyWriteBuffer</name></name></expr></argument>, <comment type="line">//Temporary buffer to hold uncompressed data.</comment>
					  <argument><expr><name>uncompressedLen</name></expr></argument>,
					  <argument><expr><name>decompressor</name></expr></argument>,
					  <argument><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>verifyWriteCompressionState</name></name></expr></argument>,
					  <argument><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>bufferCount</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Compare.
		 */</comment>
		<expr_stmt><expr><name>test</name> <operator>=</operator> <call><name>memcmp</name><argument_list>(<argument><expr><name>expectedContent</name></expr></argument>,
					  <argument><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>verifyWriteBuffer</name></name></expr></argument>,
					  <argument><expr><name>uncompressedLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>test</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Verify block during write found decompress did not produce the exact same bits passed to compress! "</literal>
							<literal type="string">"Memcmp result %d"</literal></expr></argument>,
							<argument><expr><name>test</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail_appendonly_write_storage_block_header</name><argument_list>(<argument><expr><name>storageWrite</name></expr></argument>)</argument_list></call><operator>,</operator>
			<call><name>errcontext_appendonly_write_storage_block</name><argument_list>(<argument><expr><name>storageWrite</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* UNDONE: Do comparison here */</comment>
	</block_content>}</block></else></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NeedCallBack</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><name>executorBlockKind</name> <operator>==</operator> <name>AoExecutorBlockKind_VarBlock</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>VarBlockCheckError</name></type> <name>varBlockCheckError</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>VarBlockReader</name></type> <name>varBlockReader</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>readerItemCount</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>varBlockCheckError</name> <operator>=</operator> <call><name>VarBlockIsValid</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>uncompressedLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>varBlockCheckError</name> <operator>!=</operator> <name>VarBlockCheckOk</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Verify block during write found VarBlock is not valid "</literal>
							<literal type="string">"Valid block check error %d, detail '%s'"</literal></expr></argument>,
							<argument><expr><name>varBlockCheckError</name></expr></argument>,
							<argument><expr><call><name>VarBlockGetCheckErrorStr</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail_appendonly_write_storage_block_header</name><argument_list>(<argument><expr><name>storageWrite</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errcontext_appendonly_write_storage_block</name><argument_list>(<argument><expr><name>storageWrite</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Now use the VarBlock module to extract the items out.
		 */</comment>
		<expr_stmt><expr><call><name>VarBlockReaderInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>varBlockReader</name></expr></argument>,
						   <argument><expr><name>data</name></expr></argument>,
						   <argument><expr><name>uncompressedLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>readerItemCount</name> <operator>=</operator> <call><name>VarBlockReaderItemCount</name><argument_list>(<argument><expr><operator>&amp;</operator><name>varBlockReader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>rowCount</name> <operator>!=</operator> <name>readerItemCount</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Verify block during write found row count %d in append-only storage header does not match VarBlock item count %d"</literal></expr></argument>,
							<argument><expr><name>rowCount</name></expr></argument>,
							<argument><expr><name>readerItemCount</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail_appendonly_write_storage_block_header</name><argument_list>(<argument><expr><name>storageWrite</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errcontext_appendonly_write_storage_block</name><argument_list>(<argument><expr><name>storageWrite</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>AppendOnlyStorageWrite_CompressAppend</name><parameter_list>(<parameter><decl><type><name>AppendOnlyStorageWrite</name> <modifier>*</modifier></type><name>storageWrite</name></decl></parameter>,
									  <parameter><decl><type><name>uint8</name> <modifier>*</modifier></type><name>sourceData</name></decl></parameter>,
									  <parameter><decl><type><name>int32</name></type> <name>sourceLen</name></decl></parameter>,
									  <parameter><decl><type><name>int</name></type> <name>executorBlockKind</name></decl></parameter>,
									  <parameter><decl><type><name>int</name></type> <name>itemCount</name></decl></parameter>,
									  <parameter><decl><type><name>int32</name> <modifier>*</modifier></type><name>compressedLen</name></decl></parameter>,
									  <parameter><decl><type><name>int32</name> <modifier>*</modifier></type><name>bufferLen</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint8</name>	   <modifier>*</modifier></type><name>header</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint8</name>	   <modifier>*</modifier></type><name>dataBuffer</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>dataBufferWithOverrrunLen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGFunction</name> <modifier>*</modifier></type><name>cfns</name> <init>= <expr><name><name>storageWrite</name><operator>-&gt;</operator><name>compression_functions</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGFunction</name></type>	<name>compressor</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>cfns</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>compressor</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>compressor</name> <operator>=</operator> <name><name>cfns</name><index>[<expr><name>COMPRESSION_COMPRESS</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* UNDONE: This can be a duplicate call... */</comment>
	<expr_stmt><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>currentCompleteHeaderLen</name></name> <operator>=</operator>
		<call><name>AppendOnlyStorageWrite_CompleteHeaderLen</name><argument_list>(
			<argument><expr><name>storageWrite</name></expr></argument>,
			<argument><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>getBufferAoHeaderKind</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>header</name> <operator>=</operator> <call><name>BufferedAppendGetMaxBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>storageWrite</name><operator>-&gt;</operator><name>bufferedAppend</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>header</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"We do not expect files to be have a maximum length"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errcontext_appendonly_write_storage_block</name><argument_list>(<argument><expr><name>storageWrite</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>dataBuffer</name> <operator>=</operator> <operator>&amp;</operator><name><name>header</name><index>[<expr><name><name>storageWrite</name><operator>-&gt;</operator><name>currentCompleteHeaderLen</name></name></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>dataBufferWithOverrrunLen</name> <operator>=</operator>
		<name><name>storageWrite</name><operator>-&gt;</operator><name>maxBufferWithCompressionOverrrunLen</name></name>
		<operator>-</operator> <name><name>storageWrite</name><operator>-&gt;</operator><name>currentCompleteHeaderLen</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Compress into the BufferedAppend buffer after the large header (and
	 * optional checksum, etc.
	 */</comment>
	<expr_stmt><expr><call><name>gp_trycompress</name><argument_list>(<argument><expr><name>sourceData</name></expr></argument>,
					<argument><expr><name>sourceLen</name></expr></argument>,
					<argument><expr><name>dataBuffer</name></expr></argument>,
					<argument><expr><name>dataBufferWithOverrrunLen</name></expr></argument>,
					<argument><expr><name>compressedLen</name></expr></argument>,
					<argument><expr><name>compressor</name></expr></argument>,
					<argument><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>compressionState</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FAULT_INJECTOR</name></cpp:ifdef>
	<comment type="block">/* Simulate that compression is not possible if the fault is set. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>FaultInjector_InjectFaultIfSet</name><argument_list>(
			<argument><expr><literal type="string">"appendonly_skip_compression"</literal></expr></argument>,
			<argument><expr><name>DDLNotSpecified</name></expr></argument>,
			<argument><expr><literal type="string">""</literal></expr></argument>,
			<argument><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>relationName</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FaultInjectorTypeSkip</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>compressedLen</name> <operator>=</operator> <name>sourceLen</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/*
	 * We always store the data compressed if the compressed length is less
	 * than the uncompressed length.
	 *
	 * TODO: this is a weak assumption. It doesn't account for the fact that
	 * it's not worth paying the CPU cost of decompression for a potentially
	 * trivial saving.
	 *
	 * The best solution to this seems to be to make the threshold at which we
	 * compress data user configurable.
	 */</comment>
	<decl_stmt><decl><type><name>int32</name></type> <name>dataLen</name> <init>= <expr><operator>*</operator><name>compressedLen</name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>compressedLen</name> <operator>&gt;=</operator> <name>sourceLen</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>dataLen</name> <operator>=</operator> <name>sourceLen</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>dataBuffer</name></expr></argument>, <argument><expr><name>sourceData</name></expr></argument>, <argument><expr><name>sourceLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>compressedLen</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<decl_stmt><decl><type><name>int32</name></type> <name>dataRoundedUpLen</name> <init>=
		<expr><call><name>AOStorage_RoundUp</name><argument_list>(<argument><expr><name>dataLen</name></expr></argument>, <argument><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>formatVersion</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>AOStorage_ZeroPad</name><argument_list>(<argument><expr><name>dataBuffer</name></expr></argument>, <argument><expr><name>dataLen</name></expr></argument>, <argument><expr><name>dataRoundedUpLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Make the header and compute the checksum if necessary. */</comment>
	<switch>switch <condition>(<expr><name><name>storageWrite</name><operator>-&gt;</operator><name>getBufferAoHeaderKind</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>AoHeaderKind_SmallContent</name></expr>:</case>
			<expr_stmt><expr><call><name>AppendOnlyStorageFormat_MakeSmallContentHeader</name>
				<argument_list>(<argument><expr><name>header</name></expr></argument>,
				 <argument><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>storageAttributes</name><operator>.</operator><name>checksum</name></name></expr></argument>,
				 <argument><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>isFirstRowNumSet</name></name></expr></argument>,
				 <argument><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>formatVersion</name></name></expr></argument>,
				 <argument><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>firstRowNum</name></name></expr></argument>,
				 <argument><expr><name>executorBlockKind</name></expr></argument>,
				 <argument><expr><name>itemCount</name></expr></argument>,
				 <argument><expr><name>sourceLen</name></expr></argument>,
				 <argument><expr><operator>*</operator><name>compressedLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>AoHeaderKind_BulkDenseContent</name></expr>:</case>
			<comment type="block">/*
			 * This header is used when compresslevel &gt; 1 is specified with
			 * rle_type compression.  The sourceData is already encoded with
			 * RLE.  It is further compressed with bulk compression.
			 * Corresponding datumstream version is
			 * DatumStreamVersion_Dense_Enhanced.
			 */</comment>
			<expr_stmt><expr><call><name>AppendOnlyStorageFormat_MakeBulkDenseContentHeader</name>
				<argument_list>(<argument><expr><name>header</name></expr></argument>,
				 <argument><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>storageAttributes</name><operator>.</operator><name>checksum</name></name></expr></argument>,
				 <argument><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>isFirstRowNumSet</name></name></expr></argument>,
				 <argument><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>formatVersion</name></name></expr></argument>,
				 <argument><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>firstRowNum</name></name></expr></argument>,
				 <argument><expr><name>executorBlockKind</name></expr></argument>,
				 <argument><expr><name>itemCount</name></expr></argument>,
				 <argument><expr><name>sourceLen</name></expr></argument>,
				 <argument><expr><operator>*</operator><name>compressedLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected Append-Only header kind %d"</literal></expr></argument>,
				 <argument><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>getBufferAoHeaderKind</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<if_stmt><if>if <condition>(<expr><name>Debug_appendonly_print_storage_headers</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>AppendOnlyStorageWrite_LogBlockHeader</name><argument_list>(
			<argument><expr><name>storageWrite</name></expr></argument>,
			<argument><expr><call><name>BufferedAppendCurrentBufferPosition</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>storageWrite</name><operator>-&gt;</operator><name>bufferedAppend</name></name></expr></argument>)</argument_list></call></expr></argument>,
			<argument><expr><name>header</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>elogif</name><argument_list>(<argument><expr><name>Debug_appendonly_print_insert</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>,
		   <argument><expr><literal type="string">"Append-only insert block for table '%s' stored %s "</literal>
		   <literal type="string">"(segment file '%s', header offset in file "</literal> <name>INT64_FORMAT</name> <literal type="string">", "</literal>
		   <literal type="string">"source length = %d, result length %d item count %d, block count "</literal>
		   <name>INT64_FORMAT</name> <literal type="string">")"</literal></expr></argument>,
		   <argument><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>relationName</name></name></expr></argument>,
		   <argument><expr><ternary><condition><expr><operator>(</operator><operator>*</operator><name>compressedLen</name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">"compressed"</literal></expr> </then><else>: <expr><literal type="string">"uncompressed"</literal></expr></else></ternary></expr></argument>,
		   <argument><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>segmentFileName</name></name></expr></argument>,
		   <argument><expr><call><name>BufferedAppendCurrentBufferPosition</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>storageWrite</name><operator>-&gt;</operator><name>bufferedAppend</name></name></expr></argument>)</argument_list></call></expr></argument>,
		   <argument><expr><name>sourceLen</name></expr></argument>,
		   <argument><expr><name>dataLen</name></expr></argument>,
		   <argument><expr><name>itemCount</name></expr></argument>,
		   <argument><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>bufferCount</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>bufferLen</name> <operator>=</operator> <name><name>storageWrite</name><operator>-&gt;</operator><name>currentCompleteHeaderLen</name></name> <operator>+</operator> <name>dataRoundedUpLen</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Mark the current buffer "small" buffer as finished.
 *
 * If compression is configured, we will try to compress the contents in
 * the temporary uncompressed buffer into the write buffer.
 *
 * The buffer can be scheduled for writing and reused.
 *
 * contentLen		- byte length of the content generated directly into the
 *					  buffer returned by AppendOnlyStorageWrite_GetBuffer.
 * executorBlockKind - A value defined externally by the executor that
 *					   describes in content stored in the Append-Only Storage
 *					   Block.
 * rowCount			-  number of rows stored in the content.
 */</comment>
<function><type><name>void</name></type>
<name>AppendOnlyStorageWrite_FinishBuffer</name><parameter_list>(<parameter><decl><type><name>AppendOnlyStorageWrite</name> <modifier>*</modifier></type><name>storageWrite</name></decl></parameter>,
									<parameter><decl><type><name>int32</name></type> <name>contentLen</name></decl></parameter>,
									<parameter><decl><type><name>int</name></type> <name>executorBlockKind</name></decl></parameter>,
									<parameter><decl><type><name>int</name></type> <name>rowCount</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int64</name></type>		<name>headerOffsetInFile</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>bufferLen</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>storageWrite</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>isActive</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>currentCompleteHeaderLen</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>contentLen</name> <operator>&gt;</operator>
		<name><name>storageWrite</name><operator>-&gt;</operator><name>maxBufferLen</name></name> <operator>-</operator> <name><name>storageWrite</name><operator>-&gt;</operator><name>currentCompleteHeaderLen</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
			 <argument><expr><literal type="string">"Append-only content too large AO storage block (table '%s', "</literal>
			 <literal type="string">"content length = %d, maximum buffer length %d, complete header length %d, first row number is set %s)"</literal></expr></argument>,
			 <argument><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>relationName</name></name></expr></argument>,
			 <argument><expr><name>contentLen</name></expr></argument>,
			 <argument><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>maxBufferLen</name></name></expr></argument>,
			 <argument><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>currentCompleteHeaderLen</name></name></expr></argument>,
			 <argument><expr><operator>(</operator><ternary><condition><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>isFirstRowNumSet</name></name></expr> ?</condition><then> <expr><literal type="string">"true"</literal></expr> </then><else>: <expr><literal type="string">"false"</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


	<expr_stmt><expr><name>headerOffsetInFile</name> <operator>=</operator> <call><name>BufferedAppendCurrentBufferPosition</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>storageWrite</name><operator>-&gt;</operator><name>bufferedAppend</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>storageWrite</name><operator>-&gt;</operator><name>storageAttributes</name><operator>.</operator><name>compress</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>uint8</name>	   <modifier>*</modifier></type><name>nonCompressedHeader</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint8</name>	   <modifier>*</modifier></type><name>nonCompressedData</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int32</name></type>		<name>dataRoundedUpLen</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int32</name></type>		<name>uncompressedlen</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>nonCompressedHeader</name> <operator>=</operator> <name><name>storageWrite</name><operator>-&gt;</operator><name>currentBuffer</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><name>nonCompressedData</name> <operator>=</operator> <operator>&amp;</operator><name><name>nonCompressedHeader</name><index>[<expr><name><name>storageWrite</name><operator>-&gt;</operator><name>currentCompleteHeaderLen</name></name></expr>]</index></name></expr>;</expr_stmt>

		<expr_stmt><expr><name>dataRoundedUpLen</name> <operator>=</operator> <call><name>AOStorage_RoundUp</name><argument_list>(<argument><expr><name>contentLen</name></expr></argument>, <argument><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>formatVersion</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>AOStorage_ZeroPad</name><argument_list>(
						  <argument><expr><name>nonCompressedData</name></expr></argument>,
						  <argument><expr><name>contentLen</name></expr></argument>,
						  <argument><expr><name>dataRoundedUpLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<switch>switch <condition>(<expr><name><name>storageWrite</name><operator>-&gt;</operator><name>getBufferAoHeaderKind</name></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>AoHeaderKind_SmallContent</name></expr>:</case>

				<comment type="block">/*
				 * Make the header and compute the checksum if necessary.
				 */</comment>
				<expr_stmt><expr><call><name>AppendOnlyStorageFormat_MakeSmallContentHeader</name>
					<argument_list>(<argument><expr><name>nonCompressedHeader</name></expr></argument>,
					 <argument><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>storageAttributes</name><operator>.</operator><name>checksum</name></name></expr></argument>,
					 <argument><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>isFirstRowNumSet</name></name></expr></argument>,
					 <argument><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>formatVersion</name></name></expr></argument>,
					 <argument><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>firstRowNum</name></name></expr></argument>,
					 <argument><expr><name>executorBlockKind</name></expr></argument>,
					 <argument><expr><name>rowCount</name></expr></argument>,
					 <argument><expr><name>contentLen</name></expr></argument>,
					  <comment type="block">/* compressedLength */</comment> <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>AoHeaderKind_NonBulkDenseContent</name></expr>:</case>

				<comment type="block">/*
				 * Make the header and compute the checksum if necessary.
				 */</comment>
				<expr_stmt><expr><call><name>AppendOnlyStorageFormat_MakeNonBulkDenseContentHeader</name>
					<argument_list>(<argument><expr><name>nonCompressedHeader</name></expr></argument>,
					 <argument><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>storageAttributes</name><operator>.</operator><name>checksum</name></name></expr></argument>,
					 <argument><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>isFirstRowNumSet</name></name></expr></argument>,
					 <argument><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>formatVersion</name></name></expr></argument>,
					 <argument><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>firstRowNum</name></name></expr></argument>,
					 <argument><expr><name>executorBlockKind</name></expr></argument>,
					 <argument><expr><name>rowCount</name></expr></argument>,
					 <argument><expr><name>contentLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<default>default:</default>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Unexpected Append-Only header kind %d"</literal></expr></argument>,
					 <argument><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>getBufferAoHeaderKind</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
		</block_content>}</block></switch>

		<if_stmt><if>if <condition>(<expr><name>Debug_appendonly_print_storage_headers</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>AppendOnlyStorageWrite_LogBlockHeader</name><argument_list>(<argument><expr><name>storageWrite</name></expr></argument>,
												  <argument><expr><name>headerOffsetInFile</name></expr></argument>,
												  <argument><expr><name>nonCompressedHeader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>


		<expr_stmt><expr><name>bufferLen</name> <operator>=</operator> <name><name>storageWrite</name><operator>-&gt;</operator><name>currentCompleteHeaderLen</name></name> <operator>+</operator> <name>dataRoundedUpLen</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>uncompressedlen</name> <operator>=</operator> <name>bufferLen</name></expr>;</expr_stmt>	<comment type="block">/* since there's no compression.. */</comment>

		<comment type="block">/*
		 * Just before finishing the AO Storage buffer with our non-compressed
		 * content, let's verify it.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>gp_appendonly_verify_write_block</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>AppendOnlyStorageWrite_VerifyWriteBlock</name><argument_list>(<argument><expr><name>storageWrite</name></expr></argument>,
													<argument><expr><name>headerOffsetInFile</name></expr></argument>,
													<argument><expr><name>bufferLen</name></expr></argument>,
													<argument><expr><name>nonCompressedData</name></expr></argument>,
													<argument><expr><name>contentLen</name></expr></argument>,
													<argument><expr><name>executorBlockKind</name></expr></argument>,
													<argument><expr><name>rowCount</name></expr></argument>,
													 <comment type="block">/* expectedCompressedLen */</comment> <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>BufferedAppendFinishBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>storageWrite</name><operator>-&gt;</operator><name>bufferedAppend</name></name></expr></argument>,
								   <argument><expr><name>bufferLen</name></expr></argument>,
								   <argument><expr><name>uncompressedlen</name></expr></argument>,
								   <argument><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>needsWAL</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Declare it finished. */</comment>
		<expr_stmt><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>currentCompleteHeaderLen</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>elogif</name><argument_list>(<argument><expr><name>Debug_appendonly_print_insert</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>,
			   <argument><expr><literal type="string">"Append-only insert finished uncompressed block for table '%s' "</literal>
			   <literal type="string">"(length = %d, executor block kind %d, item count %d, block count "</literal> <name>INT64_FORMAT</name> <literal type="string">")"</literal></expr></argument>,
			   <argument><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>relationName</name></name></expr></argument>,
			   <argument><expr><name>contentLen</name></expr></argument>,
			   <argument><expr><name>executorBlockKind</name></expr></argument>,
			   <argument><expr><name>rowCount</name></expr></argument>,
			   <argument><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>bufferCount</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>int32</name></type>		<name>compressedLen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>AppendOnlyStorageWrite_CompressAppend</name><argument_list>(<argument><expr><name>storageWrite</name></expr></argument>,
											  <argument><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>uncompressedBuffer</name></name></expr></argument>,
											  <argument><expr><name>contentLen</name></expr></argument>,
											  <argument><expr><name>executorBlockKind</name></expr></argument>,
											  <argument><expr><name>rowCount</name></expr></argument>,
											  <argument><expr><operator>&amp;</operator><name>compressedLen</name></expr></argument>,
											  <argument><expr><operator>&amp;</operator><name>bufferLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Just before finishing the AO Storage buffer with our non-compressed
		 * content, let's verify it.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>gp_appendonly_verify_write_block</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>AppendOnlyStorageWrite_VerifyWriteBlock</name><argument_list>(<argument><expr><name>storageWrite</name></expr></argument>,
													<argument><expr><name>headerOffsetInFile</name></expr></argument>,
													<argument><expr><name>bufferLen</name></expr></argument>,
													<argument><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>uncompressedBuffer</name></name></expr></argument>,
													<argument><expr><name>contentLen</name></expr></argument>,
													<argument><expr><name>executorBlockKind</name></expr></argument>,
													<argument><expr><name>rowCount</name></expr></argument>,
													<argument><expr><name>compressedLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Finish the current buffer by specifying the used length.
		 */</comment>
		<expr_stmt><expr><call><name>BufferedAppendFinishBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>storageWrite</name><operator>-&gt;</operator><name>bufferedAppend</name></name></expr></argument>,
								   <argument><expr><name>bufferLen</name></expr></argument>,
								   <argument><expr><operator>(</operator><name><name>storageWrite</name><operator>-&gt;</operator><name>currentCompleteHeaderLen</name></name> <operator>+</operator>
								       <call><name>AOStorage_RoundUp</name><argument_list>(<argument><expr><name>contentLen</name></expr></argument>, <argument><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>formatVersion</name></name></expr></argument>)</argument_list></call> <comment type="block">/* non-compressed size */</comment> <operator>)</operator></expr></argument>,
								   <argument><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>needsWAL</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Declare it finished. */</comment>
		<expr_stmt><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>currentCompleteHeaderLen</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>currentCompleteHeaderLen</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>currentBuffer</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>isFirstRowNumSet</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Cancel the last ~GetBuffer call.
 *
 * This will also turn off the firstRowNum flag.
 */</comment>
<function><type><name>void</name></type>
<name>AppendOnlyStorageWrite_CancelLastBuffer</name><parameter_list>(
										<parameter><decl><type><name>AppendOnlyStorageWrite</name> <modifier>*</modifier></type><name>storageWrite</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>storageWrite</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>isActive</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>currentCompleteHeaderLen</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>storageWrite</name><operator>-&gt;</operator><name>currentBuffer</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>BufferedAppendCancelLastBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>storageWrite</name><operator>-&gt;</operator><name>bufferedAppend</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>currentBuffer</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>currentCompleteHeaderLen</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * Since we don't know if AppendOnlyStorageWrite_Content will be called
	 * next or the writer is doing something else, let's turn off the
	 * firstRowNum flag.
	 */</comment>
	<expr_stmt><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>isFirstRowNumSet</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*----------------------------------------------------------------
 * Writing "Large" Content
 *----------------------------------------------------------------
 */</comment>

<comment type="block">/*
 * This section describes for writing long content that can be up to 1 Gb
 * long and/or content that will be bulk-compressed when configured.
 */</comment>


<comment type="block">/*
 * Write content up to 1Gb.
 *
 * Large content will be writen in fragment blocks by the Append-Only
 * Storage Layer.
 *
 * If compression is configured, then the content will be compressed in
 * fragments.
 *
 * Returns NULL when the current file does not have enough room for another
 * buffer.
 *
 * content		- Content to store.  All contiguous.
 * contentLen	- byte length of the data to store.
 * executorBlockKind - a value defined externally by the executor that
 *					   describes in content stored in the Append-Only Storage
 *					   Block.
 * rowCount		- number of rows stored in the content.
 */</comment>
<function><type><name>void</name></type>
<name>AppendOnlyStorageWrite_Content</name><parameter_list>(<parameter><decl><type><name>AppendOnlyStorageWrite</name> <modifier>*</modifier></type><name>storageWrite</name></decl></parameter>,
							   <parameter><decl><type><name>uint8</name> <modifier>*</modifier></type><name>content</name></decl></parameter>,
							   <parameter><decl><type><name>int32</name></type> <name>contentLen</name></decl></parameter>,
							   <parameter><decl><type><name>int</name></type> <name>executorBlockKind</name></decl></parameter>,
							   <parameter><decl><type><name>int</name></type> <name>rowCount</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int32</name></type>		<name>completeHeaderLen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>compressedLen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>bufferLen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint8</name>	   <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>storageWrite</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>isActive</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>completeHeaderLen</name> <operator>=</operator>
		<call><name>AppendOnlyStorageWrite_CompleteHeaderLen</name><argument_list>(<argument><expr><name>storageWrite</name></expr></argument>,
												 <argument><expr><name>AoHeaderKind_SmallContent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>contentLen</name> <operator>&lt;=</operator> <name><name>storageWrite</name><operator>-&gt;</operator><name>maxBufferLen</name></name> <operator>-</operator> <name>completeHeaderLen</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * This is "small" content.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>storageWrite</name><operator>-&gt;</operator><name>storageAttributes</name><operator>.</operator><name>compress</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>data</name> <operator>=</operator> <call><name>AppendOnlyStorageWrite_GetBuffer</name><argument_list>(<argument><expr><name>storageWrite</name></expr></argument>,
													<argument><expr><name>AoHeaderKind_SmallContent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>content</name></expr></argument>, <argument><expr><name>contentLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>logicalBlockStartOffset</name></name> <operator>=</operator>
				<call><name>BufferedAppendNextBufferPosition</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>storageWrite</name><operator>-&gt;</operator><name>bufferedAppend</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>AppendOnlyStorageWrite_FinishBuffer</name><argument_list>(<argument><expr><name>storageWrite</name></expr></argument>,
												<argument><expr><name>contentLen</name></expr></argument>,
												<argument><expr><name>executorBlockKind</name></expr></argument>,
												<argument><expr><name>rowCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>currentCompleteHeaderLen</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * Since ~_GetBuffer now takes in a specification of the header
			 * kind, we need to set the header kind so general routines like
			 * ~_CompressAppend will work correctly when writing the small
			 * "fragments
			 */</comment>
			<expr_stmt><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>getBufferAoHeaderKind</name></name> <operator>=</operator> <name>AoHeaderKind_SmallContent</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>AppendOnlyStorageWrite_CompressAppend</name><argument_list>(<argument><expr><name>storageWrite</name></expr></argument>,
												  <argument><expr><name>content</name></expr></argument>,
												  <argument><expr><name>contentLen</name></expr></argument>,
												  <argument><expr><name>executorBlockKind</name></expr></argument>,
												  <argument><expr><name>rowCount</name></expr></argument>,
												  <argument><expr><operator>&amp;</operator><name>compressedLen</name></expr></argument>,
												  <argument><expr><operator>&amp;</operator><name>bufferLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Just before finishing the AO Storage buffer with our
			 * non-compressed content, let's verify it.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>gp_appendonly_verify_write_block</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>AppendOnlyStorageWrite_VerifyWriteBlock</name><argument_list>(<argument><expr><name>storageWrite</name></expr></argument>,
														<argument><expr><call><name>BufferedAppendCurrentBufferPosition</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>storageWrite</name><operator>-&gt;</operator><name>bufferedAppend</name></name></expr></argument>)</argument_list></call></expr></argument>,
														<argument><expr><name>bufferLen</name></expr></argument>,
														<argument><expr><name>content</name></expr></argument>,
														<argument><expr><name>contentLen</name></expr></argument>,
														<argument><expr><name>executorBlockKind</name></expr></argument>,
														<argument><expr><name>rowCount</name></expr></argument>,
														<argument><expr><name>compressedLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>logicalBlockStartOffset</name></name> <operator>=</operator>
				<call><name>BufferedAppendNextBufferPosition</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>storageWrite</name><operator>-&gt;</operator><name>bufferedAppend</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Finish the current buffer by specifying the used length.
			 */</comment>
			<expr_stmt><expr><call><name>BufferedAppendFinishBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>storageWrite</name><operator>-&gt;</operator><name>bufferedAppend</name></name></expr></argument>,
									   <argument><expr><name>bufferLen</name></expr></argument>,
									   <argument><expr><operator>(</operator><name><name>storageWrite</name><operator>-&gt;</operator><name>currentCompleteHeaderLen</name></name> <operator>+</operator>
									       <call><name>AOStorage_RoundUp</name><argument_list>(<argument><expr><name>contentLen</name></expr></argument>, <argument><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>formatVersion</name></name></expr></argument>)</argument_list></call> <comment type="block">/* non-compressed size */</comment> <operator>)</operator></expr></argument>,
									   <argument><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>needsWAL</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Declare it finished. */</comment>
			<expr_stmt><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>currentCompleteHeaderLen</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>int32</name></type>		<name>largeContentHeaderLen</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint8</name>	   <modifier>*</modifier></type><name>largeContentHeader</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int32</name></type>		<name>smallContentHeaderLen</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int32</name></type>		<name>maxSmallContentLen</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int32</name></type>		<name>countdownContentLen</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint8</name>	   <modifier>*</modifier></type><name>contentNext</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int32</name></type>		<name>smallContentLen</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Write the "Large" content in fragments.
		 */</comment>

		<expr_stmt><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>logicalBlockStartOffset</name></name> <operator>=</operator>
			<call><name>BufferedAppendNextBufferPosition</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>storageWrite</name><operator>-&gt;</operator><name>bufferedAppend</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * First is a LargeContent header-only block that has the "large"
		 * content length and "large" row count.
		 */</comment>
		<expr_stmt><expr><name>largeContentHeaderLen</name> <operator>=</operator> <call><name>AppendOnlyStorageWrite_LargeContentHeaderLen</name><argument_list>(<argument><expr><name>storageWrite</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>largeContentHeader</name> <operator>=</operator>
			<call><name>BufferedAppendGetBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>storageWrite</name><operator>-&gt;</operator><name>bufferedAppend</name></name></expr></argument>,
									<argument><expr><name>largeContentHeaderLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>AppendOnlyStorageFormat_MakeLargeContentHeader</name><argument_list>(<argument><expr><name>largeContentHeader</name></expr></argument>,
													   <argument><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>storageAttributes</name><operator>.</operator><name>checksum</name></name></expr></argument>,
													   <argument><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>isFirstRowNumSet</name></name></expr></argument>,
													   <argument><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>formatVersion</name></name></expr></argument>,
													   <argument><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>firstRowNum</name></name></expr></argument>,
													   <argument><expr><name>executorBlockKind</name></expr></argument>,
													   <argument><expr><name>rowCount</name></expr></argument>,
													   <argument><expr><name>contentLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>BufferedAppendFinishBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>storageWrite</name><operator>-&gt;</operator><name>bufferedAppend</name></name></expr></argument>,
								   <argument><expr><name>largeContentHeaderLen</name></expr></argument>,
								   <argument><expr><name>largeContentHeaderLen</name></expr></argument>,
								   <argument><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>needsWAL</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Declare it finished. */</comment>
		<expr_stmt><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>currentCompleteHeaderLen</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

		<comment type="block">/*
		 * Now write the fragments as type Block.
		 */</comment>
		<expr_stmt><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>isFirstRowNumSet</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt> <comment type="block">/* Not written with fragments. */</comment>

		<expr_stmt><expr><name>smallContentHeaderLen</name> <operator>=</operator>
			<call><name>AppendOnlyStorageWrite_CompleteHeaderLen</name><argument_list>(<argument><expr><name>storageWrite</name></expr></argument>,
													 <argument><expr><name>AoHeaderKind_SmallContent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>maxSmallContentLen</name> <operator>=</operator> <name><name>storageWrite</name><operator>-&gt;</operator><name>maxBufferLen</name></name> <operator>-</operator> <name>smallContentHeaderLen</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>countdownContentLen</name> <operator>=</operator> <name>contentLen</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>contentNext</name> <operator>=</operator> <name>content</name></expr>;</expr_stmt>
		<while>while <condition>(<expr><name>true</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>countdownContentLen</name> <operator>&lt;=</operator> <name>maxSmallContentLen</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>smallContentLen</name> <operator>=</operator> <name>countdownContentLen</name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>smallContentLen</name> <operator>=</operator> <name>maxSmallContentLen</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>storageWrite</name><operator>-&gt;</operator><name>storageAttributes</name><operator>.</operator><name>compress</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>data</name> <operator>=</operator> <call><name>AppendOnlyStorageWrite_GetBuffer</name><argument_list>(<argument><expr><name>storageWrite</name></expr></argument>,
														<argument><expr><name>AoHeaderKind_SmallContent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>contentNext</name></expr></argument>, <argument><expr><name>smallContentLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>AppendOnlyStorageWrite_FinishBuffer</name><argument_list>(<argument><expr><name>storageWrite</name></expr></argument>,
													<argument><expr><name>smallContentLen</name></expr></argument>,
													<argument><expr><name>executorBlockKind</name></expr></argument>,
													 <comment type="block">/* rowCount */</comment> <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/*
				 * Since ~_GetBuffer now takes in a specification of the
				 * header kind, we need to set the header kind so general
				 * routines like ~_CompressAppend will work correctly when
				 * writing the small "fragments
				 */</comment>
				<expr_stmt><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>getBufferAoHeaderKind</name></name> <operator>=</operator> <name>AoHeaderKind_SmallContent</name></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>AppendOnlyStorageWrite_CompressAppend</name><argument_list>(<argument><expr><name>storageWrite</name></expr></argument>,
													  <argument><expr><name>contentNext</name></expr></argument>,
													  <argument><expr><name>smallContentLen</name></expr></argument>,
													  <argument><expr><name>executorBlockKind</name></expr></argument>,
													   <comment type="block">/* rowCount */</comment> <argument><expr><literal type="number">0</literal></expr></argument>,
													  <argument><expr><operator>&amp;</operator><name>compressedLen</name></expr></argument>,
													  <argument><expr><operator>&amp;</operator><name>bufferLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * Just before finishing the AO Storage buffer with our
				 * non-compressed content, let's verify it.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>gp_appendonly_verify_write_block</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>AppendOnlyStorageWrite_VerifyWriteBlock</name><argument_list>(<argument><expr><name>storageWrite</name></expr></argument>,
															<argument><expr><call><name>BufferedAppendCurrentBufferPosition</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>storageWrite</name><operator>-&gt;</operator><name>bufferedAppend</name></name></expr></argument>)</argument_list></call></expr></argument>,
															<argument><expr><name>bufferLen</name></expr></argument>,
															<argument><expr><name>contentNext</name></expr></argument>,
															<argument><expr><name>smallContentLen</name></expr></argument>,
															<argument><expr><name>executorBlockKind</name></expr></argument>,
															 <comment type="block">/* rowCount */</comment> <argument><expr><literal type="number">0</literal></expr></argument>,
															<argument><expr><name>compressedLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<comment type="block">/*
				 * Finish the current buffer by specifying the used length.
				 */</comment>
				<expr_stmt><expr><call><name>BufferedAppendFinishBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>storageWrite</name><operator>-&gt;</operator><name>bufferedAppend</name></name></expr></argument>,
										   <argument><expr><name>bufferLen</name></expr></argument>,
										   <argument><expr><operator>(</operator><name>smallContentHeaderLen</name> <operator>+</operator>
										   <call><name>AOStorage_RoundUp</name><argument_list>(<argument><expr><name>smallContentLen</name></expr></argument>, <argument><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>formatVersion</name></name></expr></argument>)</argument_list></call> <comment type="block">/* non-compressed size */</comment> <operator>)</operator></expr></argument>,
										   <argument><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>needsWAL</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* Declare it finished. */</comment>
				<expr_stmt><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>currentCompleteHeaderLen</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<expr_stmt><expr><name>countdownContentLen</name> <operator>-=</operator> <name>smallContentLen</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>countdownContentLen</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>contentNext</name> <operator>+=</operator> <name>smallContentLen</name></expr>;</expr_stmt>
		</block_content>}</block></while>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>isFirstRowNumSet</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/* Verify we have no buffer allocated. */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>currentCompleteHeaderLen</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*----------------------------------------------------------------
 * Optional: Set First Row Number
 *----------------------------------------------------------------
 */</comment>


<comment type="block">/*
 * Normally, the first row of an Append-Only Storage Block is implicit. It
 * is the last row number of the previous block + 1. However, to support
 * BTree indexes that stored TIDs in shared-memory/disk before the
 * transaction commits, we may need to not reuse row numbers of aborted
 * transactions.  So, this routine tells the Append-Only Storage Layer to
 * explicitly keep the first row number. This will take up more header
 * overhead, so the AppendOnlyStorageWrite_HeaderLen routine should be
 * called afterwards to get the new overhead length.
 */</comment>


<comment type="block">/*
 * Set the first row value for the next Append-Only Storage Block to be
 * written.  Only applies to the next block.
 */</comment>
<function><type><name>void</name></type>
<name>AppendOnlyStorageWrite_SetFirstRowNum</name><parameter_list>(<parameter><decl><type><name>AppendOnlyStorageWrite</name> <modifier>*</modifier></type><name>storageWrite</name></decl></parameter>,
									  <parameter><decl><type><name>int64</name></type> <name>firstRowNum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>storageWrite</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>isActive</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* UNDONE: Range check firstRowNum */</comment>

	<expr_stmt><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>isFirstRowNumSet</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>storageWrite</name><operator>-&gt;</operator><name>firstRowNum</name></name> <operator>=</operator> <name>firstRowNum</name></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
