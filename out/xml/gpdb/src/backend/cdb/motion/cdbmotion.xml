<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/backend/cdb/motion/cdbmotion.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * cdbmotion.c
 *		Access into the motion-layer in order to send and receive tuples
 *		within a motion node ID within a particular process group id.
 *
 * Portions Copyright (c) 2005-2008, Greenplum inc
 * Portions Copyright (c) 2012-Present VMware, Inc. or its affiliates.
 *
 *
 * IDENTIFICATION
 *	    src/backend/cdb/motion/cdbmotion.c
 *
 * Reviewers: jzhang, tkordas
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq-fe.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq-int.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbconn.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbmotion.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbvars.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/htupfifo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/ml_ipc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/tupleremap.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/tupser.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/typcache.h"</cpp:file></cpp:include>


<comment type="block">/*
 * MOTION NODE INFO DATA STRUCTURES
 */</comment>
<decl_stmt><decl><type><name>int</name></type>			<name>Gp_max_tuple_chunk_size</name></decl>;</decl_stmt>

<comment type="block">/*
 * STATIC STATE VARS
 *
 * Note, the alignment here isn't quite right.
 * GCC4.0 doesn't like our earlier initializer method of declaration.
 *
 * static TupleChunkListItemData s_eos_chunk_data = {NULL, TUPLE_CHUNK_HEADER_SIZE, NULL, "                "};
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>uint8</name></type> <name><name>s_eos_buffer</name><index>[<expr><sizeof>sizeof<argument_list>(<argument><expr><name>TupleChunkListItemData</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <literal type="number">8</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>TupleChunkListItem</name></type> <name>s_eos_chunk_data</name> <init>= <expr><operator>(</operator><name>TupleChunkListItem</name><operator>)</operator> <name>s_eos_buffer</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * HELPER FUNCTION DECLARATIONS
 */</comment>
<function_decl><type><specifier>static</specifier> <name>MotionNodeEntry</name> <modifier>*</modifier></type><name>getMotionNodeEntry</name><parameter_list>(<parameter><decl><type><name>MotionLayerState</name> <modifier>*</modifier></type><name>mlStates</name></decl></parameter>, <parameter><decl><type><name>int16</name></type> <name>motNodeID</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ChunkSorterEntry</name> <modifier>*</modifier></type><name>getChunkSorterEntry</name><parameter_list>(<parameter><decl><type><name>MotionLayerState</name> <modifier>*</modifier></type><name>mlStates</name></decl></parameter>,
					<parameter><decl><type><name>MotionNodeEntry</name> <modifier>*</modifier></type><name>motNodeEntry</name></decl></parameter>,
					<parameter><decl><type><name>int16</name></type> <name>srcRoute</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>addChunkToSorter</name><parameter_list>(<parameter><decl><type><name>ChunkTransportState</name> <modifier>*</modifier></type><name>transportStates</name></decl></parameter>,
							 <parameter><decl><type><name>MotionNodeEntry</name> <modifier>*</modifier></type><name>pMNEntry</name></decl></parameter>,
							 <parameter><decl><type><name>TupleChunkListItem</name></type> <name>tcItem</name></decl></parameter>,
							 <parameter><decl><type><name>int16</name></type> <name>motNodeID</name></decl></parameter>,
							 <parameter><decl><type><name>ChunkSorterEntry</name> <modifier>*</modifier></type><name>chunkSorterEntry</name></decl></parameter>,
							 <parameter><decl><type><name>ChunkTransportStateEntry</name> <modifier>*</modifier></type><name>pEntry</name></decl></parameter>,
							 <parameter><decl><type><name>MotionConn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>,
							 <parameter><decl><type><name>int16</name></type> <name>srcRoute</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>processIncomingChunks</name><parameter_list>(<parameter><decl><type><name>MotionLayerState</name> <modifier>*</modifier></type><name>mlStates</name></decl></parameter>,
					  <parameter><decl><type><name>ChunkTransportState</name> <modifier>*</modifier></type><name>transportStates</name></decl></parameter>,
					  <parameter><decl><type><name>MotionNodeEntry</name> <modifier>*</modifier></type><name>pMNEntry</name></decl></parameter>,
					  <parameter><decl><type><name>int16</name></type> <name>motNodeID</name></decl></parameter>,
					  <parameter><decl><type><name>int16</name></type> <name>srcRoute</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>reconstructTuple</name><parameter_list>(<parameter><decl><type><name>MotionNodeEntry</name> <modifier>*</modifier></type><name>pMNEntry</name></decl></parameter>, <parameter><decl><type><name>ChunkSorterEntry</name> <modifier>*</modifier></type><name>pCSEntry</name></decl></parameter>, <parameter><decl><type><name>TupleRemapper</name> <modifier>*</modifier></type><name>remapper</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Stats-function declarations. */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>statSendTuple</name><parameter_list>(<parameter><decl><type><name>MotionLayerState</name> <modifier>*</modifier></type><name>mlStates</name></decl></parameter>, <parameter><decl><type><name>MotionNodeEntry</name> <modifier>*</modifier></type><name>pMNEntry</name></decl></parameter>, <parameter><decl><type><name>TupleChunkList</name></type> <name>tcList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>statSendEOS</name><parameter_list>(<parameter><decl><type><name>MotionLayerState</name> <modifier>*</modifier></type><name>mlStates</name></decl></parameter>, <parameter><decl><type><name>MotionNodeEntry</name> <modifier>*</modifier></type><name>pMNEntry</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>statChunksProcessed</name><parameter_list>(<parameter><decl><type><name>MotionLayerState</name> <modifier>*</modifier></type><name>mlStates</name></decl></parameter>, <parameter><decl><type><name>MotionNodeEntry</name> <modifier>*</modifier></type><name>pMNEntry</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>chunksProcessed</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>chunkBytes</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>tupleBytes</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>statNewTupleArrived</name><parameter_list>(<parameter><decl><type><name>MotionNodeEntry</name> <modifier>*</modifier></type><name>pMNEntry</name></decl></parameter>, <parameter><decl><type><name>ChunkSorterEntry</name> <modifier>*</modifier></type><name>pCSEntry</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>statRecvTuple</name><parameter_list>(<parameter><decl><type><name>MotionNodeEntry</name> <modifier>*</modifier></type><name>pMNEntry</name></decl></parameter>, <parameter><decl><type><name>ChunkSorterEntry</name> <modifier>*</modifier></type><name>pCSEntry</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>ShouldSendRecordCache</name><parameter_list>(<parameter><decl><type><name>MotionConn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>SerTupInfo</name> <modifier>*</modifier></type><name>pSerInfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>UpdateSentRecordCache</name><parameter_list>(<parameter><decl><type><name>MotionConn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>;</function_decl>



<comment type="block">/* Helper function to perform the operations necessary to reconstruct a
 * HeapTuple from a list of tuple-chunks, and then update the Motion Layer
 * state appropriately.  This includes storing the tuple, cleaning out the
 * tuple-chunk list, and recording statistics about the newly formed tuple.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>reconstructTuple</name><parameter_list>(<parameter><decl><type><name>MotionNodeEntry</name> <modifier>*</modifier></type><name>pMNEntry</name></decl></parameter>, <parameter><decl><type><name>ChunkSorterEntry</name> <modifier>*</modifier></type><name>pCSEntry</name></decl></parameter>, <parameter><decl><type><name>TupleRemapper</name> <modifier>*</modifier></type><name>remapper</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MinimalTuple</name></type> <name>tup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SerTupInfo</name> <modifier>*</modifier></type><name>pSerInfo</name> <init>= <expr><operator>&amp;</operator><name><name>pMNEntry</name><operator>-&gt;</operator><name>ser_tup_info</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Convert the list of chunks into a tuple, then stow it away.
	 */</comment>
	<expr_stmt><expr><name>tup</name> <operator>=</operator> <call><name>CvtChunksToTup</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pCSEntry</name><operator>-&gt;</operator><name>chunk_list</name></name></expr></argument>, <argument><expr><name>pSerInfo</name></expr></argument>, <argument><expr><name>remapper</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* We're done with the chunks now. */</comment>
	<expr_stmt><expr><call><name>clearTCList</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pCSEntry</name><operator>-&gt;</operator><name>chunk_list</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>tup</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>tup</name> <operator>=</operator> <call><name>TRCheckAndRemap</name><argument_list>(<argument><expr><name>remapper</name></expr></argument>, <argument><expr><name><name>pSerInfo</name><operator>-&gt;</operator><name>tupdesc</name></name></expr></argument>, <argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>htfifo_addtuple</name><argument_list>(<argument><expr><name><name>pCSEntry</name><operator>-&gt;</operator><name>ready_tuples</name></name></expr></argument>, <argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Stats */</comment>
	<expr_stmt><expr><call><name>statNewTupleArrived</name><argument_list>(<argument><expr><name>pMNEntry</name></expr></argument>, <argument><expr><name>pCSEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * FUNCTION DEFINITIONS
 */</comment>

<comment type="block">/*
 * This function deletes the Motion Layer state at the end of a query
 * execution.
 */</comment>
<function><type><name>void</name></type>
<name>RemoveMotionLayer</name><parameter_list>(<parameter><decl><type><name>MotionLayerState</name> <modifier>*</modifier></type><name>mlStates</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>mlStates</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_UTILITY</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AMS_VERBOSE_LOGGING</name></cpp:ifdef>
	<comment type="block">/* Emit statistics to log */</comment>
	<if_stmt><if>if <condition>(<expr><name>gp_log_interconnect</name> <operator>&gt;=</operator> <name>GPVARS_VERBOSITY_VERBOSE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"RemoveMotionLayer(): dumping stats\n"</literal>
			 <literal type="string">"      Sent: %9u chunks %9u total bytes %9u tuple bytes\n"</literal>
			 <literal type="string">"  Received: %9u chunks %9u total bytes %9u tuple bytes; "</literal>
			 <literal type="string">"%9u chunkproc calls\n"</literal></expr></argument>,
			 <argument><expr><name><name>mlStates</name><operator>-&gt;</operator><name>stat_total_chunks_sent</name></name></expr></argument>,
			 <argument><expr><name><name>mlStates</name><operator>-&gt;</operator><name>stat_total_bytes_sent</name></name></expr></argument>,
			 <argument><expr><name><name>mlStates</name><operator>-&gt;</operator><name>stat_tuple_bytes_sent</name></name></expr></argument>,
			 <argument><expr><name><name>mlStates</name><operator>-&gt;</operator><name>stat_total_chunks_recvd</name></name></expr></argument>,
			 <argument><expr><name><name>mlStates</name><operator>-&gt;</operator><name>stat_total_bytes_recvd</name></name></expr></argument>,
			 <argument><expr><name><name>mlStates</name><operator>-&gt;</operator><name>stat_tuple_bytes_recvd</name></name></expr></argument>,
			 <argument><expr><name><name>mlStates</name><operator>-&gt;</operator><name>stat_total_chunkproc_calls</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/*
	 * Free all memory used by the Motion Layer in the processing of this
	 * query.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>mlStates</name><operator>-&gt;</operator><name>motion_layer_mctx</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name><name>mlStates</name><operator>-&gt;</operator><name>motion_layer_mctx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>


<function><type><name>MotionLayerState</name> <modifier>*</modifier></type>
<name>createMotionLayerState</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>maxMotNodeID</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldCtxt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>ml_mctx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint8</name>	   <modifier>*</modifier></type><name>pData</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MotionLayerState</name> <modifier>*</modifier></type><name>mlState</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_UTILITY</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>Gp_interconnect_type</name> <operator>==</operator> <name>INTERCONNECT_TYPE_UDPIFC</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>Gp_max_tuple_chunk_size</name> <operator>=</operator> <name>Gp_max_packet_size</name> <operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr>struct <name>icpkthdr</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <name>TUPLE_CHUNK_HEADER_SIZE</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>Gp_interconnect_type</name> <operator>==</operator> <name>INTERCONNECT_TYPE_TCP</name> <operator>||</operator>
			 <name>Gp_interconnect_type</name> <operator>==</operator> <name>INTERCONNECT_TYPE_PROXY</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>Gp_max_tuple_chunk_size</name> <operator>=</operator> <name>Gp_max_packet_size</name> <operator>-</operator> <name>PACKET_HEADER_SIZE</name> <operator>-</operator> <name>TUPLE_CHUNK_HEADER_SIZE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Use the statically allocated chunk that is intended for sending end-of-
	 * stream messages so that we don't incur allocation and deallocation
	 * overheads.
	 */</comment>
	<expr_stmt><expr><name><name>s_eos_chunk_data</name><operator>-&gt;</operator><name>p_next</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>s_eos_chunk_data</name><operator>-&gt;</operator><name>inplace</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>s_eos_chunk_data</name><operator>-&gt;</operator><name>chunk_length</name></name> <operator>=</operator> <name>TUPLE_CHUNK_HEADER_SIZE</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>pData</name> <operator>=</operator> <name><name>s_eos_chunk_data</name><operator>-&gt;</operator><name>chunk_data</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>SetChunkDataSize</name><argument_list>(<argument><expr><name>pData</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SetChunkType</name><argument_list>(<argument><expr><name>pData</name></expr></argument>, <argument><expr><name>TC_END_OF_STREAM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Create the memory-contexts that we will use within the Motion Layer.
	 *
	 * We make the Motion Layer memory-context a child of the ExecutorState
	 * Context, as it lives inside of the estate of a specific query and needs
	 * to get freed when the query is finished.
	 *
	 * The tuple-serial memory-context is a child of the Motion Layer
	 * memory-context
	 *
	 * NOTE: we need to be sure the caller is in ExecutorState memory context
	 * (estate-&gt;es_query_cxt) before calling us .
	 */</comment>
	<expr_stmt><expr><name>ml_mctx</name> <operator>=</operator>
		<call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>, <argument><expr><literal type="string">"MotionLayerMemCtxt"</literal></expr></argument>,
							  <argument><expr><name>ALLOCSET_SMALL_MINSIZE</name></expr></argument>,
							  <argument><expr><name>ALLOCSET_SMALL_INITSIZE</name></expr></argument>,
							  <argument><expr><name>ALLOCSET_DEFAULT_MAXSIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* use a setting bigger
															 * than "small" */</comment>

	<comment type="block">/*
	 * Switch to the Motion Layer memory context, so that we can clean things
	 * up easily.
	 */</comment>
	<expr_stmt><expr><name>oldCtxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>ml_mctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>mlState</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>MotionLayerState</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>mlState</name><operator>-&gt;</operator><name>mnEntries</name></name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>maxMotNodeID</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>MotionNodeEntry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>mlState</name><operator>-&gt;</operator><name>mneCount</name></name> <operator>=</operator> <name>maxMotNodeID</name></expr>;</expr_stmt>

	<for>for <control>(<init><decl><type><name>int</name></type> <name>motNodeID</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</init> <condition><expr><name>motNodeID</name> <operator>&lt;=</operator> <name>maxMotNodeID</name></expr>;</condition> <incr><expr><name>motNodeID</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MotionNodeEntry</name> <modifier>*</modifier></type><name>pEntry</name> <init>= <expr><operator>&amp;</operator><name><name>mlState</name><operator>-&gt;</operator><name>mnEntries</name><index>[<expr><name>motNodeID</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>pEntry</name><operator>-&gt;</operator><name>motion_node_id</name></name> <operator>=</operator> <name>motNodeID</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pEntry</name><operator>-&gt;</operator><name>valid</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * we'll just set this to 0.  later, ml_ipc will call
		 * setExpectedReceivers() to set this if we are a "Receiving" motion node.
		 */</comment>
		<expr_stmt><expr><name><name>pEntry</name><operator>-&gt;</operator><name>num_senders</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Allocation is done.	Go back to caller memory-context. */</comment>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldCtxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Keep our motion layer memory context in our newly created motion layer.
	 */</comment>
	<expr_stmt><expr><name><name>mlState</name><operator>-&gt;</operator><name>motion_layer_mctx</name></name> <operator>=</operator> <name>ml_mctx</name></expr>;</expr_stmt>

	<return>return <expr><name>mlState</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Initialize a single motion node.  This is called by the executor when a
 * motion node in the plan tree is being initialized.
 *
 * This function is called from:  ExecInitMotion()
 */</comment>
<function><type><name>void</name></type>
<name>UpdateMotionLayerNode</name><parameter_list>(<parameter><decl><type><name>MotionLayerState</name> <modifier>*</modifier></type><name>mlStates</name></decl></parameter>, <parameter><decl><type><name>int16</name></type> <name>motNodeID</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>preserveOrder</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type> <name>tupDesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldCtxt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MotionNodeEntry</name> <modifier>*</modifier></type><name>pEntry</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>motNodeID</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">1</literal> <operator>||</operator> <name>motNodeID</name></expr></argument> &gt;</argument_list></name> <name><name>mlStates</name><operator>-&gt;</operator><name>mneCount</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid motion node ID %d"</literal></expr></argument>, <argument><expr><name>motNodeID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><name>tupDesc</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Switch to the Motion Layer's memory-context, so that the motion node
	 * can be reset later.
	 */</comment>
	<expr_stmt><expr><name>oldCtxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>mlStates</name><operator>-&gt;</operator><name>motion_layer_mctx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>pEntry</name> <operator>=</operator> <operator>&amp;</operator><name><name>mlStates</name><operator>-&gt;</operator><name>mnEntries</name><index>[<expr><name>motNodeID</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>pEntry</name><operator>-&gt;</operator><name>valid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>pEntry</name><operator>-&gt;</operator><name>motion_node_id</name></name> <operator>=</operator> <name>motNodeID</name></expr>;</expr_stmt>

	<comment type="block">/* Finish up initialization of the motion node entry. */</comment>
	<expr_stmt><expr><name><name>pEntry</name><operator>-&gt;</operator><name>preserve_order</name></name> <operator>=</operator> <name>preserveOrder</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pEntry</name><operator>-&gt;</operator><name>tuple_desc</name></name> <operator>=</operator> <call><name>CreateTupleDescCopy</name><argument_list>(<argument><expr><name>tupDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>InitSerTupInfo</name><argument_list>(<argument><expr><name><name>pEntry</name><operator>-&gt;</operator><name>tuple_desc</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pEntry</name><operator>-&gt;</operator><name>ser_tup_info</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>preserveOrder</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Create a tuple-store for the motion node's incoming tuples. */</comment>
		<expr_stmt><expr><name><name>pEntry</name><operator>-&gt;</operator><name>ready_tuples</name></name> <operator>=</operator> <call><name>htfifo_create</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>pEntry</name><operator>-&gt;</operator><name>ready_tuples</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>


	<expr_stmt><expr><name><name>pEntry</name><operator>-&gt;</operator><name>num_stream_ends_recvd</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/* Initialize statistics counters. */</comment>
	<expr_stmt><expr><name><name>pEntry</name><operator>-&gt;</operator><name>stat_total_chunks_sent</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pEntry</name><operator>-&gt;</operator><name>stat_total_bytes_sent</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pEntry</name><operator>-&gt;</operator><name>stat_tuple_bytes_sent</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pEntry</name><operator>-&gt;</operator><name>stat_total_sends</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pEntry</name><operator>-&gt;</operator><name>stat_total_recvs</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pEntry</name><operator>-&gt;</operator><name>stat_tuples_available</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pEntry</name><operator>-&gt;</operator><name>stat_tuples_available_hwm</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pEntry</name><operator>-&gt;</operator><name>stat_total_chunks_recvd</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pEntry</name><operator>-&gt;</operator><name>stat_total_bytes_recvd</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pEntry</name><operator>-&gt;</operator><name>stat_tuple_bytes_recvd</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>pEntry</name><operator>-&gt;</operator><name>cleanedUp</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pEntry</name><operator>-&gt;</operator><name>stopped</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pEntry</name><operator>-&gt;</operator><name>moreNetWork</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>


	<comment type="block">/* All done!  Go back to caller memory-context. */</comment>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldCtxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>UpdateMotionExpectedReceivers</name><parameter_list>(<parameter><decl><type><name>MotionLayerState</name> <modifier>*</modifier></type><name>mlStates</name></decl></parameter>, <parameter><decl><type><name>SliceTable</name> <modifier>*</modifier></type><name>sliceTable</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ExecSlice</name>  <modifier>*</modifier></type><name>mySlice</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExecSlice</name>  <modifier>*</modifier></type><name>aSlice</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CdbProcess</name> <modifier>*</modifier></type><name>cdbProc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MotionNodeEntry</name> <modifier>*</modifier></type><name>pEntry</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>mySlice</name> <operator>=</operator> <operator>&amp;</operator><name><name>sliceTable</name><operator>-&gt;</operator><name>slices</name><index>[<expr><name><name>sliceTable</name><operator>-&gt;</operator><name>localSlice</name></name></expr>]</index></name></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>mySlice-&gt;children</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>totalNumProcs</name></decl>, <decl><type ref="prev"/><name>activeNumProcs</name></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>childId</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>aSlice</name> <operator>=</operator> <operator>&amp;</operator><name><name>sliceTable</name><operator>-&gt;</operator><name>slices</name><index>[<expr><name>childId</name></expr>]</index></name></expr>;</expr_stmt>

		<comment type="block">/*
		 * If we're using directed-dispatch we have dummy primary-process
		 * entries, so we count the entries.
		 */</comment>
		<expr_stmt><expr><name>activeNumProcs</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>totalNumProcs</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>aSlice</name><operator>-&gt;</operator><name>primaryProcesses</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>totalNumProcs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name>cdbProc</name> <operator>=</operator> <call><name>list_nth</name><argument_list>(<argument><expr><name><name>aSlice</name><operator>-&gt;</operator><name>primaryProcesses</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>cdbProc</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>activeNumProcs</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></for>

		<expr_stmt><expr><name>pEntry</name> <operator>=</operator> <call><name>getMotionNodeEntry</name><argument_list>(<argument><expr><name>mlStates</name></expr></argument>, <argument><expr><name>childId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pEntry</name><operator>-&gt;</operator><name>num_senders</name></name> <operator>=</operator> <name>activeNumProcs</name></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>SendStopMessage</name><parameter_list>(<parameter><decl><type><name>MotionLayerState</name> <modifier>*</modifier></type><name>mlStates</name></decl></parameter>,
				<parameter><decl><type><name>ChunkTransportState</name> <modifier>*</modifier></type><name>transportStates</name></decl></parameter>,
				<parameter><decl><type><name>int16</name></type> <name>motNodeID</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MotionNodeEntry</name> <modifier>*</modifier></type><name>pEntry</name> <init>= <expr><call><name>getMotionNodeEntry</name><argument_list>(<argument><expr><name>mlStates</name></expr></argument>, <argument><expr><name>motNodeID</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>pEntry</name><operator>-&gt;</operator><name>stopped</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>transportStates</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>transportStates</name><operator>-&gt;</operator><name>doSendStopMessage</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name><name>transportStates</name><operator>-&gt;</operator><name>doSendStopMessage</name></name><argument_list>(<argument><expr><name>transportStates</name></expr></argument>, <argument><expr><name>motNodeID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>CheckAndSendRecordCache</name><parameter_list>(<parameter><decl><type><name>MotionLayerState</name> <modifier>*</modifier></type><name>mlStates</name></decl></parameter>,
						<parameter><decl><type><name>ChunkTransportState</name> <modifier>*</modifier></type><name>transportStates</name></decl></parameter>,
						<parameter><decl><type><name>int16</name></type> <name>motNodeID</name></decl></parameter>,
						<parameter><decl><type><name>int16</name></type> <name>targetRoute</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MotionNodeEntry</name> <modifier>*</modifier></type><name>pMNEntry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleChunkListData</name></type> <name>tcList</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldCtxt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ChunkTransportStateEntry</name> <modifier>*</modifier></type><name>pEntry</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MotionConn</name> <modifier>*</modifier></type><name>conn</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>getChunkTransportState</name><argument_list>(<argument><expr><name>transportStates</name></expr></argument>, <argument><expr><name>motNodeID</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * for broadcast we only mark sent_record_typmod for connection 0 for
	 * efficiency and convenience
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>targetRoute</name> <operator>==</operator> <name>BROADCAST_SEGIDX</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>conn</name> <operator>=</operator> <operator>&amp;</operator><name><name>pEntry</name><operator>-&gt;</operator><name>conns</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>conn</name> <operator>=</operator> <operator>&amp;</operator><name><name>pEntry</name><operator>-&gt;</operator><name>conns</name><index>[<expr><name>targetRoute</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * Analyze tools.  Do not send any thing if this slice is in the bit mask
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>gp_motion_slice_noop</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>gp_motion_slice_noop</name> <operator>&amp;</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>currentSliceId</name><operator>)</operator><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Pull up the motion node entry with the node's details.  This includes
	 * details that affect sending, such as whether the motion node needs to
	 * include backup segment-dbs.
	 */</comment>
	<expr_stmt><expr><name>pMNEntry</name> <operator>=</operator> <call><name>getMotionNodeEntry</name><argument_list>(<argument><expr><name>mlStates</name></expr></argument>, <argument><expr><name>motNodeID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ShouldSendRecordCache</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pMNEntry</name><operator>-&gt;</operator><name>ser_tup_info</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AMS_VERBOSE_LOGGING</name></cpp:ifdef>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG5</name></expr></argument>, <argument><expr><literal type="string">"Serializing RecordCache for sending."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/* Create and store the serialized form, and some stats about it. */</comment>
	<expr_stmt><expr><name>oldCtxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>mlStates</name><operator>-&gt;</operator><name>motion_layer_mctx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>SerializeRecordCacheIntoChunks</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pMNEntry</name><operator>-&gt;</operator><name>ser_tup_info</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tcList</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldCtxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AMS_VERBOSE_LOGGING</name></cpp:ifdef>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG5</name></expr></argument>, <argument><expr><literal type="string">"Serialized RecordCache for sending:\n"</literal>
		 <literal type="string">"\ttarget-route %d \n"</literal>
		 <literal type="string">"\t%d bytes in serial form\n"</literal>
		 <literal type="string">"\tbroken into %d chunks"</literal></expr></argument>,
		 <argument><expr><name>targetRoute</name></expr></argument>,
		 <argument><expr><name><name>tcList</name><operator>.</operator><name>serialized_data_length</name></name></expr></argument>,
		 <argument><expr><name><name>tcList</name><operator>.</operator><name>num_chunks</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/* do the send. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SendTupleChunkToAMS</name><argument_list>(<argument><expr><name>mlStates</name></expr></argument>, <argument><expr><name>transportStates</name></expr></argument>, <argument><expr><name>motNodeID</name></expr></argument>, <argument><expr><name>targetRoute</name></expr></argument>, <argument><expr><name><name>tcList</name><operator>.</operator><name>p_first</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>pMNEntry</name><operator>-&gt;</operator><name>stopped</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* update stats */</comment>
		<expr_stmt><expr><call><name>statSendTuple</name><argument_list>(<argument><expr><name>mlStates</name></expr></argument>, <argument><expr><name>pMNEntry</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tcList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* cleanup */</comment>
	<expr_stmt><expr><call><name>clearTCList</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pMNEntry</name><operator>-&gt;</operator><name>ser_tup_info</name><operator>.</operator><name>chunkCache</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tcList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>UpdateSentRecordCache</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Function:  SendTuple - Sends a portion or whole tuple to the AMS layer.
 */</comment>
<function><type><name>SendReturnCode</name></type>
<name>SendTuple</name><parameter_list>(<parameter><decl><type><name>MotionLayerState</name> <modifier>*</modifier></type><name>mlStates</name></decl></parameter>,
		  <parameter><decl><type><name>ChunkTransportState</name> <modifier>*</modifier></type><name>transportStates</name></decl></parameter>,
		  <parameter><decl><type><name>int16</name></type> <name>motNodeID</name></decl></parameter>,
		  <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>,
		  <parameter><decl><type><name>int16</name></type> <name>targetRoute</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MotionNodeEntry</name> <modifier>*</modifier></type><name>pMNEntry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleChunkListData</name></type> <name>tcList</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldCtxt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SendReturnCode</name></type> <name>rc</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><operator>!</operator><call><name>TupIsNull</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Analyze tools.  Do not send any thing if this slice is in the bit mask
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>gp_motion_slice_noop</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>gp_motion_slice_noop</name> <operator>&amp;</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>currentSliceId</name><operator>)</operator><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>SEND_COMPLETE</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Pull up the motion node entry with the node's details.  This includes
	 * details that affect sending, such as whether the motion node needs to
	 * include backup segment-dbs.
	 */</comment>
	<expr_stmt><expr><name>pMNEntry</name> <operator>=</operator> <call><name>getMotionNodeEntry</name><argument_list>(<argument><expr><name>mlStates</name></expr></argument>, <argument><expr><name>motNodeID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AMS_VERBOSE_LOGGING</name></cpp:ifdef>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG5</name></expr></argument>, <argument><expr><literal type="string">"Serializing HeapTuple for sending."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<decl_stmt><decl><type><name><name>struct</name> <name>directTransportBuffer</name></name></type> <name>b</name></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>targetRoute</name> <operator>!=</operator> <name>BROADCAST_SEGIDX</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>getTransportDirectBuffer</name><argument_list>(<argument><expr><name>transportStates</name></expr></argument>, <argument><expr><name>motNodeID</name></expr></argument>, <argument><expr><name>targetRoute</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<decl_stmt><decl><type><name>int</name></type>			<name>sent</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Create and store the serialized form, and some stats about it. */</comment>
	<expr_stmt><expr><name>oldCtxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>mlStates</name><operator>-&gt;</operator><name>motion_layer_mctx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>sent</name> <operator>=</operator> <call><name>SerializeTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pMNEntry</name><operator>-&gt;</operator><name>ser_tup_info</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>b</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tcList</name></expr></argument>, <argument><expr><name>targetRoute</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldCtxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>sent</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>putTransportDirectBuffer</name><argument_list>(<argument><expr><name>transportStates</name></expr></argument>, <argument><expr><name>motNodeID</name></expr></argument>, <argument><expr><name>targetRoute</name></expr></argument>, <argument><expr><name>sent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* fill-in tcList fields to update stats */</comment>
		<expr_stmt><expr><name><name>tcList</name><operator>.</operator><name>num_chunks</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tcList</name><operator>.</operator><name>serialized_data_length</name></name> <operator>=</operator> <name>sent</name></expr>;</expr_stmt>

		<comment type="block">/* update stats */</comment>
		<expr_stmt><expr><call><name>statSendTuple</name><argument_list>(<argument><expr><name>mlStates</name></expr></argument>, <argument><expr><name>pMNEntry</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tcList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return <expr><name>SEND_COMPLETE</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Otherwise fall-through */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AMS_VERBOSE_LOGGING</name></cpp:ifdef>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG5</name></expr></argument>, <argument><expr><literal type="string">"Serialized HeapTuple for sending:\n"</literal>
		 <literal type="string">"\ttarget-route %d \n"</literal>
		 <literal type="string">"\t%d bytes in serial form\n"</literal>
		 <literal type="string">"\tbroken into %d chunks"</literal></expr></argument>,
		 <argument><expr><name>targetRoute</name></expr></argument>,
		 <argument><expr><name><name>tcList</name><operator>.</operator><name>serialized_data_length</name></name></expr></argument>,
		 <argument><expr><name><name>tcList</name><operator>.</operator><name>num_chunks</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/* do the send. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SendTupleChunkToAMS</name><argument_list>(<argument><expr><name>mlStates</name></expr></argument>, <argument><expr><name>transportStates</name></expr></argument>, <argument><expr><name>motNodeID</name></expr></argument>, <argument><expr><name>targetRoute</name></expr></argument>, <argument><expr><name><name>tcList</name><operator>.</operator><name>p_first</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>pMNEntry</name><operator>-&gt;</operator><name>stopped</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <name>STOP_SENDING</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* update stats */</comment>
		<expr_stmt><expr><call><name>statSendTuple</name><argument_list>(<argument><expr><name>mlStates</name></expr></argument>, <argument><expr><name>pMNEntry</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tcList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SEND_COMPLETE</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* cleanup */</comment>
	<expr_stmt><expr><call><name>clearTCList</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pMNEntry</name><operator>-&gt;</operator><name>ser_tup_info</name><operator>.</operator><name>chunkCache</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tcList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>TupleChunkListItem</name></type>
<name>get_eos_tuplechunklist</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name>s_eos_chunk_data</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Sends a token to all peer Motion Nodes, indicating that this motion
 * node has no more tuples to send out.
 */</comment>
<function><type><name>void</name></type>
<name>SendEndOfStream</name><parameter_list>(<parameter><decl><type><name>MotionLayerState</name> <modifier>*</modifier></type><name>mlStates</name></decl></parameter>,
				<parameter><decl><type><name>ChunkTransportState</name> <modifier>*</modifier></type><name>transportStates</name></decl></parameter>,
				<parameter><decl><type><name>int</name></type> <name>motNodeID</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MotionNodeEntry</name> <modifier>*</modifier></type><name>pMNEntry</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Pull up the motion node entry with the node's details.  This includes
	 * details that affect sending, such as whether the motion node needs to
	 * include backup segment-dbs.
	 */</comment>
	<expr_stmt><expr><name>pMNEntry</name> <operator>=</operator> <call><name>getMotionNodeEntry</name><argument_list>(<argument><expr><name>mlStates</name></expr></argument>, <argument><expr><name>motNodeID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name><name>transportStates</name><operator>-&gt;</operator><name>SendEos</name></name><argument_list>(<argument><expr><name>transportStates</name></expr></argument>, <argument><expr><name>motNodeID</name></expr></argument>, <argument><expr><name>s_eos_chunk_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We increment our own "stream-ends received" count when we send our own,
	 * as well as when we receive one.
	 */</comment>
	<expr_stmt><expr><name><name>pMNEntry</name><operator>-&gt;</operator><name>num_stream_ends_recvd</name></name><operator>++</operator></expr>;</expr_stmt>

	<comment type="block">/* We record EOS as if a tuple were sent. */</comment>
	<expr_stmt><expr><call><name>statSendEOS</name><argument_list>(<argument><expr><name>mlStates</name></expr></argument>, <argument><expr><name>pMNEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Receive one tuple from a sender. An unordered receiver will call this with
 * srcRoute == ANY_ROUTE.
 *
 * The tuple is stored in *slot.
 */</comment>
<function><type><name>MinimalTuple</name></type>
<name>RecvTupleFrom</name><parameter_list>(<parameter><decl><type><name>MotionLayerState</name> <modifier>*</modifier></type><name>mlStates</name></decl></parameter>,
			  <parameter><decl><type><name>ChunkTransportState</name> <modifier>*</modifier></type><name>transportStates</name></decl></parameter>,
			  <parameter><decl><type><name>int16</name></type> <name>motNodeID</name></decl></parameter>,
			  <parameter><decl><type><name>int16</name></type> <name>srcRoute</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MotionNodeEntry</name> <modifier>*</modifier></type><name>pMNEntry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ChunkSorterEntry</name> <modifier>*</modifier></type><name>pCSEntry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>htup_fifo</name></type>	<name>ReadyList</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MinimalTuple</name></type> <name>tuple</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AMS_VERBOSE_LOGGING</name></cpp:ifdef>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG5</name></expr></argument>, <argument><expr><literal type="string">"RecvTupleFrom( motNodeID = %d, srcRoute = %d )"</literal></expr></argument>, <argument><expr><name>motNodeID</name></expr></argument>, <argument><expr><name>srcRoute</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><name>pMNEntry</name> <operator>=</operator> <call><name>getMotionNodeEntry</name><argument_list>(<argument><expr><name>mlStates</name></expr></argument>, <argument><expr><name>motNodeID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>srcRoute</name> <operator>==</operator> <name>ANY_ROUTE</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>pMNEntry</name><operator>-&gt;</operator><name>preserve_order</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>pCSEntry</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>ReadyList</name> <operator>=</operator> <name><name>pMNEntry</name><operator>-&gt;</operator><name>ready_tuples</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>pMNEntry</name><operator>-&gt;</operator><name>preserve_order</name></name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Pull up the chunk-sorter entry for the specified sender, and get
		 * the tuple-store we should use.
		 */</comment>
		<expr_stmt><expr><name>pCSEntry</name> <operator>=</operator> <call><name>getChunkSorterEntry</name><argument_list>(<argument><expr><name>mlStates</name></expr></argument>, <argument><expr><name>pMNEntry</name></expr></argument>, <argument><expr><name>srcRoute</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>ReadyList</name> <operator>=</operator> <name><name>pCSEntry</name><operator>-&gt;</operator><name>ready_tuples</name></name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<comment type="block">/* Get the next tuple from the FIFO, if one is available. */</comment>
		<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>htfifo_gettuple</name><argument_list>(<argument><expr><name>ReadyList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>tuple</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * We need to get more chunks before we have a full tuple to return. Loop
		 * until we get one, or we reach end-of-stream.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>srcRoute</name> <operator>==</operator> <name>ANY_ROUTE</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>pMNEntry</name><operator>-&gt;</operator><name>moreNetWork</name></name><operator>)</operator> <operator>||</operator>
			<operator>(</operator><name>srcRoute</name> <operator>!=</operator> <name>ANY_ROUTE</name> <operator>&amp;&amp;</operator> <name><name>pCSEntry</name><operator>-&gt;</operator><name>end_of_stream</name></name><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * No tuple was available (tuple-store was at EOF), and
			 * end-of-stream has been marked.  No more tuples are going to
			 * show up.
			 */</comment>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>processIncomingChunks</name><argument_list>(<argument><expr><name>mlStates</name></expr></argument>, <argument><expr><name>transportStates</name></expr></argument>, <argument><expr><name>pMNEntry</name></expr></argument>, <argument><expr><name>motNodeID</name></expr></argument>, <argument><expr><name>srcRoute</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Stats */</comment>
	<if_stmt><if>if <condition>(<expr><name>tuple</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>statRecvTuple</name><argument_list>(<argument><expr><name>pMNEntry</name></expr></argument>, <argument><expr><name>pCSEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>tuple</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * This helper function is the receive-tuple workhorse.  It pulls
 * tuple chunks from the AMS, and pushes them to the chunk-sorter
 * where they can be sorted based on sender, and reconstituted into
 * whole HeapTuples.  Functions like RecvTuple() and RecvTupleFrom()
 * should definitely call this before trying to get a HeapTuple to
 * return.  It can also be called during other operations if that
 * seems like a good idea.  For example, it can be called sometime
 * during send-tuple operations as well.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>processIncomingChunks</name><parameter_list>(<parameter><decl><type><name>MotionLayerState</name> <modifier>*</modifier></type><name>mlStates</name></decl></parameter>,
					  <parameter><decl><type><name>ChunkTransportState</name> <modifier>*</modifier></type><name>transportStates</name></decl></parameter>,
					  <parameter><decl><type><name>MotionNodeEntry</name> <modifier>*</modifier></type><name>pMNEntry</name></decl></parameter>,
					  <parameter><decl><type><name>int16</name></type> <name>motNodeID</name></decl></parameter>,
					  <parameter><decl><type><name>int16</name></type> <name>srcRoute</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TupleChunkListItem</name></type> <name>tcItem</name></decl>,
				<decl><type ref="prev"/><name>tcNext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldCtxt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ChunkSorterEntry</name> <modifier>*</modifier></type><name>chunkSorterEntry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ChunkTransportStateEntry</name> <modifier>*</modifier></type><name>pEntry</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MotionConn</name> <modifier>*</modifier></type><name>conn</name></decl>;</decl_stmt>

	<comment type="block">/* Keep track of processed chunk stats. */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>numChunks</name></decl>,
				<decl><type ref="prev"/><name>chunkBytes</name></decl>,
				<decl><type ref="prev"/><name>tupleBytes</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>oldCtxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>mlStates</name><operator>-&gt;</operator><name>motion_layer_mctx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Get all of the currently available tuple-chunks, and push each one into
	 * the chunk-sorter.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>srcRoute</name> <operator>==</operator> <name>ANY_ROUTE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>tcItem</name> <operator>=</operator> <call><name><name>transportStates</name><operator>-&gt;</operator><name>RecvTupleChunkFromAny</name></name><argument_list>(<argument><expr><name>transportStates</name></expr></argument>, <argument><expr><name>motNodeID</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>srcRoute</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>tcItem</name> <operator>=</operator> <call><name><name>transportStates</name><operator>-&gt;</operator><name>RecvTupleChunkFrom</name></name><argument_list>(<argument><expr><name>transportStates</name></expr></argument>, <argument><expr><name>motNodeID</name></expr></argument>, <argument><expr><name>srcRoute</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* Look up various things related to the sender that we received chunks from. */</comment>
	<expr_stmt><expr><name>chunkSorterEntry</name> <operator>=</operator> <call><name>getChunkSorterEntry</name><argument_list>(<argument><expr><name>mlStates</name></expr></argument>, <argument><expr><name>pMNEntry</name></expr></argument>, <argument><expr><name>srcRoute</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>getChunkTransportState</name><argument_list>(<argument><expr><name>transportStates</name></expr></argument>, <argument><expr><name>motNodeID</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>conn</name> <operator>=</operator> <name><name>pEntry</name><operator>-&gt;</operator><name>conns</name></name> <operator>+</operator> <name>srcRoute</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>numChunks</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>chunkBytes</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>tupleBytes</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<while>while <condition>(<expr><name>tcItem</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>numChunks</name><operator>++</operator></expr>;</expr_stmt>

		<comment type="block">/* Detach the current chunk off of the front of the list. */</comment>
		<expr_stmt><expr><name>tcNext</name> <operator>=</operator> <name><name>tcItem</name><operator>-&gt;</operator><name>p_next</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tcItem</name><operator>-&gt;</operator><name>p_next</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

		<comment type="block">/* Track stats. */</comment>
		<expr_stmt><expr><name>chunkBytes</name> <operator>+=</operator> <name><name>tcItem</name><operator>-&gt;</operator><name>chunk_length</name></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>tcItem</name><operator>-&gt;</operator><name>chunk_length</name></name> <operator>&gt;=</operator> <name>TUPLE_CHUNK_HEADER_SIZE</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>tupleBytes</name> <operator>+=</operator> <name><name>tcItem</name><operator>-&gt;</operator><name>chunk_length</name></name> <operator>-</operator> <name>TUPLE_CHUNK_HEADER_SIZE</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Received tuple-chunk of size %u; smaller than"</literal>
				 <literal type="string">" chunk header size %d!"</literal></expr></argument>, <argument><expr><name><name>tcItem</name><operator>-&gt;</operator><name>chunk_length</name></name></expr></argument>,
				 <argument><expr><name>TUPLE_CHUNK_HEADER_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/* Stick the chunk into the sorter. */</comment>
		<expr_stmt><expr><call><name>addChunkToSorter</name><argument_list>(<argument><expr><name>transportStates</name></expr></argument>,
						 <argument><expr><name>pMNEntry</name></expr></argument>,
						 <argument><expr><name>tcItem</name></expr></argument>,
						 <argument><expr><name>motNodeID</name></expr></argument>,
						 <argument><expr><name>chunkSorterEntry</name></expr></argument>,
						 <argument><expr><name>pEntry</name></expr></argument>,
						 <argument><expr><name>conn</name></expr></argument>,
						 <argument><expr><name>srcRoute</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>tcItem</name> <operator>=</operator> <name>tcNext</name></expr>;</expr_stmt>
	</block_content>}</block></while>

	<comment type="block">/* The chunk list we just processed freed-up our rx-buffer space. */</comment>
	<if_stmt><if>if <condition>(<expr><name>numChunks</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>Gp_interconnect_type</name> <operator>==</operator> <name>INTERCONNECT_TYPE_UDPIFC</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>MlPutRxBufferIFC</name><argument_list>(<argument><expr><name>transportStates</name></expr></argument>, <argument><expr><name>motNodeID</name></expr></argument>, <argument><expr><name>srcRoute</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Stats */</comment>
	<expr_stmt><expr><call><name>statChunksProcessed</name><argument_list>(<argument><expr><name>mlStates</name></expr></argument>, <argument><expr><name>pMNEntry</name></expr></argument>, <argument><expr><name>numChunks</name></expr></argument>, <argument><expr><name>chunkBytes</name></expr></argument>, <argument><expr><name>tupleBytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldCtxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>EndMotionLayerNode</name><parameter_list>(<parameter><decl><type><name>MotionLayerState</name> <modifier>*</modifier></type><name>mlStates</name></decl></parameter>, <parameter><decl><type><name>int16</name></type> <name>motNodeID</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>flushCommLayer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MotionNodeEntry</name> <modifier>*</modifier></type><name>pMNEntry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ChunkSorterEntry</name> <modifier>*</modifier></type><name>pCSEntry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>pMNEntry</name> <operator>=</operator> <call><name>getMotionNodeEntry</name><argument_list>(<argument><expr><name>mlStates</name></expr></argument>, <argument><expr><name>motNodeID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AMS_VERBOSE_LOGGING</name></cpp:ifdef>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG5</name></expr></argument>, <argument><expr><literal type="string">"Cleaning up Motion Layer details for motion node %d."</literal></expr></argument>,
		 <argument><expr><name>motNodeID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/*
	 * Iterate through all entries in the motion layer's chunk-sort map, to
	 * see if we have gotten end-of-stream from all senders.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>pMNEntry</name><operator>-&gt;</operator><name>preserve_order</name></name> <operator>&amp;&amp;</operator> <name><name>pMNEntry</name><operator>-&gt;</operator><name>ready_tuple_lists</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>pMNEntry</name><operator>-&gt;</operator><name>num_senders</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name>pCSEntry</name> <operator>=</operator> <operator>&amp;</operator><name><name>pMNEntry</name><operator>-&gt;</operator><name>ready_tuple_lists</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

			<comment type="block">/*
			 * QD should not expect end-of-stream comes from QEs who is not
			 * members of direct dispatch
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>pCSEntry</name><operator>-&gt;</operator><name>init</name></name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>pMNEntry</name><operator>-&gt;</operator><name>preserve_order</name></name> <operator>&amp;&amp;</operator>
				<name>gp_log_interconnect</name> <operator>&gt;=</operator> <name>GPVARS_VERBOSITY_DEBUG</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Print chunk-sorter entry statistics. */</comment>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG4</name></expr></argument>, <argument><expr><literal type="string">"Chunk-sorter entry [route=%d,node=%d] statistics:\n"</literal>
					 <literal type="string">"\tAvailable Tuples High-Watermark: "</literal> <name>UINT64_FORMAT</name></expr></argument>,
					 <argument><expr><name>i</name></expr></argument>, <argument><expr><name><name>pMNEntry</name><operator>-&gt;</operator><name>motion_node_id</name></name></expr></argument>,
					 <argument><expr><name><name>pMNEntry</name><operator>-&gt;</operator><name>stat_tuples_available_hwm</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>pMNEntry</name><operator>-&gt;</operator><name>stopped</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>pCSEntry</name><operator>-&gt;</operator><name>end_of_stream</name></name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>flushCommLayer</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"Motion layer node %d cleanup - did not receive"</literal>
						 <literal type="string">" end-of-stream from sender %d."</literal></expr></argument>, <argument><expr><name>motNodeID</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block" format="doxygen">/*** TODO - get chunks until end-of-stream comes in. ***/</comment>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Motion layer node %d cleanup - did not receive"</literal>
						 <literal type="string">" end-of-stream from sender %d."</literal></expr></argument>, <argument><expr><name>motNodeID</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* End-of-stream is marked for this entry. */</comment>

				<comment type="block" format="doxygen">/*** TODO - do more than just complain! ***/</comment>

				<if_stmt><if>if <condition>(<expr><name><name>pCSEntry</name><operator>-&gt;</operator><name>chunk_list</name><operator>.</operator><name>num_chunks</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Motion layer node %d cleanup - there are still"</literal>
						 <literal type="string">" %d chunks enqueued from sender %d."</literal></expr></argument>, <argument><expr><name>motNodeID</name></expr></argument>,
						 <argument><expr><name><name>pCSEntry</name><operator>-&gt;</operator><name>chunk_list</name><operator>.</operator><name>num_chunks</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<comment type="block" format="doxygen">/***
					TODO - Make sure there are no outstanding tuples in the
					tuple-store.
				***/</comment>
			</block_content>}</block></else></if_stmt>

			<comment type="block">/*
			 * Clean up the chunk-sorter entry, then remove it from the hash
			 * table.
			 */</comment>
			<expr_stmt><expr><call><name>clearTCList</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pMNEntry</name><operator>-&gt;</operator><name>ser_tup_info</name><operator>.</operator><name>chunkCache</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pCSEntry</name><operator>-&gt;</operator><name>chunk_list</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>pMNEntry</name><operator>-&gt;</operator><name>preserve_order</name></name></expr>)</condition><block type="pseudo"><block_content>	<comment type="block">/* Clean up the tuple-store. */</comment>
				<expr_stmt><expr><call><name>htfifo_destroy</name><argument_list>(<argument><expr><name><name>pCSEntry</name><operator>-&gt;</operator><name>ready_tuples</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name><name>pMNEntry</name><operator>-&gt;</operator><name>cleanedUp</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<comment type="block">/* Clean up the motion-node entry, then remove it from the hash table. */</comment>
	<if_stmt><if>if <condition>(<expr><name>gp_log_interconnect</name> <operator>&gt;=</operator> <name>GPVARS_VERBOSITY_VERBOSE</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>pMNEntry</name><operator>-&gt;</operator><name>stat_total_bytes_sent</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Interconnect seg%d slice%d sent "</literal> <name>UINT64_FORMAT</name> <literal type="string">" tuples, "</literal>
				 <name>UINT64_FORMAT</name> <literal type="string">" total bytes, "</literal> <name>UINT64_FORMAT</name> <literal type="string">" tuple bytes, "</literal>
				 <name>UINT64_FORMAT</name> <literal type="string">" chunks."</literal></expr></argument>,
				 <argument><expr><name><name>GpIdentity</name><operator>.</operator><name>segindex</name></name></expr></argument>,
				 <argument><expr><name>currentSliceId</name></expr></argument>,
				 <argument><expr><name><name>pMNEntry</name><operator>-&gt;</operator><name>stat_total_sends</name></name></expr></argument>,
				 <argument><expr><name><name>pMNEntry</name><operator>-&gt;</operator><name>stat_total_bytes_sent</name></name></expr></argument>,
				 <argument><expr><name><name>pMNEntry</name><operator>-&gt;</operator><name>stat_tuple_bytes_sent</name></name></expr></argument>,
				 <argument><expr><name><name>pMNEntry</name><operator>-&gt;</operator><name>stat_total_chunks_sent</name></name></expr></argument>
				)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>pMNEntry</name><operator>-&gt;</operator><name>stat_total_bytes_recvd</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Interconnect seg%d slice%d received from slice%d: "</literal> <name>UINT64_FORMAT</name> <literal type="string">" tuples, "</literal>
				 <name>UINT64_FORMAT</name> <literal type="string">" total bytes, "</literal> <name>UINT64_FORMAT</name> <literal type="string">" tuple bytes, "</literal>
				 <name>UINT64_FORMAT</name> <literal type="string">" chunks."</literal></expr></argument>,
				 <argument><expr><name><name>GpIdentity</name><operator>.</operator><name>segindex</name></name></expr></argument>,
				 <argument><expr><name>currentSliceId</name></expr></argument>,
				 <argument><expr><name>motNodeID</name></expr></argument>,
				 <argument><expr><name><name>pMNEntry</name><operator>-&gt;</operator><name>stat_total_recvs</name></name></expr></argument>,
				 <argument><expr><name><name>pMNEntry</name><operator>-&gt;</operator><name>stat_total_bytes_recvd</name></name></expr></argument>,
				 <argument><expr><name><name>pMNEntry</name><operator>-&gt;</operator><name>stat_tuple_bytes_recvd</name></name></expr></argument>,
				 <argument><expr><name><name>pMNEntry</name><operator>-&gt;</operator><name>stat_total_chunks_recvd</name></name></expr></argument>
				)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>CleanupSerTupInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pMNEntry</name><operator>-&gt;</operator><name>ser_tup_info</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FreeTupleDesc</name><argument_list>(<argument><expr><name><name>pMNEntry</name><operator>-&gt;</operator><name>tuple_desc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>pMNEntry</name><operator>-&gt;</operator><name>preserve_order</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>htfifo_destroy</name><argument_list>(<argument><expr><name><name>pMNEntry</name><operator>-&gt;</operator><name>ready_tuples</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>pMNEntry</name><operator>-&gt;</operator><name>valid</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Helper function to get the motion node entry for a given ID.  NULL
 * is returned if the ID is unrecognized.
 */</comment>
<function><type><specifier>static</specifier> <name>MotionNodeEntry</name> <modifier>*</modifier></type>
<name>getMotionNodeEntry</name><parameter_list>(<parameter><decl><type><name>MotionLayerState</name> <modifier>*</modifier></type><name>mlStates</name></decl></parameter>, <parameter><decl><type><name>int16</name></type> <name>motNodeID</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MotionNodeEntry</name> <modifier>*</modifier></type><name>pMNEntry</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>motNodeID</name> <operator>&gt;</operator> <name><name>mlStates</name><operator>-&gt;</operator><name>mneCount</name></name> <operator>||</operator>
		<operator>!</operator><name><name>mlStates</name><operator>-&gt;</operator><name>mnEntries</name><index>[<expr><name>motNodeID</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>valid</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_GP_INTERCONNECTION_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"interconnect error: Unexpected Motion Node Id: %d"</literal></expr></argument>,
						<argument><expr><name>motNodeID</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"This means a motion node that wasn't setup is requesting interconnect resources."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>pMNEntry</name> <operator>=</operator> <operator>&amp;</operator><name><name>mlStates</name><operator>-&gt;</operator><name>mnEntries</name><index>[<expr><name>motNodeID</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>pMNEntry</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>pMNEntry</name><operator>-&gt;</operator><name>motion_node_id</name></name> <operator>==</operator> <name>motNodeID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>pMNEntry</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Retrieve the chunk-sorter entry for the specified motion-node/source pair.
 * If one doesn't exist, it is created and initialized.
 *
 * It might not seem obvious why the MotionNodeEntry is required as an
 * argument.  It's in there to ensure that only valid motion nodes are
 * represented in the chunk-sorter.  The motion-node's entry is typically
 * retrieved using getMotionNodeEntry() before this function is called.
 */</comment>
<function><type><name>ChunkSorterEntry</name> <modifier>*</modifier></type>
<name>getChunkSorterEntry</name><parameter_list>(<parameter><decl><type><name>MotionLayerState</name> <modifier>*</modifier></type><name>mlStates</name></decl></parameter>,
					<parameter><decl><type><name>MotionNodeEntry</name> <modifier>*</modifier></type><name>motNodeEntry</name></decl></parameter>,
					<parameter><decl><type><name>int16</name></type> <name>srcRoute</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldCtxt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ChunkSorterEntry</name> <modifier>*</modifier></type><name>chunkSorterEntry</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><name>motNodeEntry</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>srcRoute</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>srcRoute</name> <operator>&lt;</operator> <name><name>motNodeEntry</name><operator>-&gt;</operator><name>num_senders</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Do we have a sorter initialized ? */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>motNodeEntry</name><operator>-&gt;</operator><name>ready_tuple_lists</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>motNodeEntry</name><operator>-&gt;</operator><name>ready_tuple_lists</name><index>[<expr><name>srcRoute</name></expr>]</index></name><operator>.</operator><name>init</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><operator>&amp;</operator><name><name>motNodeEntry</name><operator>-&gt;</operator><name>ready_tuple_lists</name><index>[<expr><name>srcRoute</name></expr>]</index></name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* We have to create an entry */</comment>
	<expr_stmt><expr><name>oldCtxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>mlStates</name><operator>-&gt;</operator><name>motion_layer_mctx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>motNodeEntry</name><operator>-&gt;</operator><name>ready_tuple_lists</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>motNodeEntry</name><operator>-&gt;</operator><name>ready_tuple_lists</name></name> <operator>=</operator> <operator>(</operator><name>ChunkSorterEntry</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name><name>motNodeEntry</name><operator>-&gt;</operator><name>num_senders</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ChunkSorterEntry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>chunkSorterEntry</name> <operator>=</operator> <operator>&amp;</operator><name><name>motNodeEntry</name><operator>-&gt;</operator><name>ready_tuple_lists</name><index>[<expr><name>srcRoute</name></expr>]</index></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>chunkSorterEntry</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not allocate entry for tuple chunk sorter"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>chunkSorterEntry</name><operator>-&gt;</operator><name>chunk_list</name><operator>.</operator><name>serialized_data_length</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>chunkSorterEntry</name><operator>-&gt;</operator><name>chunk_list</name><operator>.</operator><name>max_chunk_length</name></name> <operator>=</operator> <name>Gp_max_tuple_chunk_size</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>chunkSorterEntry</name><operator>-&gt;</operator><name>chunk_list</name><operator>.</operator><name>num_chunks</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>chunkSorterEntry</name><operator>-&gt;</operator><name>chunk_list</name><operator>.</operator><name>p_first</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>chunkSorterEntry</name><operator>-&gt;</operator><name>chunk_list</name><operator>.</operator><name>p_last</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>chunkSorterEntry</name><operator>-&gt;</operator><name>end_of_stream</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>chunkSorterEntry</name><operator>-&gt;</operator><name>init</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * If motion node is not order-preserving, then all chunk-sorter entries
	 * share one global tuple-store.  If motion node is order- preserving then
	 * there is a tuple-store per sender per motion node.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>motNodeEntry</name><operator>-&gt;</operator><name>preserve_order</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>chunkSorterEntry</name><operator>-&gt;</operator><name>ready_tuples</name></name> <operator>=</operator> <call><name>htfifo_create</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AMS_VERBOSE_LOGGING</name></cpp:ifdef>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG5</name></expr></argument>, <argument><expr><literal type="string">"Motion node %d is order-preserving.  Creating tuple-store for entry [src=%d,mn=%d]."</literal></expr></argument>,
			 <argument><expr><name><name>motNodeEntry</name><operator>-&gt;</operator><name>motion_node_id</name></name></expr></argument>,
			 <argument><expr><name>srcRoute</name></expr></argument>, <argument><expr><name><name>motNodeEntry</name><operator>-&gt;</operator><name>motion_node_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>chunkSorterEntry</name><operator>-&gt;</operator><name>ready_tuples</name></name> <operator>=</operator> <name><name>motNodeEntry</name><operator>-&gt;</operator><name>ready_tuples</name></name></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AMS_VERBOSE_LOGGING</name></cpp:ifdef>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG5</name></expr></argument>, <argument><expr><literal type="string">"Motion node %d is not order-preserving.  Using shared tuple-store for entry [src=%d,mn=%d]."</literal></expr></argument>,
			 <argument><expr><name><name>motNodeEntry</name><operator>-&gt;</operator><name>motion_node_id</name></name></expr></argument>,
			 <argument><expr><name>srcRoute</name></expr></argument>, <argument><expr><name><name>motNodeEntry</name><operator>-&gt;</operator><name>motion_node_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

		<comment type="block">/* Sanity-check: */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>motNodeEntry</name><operator>-&gt;</operator><name>ready_tuples</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldCtxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>chunkSorterEntry</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>chunkSorterEntry</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Helper function for converting chunks from the receive state (where
 * they point into a share buffer) into the transient state (where they
 * have their own storage). We need to do this if we didn't receive enough
 * information in one chunk to reconstruct a tuple.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>materializeChunk</name><parameter_list>(<parameter><decl><type><name>TupleChunkListItem</name> <modifier>*</modifier></type><name>tcItem</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TupleChunkListItem</name></type> <name>newItem</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * This chunk needs to be converted from pointing to global receive buffer
	 * store to having its own storage
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>tcItem</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>*</operator><name>tcItem</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>newItem</name> <operator>=</operator> <call><name>repalloc</name><argument_list>(<argument><expr><operator>*</operator><name>tcItem</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TupleChunkListItemData</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name><operator>(</operator><operator>*</operator><name>tcItem</name><operator>)</operator><operator>-&gt;</operator><name>chunk_length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>newItem</name><operator>-&gt;</operator><name>chunk_data</name></name></expr></argument>, <argument><expr><name><name>newItem</name><operator>-&gt;</operator><name>inplace</name></name></expr></argument>, <argument><expr><name><name>newItem</name><operator>-&gt;</operator><name>chunk_length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newItem</name><operator>-&gt;</operator><name>inplace</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>	<comment type="block">/* no need to free, someone else owns it */</comment>

	<expr_stmt><expr><operator>*</operator><name>tcItem</name> <operator>=</operator> <name>newItem</name></expr>;</expr_stmt>

	<return>return;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Add another tuple-chunk to the chunk sorter.  If the new chunk
 * completes another HeapTuple, that tuple will be deserialized and
 * stored into a htfifo.  If not, the chunk is added to the
 * appropriate list of chunks.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>addChunkToSorter</name><parameter_list>(<parameter><decl><type><name>ChunkTransportState</name> <modifier>*</modifier></type><name>transportStates</name></decl></parameter>,
				 <parameter><decl><type><name>MotionNodeEntry</name> <modifier>*</modifier></type><name>pMNEntry</name></decl></parameter>,
				 <parameter><decl><type><name>TupleChunkListItem</name></type> <name>tcItem</name></decl></parameter>,
				 <parameter><decl><type><name>int16</name></type> <name>motNodeID</name></decl></parameter>,
				 <parameter><decl><type><name>ChunkSorterEntry</name> <modifier>*</modifier></type><name>chunkSorterEntry</name></decl></parameter>,
				 <parameter><decl><type><name>ChunkTransportStateEntry</name> <modifier>*</modifier></type><name>pEntry</name></decl></parameter>,
				 <parameter><decl><type><name>MotionConn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>,
				 <parameter><decl><type><name>int16</name></type> <name>srcRoute</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TupleChunkType</name></type> <name>tcType</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><name>tcItem</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Look at the chunk's type, to figure out what to do with it. */</comment>
	<expr_stmt><expr><call><name>GetChunkType</name><argument_list>(<argument><expr><name>tcItem</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tcType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><name>tcType</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>TC_WHOLE</name></expr>:</case>
		<case>case <expr><name>TC_EMPTY</name></expr>:</case>
			<comment type="block">/* There shouldn't be any partial tuple data in the list! */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>chunkSorterEntry</name><operator>-&gt;</operator><name>chunk_list</name><operator>.</operator><name>num_chunks</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_GP_INTERCONNECTION_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"received TC_WHOLE chunk from [src=%d,mn=%d] after partial tuple data"</literal></expr></argument>,
								<argument><expr><name>srcRoute</name></expr></argument>, <argument><expr><name>motNodeID</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* Put this chunk into the list, then turn it into a HeapTuple! */</comment>
			<expr_stmt><expr><call><name>appendChunkToTCList</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>chunkSorterEntry</name><operator>-&gt;</operator><name>chunk_list</name></name></expr></argument>, <argument><expr><name>tcItem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>reconstructTuple</name><argument_list>(<argument><expr><name>pMNEntry</name></expr></argument>, <argument><expr><name>chunkSorterEntry</name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>remapper</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<break>break;</break>

		<case>case <expr><name>TC_PARTIAL_START</name></expr>:</case>

			<comment type="block">/* There shouldn't be any partial tuple data in the list! */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>chunkSorterEntry</name><operator>-&gt;</operator><name>chunk_list</name><operator>.</operator><name>num_chunks</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_GP_INTERCONNECTION_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"received TC_PARTIAL_START chunk from [src=%d,mn=%d] after partial tuple data"</literal></expr></argument>,
								<argument><expr><name>srcRoute</name></expr></argument>, <argument><expr><name>motNodeID</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * we don't have enough to reconstruct the tuple, we need to copy
			 * the chunk data out of our shared buffer
			 */</comment>
			<expr_stmt><expr><call><name>materializeChunk</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tcItem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Put this chunk into the list. */</comment>
			<expr_stmt><expr><call><name>appendChunkToTCList</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>chunkSorterEntry</name><operator>-&gt;</operator><name>chunk_list</name></name></expr></argument>, <argument><expr><name>tcItem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<break>break;</break>

		<case>case <expr><name>TC_PARTIAL_MID</name></expr>:</case>

			<comment type="block">/* There should be partial tuple data in the list. */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>chunkSorterEntry</name><operator>-&gt;</operator><name>chunk_list</name><operator>.</operator><name>num_chunks</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_GP_INTERCONNECTION_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"received TC_PARTIAL_MID chunk from [src=%d,mn=%d] without any leading tuple data"</literal></expr></argument>,
								<argument><expr><name>srcRoute</name></expr></argument>, <argument><expr><name>motNodeID</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * we don't have enough to reconstruct the tuple, we need to copy
			 * the chunk data out of our shared buffer
			 */</comment>
			<expr_stmt><expr><call><name>materializeChunk</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tcItem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Append this chunk to the list. */</comment>
			<expr_stmt><expr><call><name>appendChunkToTCList</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>chunkSorterEntry</name><operator>-&gt;</operator><name>chunk_list</name></name></expr></argument>, <argument><expr><name>tcItem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<break>break;</break>

		<case>case <expr><name>TC_PARTIAL_END</name></expr>:</case>

			<comment type="block">/* There should be partial tuple data in the list. */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>chunkSorterEntry</name><operator>-&gt;</operator><name>chunk_list</name><operator>.</operator><name>num_chunks</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_GP_INTERCONNECTION_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"received TC_PARTIAL_END chunk from [src=%d,mn=%d] without any leading tuple data"</literal></expr></argument>,
								<argument><expr><name>srcRoute</name></expr></argument>, <argument><expr><name>motNodeID</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* Put this chunk into the list, then turn it into a HeapTuple! */</comment>
			<expr_stmt><expr><call><name>appendChunkToTCList</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>chunkSorterEntry</name><operator>-&gt;</operator><name>chunk_list</name></name></expr></argument>, <argument><expr><name>tcItem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>reconstructTuple</name><argument_list>(<argument><expr><name>pMNEntry</name></expr></argument>, <argument><expr><name>chunkSorterEntry</name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>remapper</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<break>break;</break>

		<case>case <expr><name>TC_END_OF_STREAM</name></expr>:</case>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AMS_VERBOSE_LOGGING</name></cpp:ifdef>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Got end-of-stream. motnode %d route %d"</literal></expr></argument>, <argument><expr><name>motNodeID</name></expr></argument>, <argument><expr><name>srcRoute</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<comment type="block">/* There shouldn't be any partial tuple data in the list! */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>chunkSorterEntry</name><operator>-&gt;</operator><name>chunk_list</name><operator>.</operator><name>num_chunks</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_GP_INTERCONNECTION_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"received TC_END_OF_STREAM chunk from [src=%d,mn=%d] after partial tuple data"</literal></expr></argument>,
								<argument><expr><name>srcRoute</name></expr></argument>, <argument><expr><name>motNodeID</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* Make sure that we haven't already received end-of-stream! */</comment>

			<if_stmt><if>if <condition>(<expr><name><name>chunkSorterEntry</name><operator>-&gt;</operator><name>end_of_stream</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_GP_INTERCONNECTION_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"received end-of-stream chunk from [src=%d,mn=%d] when already marked as at end-of-stream"</literal></expr></argument>,
								<argument><expr><name>srcRoute</name></expr></argument>, <argument><expr><name>motNodeID</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* Mark the state as "end of stream." */</comment>
			<expr_stmt><expr><name><name>chunkSorterEntry</name><operator>-&gt;</operator><name>end_of_stream</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>pMNEntry</name><operator>-&gt;</operator><name>num_stream_ends_recvd</name></name><operator>++</operator></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>pMNEntry</name><operator>-&gt;</operator><name>num_stream_ends_recvd</name></name> <operator>==</operator> <name><name>pMNEntry</name><operator>-&gt;</operator><name>num_senders</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>pMNEntry</name><operator>-&gt;</operator><name>moreNetWork</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * Since we received an end-of-stream.	Then we no longer need
			 * read interest in the interconnect.
			 */</comment>
			<expr_stmt><expr><call><name>DeregisterReadInterest</name><argument_list>(<argument><expr><name>transportStates</name></expr></argument>, <argument><expr><name>motNodeID</name></expr></argument>, <argument><expr><name>srcRoute</name></expr></argument>,
								   <argument><expr><literal type="string">"end of stream"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<default>default:</default>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_GP_INTERCONNECTION_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"received tuple chunk of unrecognized type %d (len %d) from [src=%d,mn=%d]"</literal></expr></argument>,
							<argument><expr><name>tcType</name></expr></argument>, <argument><expr><name><name>tcItem</name><operator>-&gt;</operator><name>chunk_length</name></name></expr></argument>, <argument><expr><name>srcRoute</name></expr></argument>, <argument><expr><name>motNodeID</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>
</block_content>}</block></function>



<comment type="block">/*
 * STATISTICS HELPER-FUNCTIONS
 *
 * NOTE: the only fields that are required to be valid are
 * tcList-&gt;num_chunks and tcList-&gt;serialized_data_length, and
 * SerializeTupleDirect() only fills those fields out.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>statSendTuple</name><parameter_list>(<parameter><decl><type><name>MotionLayerState</name> <modifier>*</modifier></type><name>mlStates</name></decl></parameter>, <parameter><decl><type><name>MotionNodeEntry</name> <modifier>*</modifier></type><name>pMNEntry</name></decl></parameter>, <parameter><decl><type><name>TupleChunkList</name></type> <name>tcList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>headerOverhead</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><name>pMNEntry</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>headerOverhead</name> <operator>=</operator> <name>TUPLE_CHUNK_HEADER_SIZE</name> <operator>*</operator> <name><name>tcList</name><operator>-&gt;</operator><name>num_chunks</name></name></expr>;</expr_stmt>

	<comment type="block">/* per motion-node stats. */</comment>
	<expr_stmt><expr><name><name>pMNEntry</name><operator>-&gt;</operator><name>stat_total_sends</name></name><operator>++</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pMNEntry</name><operator>-&gt;</operator><name>stat_total_chunks_sent</name></name> <operator>+=</operator> <name><name>tcList</name><operator>-&gt;</operator><name>num_chunks</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pMNEntry</name><operator>-&gt;</operator><name>stat_total_bytes_sent</name></name> <operator>+=</operator> <name><name>tcList</name><operator>-&gt;</operator><name>serialized_data_length</name></name> <operator>+</operator> <name>headerOverhead</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pMNEntry</name><operator>-&gt;</operator><name>stat_tuple_bytes_sent</name></name> <operator>+=</operator> <name><name>tcList</name><operator>-&gt;</operator><name>serialized_data_length</name></name></expr>;</expr_stmt>

	<comment type="block">/* Update global motion-layer statistics. */</comment>
	<expr_stmt><expr><name><name>mlStates</name><operator>-&gt;</operator><name>stat_total_chunks_sent</name></name> <operator>+=</operator> <name><name>tcList</name><operator>-&gt;</operator><name>num_chunks</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>mlStates</name><operator>-&gt;</operator><name>stat_total_bytes_sent</name></name> <operator>+=</operator>
		<name><name>tcList</name><operator>-&gt;</operator><name>serialized_data_length</name></name> <operator>+</operator> <name>headerOverhead</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>mlStates</name><operator>-&gt;</operator><name>stat_tuple_bytes_sent</name></name> <operator>+=</operator> <name><name>tcList</name><operator>-&gt;</operator><name>serialized_data_length</name></name></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>statSendEOS</name><parameter_list>(<parameter><decl><type><name>MotionLayerState</name> <modifier>*</modifier></type><name>mlStates</name></decl></parameter>, <parameter><decl><type><name>MotionNodeEntry</name> <modifier>*</modifier></type><name>pMNEntry</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><name>pMNEntry</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Update motion node statistics. */</comment>
	<expr_stmt><expr><name><name>pMNEntry</name><operator>-&gt;</operator><name>stat_total_chunks_sent</name></name><operator>++</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pMNEntry</name><operator>-&gt;</operator><name>stat_total_bytes_sent</name></name> <operator>+=</operator> <name>TUPLE_CHUNK_HEADER_SIZE</name></expr>;</expr_stmt>

	<comment type="block">/* Update global motion-layer statistics. */</comment>
	<expr_stmt><expr><name><name>mlStates</name><operator>-&gt;</operator><name>stat_total_chunks_sent</name></name><operator>++</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>mlStates</name><operator>-&gt;</operator><name>stat_total_bytes_sent</name></name> <operator>+=</operator> <name>TUPLE_CHUNK_HEADER_SIZE</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>statChunksProcessed</name><parameter_list>(<parameter><decl><type><name>MotionLayerState</name> <modifier>*</modifier></type><name>mlStates</name></decl></parameter>, <parameter><decl><type><name>MotionNodeEntry</name> <modifier>*</modifier></type><name>pMNEntry</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>chunksProcessed</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>chunkBytes</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>tupleBytes</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><name>chunksProcessed</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><name>chunkBytes</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><name>tupleBytes</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Update Global Motion Layer Stats. */</comment>
	<expr_stmt><expr><name><name>mlStates</name><operator>-&gt;</operator><name>stat_total_chunks_recvd</name></name> <operator>+=</operator> <name>chunksProcessed</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>mlStates</name><operator>-&gt;</operator><name>stat_total_chunkproc_calls</name></name><operator>++</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>mlStates</name><operator>-&gt;</operator><name>stat_total_bytes_recvd</name></name> <operator>+=</operator> <name>chunkBytes</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>mlStates</name><operator>-&gt;</operator><name>stat_tuple_bytes_recvd</name></name> <operator>+=</operator> <name>tupleBytes</name></expr>;</expr_stmt>

	<comment type="block">/* Update Motion-node stats. */</comment>
	<expr_stmt><expr><name><name>pMNEntry</name><operator>-&gt;</operator><name>stat_total_chunks_recvd</name></name> <operator>+=</operator> <name>chunksProcessed</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pMNEntry</name><operator>-&gt;</operator><name>stat_total_bytes_recvd</name></name> <operator>+=</operator> <name>chunkBytes</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pMNEntry</name><operator>-&gt;</operator><name>stat_tuple_bytes_recvd</name></name> <operator>+=</operator> <name>tupleBytes</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>statNewTupleArrived</name><parameter_list>(<parameter><decl><type><name>MotionNodeEntry</name> <modifier>*</modifier></type><name>pMNEntry</name></decl></parameter>, <parameter><decl><type><name>ChunkSorterEntry</name> <modifier>*</modifier></type><name>pCSEntry</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>tupsAvail</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><name>pMNEntry</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><name>pCSEntry</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * High-watermarks:  We track the number of tuples available to receive,
	 * but that haven't yet been received.  The high-watermark is recorded.
	 *
	 * Also, if the motion node is order-preserving, we track a per-sender
	 * high-watermark as well.
	 */</comment>
	<expr_stmt><expr><name>tupsAvail</name> <operator>=</operator> <operator>++</operator><operator>(</operator><name><name>pMNEntry</name><operator>-&gt;</operator><name>stat_tuples_available</name></name><operator>)</operator></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>pMNEntry</name><operator>-&gt;</operator><name>stat_tuples_available_hwm</name></name> <operator>&lt;</operator> <name>tupsAvail</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* New high-watermark! */</comment>
		<expr_stmt><expr><name><name>pMNEntry</name><operator>-&gt;</operator><name>stat_tuples_available_hwm</name></name> <operator>=</operator> <name>tupsAvail</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>statRecvTuple</name><parameter_list>(<parameter><decl><type><name>MotionNodeEntry</name> <modifier>*</modifier></type><name>pMNEntry</name></decl></parameter>, <parameter><decl><type><name>ChunkSorterEntry</name> <modifier>*</modifier></type><name>pCSEntry</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><name>pMNEntry</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><name>pCSEntry</name> <operator>!=</operator> <name>NULL</name> <operator>||</operator> <operator>!</operator><name><name>pMNEntry</name><operator>-&gt;</operator><name>preserve_order</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Count tuples received. */</comment>
	<expr_stmt><expr><name><name>pMNEntry</name><operator>-&gt;</operator><name>stat_total_recvs</name></name><operator>++</operator></expr>;</expr_stmt>

	<comment type="block">/* Update "tuples available" counts for high watermark stats. */</comment>
	<expr_stmt><expr><name><name>pMNEntry</name><operator>-&gt;</operator><name>stat_tuples_available</name></name><operator>--</operator></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Return true if the record cache should be sent to master
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ShouldSendRecordCache</name><parameter_list>(<parameter><decl><type><name>MotionConn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>SerTupInfo</name> <modifier>*</modifier></type><name>pSerInfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name><name>pSerInfo</name><operator>-&gt;</operator><name>has_record_types</name></name> <operator>&amp;&amp;</operator>
		<name>NextRecordTypmod</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
		<name>NextRecordTypmod</name> <operator>&gt;</operator> <name><name>conn</name><operator>-&gt;</operator><name>sent_record_typmod</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Update the number of sent record types.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>UpdateSentRecordCache</name><parameter_list>(<parameter><decl><type><name>MotionConn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>sent_record_typmod</name></name> <operator>=</operator> <name>NextRecordTypmod</name></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
