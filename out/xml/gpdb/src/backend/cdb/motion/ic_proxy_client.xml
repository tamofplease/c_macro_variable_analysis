<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/backend/cdb/motion/ic_proxy_client.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * ic_proxy_client.c
 *
 *    Interconnect Proxy Client
 *
 * A client lives in the proxy bgworker and connects to a backend, each logical
 * connection needs a client, so there could be multiple connections between
 * one backend process and the proxy bgworker, the same amount of clients are
 * needed, too.
 *
 * A local client communicates to exact one remote client, a special case is
 * that both clients are on the same segment, in which case both are called
 * loopback clients.
 *
 * A client is created on a new backend connection, it is registered after the
 * hand shaking.  The hand shaking is made between the backend and the client,
 * this is different with the ic-tcp or ic-udp modes, they do the hand shaking
 * between the local and remote backends.
 *
 * A client is identified with a key, every packet also contains such a key, so
 * when a packet is received we could know which client to route it to.
 *
 * Packets can arrive before the client registration, in such a case a
 * placeholder is registered to hold the early coming packets.  Once the client
 * finishes the hand shaking it replaces the placeholder and handles these
 * early packets in the arriving order.
 *
 * The interconnect treats the motion sender and the receiver differently,
 * however in ic-proxy we do not distinguish the sender client or the receiver
 * client.  Sometimes we will mention the words sender or receiver, they only
 * have logical meanings, and are not marked in the code.
 *
 * Sometimes a backend receives slower than the sender, so more and more
 * packets are put in the writing queue.  To prevent it consuming too many
 * memory we introduce an active flow control mechanism. The sender increases
 * the number of unack packets when it sends a packet to remote peer. The
 * sender will PAUSE itself when the number of unack packets exceeds the
 * threshold. The receiver will send a ACK message back to sender, when it
 * receives a batch of packets. After get ACK message, the sender will decrease
 * the number of unack packets. When the number of unack packets is below the
 * resume threshold, the sender continues to read data from the backend.
 *
 * Packets are routed in 2 directions, c2p and p2c:
 * - c2p packets are routed from a client to a peer;
 * - p2c packets are routed from a peer to a client;
 * - there is no term "c2c" because loopback packets are also handled as c2p
 *   by the sender and p2c by the receiver;
 *
 * The directions are not named as incoming and outgoing because the they can
 * lead to confusing descriptions: "a client receives an outgoing packet from
 * its backend", or, "a client sends an incoming packet to its backend".
 *
 *
 * Copyright (c) 2020-Present VMware, Inc. or its affiliates.
 *
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ic_proxy_server.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ic_proxy_pkt_cache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ic_proxy_router.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/hsearch.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/faultinjector.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;uv.h&gt;</cpp:file></cpp:include>

<typedef>typedef <type><name><name>struct</name> <name>ICProxyClientEntry</name></name></type> <name>ICProxyClientEntry</name>;</typedef>


<comment type="block">/*
 * TODO: a client only has one target, it's either a peer, or a loopback
 * client, there is no need to lookup it every time, the loopback client lookup
 * is expansive.
 *
 * We used to save the target since the very beginning, however it was buggy on
 * placeholders, so we disabled it.  If we want to reenable it be careful on
 * below notes:
 * - a peer can be a placeholder;
 * - a loopback client can be a placeholder;
 * - ibuf/obuf functions are not reentrantable, delayed queue is necessary;
 */</comment>
<struct>struct <name>ICProxyClient</name>
<block>{
	<decl_stmt><decl><type><name>uv_pipe_t</name></type>	<name>pipe</name></decl>;</decl_stmt>			<comment type="block">/* the libuv handle */</comment>

	<decl_stmt><decl><type><name>ICProxyKey</name></type>	<name>key</name></decl>;</decl_stmt>			<comment type="block">/* the key to identify a client */</comment>

	<decl_stmt><decl><type><name>uint32</name></type>		<name>state</name></decl>;</decl_stmt>			<comment type="block">/* or'ed bits of below ones */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IC_PROXY_CLIENT_STATE_RECEIVED_HELLO</name></cpp:macro>  <cpp:value>0x00000001</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IC_PROXY_CLIENT_STATE_SENT_HELLO_ACK</name></cpp:macro>  <cpp:value>0x00000002</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IC_PROXY_CLIENT_STATE_REGISTERED</name></cpp:macro>      <cpp:value>0x00000004</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IC_PROXY_CLIENT_STATE_PLACEHOLDER</name></cpp:macro>     <cpp:value>0x00000008</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IC_PROXY_CLIENT_STATE_C2P_SHUTTING</name></cpp:macro>    <cpp:value>0x00000010</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IC_PROXY_CLIENT_STATE_C2P_SHUTTED</name></cpp:macro>     <cpp:value>0x00000020</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IC_PROXY_CLIENT_STATE_P2C_SHUTTING</name></cpp:macro>    <cpp:value>0x00000040</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IC_PROXY_CLIENT_STATE_P2C_SHUTTED</name></cpp:macro>     <cpp:value>0x00000080</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IC_PROXY_CLIENT_STATE_CLOSING</name></cpp:macro>         <cpp:value>0x00000100</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IC_PROXY_CLIENT_STATE_CLOSED</name></cpp:macro>          <cpp:value>0x00000200</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IC_PROXY_CLIENT_STATE_PAUSED</name></cpp:macro>          <cpp:value>0x00000800</cpp:value></cpp:define>

	<decl_stmt><decl><type><name>int</name></type>			<name>unconsumed</name></decl>;</decl_stmt>		<comment type="block">/* count of the packets that are unconsumed by
								 * the backend */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>sending</name></decl>;</decl_stmt>		<comment type="block">/* count of the packets being sent, both c2p &amp;
								 * p2c, both data &amp; message */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>unackSendPkt</name></decl>;</decl_stmt>	<comment type="block">/* count of the unack packets from sender */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>unackRecvPkt</name></decl>;</decl_stmt>	<comment type="block">/* count of the unack packets from receiver */</comment>

	<decl_stmt><decl><type><name>ICProxyOBuf</name></type>	<name>obuf</name></decl>;</decl_stmt>			<comment type="block">/* obuf merges small outgoing packets into
								 * large ones to reduce network overhead */</comment>
	<decl_stmt><decl><type><name>ICProxyIBuf</name></type>	<name>ibuf</name></decl>;</decl_stmt>			<comment type="block">/* ibuf detects the packet boundaries */</comment>

	<decl_stmt><decl><type><name>ICProxyClient</name> <modifier>*</modifier></type><name>successor</name></decl>;</decl_stmt>	<comment type="block">/* if a client is registered while a previous
								 * one with the same key is still alive, the
								 * registration is delayed, the new one marks
								 * itself as the successor of the previous one,
								 * when the previous one is deregistered the
								 * new one gets actually registered. */</comment>

	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>pkts</name></decl>;</decl_stmt>			<comment type="block">/* early coming packets */</comment>

	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>			<comment type="block">/* name of the client, only for logging */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IC_PROXY_CLIENT_NAME_SIZE</name></cpp:macro> <cpp:value>256</cpp:value></cpp:define>

	<comment type="block">/* TODO: statistics */</comment>
}</block>;</struct>

<comment type="block">/*
 * Client hash table entry.
 */</comment>
<struct>struct <name>ICProxyClientEntry</name>
<block>{
	<decl_stmt><decl><type><name>ICProxyKey</name></type>	<name>key</name></decl>;</decl_stmt>			<comment type="block">/* the hash key */</comment>

	<decl_stmt><decl><type><name>ICProxyClient</name> <modifier>*</modifier></type><name>client</name></decl>;</decl_stmt>		<comment type="block">/* the client */</comment>
}</block>;</struct>


<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ic_proxy_client_clear_name</name><parameter_list>(<parameter><decl><type><name>ICProxyClient</name> <modifier>*</modifier></type><name>client</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ic_proxy_client_shutdown_c2p</name><parameter_list>(<parameter><decl><type><name>ICProxyClient</name> <modifier>*</modifier></type><name>client</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ic_proxy_client_shutdown_p2c</name><parameter_list>(<parameter><decl><type><name>ICProxyClient</name> <modifier>*</modifier></type><name>client</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ic_proxy_client_close</name><parameter_list>(<parameter><decl><type><name>ICProxyClient</name> <modifier>*</modifier></type><name>client</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ic_proxy_client_read_data</name><parameter_list>(<parameter><decl><type><name>ICProxyClient</name> <modifier>*</modifier></type><name>client</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ic_proxy_client_cache_p2c_pkt</name><parameter_list>(<parameter><decl><type><name>ICProxyClient</name> <modifier>*</modifier></type><name>client</name></decl></parameter>,
										  <parameter><decl><type><name>ICProxyPkt</name> <modifier>*</modifier></type><name>pkt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ic_proxy_client_cache_p2c_pkts</name><parameter_list>(<parameter><decl><type><name>ICProxyClient</name> <modifier>*</modifier></type><name>client</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>pkts</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ic_proxy_client_drop_p2c_cache</name><parameter_list>(<parameter><decl><type><name>ICProxyClient</name> <modifier>*</modifier></type><name>client</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ic_proxy_client_handle_p2c_cache</name><parameter_list>(<parameter><decl><type><name>ICProxyClient</name> <modifier>*</modifier></type><name>client</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ic_proxy_client_maybe_start_read_data</name><parameter_list>(<parameter><decl><type><name>ICProxyClient</name> <modifier>*</modifier></type><name>client</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ic_proxy_client_maybe_pause</name><parameter_list>(<parameter><decl><type><name>ICProxyClient</name> <modifier>*</modifier></type><name>client</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ic_proxy_client_maybe_send_ack_message</name><parameter_list>(<parameter><decl><type><name>ICProxyClient</name> <modifier>*</modifier></type><name>client</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ic_proxy_client_maybe_resume</name><parameter_list>(<parameter><decl><type><name>ICProxyClient</name> <modifier>*</modifier></type><name>client</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * The client register table.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>HTAB</name>		   <modifier>*</modifier></type><name>ic_proxy_clients</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>


<function><type><name>void</name></type>
<name>ic_proxy_client_table_init</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HASHCTL</name></type>		<name>hashctl</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>hashctl</name><operator>.</operator><name>hash</name></name> <operator>=</operator> <operator>(</operator><name>HashValueFunc</name><operator>)</operator> <name>ic_proxy_key_hash</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hashctl</name><operator>.</operator><name>match</name></name> <operator>=</operator> <operator>(</operator><name>HashCompareFunc</name><operator>)</operator> <name>ic_proxy_key_equal_for_hash</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hashctl</name><operator>.</operator><name>keycopy</name></name> <operator>=</operator> <name>memcpy</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>hashctl</name><operator>.</operator><name>keysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ICProxyKey</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hashctl</name><operator>.</operator><name>entrysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ICProxyClientEntry</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

	<expr_stmt><expr><name>ic_proxy_clients</name> <operator>=</operator> <call><name>hash_create</name><argument_list>(<argument><expr><literal type="string">"ic-proxy clients"</literal></expr></argument>,
								   <argument><expr><name>MaxConnections</name></expr></argument> <comment type="block">/* nelem */</comment>,
								   <argument><expr><operator>&amp;</operator><name>hashctl</name></expr></argument>,
								   <argument><expr><name>HASH_ELEM</name> <operator>|</operator> <name>HASH_FUNCTION</name> <operator>|</operator>
								   <name>HASH_COMPARE</name> <operator>|</operator> <name>HASH_KEYCOPY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ic_proxy_client_table_uninit</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>ic_proxy_clients</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>hash_destroy</name><argument_list>(<argument><expr><name>ic_proxy_clients</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>ic_proxy_clients</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Shutdown all the clients who communicate with dbid.
 *
 * When a proxy-proxy connection to dbid is lost, all the logical connections
 * from or to it must be dropped, too.
 */</comment>
<function><type><name>void</name></type>
<name>ic_proxy_client_table_shutdown_by_dbid</name><parameter_list>(<parameter><decl><type><name>uint16</name></type> <name>dbid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ICProxyClientEntry</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HASH_SEQ_STATUS</name></type> <name>seq</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>elogif</name><argument_list>(<argument><expr><name>gp_log_interconnect</name> <operator>&gt;=</operator> <name>GPVARS_VERBOSITY_VERBOSE</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>,
				 <argument><expr><literal type="string">"ic-proxy: shutting down all the clients by dbid %hu"</literal></expr></argument>,
				 <argument><expr><name>dbid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>hash_seq_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>seq</name></expr></argument>, <argument><expr><name>ic_proxy_clients</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><operator>(</operator><name>entry</name> <operator>=</operator> <call><name>hash_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>seq</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ICProxyClient</name> <modifier>*</modifier></type><name>client</name> <init>= <expr><name><name>entry</name><operator>-&gt;</operator><name>client</name></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>client</name><operator>-&gt;</operator><name>state</name></name> <operator>&amp;</operator> <name>IC_PROXY_CLIENT_STATE_PLACEHOLDER</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>client</name><operator>-&gt;</operator><name>key</name><operator>.</operator><name>remoteDbid</name></name> <operator>!=</operator> <name>dbid</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* cached pkts from/to the remote dbid must also be dropped */</comment>
		<expr_stmt><expr><call><name>ic_proxy_client_drop_p2c_cache</name><argument_list>(<argument><expr><name>client</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ic_proxy_client_shutdown_c2p</name><argument_list>(<argument><expr><name>client</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ic_proxy_client_shutdown_p2c</name><argument_list>(<argument><expr><name>client</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>SIMPLE_FAULT_INJECTOR</name><argument_list>(<argument><expr><literal type="string">"ic_proxy_client_table_shutdown_by_dbid_end"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Register a client with its key.
 *
 * - if there was a placeholder, replace it;
 * - if there was a legacy but still alive one, make the client as its
 *   successor and delay the registration;
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ic_proxy_client_register</name><parameter_list>(<parameter><decl><type><name>ICProxyClient</name> <modifier>*</modifier></type><name>client</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ICProxyClientEntry</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>

	<comment type="block">/* this should never happen */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>client</name><operator>-&gt;</operator><name>state</name></name> <operator>&amp;</operator> <name>IC_PROXY_CLIENT_STATE_REGISTERED</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"ic-proxy: %s: already registered"</literal></expr></argument>,
					 <argument><expr><call><name>ic_proxy_client_get_name</name><argument_list>(<argument><expr><name>client</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>entry</name> <operator>=</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>ic_proxy_clients</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>client</name><operator>-&gt;</operator><name>key</name></name></expr></argument>, <argument><expr><name>HASH_ENTER</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* someone with the same identifier comes earlier than me */</comment>
		<decl_stmt><decl><type><name>ICProxyClient</name> <modifier>*</modifier></type><name>placeholder</name> <init>= <expr><name><name>entry</name><operator>-&gt;</operator><name>client</name></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* this should never happen, if it does, sth. serious is wrong */</comment>
		<if_stmt><if>if <condition>(<expr><name>placeholder</name> <operator>==</operator> <name>client</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						 <argument><expr><literal type="string">"ic-proxy: %s: unregistered client found in the client table"</literal></expr></argument>,
						 <argument><expr><call><name>ic_proxy_client_get_name</name><argument_list>(<argument><expr><name>client</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>placeholder</name><operator>-&gt;</operator><name>state</name></name> <operator>&amp;</operator> <name>IC_PROXY_CLIENT_STATE_PLACEHOLDER</name><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * it's the client of last statement, for example in the query
			 * "alter table set distributed by", it contains multiple
			 * statements, some of them share the same command id.
			 *
			 * TODO: we believe the old one is shutting down, but what if not?
			 */</comment>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
						 <argument><expr><literal type="string">"ic-proxy: %s: delay the register as the previous client is still shutting down"</literal></expr></argument>,
						 <argument><expr><call><name>ic_proxy_client_get_name</name><argument_list>(<argument><expr><name>client</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* this should never happen, if it does, sth. serious is wrong */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>placeholder</name><operator>-&gt;</operator><name>successor</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							 <argument><expr><literal type="string">"ic-proxy: %s: the previous client already has a successor"</literal></expr></argument>,
							 <argument><expr><call><name>ic_proxy_client_get_name</name><argument_list>(<argument><expr><name>client</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * register client as a successor, it will be actually registered
			 * when the placeholder unregister.
			 */</comment>
			<expr_stmt><expr><name><name>placeholder</name><operator>-&gt;</operator><name>successor</name></name> <operator>=</operator> <name>client</name></expr>;</expr_stmt>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* it's a placeholder, this happens if the pkts arrived before me */</comment>
		<expr_stmt><expr><call><name>elogif</name><argument_list>(<argument><expr><name>gp_log_interconnect</name> <operator>&gt;=</operator> <name>GPVARS_VERBOSITY_DEBUG</name></expr></argument>, <argument><expr><name>DEBUG3</name></expr></argument>,
			   <argument><expr><literal type="string">"ic-proxy: %s: replace my placeholder %s"</literal></expr></argument>,
					 <argument><expr><call><name>ic_proxy_client_get_name</name><argument_list>(<argument><expr><name>client</name></expr></argument>)</argument_list></call></expr></argument>,
					 <argument><expr><call><name>ic_proxy_client_get_name</name><argument_list>(<argument><expr><name>placeholder</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * the only purpose of a placeholder is to save the early coming
		 * pkts, there should be no chance for it to be empty; but in case
		 * it really happens, don't panic, nothing serious.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>placeholder</name><operator>-&gt;</operator><name>pkts</name></name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elogif</name><argument_list>(<argument><expr><name>gp_log_interconnect</name> <operator>&gt;=</operator> <name>GPVARS_VERBOSITY_DEBUG</name></expr></argument>, <argument><expr><name>DEBUG3</name></expr></argument>,
				   <argument><expr><literal type="string">"ic-proxy: %s: no cached pkts in the placeholder %s"</literal></expr></argument>,
						 <argument><expr><call><name>ic_proxy_client_get_name</name><argument_list>(<argument><expr><name>client</name></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><call><name>ic_proxy_client_get_name</name><argument_list>(<argument><expr><name>placeholder</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* replace the placeholder / legacy client */</comment>
		<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>client</name></name> <operator>=</operator> <name>client</name></expr>;</expr_stmt>

		<comment type="block">/* transfer the cached pkts */</comment>
		<expr_stmt><expr><call><name>ic_proxy_client_cache_p2c_pkts</name><argument_list>(<argument><expr><name>client</name></expr></argument>, <argument><expr><name><name>placeholder</name><operator>-&gt;</operator><name>pkts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>placeholder</name><operator>-&gt;</operator><name>pkts</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>placeholder</name><operator>-&gt;</operator><name>state</name></name> <operator>&amp;</operator> <name>IC_PROXY_CLIENT_STATE_PLACEHOLDER</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * need to free the placeholder, but no need to unregister it as we
			 * replaced it already.  The placeholder has nothing more than
			 * itself, so free it directly.
			 */</comment>
			<expr_stmt><expr><call><name>ic_proxy_free</name><argument_list>(<argument><expr><name>placeholder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>elogif</name><argument_list>(<argument><expr><name>gp_log_interconnect</name> <operator>&gt;=</operator> <name>GPVARS_VERBOSITY_DEBUG</name></expr></argument>, <argument><expr><name>DEBUG5</name></expr></argument>,
				   <argument><expr><literal type="string">"%s: freed my placeholder"</literal></expr></argument>,
						 <argument><expr><call><name>ic_proxy_client_get_name</name><argument_list>(<argument><expr><name>client</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>client</name></name> <operator>=</operator> <name>client</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name><name>client</name><operator>-&gt;</operator><name>state</name></name> <operator>|=</operator> <name>IC_PROXY_CLIENT_STATE_REGISTERED</name></expr>;</expr_stmt>

	<comment type="block">/* clear the name so we could show the new name */</comment>
	<expr_stmt><expr><call><name>ic_proxy_client_clear_name</name><argument_list>(<argument><expr><name>client</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>elogif</name><argument_list>(<argument><expr><name>gp_log_interconnect</name> <operator>&gt;=</operator> <name>GPVARS_VERBOSITY_VERBOSE</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>,
		   <argument><expr><literal type="string">"ic-proxy: %s: registered, %ld in total"</literal></expr></argument>,
				 <argument><expr><call><name>ic_proxy_client_get_name</name><argument_list>(<argument><expr><name>client</name></expr></argument>)</argument_list></call></expr></argument>,
				 <argument><expr><call><name>hash_get_num_entries</name><argument_list>(<argument><expr><name>ic_proxy_clients</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Unregister a client.
 *
 * If it has a successor, trigger its registration.
 *
 * If there are still unhandled pkts, transfer them to the successor or the
 * placeholder.  This happens on loopback connections, due to the limitation of
 * the delayed delivery, pkts can be pushed to a p2c shutting/shutted client,
 * these pkts belong to the next subplan in the same query.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ic_proxy_client_unregister</name><parameter_list>(<parameter><decl><type><name>ICProxyClient</name> <modifier>*</modifier></type><name>client</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>client</name><operator>-&gt;</operator><name>state</name></name> <operator>&amp;</operator> <name>IC_PROXY_CLIENT_STATE_REGISTERED</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>hash_search</name><argument_list>(<argument><expr><name>ic_proxy_clients</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>client</name><operator>-&gt;</operator><name>key</name></name></expr></argument>, <argument><expr><name>HASH_REMOVE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>client</name><operator>-&gt;</operator><name>state</name></name> <operator>&amp;=</operator> <operator>~</operator><name>IC_PROXY_CLIENT_STATE_REGISTERED</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>elogif</name><argument_list>(<argument><expr><name>gp_log_interconnect</name> <operator>&gt;=</operator> <name>GPVARS_VERBOSITY_VERBOSE</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>,
		   <argument><expr><literal type="string">"ic-proxy: %s: unregistered, %ld in total"</literal></expr></argument>,
				 <argument><expr><call><name>ic_proxy_client_get_name</name><argument_list>(<argument><expr><name>client</name></expr></argument>)</argument_list></call></expr></argument>,
				 <argument><expr><call><name>hash_get_num_entries</name><argument_list>(<argument><expr><name>ic_proxy_clients</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>client</name><operator>-&gt;</operator><name>successor</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ICProxyClient</name> <modifier>*</modifier></type><name>successor</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>successor</name> <operator>=</operator> <name><name>client</name><operator>-&gt;</operator><name>successor</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>client</name><operator>-&gt;</operator><name>successor</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>client</name><operator>-&gt;</operator><name>pkts</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>elogif</name><argument_list>(<argument><expr><name>gp_log_interconnect</name> <operator>&gt;=</operator> <name>GPVARS_VERBOSITY_DEBUG</name></expr></argument>, <argument><expr><name>DEBUG3</name></expr></argument>,
				   <argument><expr><literal type="string">"%s: transfer %d unhandled pkts to my successor"</literal></expr></argument>,
						 <argument><expr><call><name>ic_proxy_client_get_name</name><argument_list>(<argument><expr><name>client</name></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>client</name><operator>-&gt;</operator><name>pkts</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>ic_proxy_client_cache_p2c_pkts</name><argument_list>(<argument><expr><name>successor</name></expr></argument>, <argument><expr><name><name>client</name><operator>-&gt;</operator><name>pkts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>client</name><operator>-&gt;</operator><name>pkts</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>elogif</name><argument_list>(<argument><expr><name>gp_log_interconnect</name> <operator>&gt;=</operator> <name>GPVARS_VERBOSITY_VERBOSE</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>,
			   <argument><expr><literal type="string">"%s: re-register my successor"</literal></expr></argument>,
					 <argument><expr><call><name>ic_proxy_client_get_name</name><argument_list>(<argument><expr><name>client</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* the successor must have not registered */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><operator>(</operator><name><name>successor</name><operator>-&gt;</operator><name>state</name></name> <operator>&amp;</operator> <name>IC_PROXY_CLIENT_STATE_REGISTERED</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ic_proxy_client_register</name><argument_list>(<argument><expr><name>successor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* the successor must have successfully registered */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>successor</name><operator>-&gt;</operator><name>state</name></name> <operator>&amp;</operator> <name>IC_PROXY_CLIENT_STATE_REGISTERED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ic_proxy_client_maybe_start_read_data</name><argument_list>(<argument><expr><name>successor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>client</name><operator>-&gt;</operator><name>pkts</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ICProxyClient</name> <modifier>*</modifier></type><name>placeholder</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>elogif</name><argument_list>(<argument><expr><name>gp_log_interconnect</name> <operator>&gt;=</operator> <name>GPVARS_VERBOSITY_DEBUG</name></expr></argument>, <argument><expr><name>DEBUG3</name></expr></argument>,
			   <argument><expr><literal type="string">"%s: transfer %d unhandled pkts to my placeholder"</literal></expr></argument>,
					 <argument><expr><call><name>ic_proxy_client_get_name</name><argument_list>(<argument><expr><name>client</name></expr></argument>)</argument_list></call></expr></argument>,
					 <argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>client</name><operator>-&gt;</operator><name>pkts</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>placeholder</name> <operator>=</operator> <call><name>ic_proxy_client_new</name><argument_list>(<argument><expr><name><name>client</name><operator>-&gt;</operator><name>pipe</name><operator>.</operator><name>loop</name></name></expr></argument>,
										  <argument><expr><name>true</name></expr></argument> <comment type="block">/* placeholder */</comment>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>placeholder</name><operator>-&gt;</operator><name>key</name></name> <operator>=</operator> <name><name>client</name><operator>-&gt;</operator><name>key</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ic_proxy_client_register</name><argument_list>(<argument><expr><name>placeholder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ic_proxy_client_cache_p2c_pkts</name><argument_list>(<argument><expr><name>placeholder</name></expr></argument>, <argument><expr><name><name>client</name><operator>-&gt;</operator><name>pkts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>client</name><operator>-&gt;</operator><name>pkts</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Look up a client with a key.
 */</comment>
<function><type><specifier>static</specifier> <name>ICProxyClient</name> <modifier>*</modifier></type>
<name>ic_proxy_client_lookup</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ICProxyKey</name> <modifier>*</modifier></type><name>key</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ICProxyClientEntry</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>entry</name> <operator>=</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>ic_proxy_clients</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>HASH_FIND</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><ternary><condition><expr><name>found</name></expr> ?</condition><then> <expr><name><name>entry</name><operator>-&gt;</operator><name>client</name></name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Look up a client with a key, create a placeholder if not found.
 */</comment>
<function><type><name>ICProxyClient</name> <modifier>*</modifier></type>
<name>ic_proxy_client_blessed_lookup</name><parameter_list>(<parameter><decl><type><name>uv_loop_t</name> <modifier>*</modifier></type><name>loop</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ICProxyKey</name> <modifier>*</modifier></type><name>key</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ICProxyClient</name> <modifier>*</modifier></type><name>client</name> <init>= <expr><call><name>ic_proxy_client_lookup</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>client</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>client</name> <operator>=</operator> <call><name>ic_proxy_client_new</name><argument_list>(<argument><expr><name>loop</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>client</name><operator>-&gt;</operator><name>key</name></name> <operator>=</operator> <operator>*</operator><name>key</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ic_proxy_client_register</name><argument_list>(<argument><expr><name>client</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>elogif</name><argument_list>(<argument><expr><name>gp_log_interconnect</name> <operator>&gt;=</operator> <name>GPVARS_VERBOSITY_DEBUG</name></expr></argument>, <argument><expr><name>DEBUG3</name></expr></argument>,
			   <argument><expr><literal type="string">"ic-proxy: %s: registered as a placeholder"</literal></expr></argument>,
					 <argument><expr><call><name>ic_proxy_client_get_name</name><argument_list>(<argument><expr><name>client</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>client</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Pass a c2p packet to the router.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ic_proxy_client_route_c2p_data</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>opaque</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>uint16</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>ICProxyPkt</name> <modifier>*</modifier></type><name>pkt</name> <init>= <expr><name>data</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ICProxyClient</name> <modifier>*</modifier></type><name>client</name> <init>= <expr><name>opaque</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>ic_proxy_pkt_is_from_client</name><argument_list>(<argument><expr><name>pkt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>client</name><operator>-&gt;</operator><name>key</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>ic_proxy_pkt_is_live</name><argument_list>(<argument><expr><name>pkt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>client</name><operator>-&gt;</operator><name>key</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ic_proxy_router_route</name><argument_list>(<argument><expr><name><name>client</name><operator>-&gt;</operator><name>pipe</name><operator>.</operator><name>loop</name></name></expr></argument>, <argument><expr><call><name>ic_proxy_pkt_dup</name><argument_list>(<argument><expr><name>pkt</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Received a complete c2p packet.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ic_proxy_client_on_c2p_data_pkt</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>opaque</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>uint16</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ICProxyClient</name> <modifier>*</modifier></type><name>client</name> <init>= <expr><name>opaque</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>elogif</name><argument_list>(<argument><expr><name>gp_log_interconnect</name> <operator>&gt;=</operator> <name>GPVARS_VERBOSITY_DEBUG</name></expr></argument>, <argument><expr><name>DEBUG5</name></expr></argument>,
		   <argument><expr><literal type="string">"ic-proxy: %s: received B2C PKT [%d bytes] from the backend"</literal></expr></argument>,
				 <argument><expr><call><name>ic_proxy_client_get_name</name><argument_list>(<argument><expr><name>client</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* increase the number of unack packets */</comment>
	<expr_stmt><expr><name><name>client</name><operator>-&gt;</operator><name>unackSendPkt</name></name><operator>++</operator></expr>;</expr_stmt>

	<comment type="block">/* check whether pause threshold is reached */</comment>
	<expr_stmt><expr><call><name>ic_proxy_client_maybe_pause</name><argument_list>(<argument><expr><name>client</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Send it out, but maybe not immediately.  The obuf helps to merge small
	 * packets into large ones, which reduces the network overhead
	 * significantly.
	 */</comment>
	<expr_stmt><expr><call><name>ic_proxy_obuf_push</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>client</name><operator>-&gt;</operator><name>obuf</name></name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>size</name></expr></argument>,
					   <argument><expr><name>ic_proxy_client_route_c2p_data</name></expr></argument>, <argument><expr><name>client</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Received c2p data, or events (error, eof).
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ic_proxy_client_on_c2p_data</name><parameter_list>(<parameter><decl><type><name>uv_stream_t</name> <modifier>*</modifier></type><name>stream</name></decl></parameter>,
							<parameter><decl><type><name>ssize_t</name></type> <name>nread</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>uv_buf_t</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ICProxyClient</name> <modifier>*</modifier></type><name>client</name> <init>= <expr><call><name>CONTAINER_OF</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>stream</name></expr></argument>, <argument><expr><name>ICProxyClient</name></expr></argument>, <argument><expr><name>pipe</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name>nread</name> <operator>&lt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>nread</name> <operator>!=</operator> <name>UV_EOF</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"ic-proxy: %s: fail to receive c2p DATA: %s"</literal></expr></argument>,
						 <argument><expr><call><name>ic_proxy_client_get_name</name><argument_list>(<argument><expr><name>client</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>uv_strerror</name><argument_list>(<argument><expr><name>nread</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elogif</name><argument_list>(<argument><expr><name>gp_log_interconnect</name> <operator>&gt;=</operator> <name>GPVARS_VERBOSITY_VERBOSE</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>,
				   <argument><expr><literal type="string">"ic-proxy: %s: received EOF while waiting for c2p DATA"</literal></expr></argument>,
						 <argument><expr><call><name>ic_proxy_client_get_name</name><argument_list>(<argument><expr><name>client</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>buf</name><operator>-&gt;</operator><name>base</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ic_proxy_pkt_cache_free</name><argument_list>(<argument><expr><name><name>buf</name><operator>-&gt;</operator><name>base</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * If a backend shuts down normally the ibuf should be empty, or
		 * contains exactly 1 byte, the STOP message.  However it's possible
		 * that the backend shuts down due to exception, in such a case there
		 * can be any amount of data left in the ibuf.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>client</name><operator>-&gt;</operator><name>ibuf</name><operator>.</operator><name>len</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>elogif</name><argument_list>(<argument><expr><name>gp_log_interconnect</name> <operator>&gt;=</operator> <name>GPVARS_VERBOSITY_VERBOSE</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>,
						 <argument><expr><literal type="string">"ic-proxy: %s: the ibuf still contains %d bytes,"</literal>
						 <literal type="string">" flush before shutting down"</literal></expr></argument>,
						 <argument><expr><call><name>ic_proxy_client_get_name</name><argument_list>(<argument><expr><name>client</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>client</name><operator>-&gt;</operator><name>ibuf</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>ic_proxy_ibuf_push</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>client</name><operator>-&gt;</operator><name>ibuf</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
							   <argument><expr><name>ic_proxy_client_on_c2p_data_pkt</name></expr></argument>, <argument><expr><name>client</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* flush unsent data */</comment>
		<expr_stmt><expr><call><name>ic_proxy_obuf_push</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>client</name><operator>-&gt;</operator><name>obuf</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
						   <argument><expr><name>ic_proxy_client_route_c2p_data</name></expr></argument>, <argument><expr><name>client</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* stop reading from the backend */</comment>
		<expr_stmt><expr><call><name>uv_read_stop</name><argument_list>(<argument><expr><operator>(</operator><name>uv_stream_t</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>client</name><operator>-&gt;</operator><name>pipe</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* inform the other side of the logical connection to close, too */</comment>
		<expr_stmt><expr><call><name>ic_proxy_client_shutdown_c2p</name><argument_list>(<argument><expr><name>client</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name>nread</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>buf</name><operator>-&gt;</operator><name>base</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ic_proxy_pkt_cache_free</name><argument_list>(<argument><expr><name><name>buf</name><operator>-&gt;</operator><name>base</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* EAGAIN or EWOULDBLOCK, retry */</comment>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* TODO: Will this really happen? */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>client</name><operator>-&gt;</operator><name>state</name></name> <operator>&amp;</operator> <name>IC_PROXY_CLIENT_STATE_PAUSED</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					 <argument><expr><literal type="string">"ic-proxy: %s: paused already, but still received DATA[%zd bytes] from the backend, state is 0x%08x"</literal></expr></argument>,
					 <argument><expr><call><name>ic_proxy_client_get_name</name><argument_list>(<argument><expr><name>client</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>nread</name></expr></argument>, <argument><expr><name><name>client</name><operator>-&gt;</operator><name>state</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>elogif</name><argument_list>(<argument><expr><name>gp_log_interconnect</name> <operator>&gt;=</operator> <name>GPVARS_VERBOSITY_DEBUG</name></expr></argument>, <argument><expr><name>DEBUG5</name></expr></argument>,
		   <argument><expr><literal type="string">"%s: received DATA[%zd bytes] from the backend"</literal></expr></argument>,
				 <argument><expr><call><name>ic_proxy_client_get_name</name><argument_list>(<argument><expr><name>client</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>nread</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * The c2p data needs to be handled as packets, the ibuf helps to find the
	 * boundaries.
	 */</comment>
	<expr_stmt><expr><call><name>ic_proxy_ibuf_push</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>client</name><operator>-&gt;</operator><name>ibuf</name></name></expr></argument>, <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>base</name></name></expr></argument>, <argument><expr><name>nread</name></expr></argument>,
					   <argument><expr><name>ic_proxy_client_on_c2p_data_pkt</name></expr></argument>, <argument><expr><name>client</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ic_proxy_pkt_cache_free</name><argument_list>(<argument><expr><name><name>buf</name><operator>-&gt;</operator><name>base</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Start reading from backend if the client is successfully registered.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ic_proxy_client_maybe_start_read_data</name><parameter_list>(<parameter><decl><type><name>ICProxyClient</name> <modifier>*</modifier></type><name>client</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>client</name><operator>-&gt;</operator><name>state</name></name> <operator>&amp;</operator> <name>IC_PROXY_CLIENT_STATE_REGISTERED</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<comment type="block">/*
		 * the register is delayed as the previous client is still shutting
		 * down, do not send the ACK until that's done.
		 */</comment>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>elogif</name><argument_list>(<argument><expr><name>gp_log_interconnect</name> <operator>&gt;=</operator> <name>GPVARS_VERBOSITY_DEBUG</name></expr></argument>, <argument><expr><name>DEBUG3</name></expr></argument>,
		   <argument><expr><literal type="string">"ic-proxy: %s: start receiving DATA"</literal></expr></argument>,
				 <argument><expr><call><name>ic_proxy_client_get_name</name><argument_list>(<argument><expr><name>client</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* since now on, the client and backend communicate only via b2c packets */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>ic_proxy_ibuf_empty</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>client</name><operator>-&gt;</operator><name>ibuf</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ic_proxy_ibuf_uninit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>client</name><operator>-&gt;</operator><name>ibuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ic_proxy_ibuf_init_b2c</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>client</name><operator>-&gt;</operator><name>ibuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* and do not forget to init the obuf header */</comment>
	<expr_stmt><expr><call><name>ic_proxy_message_init</name><argument_list>(<argument><expr><call><name>ic_proxy_obuf_ensure_buffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>client</name><operator>-&gt;</operator><name>obuf</name></name></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>client</name><operator>-&gt;</operator><name>key</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ASSERT_CHECKING</name></cpp:ifdef>
	<comment type="block">/*
	 * this should never happen because no p2c pkt is handled yet, the early
	 * coming pkts are in the cache list, we are just going to handle them.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>client</name><operator>-&gt;</operator><name>state</name></name> <operator>&amp;</operator>
		<operator>(</operator><name>IC_PROXY_CLIENT_STATE_C2P_SHUTTING</name> <operator>|</operator>
		 <name>IC_PROXY_CLIENT_STATE_P2C_SHUTTING</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
					 <argument><expr><literal type="string">"ic-proxy: %s: state=0x%08x: unexpected shutting down in progress"</literal></expr></argument>,
					 <argument><expr><call><name>ic_proxy_client_get_name</name><argument_list>(<argument><expr><name>client</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>client</name><operator>-&gt;</operator><name>state</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_ASSERT_CHECKING */</comment>

	<comment type="block">/*
	 * now it's time to receive the normal data, it is important to start the
	 * reading before handling the cached pkts, so if the cached pkts contain
	 * the BYE we could stop the reading in time.
	 */</comment>
	<expr_stmt><expr><call><name>ic_proxy_client_read_data</name><argument_list>(<argument><expr><name>client</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ic_proxy_client_handle_p2c_cache</name><argument_list>(<argument><expr><name>client</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * The HELLO ACK is sent out.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ic_proxy_client_on_sent_hello_ack</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>opaque</name></decl></parameter>,
								  <parameter><decl><type><specifier>const</specifier> <name>ICProxyPkt</name> <modifier>*</modifier></type><name>pkt</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>status</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ICProxyClient</name> <modifier>*</modifier></type><name>client</name> <init>= <expr><name>opaque</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>status</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ic_proxy_client_shutdown_p2c</name><argument_list>(<argument><expr><name>client</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>client</name><operator>-&gt;</operator><name>state</name></name> <operator>|=</operator> <name>IC_PROXY_CLIENT_STATE_SENT_HELLO_ACK</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ic_proxy_client_register</name><argument_list>(<argument><expr><name>client</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ic_proxy_client_maybe_start_read_data</name><argument_list>(<argument><expr><name>client</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Received the complete HELLO message.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ic_proxy_client_on_hello_pkt</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>opaque</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>uint16</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>ICProxyPkt</name> <modifier>*</modifier></type><name>pkt</name> <init>= <expr><name>data</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ICProxyClient</name> <modifier>*</modifier></type><name>client</name> <init>= <expr><name>opaque</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ICProxyKey</name></type>	<name>key</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ICProxyPkt</name> <modifier>*</modifier></type><name>ackpkt</name></decl>;</decl_stmt>

	<comment type="block">/* we only expect one HELLO message */</comment>
	<expr_stmt><expr><call><name>uv_read_stop</name><argument_list>(<argument><expr><operator>(</operator><name>uv_stream_t</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>client</name><operator>-&gt;</operator><name>pipe</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ic_proxy_pkt_is</name><argument_list>(<argument><expr><name>pkt</name></expr></argument>, <argument><expr><name>IC_PROXY_MESSAGE_HELLO</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"ic-proxy: %s: invalid %s"</literal></expr></argument>,
					 <argument><expr><call><name>ic_proxy_client_get_name</name><argument_list>(<argument><expr><name>client</name></expr></argument>)</argument_list></call></expr></argument>,
					 <argument><expr><call><name>ic_proxy_pkt_to_str</name><argument_list>(<argument><expr><name>pkt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ic_proxy_client_shutdown_p2c</name><argument_list>(<argument><expr><name>client</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>elogif</name><argument_list>(<argument><expr><name>gp_log_interconnect</name> <operator>&gt;=</operator> <name>GPVARS_VERBOSITY_DEBUG</name></expr></argument>, <argument><expr><name>DEBUG1</name></expr></argument>,
		   <argument><expr><literal type="string">"%s: received %s from the backend"</literal></expr></argument>,
				 <argument><expr><call><name>ic_proxy_client_get_name</name><argument_list>(<argument><expr><name>client</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>ic_proxy_pkt_to_str</name><argument_list>(<argument><expr><name>pkt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>client</name><operator>-&gt;</operator><name>state</name></name> <operator>|=</operator> <name>IC_PROXY_CLIENT_STATE_RECEIVED_HELLO</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ic_proxy_key_from_c2p_pkt</name><argument_list>(<argument><expr><operator>&amp;</operator><name>key</name></expr></argument>, <argument><expr><name>pkt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If we register before the HELLO ACK is sent, the peer has a chance to
	 * route data before HELLO ACK.  So we must register in the write callback.
	 */</comment>

	<expr_stmt><expr><name><name>client</name><operator>-&gt;</operator><name>key</name></name> <operator>=</operator> <name>key</name></expr>;</expr_stmt>

	<comment type="block">/* clear the name so we could show the new name */</comment>
	<expr_stmt><expr><call><name>ic_proxy_client_clear_name</name><argument_list>(<argument><expr><name>client</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* build a HELLO ACK */</comment>
	<expr_stmt><expr><call><name>ic_proxy_key_reverse</name><argument_list>(<argument><expr><operator>&amp;</operator><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ackpkt</name> <operator>=</operator> <call><name>ic_proxy_message_new</name><argument_list>(<argument><expr><name>IC_PROXY_MESSAGE_HELLO_ACK</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ic_proxy_router_write</name><argument_list>(<argument><expr><operator>(</operator><name>uv_stream_t</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>client</name><operator>-&gt;</operator><name>pipe</name></name></expr></argument>, <argument><expr><name>ackpkt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
						  <argument><expr><name>ic_proxy_client_on_sent_hello_ack</name></expr></argument>, <argument><expr><name>client</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Received the HELLO message, maybe only part of.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ic_proxy_client_on_hello_data</name><parameter_list>(<parameter><decl><type><name>uv_stream_t</name> <modifier>*</modifier></type><name>stream</name></decl></parameter>,
							  <parameter><decl><type><name>ssize_t</name></type> <name>nread</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>uv_buf_t</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ICProxyClient</name> <modifier>*</modifier></type><name>client</name> <init>= <expr><call><name>CONTAINER_OF</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>stream</name></expr></argument>, <argument><expr><name>ICProxyClient</name></expr></argument>, <argument><expr><name>pipe</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name>nread</name> <operator>&lt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>nread</name> <operator>!=</operator> <name>UV_EOF</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"ic-proxy: %s: fail to receive HELLO: %s"</literal></expr></argument>,
						 <argument><expr><call><name>ic_proxy_client_get_name</name><argument_list>(<argument><expr><name>client</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>uv_strerror</name><argument_list>(<argument><expr><name>nread</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elogif</name><argument_list>(<argument><expr><name>gp_log_interconnect</name> <operator>&gt;=</operator> <name>GPVARS_VERBOSITY_VERBOSE</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>,
				   <argument><expr><literal type="string">"ic-proxy: %s: received EOF while waiting for HELLO"</literal></expr></argument>,
						 <argument><expr><call><name>ic_proxy_client_get_name</name><argument_list>(<argument><expr><name>client</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>buf</name><operator>-&gt;</operator><name>base</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ic_proxy_pkt_cache_free</name><argument_list>(<argument><expr><name><name>buf</name><operator>-&gt;</operator><name>base</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"ic-proxy: %s, failed to receive HELLO"</literal></expr></argument>,
					 <argument><expr><call><name>ic_proxy_client_get_name</name><argument_list>(<argument><expr><name>client</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* 
		 * Pending data in a failed handshake is useless,
		 * no need to call shutdown() explicitly.
		 */</comment>
		<expr_stmt><expr><call><name>ic_proxy_client_close</name><argument_list>(<argument><expr><name>client</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name>nread</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>buf</name><operator>-&gt;</operator><name>base</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ic_proxy_pkt_cache_free</name><argument_list>(<argument><expr><name><name>buf</name><operator>-&gt;</operator><name>base</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* EAGAIN or EWOULDBLOCK, retry */</comment>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Hand shaking is done via p2p packets */</comment>
	<expr_stmt><expr><call><name>ic_proxy_ibuf_push</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>client</name><operator>-&gt;</operator><name>ibuf</name></name></expr></argument>, <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>base</name></name></expr></argument>, <argument><expr><name>nread</name></expr></argument>,
					   <argument><expr><name>ic_proxy_client_on_hello_pkt</name></expr></argument>, <argument><expr><name>client</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ic_proxy_pkt_cache_free</name><argument_list>(<argument><expr><name><name>buf</name><operator>-&gt;</operator><name>base</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Start reading the HELLO message.
 */</comment>
<function><type><name>int</name></type>
<name>ic_proxy_client_read_hello</name><parameter_list>(<parameter><decl><type><name>ICProxyClient</name> <modifier>*</modifier></type><name>client</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* start reading the HELLO message */</comment>
	<return>return <expr><call><name>uv_read_start</name><argument_list>(<argument><expr><operator>(</operator><name>uv_stream_t</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>client</name><operator>-&gt;</operator><name>pipe</name></name></expr></argument>,
						 <argument><expr><name>ic_proxy_pkt_cache_alloc_buffer</name></expr></argument>,
						 <argument><expr><name>ic_proxy_client_on_hello_data</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Start reading the DATA.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ic_proxy_client_read_data</name><parameter_list>(<parameter><decl><type><name>ICProxyClient</name> <modifier>*</modifier></type><name>client</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>ret</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>uv_read_start</name><argument_list>(<argument><expr><operator>(</operator><name>uv_stream_t</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>client</name><operator>-&gt;</operator><name>pipe</name></name></expr></argument>,
						<argument><expr><name>ic_proxy_pkt_cache_alloc_buffer</name></expr></argument>,
						<argument><expr><name>ic_proxy_client_on_c2p_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"ic-proxy: %s: state=0x%08x: fail to start reading data: %s"</literal></expr></argument>,
					 <argument><expr><call><name>ic_proxy_client_get_name</name><argument_list>(<argument><expr><name>client</name></expr></argument>)</argument_list></call></expr></argument>,
					 <argument><expr><name><name>client</name><operator>-&gt;</operator><name>state</name></name></expr></argument>, <argument><expr><call><name>uv_strerror</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ic_proxy_client_shutdown_c2p</name><argument_list>(<argument><expr><name>client</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Get the client name.
 *
 * The name is constructed from the state lazily.  When the state gets changed,
 * call ic_proxy_client_clear_name() to clear the name, so we could reconstruct
 * the name from the new state.
 */</comment>
<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>ic_proxy_client_get_name</name><parameter_list>(<parameter><decl><type><name>ICProxyClient</name> <modifier>*</modifier></type><name>client</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name><name>client</name><operator>-&gt;</operator><name>name</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>uint32</name></type>		<name>namesize</name> <init>= <expr><name>IC_PROXY_CLIENT_NAME_SIZE</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>keystr</name> <init>= <expr><literal type="string">""</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>suffix</name> <init>= <expr><literal type="string">""</literal></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>client</name><operator>-&gt;</operator><name>state</name></name> <operator>&amp;</operator> <name>IC_PROXY_CLIENT_STATE_REGISTERED</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>keystr</name> <operator>=</operator> <call><name>ic_proxy_key_to_str</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>client</name><operator>-&gt;</operator><name>key</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>client</name><operator>-&gt;</operator><name>state</name></name> <operator>&amp;</operator> <name>IC_PROXY_CLIENT_STATE_PLACEHOLDER</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>suffix</name> <operator>=</operator> <literal type="string">".placeholder"</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>client</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <call><name>ic_proxy_alloc</name><argument_list>(<argument><expr><name>namesize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name><name>client</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>namesize</name></expr></argument>, <argument><expr><literal type="string">"client%s%s"</literal></expr></argument>, <argument><expr><name>suffix</name></expr></argument>, <argument><expr><name>keystr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name><name>client</name><operator>-&gt;</operator><name>name</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ic_proxy_client_clear_name</name><parameter_list>(<parameter><decl><type><name>ICProxyClient</name> <modifier>*</modifier></type><name>client</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>client</name><operator>-&gt;</operator><name>name</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ic_proxy_free</name><argument_list>(<argument><expr><name><name>client</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>client</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Return the libuv stream handle of a client.
 */</comment>
<function><type><name>uv_stream_t</name> <modifier>*</modifier></type>
<name>ic_proxy_client_get_stream</name><parameter_list>(<parameter><decl><type><name>ICProxyClient</name> <modifier>*</modifier></type><name>client</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><operator>(</operator><name>uv_stream_t</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>client</name><operator>-&gt;</operator><name>pipe</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><name>ICProxyClient</name> <modifier>*</modifier></type>
<name>ic_proxy_client_new</name><parameter_list>(<parameter><decl><type><name>uv_loop_t</name> <modifier>*</modifier></type><name>loop</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>placeholder</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ICProxyClient</name> <modifier>*</modifier></type><name>client</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>client</name> <operator>=</operator> <call><name>ic_proxy_new</name><argument_list>(<argument><expr><name>ICProxyClient</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>uv_pipe_init</name><argument_list>(<argument><expr><name>loop</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>client</name><operator>-&gt;</operator><name>pipe</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>client</name><operator>-&gt;</operator><name>pkts</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>client</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>client</name><operator>-&gt;</operator><name>unconsumed</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>client</name><operator>-&gt;</operator><name>sending</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>client</name><operator>-&gt;</operator><name>unackSendPkt</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>client</name><operator>-&gt;</operator><name>unackRecvPkt</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>client</name><operator>-&gt;</operator><name>successor</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>client</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ic_proxy_obuf_init_p2p</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>client</name><operator>-&gt;</operator><name>obuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* hand shaking messages are in the p2p format */</comment>
	<expr_stmt><expr><call><name>ic_proxy_ibuf_init_p2p</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>client</name><operator>-&gt;</operator><name>ibuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>placeholder</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>client</name><operator>-&gt;</operator><name>state</name></name> <operator>|=</operator> <name>IC_PROXY_CLIENT_STATE_PLACEHOLDER</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>client</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Free a non-placeholder client.
 *
 * The placeholders are free()'ed directly in ic_proxy_client_register(), only
 * the non-placeholder clients will need this function.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ic_proxy_client_free</name><parameter_list>(<parameter><decl><type><name>ICProxyClient</name> <modifier>*</modifier></type><name>client</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>elogif</name><argument_list>(<argument><expr><name>gp_log_interconnect</name> <operator>&gt;=</operator> <name>GPVARS_VERBOSITY_DEBUG</name></expr></argument>, <argument><expr><name>DEBUG5</name></expr></argument>,
		   <argument><expr><literal type="string">"ic-proxy: %s: freeing"</literal></expr></argument>, <argument><expr><call><name>ic_proxy_client_get_name</name><argument_list>(<argument><expr><name>client</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * This should not happen, but in case it happens we want to leave a
	 * message in the logs to help us understand why.
	 */</comment>
	<expr_stmt><expr><call><name>ic_proxy_client_drop_p2c_cache</name><argument_list>(<argument><expr><name>client</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ic_proxy_obuf_uninit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>client</name><operator>-&gt;</operator><name>obuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ic_proxy_ibuf_uninit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>client</name><operator>-&gt;</operator><name>ibuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>client</name><operator>-&gt;</operator><name>successor</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ic_proxy_client_clear_name</name><argument_list>(<argument><expr><name>client</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ic_proxy_free</name><argument_list>(<argument><expr><name>client</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * The client is closed.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ic_proxy_client_on_close</name><parameter_list>(<parameter><decl><type><name>uv_handle_t</name> <modifier>*</modifier></type><name>handle</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ICProxyClient</name> <modifier>*</modifier></type><name>client</name> <init>= <expr><call><name>CONTAINER_OF</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>handle</name></expr></argument>, <argument><expr><name>ICProxyClient</name></expr></argument>, <argument><expr><name>pipe</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>client</name><operator>-&gt;</operator><name>state</name></name> <operator>&amp;</operator> <name>IC_PROXY_CLIENT_STATE_CLOSED</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"ic-proxy: %s: double close"</literal></expr></argument>,
					 <argument><expr><call><name>ic_proxy_client_get_name</name><argument_list>(<argument><expr><name>client</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>client</name><operator>-&gt;</operator><name>state</name></name> <operator>|=</operator> <name>IC_PROXY_CLIENT_STATE_CLOSED</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>elogif</name><argument_list>(<argument><expr><name>gp_log_interconnect</name> <operator>&gt;=</operator> <name>GPVARS_VERBOSITY_VERBOSE</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"%s: closed"</literal></expr></argument>,
		   <argument><expr><call><name>ic_proxy_client_get_name</name><argument_list>(<argument><expr><name>client</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ic_proxy_client_free</name><argument_list>(<argument><expr><name>client</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Close a client.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ic_proxy_client_close</name><parameter_list>(<parameter><decl><type><name>ICProxyClient</name> <modifier>*</modifier></type><name>client</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>client</name><operator>-&gt;</operator><name>state</name></name> <operator>&amp;</operator> <name>IC_PROXY_CLIENT_STATE_CLOSING</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>client</name><operator>-&gt;</operator><name>state</name></name> <operator>|=</operator> <name>IC_PROXY_CLIENT_STATE_CLOSING</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ic_proxy_client_unregister</name><argument_list>(<argument><expr><name>client</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>elogif</name><argument_list>(<argument><expr><name>gp_log_interconnect</name> <operator>&gt;=</operator> <name>GPVARS_VERBOSITY_VERBOSE</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>,
		   <argument><expr><literal type="string">"ic-proxy: %s: closing"</literal></expr></argument>, <argument><expr><call><name>ic_proxy_client_get_name</name><argument_list>(<argument><expr><name>client</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>uv_close</name><argument_list>(<argument><expr><operator>(</operator><name>uv_handle_t</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>client</name><operator>-&gt;</operator><name>pipe</name></name></expr></argument>, <argument><expr><name>ic_proxy_client_on_close</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Close a client if it is ready to close.
 *
 * Where ready means below conditions are both met:
 * - no data or message pkts being sent;
 * - both c2p and p2c are shutted down;
 *
 * Return true if it is ready to close, false otherwise.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ic_proxy_client_maybe_close</name><parameter_list>(<parameter><decl><type><name>ICProxyClient</name> <modifier>*</modifier></type><name>client</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>bits</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>bits</name> <operator>|=</operator> <name>IC_PROXY_CLIENT_STATE_C2P_SHUTTED</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>bits</name> <operator>|=</operator> <name>IC_PROXY_CLIENT_STATE_P2C_SHUTTED</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>client</name><operator>-&gt;</operator><name>sending</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name><name>client</name><operator>-&gt;</operator><name>state</name></name> <operator>&amp;</operator> <name>bits</name><operator>)</operator> <operator>==</operator> <name>bits</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ic_proxy_client_close</name><argument_list>(<argument><expr><name>client</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Sent the c2p BYE message.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ic_proxy_client_on_sent_c2p_bye</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>opaque</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ICProxyPkt</name> <modifier>*</modifier></type><name>pkt</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>status</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ICProxyClient</name> <modifier>*</modifier></type><name>client</name> <init>= <expr><name>opaque</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>status</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Failed to send the c2p BYE, maybe the peer connection is already
		 * lost.  This can be safely ignored, we could just behave as it is
		 * sent out.
		 */</comment>
		<expr_stmt><expr><call><name>elogif</name><argument_list>(<argument><expr><name>gp_log_interconnect</name> <operator>&gt;=</operator> <name>GPVARS_VERBOSITY_VERBOSE</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>,
			   <argument><expr><literal type="string">"ic-proxy: %s: fail to shutdown c2p"</literal></expr></argument>,
					 <argument><expr><call><name>ic_proxy_client_get_name</name><argument_list>(<argument><expr><name>client</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * When we fail to send the BYE, should we trigger the shutdown_p2c
		 * process immediately?
		 */</comment>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>elogif</name><argument_list>(<argument><expr><name>gp_log_interconnect</name> <operator>&gt;=</operator> <name>GPVARS_VERBOSITY_VERBOSE</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>,
		   <argument><expr><literal type="string">"ic-proxy: %s: shutted down c2p"</literal></expr></argument>, <argument><expr><call><name>ic_proxy_client_get_name</name><argument_list>(<argument><expr><name>client</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>client</name><operator>-&gt;</operator><name>sending</name></name><operator>--</operator></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>client</name><operator>-&gt;</operator><name>state</name></name> <operator>|=</operator> <name>IC_PROXY_CLIENT_STATE_C2P_SHUTTED</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ic_proxy_client_maybe_close</name><argument_list>(<argument><expr><name>client</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Shutdown in c2p direction.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ic_proxy_client_shutdown_c2p</name><parameter_list>(<parameter><decl><type><name>ICProxyClient</name> <modifier>*</modifier></type><name>client</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Do not re-shutdown if we are already doing so or even have done */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>client</name><operator>-&gt;</operator><name>state</name></name> <operator>&amp;</operator> <name>IC_PROXY_CLIENT_STATE_C2P_SHUTTING</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ic_proxy_client_maybe_close</name><argument_list>(<argument><expr><name>client</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>elogif</name><argument_list>(<argument><expr><name>gp_log_interconnect</name> <operator>&gt;=</operator> <name>GPVARS_VERBOSITY_VERBOSE</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>,
		   <argument><expr><literal type="string">"ic-proxy: %s: shutting down c2p"</literal></expr></argument>,
				 <argument><expr><call><name>ic_proxy_client_get_name</name><argument_list>(<argument><expr><name>client</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>client</name><operator>-&gt;</operator><name>state</name></name> <operator>|=</operator> <name>IC_PROXY_CLIENT_STATE_C2P_SHUTTING</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>client</name><operator>-&gt;</operator><name>state</name></name> <operator>&amp;</operator> <name>IC_PROXY_CLIENT_STATE_REGISTERED</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * For a registered client, try to send a c2p BYE message to the
		 * remote.
		 */</comment>

		<decl_stmt><decl><type><name>ICProxyPkt</name> <modifier>*</modifier></type><name>pkt</name> <init>= <expr><call><name>ic_proxy_message_new</name><argument_list>(<argument><expr><name>IC_PROXY_MESSAGE_BYE</name></expr></argument>,
											   <argument><expr><operator>&amp;</operator><name><name>client</name><operator>-&gt;</operator><name>key</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>client</name><operator>-&gt;</operator><name>sending</name></name><operator>++</operator></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ic_proxy_router_route</name><argument_list>(<argument><expr><name><name>client</name><operator>-&gt;</operator><name>pipe</name><operator>.</operator><name>loop</name></name></expr></argument>, <argument><expr><name>pkt</name></expr></argument>,
							  <argument><expr><name>ic_proxy_client_on_sent_c2p_bye</name></expr></argument>, <argument><expr><name>client</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * For a non-registered client, simply behave as if there is a remote
		 * and it has received the BYE and sent back a P2C BYE.
		 */</comment>

		<expr_stmt><expr><call><name>elogif</name><argument_list>(<argument><expr><name>gp_log_interconnect</name> <operator>&gt;=</operator> <name>GPVARS_VERBOSITY_VERBOSE</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>,
			   <argument><expr><literal type="string">"ic-proxy: %s: shutted down c2p"</literal></expr></argument>,
					 <argument><expr><call><name>ic_proxy_client_get_name</name><argument_list>(<argument><expr><name>client</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>client</name><operator>-&gt;</operator><name>state</name></name> <operator>|=</operator> <name>IC_PROXY_CLIENT_STATE_C2P_SHUTTED</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ic_proxy_client_shutdown_p2c</name><argument_list>(<argument><expr><name>client</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Shutted down in p2c direction.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ic_proxy_client_on_shutdown_p2c</name><parameter_list>(<parameter><decl><type><name>uv_shutdown_t</name> <modifier>*</modifier></type><name>req</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>status</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ICProxyClient</name> <modifier>*</modifier></type><name>client</name> <init>= <expr><call><name>CONTAINER_OF</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name><name>req</name><operator>-&gt;</operator><name>handle</name></name></expr></argument>, <argument><expr><name>ICProxyClient</name></expr></argument>, <argument><expr><name>pipe</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ic_proxy_free</name><argument_list>(<argument><expr><name>req</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>status</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"ic-proxy: %s: fail to shutdown p2c: %s"</literal></expr></argument>,
					 <argument><expr><call><name>ic_proxy_client_get_name</name><argument_list>(<argument><expr><name>client</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>uv_strerror</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elogif</name><argument_list>(<argument><expr><name>gp_log_interconnect</name> <operator>&gt;=</operator> <name>GPVARS_VERBOSITY_VERBOSE</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>,
			   <argument><expr><literal type="string">"ic-proxy: %s: shutted down p2c"</literal></expr></argument>,
					 <argument><expr><call><name>ic_proxy_client_get_name</name><argument_list>(<argument><expr><name>client</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name><name>client</name><operator>-&gt;</operator><name>state</name></name> <operator>|=</operator> <name>IC_PROXY_CLIENT_STATE_P2C_SHUTTED</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ic_proxy_client_maybe_close</name><argument_list>(<argument><expr><name>client</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Shutdown in p2c direction.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ic_proxy_client_shutdown_p2c</name><parameter_list>(<parameter><decl><type><name>ICProxyClient</name> <modifier>*</modifier></type><name>client</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uv_shutdown_t</name> <modifier>*</modifier></type><name>req</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>client</name><operator>-&gt;</operator><name>state</name></name> <operator>&amp;</operator> <name>IC_PROXY_CLIENT_STATE_P2C_SHUTTING</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ic_proxy_client_maybe_close</name><argument_list>(<argument><expr><name>client</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>elogif</name><argument_list>(<argument><expr><name>gp_log_interconnect</name> <operator>&gt;=</operator> <name>GPVARS_VERBOSITY_VERBOSE</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>,
		   <argument><expr><literal type="string">"ic-proxy: %s: shutting down p2c"</literal></expr></argument>,
				 <argument><expr><call><name>ic_proxy_client_get_name</name><argument_list>(<argument><expr><name>client</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>client</name><operator>-&gt;</operator><name>state</name></name> <operator>|=</operator> <name>IC_PROXY_CLIENT_STATE_P2C_SHUTTING</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>req</name> <operator>=</operator> <call><name>ic_proxy_new</name><argument_list>(<argument><expr><name>uv_shutdown_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>uv_shutdown</name><argument_list>(<argument><expr><name>req</name></expr></argument>, <argument><expr><operator>(</operator><name>uv_stream_t</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>client</name><operator>-&gt;</operator><name>pipe</name></name></expr></argument>,
				<argument><expr><name>ic_proxy_client_on_shutdown_p2c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Sent c2p RESUME message.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ic_proxy_client_on_sent_c2p_resume</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>opaque</name></decl></parameter>,
								   <parameter><decl><type><specifier>const</specifier> <name>ICProxyPkt</name> <modifier>*</modifier></type><name>pkt</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>status</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ICProxyClient</name> <modifier>*</modifier></type><name>client</name> <init>= <expr><name>opaque</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>status</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * TODO: Fail to send the RESUME, should we retry instead of shutting
		 * down?
		 */</comment>
		<expr_stmt><expr><call><name>ic_proxy_client_shutdown_p2c</name><argument_list>(<argument><expr><name>client</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>client</name><operator>-&gt;</operator><name>sending</name></name><operator>--</operator></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ic_proxy_client_maybe_close</name><argument_list>(<argument><expr><name>client</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Routed p2c DATA to the backend.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ic_proxy_client_on_sent_p2c_data</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>opaque</name></decl></parameter>,
								 <parameter><decl><type><specifier>const</specifier> <name>ICProxyPkt</name> <modifier>*</modifier></type><name>pkt</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>status</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ICProxyClient</name> <modifier>*</modifier></type><name>client</name> <init>= <expr><name>opaque</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* this could happen if the backend errored out */</comment>
	<if_stmt><if>if <condition>(<expr><name>status</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ic_proxy_client_shutdown_c2p</name><argument_list>(<argument><expr><name>client</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>client</name><operator>-&gt;</operator><name>unconsumed</name></name><operator>--</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>client</name><operator>-&gt;</operator><name>sending</name></name><operator>--</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>client</name><operator>-&gt;</operator><name>unackRecvPkt</name></name><operator>++</operator></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ic_proxy_client_maybe_send_ack_message</name><argument_list>(<argument><expr><name>client</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Received a complete p2c message.
 *
 * This should not be called by a placeholder.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ic_proxy_client_on_p2c_message</name><parameter_list>(<parameter><decl><type><name>ICProxyClient</name> <modifier>*</modifier></type><name>client</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ICProxyPkt</name> <modifier>*</modifier></type><name>pkt</name></decl></parameter>,
							   <parameter><decl><type><name>ic_proxy_sent_cb</name></type> <name>callback</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>opaque</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>ic_proxy_pkt_is</name><argument_list>(<argument><expr><name>pkt</name></expr></argument>, <argument><expr><name>IC_PROXY_MESSAGE_BYE</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elogif</name><argument_list>(<argument><expr><name>gp_log_interconnect</name> <operator>&gt;=</operator> <name>GPVARS_VERBOSITY_DEBUG</name></expr></argument>, <argument><expr><name>DEBUG1</name></expr></argument>,
			   <argument><expr><literal type="string">"ic-proxy: %s: received %s"</literal></expr></argument>,
					 <argument><expr><call><name>ic_proxy_client_get_name</name><argument_list>(<argument><expr><name>client</name></expr></argument>)</argument_list></call></expr></argument>,
					 <argument><expr><call><name>ic_proxy_pkt_to_str</name><argument_list>(<argument><expr><name>pkt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ic_proxy_client_maybe_resume</name><argument_list>(<argument><expr><name>client</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ic_proxy_client_shutdown_p2c</name><argument_list>(<argument><expr><name>client</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>ic_proxy_pkt_is</name><argument_list>(<argument><expr><name>pkt</name></expr></argument>, <argument><expr><name>IC_PROXY_MESSAGE_DATA_ACK</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elogif</name><argument_list>(<argument><expr><name>gp_log_interconnect</name> <operator>&gt;=</operator> <name>GPVARS_VERBOSITY_DEBUG</name></expr></argument>, <argument><expr><name>DEBUG3</name></expr></argument>,
			   <argument><expr><literal type="string">"ic-proxy: %s: received %s, with %d existing unack packets"</literal></expr></argument>,
					 <argument><expr><call><name>ic_proxy_client_get_name</name><argument_list>(<argument><expr><name>client</name></expr></argument>)</argument_list></call></expr></argument>,
					 <argument><expr><call><name>ic_proxy_pkt_to_str</name><argument_list>(<argument><expr><name>pkt</name></expr></argument>)</argument_list></call></expr></argument>,
					 <argument><expr><name><name>client</name><operator>-&gt;</operator><name>unackSendPkt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>client</name><operator>-&gt;</operator><name>unackSendPkt</name></name> <operator>-=</operator> <name>IC_PROXY_ACK_INTERVAL</name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
		<comment type="block">/* for debug purpose */</comment>
		if (client-&gt;unackSendPkt &lt; 0)
			elog(WARNING, "ic-proxy: %s: unexpected number of unack packets: %d",
						 ic_proxy_client_get_name(client),
						 client-&gt;unackSendPkt);
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

		<expr_stmt><expr><call><name>ic_proxy_client_maybe_resume</name><argument_list>(<argument><expr><name>client</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"ic-proxy: %s: unsupported message"</literal></expr></argument>,
					 <argument><expr><call><name>ic_proxy_client_get_name</name><argument_list>(<argument><expr><name>client</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Received a complete p2c DATA / MESSAGE packet.
 *
 * The client will takes the ownership of the pkt.
 */</comment>
<function><type><name>void</name></type>
<name>ic_proxy_client_on_p2c_data</name><parameter_list>(<parameter><decl><type><name>ICProxyClient</name> <modifier>*</modifier></type><name>client</name></decl></parameter>, <parameter><decl><type><name>ICProxyPkt</name> <modifier>*</modifier></type><name>pkt</name></decl></parameter>,
							<parameter><decl><type><name>ic_proxy_sent_cb</name></type> <name>callback</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>opaque</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* A placeholder does not send any packets, it always cache them */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>client</name><operator>-&gt;</operator><name>state</name></name> <operator>&amp;</operator> <name>IC_PROXY_CLIENT_STATE_PLACEHOLDER</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* FIXME: also save the callback */</comment>
		<expr_stmt><expr><call><name>ic_proxy_client_cache_p2c_pkt</name><argument_list>(<argument><expr><name>client</name></expr></argument>, <argument><expr><name>pkt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ASSERT_CHECKING</name></cpp:ifdef>
	<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>ic_proxy_pkt_is_to_client</name><argument_list>(<argument><expr><name>pkt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>client</name><operator>-&gt;</operator><name>key</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"ic-proxy: %s: the %s is not to me"</literal></expr></argument>,
					 <argument><expr><call><name>ic_proxy_client_get_name</name><argument_list>(<argument><expr><name>client</name></expr></argument>)</argument_list></call></expr></argument>,
					 <argument><expr><call><name>ic_proxy_pkt_to_str</name><argument_list>(<argument><expr><name>pkt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* TODO: callback? */</comment>
		<expr_stmt><expr><call><name>ic_proxy_pkt_cache_free</name><argument_list>(<argument><expr><name>pkt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_ASSERT_CHECKING */</comment>
	<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>ic_proxy_pkt_is_live</name><argument_list>(<argument><expr><name>pkt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>client</name><operator>-&gt;</operator><name>key</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>ic_proxy_pkt_is_out_of_date</name><argument_list>(<argument><expr><name>pkt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>client</name><operator>-&gt;</operator><name>key</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>elogif</name><argument_list>(<argument><expr><name>gp_log_interconnect</name> <operator>&gt;=</operator> <name>GPVARS_VERBOSITY_DEBUG</name></expr></argument>, <argument><expr><name>DEBUG3</name></expr></argument>,
				   <argument><expr><literal type="string">"%s: drop out-of-date %s"</literal></expr></argument>,
						 <argument><expr><call><name>ic_proxy_client_get_name</name><argument_list>(<argument><expr><name>client</name></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><call><name>ic_proxy_pkt_to_str</name><argument_list>(<argument><expr><name>pkt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* TODO: callback? */</comment>
			<expr_stmt><expr><call><name>ic_proxy_pkt_cache_free</name><argument_list>(<argument><expr><name>pkt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>ic_proxy_pkt_is_in_the_future</name><argument_list>(<argument><expr><name>pkt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>client</name><operator>-&gt;</operator><name>key</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>elogif</name><argument_list>(<argument><expr><name>gp_log_interconnect</name> <operator>&gt;=</operator> <name>GPVARS_VERBOSITY_DEBUG</name></expr></argument>, <argument><expr><name>DEBUG3</name></expr></argument>,
				   <argument><expr><literal type="string">"ic-proxy: %s: future %s"</literal></expr></argument>,
						 <argument><expr><call><name>ic_proxy_client_get_name</name><argument_list>(<argument><expr><name>client</name></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><call><name>ic_proxy_pkt_to_str</name><argument_list>(<argument><expr><name>pkt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* FIXME: also save the callback */</comment>
			<expr_stmt><expr><call><name>ic_proxy_client_cache_p2c_pkt</name><argument_list>(<argument><expr><name>client</name></expr></argument>, <argument><expr><name>pkt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if>
	<comment type="block">/* the pkt is valid and live, send it to the backend */</comment>
	<if type="elseif">else if <condition>(<expr><call><name>ic_proxy_pkt_is</name><argument_list>(<argument><expr><name>pkt</name></expr></argument>, <argument><expr><name>IC_PROXY_MESSAGE_DATA</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>client</name><operator>-&gt;</operator><name>state</name></name> <operator>&amp;</operator> <name>IC_PROXY_CLIENT_STATE_P2C_SHUTTING</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * a special kind of future packet happens between different stats
			 * of a query, the client and its successor have the same keys,
			 * such a future packet can not be detected in previous checks,
			 * we could only tell accoding to the client state.
			 */</comment>
			<expr_stmt><expr><call><name>ic_proxy_client_cache_p2c_pkt</name><argument_list>(<argument><expr><name>client</name></expr></argument>, <argument><expr><name>pkt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name><name>client</name><operator>-&gt;</operator><name>unconsumed</name></name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>client</name><operator>-&gt;</operator><name>sending</name></name><operator>++</operator></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>callback</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ic_proxy_router_write</name><argument_list>(<argument><expr><operator>(</operator><name>uv_stream_t</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>client</name><operator>-&gt;</operator><name>pipe</name></name></expr></argument>,
							  <argument><expr><name>pkt</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pkt</name></expr></argument>)</argument_list></sizeof></expr></argument>,
							  <argument><expr><name>ic_proxy_client_on_sent_p2c_data</name></expr></argument>, <argument><expr><name>client</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>ic_proxy_client_on_p2c_message</name><argument_list>(<argument><expr><name>client</name></expr></argument>, <argument><expr><name>pkt</name></expr></argument>, <argument><expr><name>callback</name></expr></argument>, <argument><expr><name>opaque</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ic_proxy_pkt_cache_free</name><argument_list>(<argument><expr><name>pkt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Save a packet for later handling.
 *
 * The client will takes the ownership of the pkt.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ic_proxy_client_cache_p2c_pkt</name><parameter_list>(<parameter><decl><type><name>ICProxyClient</name> <modifier>*</modifier></type><name>client</name></decl></parameter>, <parameter><decl><type><name>ICProxyPkt</name> <modifier>*</modifier></type><name>pkt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* TODO: drop out-of-date pkt directly */</comment>
	<comment type="block">/* TODO: verify the pkt is to client */</comment>

	<expr_stmt><expr><name><name>client</name><operator>-&gt;</operator><name>pkts</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>client</name><operator>-&gt;</operator><name>pkts</name></name></expr></argument>, <argument><expr><name>pkt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>elogif</name><argument_list>(<argument><expr><name>gp_log_interconnect</name> <operator>&gt;=</operator> <name>GPVARS_VERBOSITY_DEBUG</name></expr></argument>, <argument><expr><name>DEBUG3</name></expr></argument>,
		   <argument><expr><literal type="string">"ic-proxy: %s: cached a %s for future use, %d in the list"</literal></expr></argument>,
				 <argument><expr><call><name>ic_proxy_client_get_name</name><argument_list>(<argument><expr><name>client</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>ic_proxy_pkt_to_str</name><argument_list>(<argument><expr><name>pkt</name></expr></argument>)</argument_list></call></expr></argument>,
				 <argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>client</name><operator>-&gt;</operator><name>pkts</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>SIMPLE_FAULT_INJECTOR</name><argument_list>(<argument><expr><literal type="string">"ic_proxy_client_cached_p2c_pkt"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Save a list of packets for later handling.
 *
 * The client will takes the ownership of the pkts.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ic_proxy_client_cache_p2c_pkts</name><parameter_list>(<parameter><decl><type><name>ICProxyClient</name> <modifier>*</modifier></type><name>client</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>pkts</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* TODO: verify the pkts is to client */</comment>

	<expr_stmt><expr><name><name>client</name><operator>-&gt;</operator><name>pkts</name></name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name><name>client</name><operator>-&gt;</operator><name>pkts</name></name></expr></argument>, <argument><expr><name>pkts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>elogif</name><argument_list>(<argument><expr><name>gp_log_interconnect</name> <operator>&gt;=</operator> <name>GPVARS_VERBOSITY_DEBUG</name></expr></argument>, <argument><expr><name>DEBUG3</name></expr></argument>,
				 <argument><expr><literal type="string">"ic-proxy: %s: cached %d pkts for future use, %d in the list"</literal></expr></argument>,
				 <argument><expr><call><name>ic_proxy_client_get_name</name><argument_list>(<argument><expr><name>client</name></expr></argument>)</argument_list></call></expr></argument>,
				 <argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>pkts</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>client</name><operator>-&gt;</operator><name>pkts</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Drop all the cached p2c packets.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ic_proxy_client_drop_p2c_cache</name><parameter_list>(<parameter><decl><type><name>ICProxyClient</name> <modifier>*</modifier></type><name>client</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>client</name><operator>-&gt;</operator><name>pkts</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>client-&gt;pkts</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ICProxyPkt</name> <modifier>*</modifier></type><name>pkt</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"ic-proxy: %s: unhandled cached %s, dropping it"</literal></expr></argument>,
					 <argument><expr><call><name>ic_proxy_client_get_name</name><argument_list>(<argument><expr><name>client</name></expr></argument>)</argument_list></call></expr></argument>,
					 <argument><expr><call><name>ic_proxy_pkt_to_str</name><argument_list>(<argument><expr><name>pkt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ic_proxy_pkt_cache_free</name><argument_list>(<argument><expr><name>pkt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name><name>client</name><operator>-&gt;</operator><name>pkts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>client</name><operator>-&gt;</operator><name>pkts</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Handle all the cached p2c packets.
 *
 * Out-of-date ones will be droped, future ones will still be cached, only the
 * live ones are handled.
 *
 * This function is only called on a new client, so it is not so expansive
 * to rebuild the cache list.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ic_proxy_client_handle_p2c_cache</name><parameter_list>(<parameter><decl><type><name>ICProxyClient</name> <modifier>*</modifier></type><name>client</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/* A placeholder does not handle any packets */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>client</name><operator>-&gt;</operator><name>state</name></name> <operator>&amp;</operator> <name>IC_PROXY_CLIENT_STATE_PLACEHOLDER</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>client</name><operator>-&gt;</operator><name>pkts</name></name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>elogif</name><argument_list>(<argument><expr><name>gp_log_interconnect</name> <operator>&gt;=</operator> <name>GPVARS_VERBOSITY_DEBUG</name></expr></argument>, <argument><expr><name>DEBUG3</name></expr></argument>,
		   <argument><expr><literal type="string">"ic-proxy: %s: trying to consume the %d cached pkts"</literal></expr></argument>,
				 <argument><expr><call><name>ic_proxy_client_get_name</name><argument_list>(<argument><expr><name>client</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>client</name><operator>-&gt;</operator><name>pkts</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Consume the pkts one by one, stop immediately if the client begin to
	 * shutdown in the p2c direction.
	 */</comment>
	<while>while <condition>(<expr><name><name>client</name><operator>-&gt;</operator><name>pkts</name></name> <operator>!=</operator> <name>NIL</name> <operator>&amp;&amp;</operator>
		   <operator>!</operator><operator>(</operator><name><name>client</name><operator>-&gt;</operator><name>state</name></name> <operator>&amp;</operator> <name>IC_PROXY_CLIENT_STATE_P2C_SHUTTING</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ICProxyPkt</name> <modifier>*</modifier></type><name>pkt</name> <init>= <expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>client</name><operator>-&gt;</operator><name>pkts</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>count</name><operator>++</operator></expr>;</expr_stmt>

		<comment type="block">/*
		 * The pkt's ownership is taken by ic_proxy_client_on_p2c_data(), so
		 * only need to free the list cell itself.
		 */</comment>
		<expr_stmt><expr><name><name>client</name><operator>-&gt;</operator><name>pkts</name></name> <operator>=</operator> <call><name>list_delete_first</name><argument_list>(<argument><expr><name><name>client</name><operator>-&gt;</operator><name>pkts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* FIXME: callback */</comment>
		<expr_stmt><expr><call><name>ic_proxy_client_on_p2c_data</name><argument_list>(<argument><expr><name>client</name></expr></argument>, <argument><expr><name>pkt</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>elogif</name><argument_list>(<argument><expr><name>gp_log_interconnect</name> <operator>&gt;=</operator> <name>GPVARS_VERBOSITY_DEBUG</name></expr></argument>, <argument><expr><name>DEBUG3</name></expr></argument>,
		   <argument><expr><literal type="string">"ic-proxy: %s: consumed %d cached pkts"</literal></expr></argument>,
				 <argument><expr><call><name>ic_proxy_client_get_name</name><argument_list>(<argument><expr><name>client</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Receiver sends ack message to the sender
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ic_proxy_client_maybe_send_ack_message</name><parameter_list>(<parameter><decl><type><name>ICProxyClient</name> <modifier>*</modifier></type><name>client</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>elogif</name><argument_list>(<argument><expr><name>gp_log_interconnect</name> <operator>&gt;=</operator> <name>GPVARS_VERBOSITY_DEBUG</name></expr></argument>, <argument><expr><name>DEBUG3</name></expr></argument>,
		   <argument><expr><literal type="string">"ic-proxy: %s: %d unconsumed packets to the backend"</literal></expr></argument>,
				 <argument><expr><call><name>ic_proxy_client_get_name</name><argument_list>(<argument><expr><name>client</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>client</name><operator>-&gt;</operator><name>unconsumed</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Send ack message when the unackRecvPkt exceeds the threshold
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>client</name><operator>-&gt;</operator><name>unackRecvPkt</name></name> <operator>&gt;=</operator> <name>IC_PROXY_ACK_INTERVAL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ICProxyPkt</name> <modifier>*</modifier></type><name>pkt</name> <init>= <expr><call><name>ic_proxy_message_new</name><argument_list>(<argument><expr><name>IC_PROXY_MESSAGE_DATA_ACK</name></expr></argument>,
											   <argument><expr><operator>&amp;</operator><name><name>client</name><operator>-&gt;</operator><name>key</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>client</name><operator>-&gt;</operator><name>sending</name></name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>client</name><operator>-&gt;</operator><name>unackRecvPkt</name></name> <operator>-=</operator> <name>IC_PROXY_ACK_INTERVAL</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ic_proxy_router_route</name><argument_list>(<argument><expr><name><name>client</name><operator>-&gt;</operator><name>pipe</name><operator>.</operator><name>loop</name></name></expr></argument>, <argument><expr><name>pkt</name></expr></argument>,
							  <argument><expr><name>ic_proxy_client_on_sent_c2p_resume</name></expr></argument>, <argument><expr><name>client</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * PAUSE if the number of unack-packets execeeds the pause threshold
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ic_proxy_client_maybe_pause</name><parameter_list>(<parameter><decl><type><name>ICProxyClient</name> <modifier>*</modifier></type><name>client</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * If the number of unack-packets execeeds the pause threshold, the
	 * ic_proxy sender should stop reading from backend.
	 *
	 * The ic_proxy receiver will send ack message back to the sender, when
	 * the number of unack-packets is below the resume threshold, the sender
	 * continues to read from the backend again.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>client</name><operator>-&gt;</operator><name>unackSendPkt</name></name> <operator>&gt;=</operator> <name>IC_PROXY_TRESHOLD_UNACK_PACKET_PAUSE</name>
		<operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name><name>client</name><operator>-&gt;</operator><name>state</name></name> <operator>&amp;</operator> <name>IC_PROXY_CLIENT_STATE_PAUSED</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>client</name><operator>-&gt;</operator><name>state</name></name> <operator>|=</operator> <name>IC_PROXY_CLIENT_STATE_PAUSED</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>uv_read_stop</name><argument_list>(<argument><expr><operator>(</operator><name>uv_stream_t</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>client</name><operator>-&gt;</operator><name>pipe</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>elogif</name><argument_list>(<argument><expr><name>gp_log_interconnect</name> <operator>&gt;=</operator> <name>GPVARS_VERBOSITY_DEBUG</name></expr></argument>, <argument><expr><name>DEBUG1</name></expr></argument>,
			   <argument><expr><literal type="string">"ic-proxy: %s: paused"</literal></expr></argument>, <argument><expr><call><name>ic_proxy_client_get_name</name><argument_list>(<argument><expr><name>client</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * RESUME if the number of unack packets is below the resume threshold
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ic_proxy_client_maybe_resume</name><parameter_list>(<parameter><decl><type><name>ICProxyClient</name> <modifier>*</modifier></type><name>client</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>client</name><operator>-&gt;</operator><name>unackSendPkt</name></name> <operator>&lt;=</operator> <name>IC_PROXY_TRESHOLD_UNACK_PACKET_RESUME</name>
		<operator>&amp;&amp;</operator> <operator>(</operator><name><name>client</name><operator>-&gt;</operator><name>state</name></name> <operator>&amp;</operator> <name>IC_PROXY_CLIENT_STATE_PAUSED</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ic_proxy_client_read_data</name><argument_list>(<argument><expr><name>client</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>client</name><operator>-&gt;</operator><name>state</name></name> <operator>&amp;=</operator> <operator>~</operator><name>IC_PROXY_CLIENT_STATE_PAUSED</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>elogif</name><argument_list>(<argument><expr><name>gp_log_interconnect</name> <operator>&gt;=</operator> <name>GPVARS_VERBOSITY_DEBUG</name></expr></argument>, <argument><expr><name>DEBUG1</name></expr></argument>,
			   <argument><expr><literal type="string">"ic-proxy: %s: resumed"</literal></expr></argument>, <argument><expr><call><name>ic_proxy_client_get_name</name><argument_list>(<argument><expr><name>client</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>
</unit>
