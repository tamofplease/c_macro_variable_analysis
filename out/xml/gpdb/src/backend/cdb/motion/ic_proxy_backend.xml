<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/backend/cdb/motion/ic_proxy_backend.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * ic_proxy_backend.c
 *
 *    Interconnect Proxy Backend
 *
 * The functions in this file are all called by the backends.
 *
 * A backend and a client is the 2 end points of a domain socket, the backend
 * is in the QD/QE backend process, the client is in the proxy bgworker
 * process.
 *
 * TODO: at the moment the ic-tcp backend logic is reused by ic-proxy, in fact
 * the ic-proxy logic just lives inside ic_tcp.c, but in the future we may want
 * to build the ic-proxy logic independently, the potential benefits are:
 * - send / receive as ICProxyPkt directly: ic-tcp sends with a 4-byte header,
 *   in the proxy bgworker we need to unpack them and repack them into
 *   ICProxyPkt packets; the receiver needs to do it reversely; if we send /
 *   receive as ICProxyPkt directly we could reduce the parsing and memory
 *   copying;
 *
 * Note that the backend setup part of ic-proxy has been implemented by libuv
 * loop. Data flow send/recv and connection tear down is still based on ic-tcp.
 *
 * Copyright (c) 2020-Present VMware, Inc. or its affiliates.
 *
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbgang.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbvars.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/ml_ipc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/execdesc.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ic_proxy.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ic_proxy_backend.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ic_proxy_packet.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ic_proxy_key.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;uv.h&gt;</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CONNECT_TIMER_TIMEOUT</name></cpp:macro> <cpp:value>100</cpp:value></cpp:define>

<typedef>typedef <type><name><name>struct</name> <name>ICProxyBackend</name></name></type> <name>ICProxyBackend</name>;</typedef>

<comment type="block">/*
 * ICProxyBackend represents a backend connection
 *
 * Connection is type of domain socket and each backend connection is identified by a
 * backend key.
 */</comment>
<struct>struct <name>ICProxyBackend</name>
<block>{
	<decl_stmt><decl><type><name>uv_pipe_t</name></type>	<name>pipe</name></decl>;</decl_stmt>		<comment type="block">/* the libuv handle */</comment>

	<decl_stmt><decl><type><name>ICProxyKey</name></type>	<name>key</name></decl>;</decl_stmt>		<comment type="block">/* the key to identify a backend */</comment>

	<comment type="block">/*
	 * TODO: MotionConn is used by ic_tcp, currently ic_proxy still reuses the code of
	 * ic_tcp to send/receive interconnect data. Keeping a MotionConn pointer here is
	 * to set pipe handle for ic_tcp, when connection between backend and proxy is
	 * established.
	 */</comment>
	<decl_stmt><decl><type><name>MotionConn</name>   <modifier>*</modifier></type><name>conn</name></decl>;</decl_stmt>		<comment type="block">/* MotionConn used by ic_tcp */</comment>

	<decl_stmt><decl><type><name>bool</name></type>	<name>isSender</name></decl>;</decl_stmt>		<comment type="block">/* is motion sender */</comment>

	<comment type="block">/* buffer to send/recv handshake messages */</comment>
	<decl_stmt><decl><type><name>char</name></type>	<name><name>buffer</name><index>[<expr><sizeof>sizeof<argument_list>(<argument><expr><name>ICProxyPkt</name></expr></argument>)</argument_list></sizeof></expr>]</index></name></decl>;</decl_stmt>

	<comment type="block">/* 
	 * Messages are sent/received in an async way, so offset is used to point to the
	 * current position where the buffer send/recv next part of messages.
	 */</comment>
	<decl_stmt><decl><type><name>int</name></type>		<name>offset</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>		<name>retryNum</name></decl>;</decl_stmt>		<comment type="block">/* connect retry number */</comment>
}</block>;</struct>


<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ic_proxy_backend_walker</name><parameter_list>(<parameter><decl><type><name>uv_handle_t</name> <modifier>*</modifier></type><name>handle</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ic_proxy_backend_schedule_connect</name><parameter_list>(<parameter><decl><type><name>ICProxyBackend</name> <modifier>*</modifier></type><name>backend</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ic_proxy_pkt_backend_alloc_buffer</name><parameter_list>(<parameter><decl><type><name>uv_handle_t</name> <modifier>*</modifier></type><name>handle</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>suggested_size</name></decl></parameter>,
											  <parameter><decl><type><name>uv_buf_t</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ChunkTransportStateEntry</name> <modifier>*</modifier></type><name>ic_proxy_backend_get_pentry</name><parameter_list>(<parameter><decl><type><name>ICProxyBackend</name> <modifier>*</modifier></type><name>backend</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* uv callback */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ic_proxy_backend_on_interrupt_timer</name><parameter_list>(<parameter><decl><type><name>uv_timer_t</name> <modifier>*</modifier></type><name>timer</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ic_proxy_backend_on_cancel_from_qd_timer</name><parameter_list>(<parameter><decl><type><name>uv_timer_t</name> <modifier>*</modifier></type><name>timer</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ic_proxy_backend_on_connect_timer</name><parameter_list>(<parameter><decl><type><name>uv_timer_t</name> <modifier>*</modifier></type><name>timer</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ic_proxy_backend_on_connected</name><parameter_list>(<parameter><decl><type><name>uv_connect_t</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>status</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ic_proxy_backend_on_sent_hello</name><parameter_list>(<parameter><decl><type><name>uv_write_t</name> <modifier>*</modifier></type><name>req</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>status</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ic_proxy_backend_on_read_hello_ack</name><parameter_list>(<parameter><decl><type><name>uv_stream_t</name> <modifier>*</modifier></type><name>stream</name></decl></parameter>, <parameter><decl><type><name>ssize_t</name></type> <name>nread</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>uv_buf_t</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ic_proxy_backend_on_close</name><parameter_list>(<parameter><decl><type><name>uv_handle_t</name> <modifier>*</modifier></type><name>handle</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * Backend connection close callback
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ic_proxy_backend_on_close</name><parameter_list>(<parameter><decl><type><name>uv_handle_t</name> <modifier>*</modifier></type><name>handle</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ICProxyBackend</name> <modifier>*</modifier></type><name>backend</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ICProxyBackendContext</name> <modifier>*</modifier></type> <name>context</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>backend</name> <operator>=</operator> <call><name>CONTAINER_OF</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>handle</name></expr></argument>, <argument><expr><name>ICProxyBackend</name></expr></argument>, <argument><expr><name>pipe</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>context</name> <operator>=</operator> <name><name>backend</name><operator>-&gt;</operator><name>pipe</name><operator>.</operator><name>loop</name><operator>-&gt;</operator><name>data</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>elogif</name><argument_list>(<argument><expr><name>gp_log_interconnect</name> <operator>&gt;=</operator> <name>GPVARS_VERBOSITY_VERBOSE</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>,
		   <argument><expr><literal type="string">"ic-proxy: backend %s: backend connection closed, begin to reconnect."</literal></expr></argument>,
				 <argument><expr><call><name>ic_proxy_key_to_str</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>backend</name><operator>-&gt;</operator><name>key</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* 
	 * the previous pipe is already destroyed by uv_close, so we should
	 * re-init the domain socket pipe here before reconnect
	 */</comment>
	<expr_stmt><expr><call><name>uv_pipe_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>context</name><operator>-&gt;</operator><name>loop</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>backend</name><operator>-&gt;</operator><name>pipe</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ic_proxy_backend_schedule_connect</name><argument_list>(<argument><expr><name>backend</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Get ChunkTransportStateEntry based on send slice index of backend
 */</comment>
<function><type><specifier>static</specifier> <name>ChunkTransportStateEntry</name> <modifier>*</modifier></type>
<name>ic_proxy_backend_get_pentry</name><parameter_list>(<parameter><decl><type><name>ICProxyBackend</name> <modifier>*</modifier></type><name>backend</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ICProxyBackendContext</name> <modifier>*</modifier></type><name>context</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ChunkTransportState</name> <modifier>*</modifier></type><name>pTransportStates</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ChunkTransportStateEntry</name> <modifier>*</modifier></type><name>pEntry</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>context</name> <operator>=</operator> <name><name>backend</name><operator>-&gt;</operator><name>pipe</name><operator>.</operator><name>loop</name><operator>-&gt;</operator><name>data</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>pTransportStates</name> <operator>=</operator> <operator>(</operator><name>ChunkTransportState</name> <operator>*</operator><operator>)</operator><name><name>context</name><operator>-&gt;</operator><name>transportState</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>getChunkTransportState</name><argument_list>(<argument><expr><name>pTransportStates</name></expr></argument>, <argument><expr><name><name>backend</name><operator>-&gt;</operator><name>key</name><operator>.</operator><name>sendSliceIndex</name></name></expr></argument>,
						   <argument><expr><operator>&amp;</operator><name>pEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>pEntry</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Backend conenction receive HELLO ACK callback
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ic_proxy_backend_on_read_hello_ack</name><parameter_list>(<parameter><decl><type><name>uv_stream_t</name> <modifier>*</modifier></type><name>stream</name></decl></parameter>, <parameter><decl><type><name>ssize_t</name></type> <name>nread</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>uv_buf_t</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ICProxyBackend</name> <modifier>*</modifier></type><name>backend</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>ICProxyPkt</name> <modifier>*</modifier></type><name>pkt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ret</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>backend</name> <operator>=</operator> <call><name>CONTAINER_OF</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>stream</name></expr></argument>, <argument><expr><name>ICProxyBackend</name></expr></argument>, <argument><expr><name>pipe</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>nread</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* UV_EOF is expected */</comment>
		<if_stmt><if>if <condition>(<expr><name>nread</name> <operator>==</operator> <name>UV_EOF</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>elogif</name><argument_list>(<argument><expr><name>gp_log_interconnect</name> <operator>&gt;=</operator> <name>GPVARS_VERBOSITY_DEBUG</name></expr></argument>, <argument><expr><name>DEBUG1</name></expr></argument>,
				   <argument><expr><literal type="string">"ic-proxy: backend %s: received EOF while receiving HELLO ACK."</literal></expr></argument>,
				   <argument><expr><call><name>ic_proxy_key_to_str</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>backend</name><operator>-&gt;</operator><name>key</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"ic-proxy: backend %s: failed to recieve HELLO ACK: %s "</literal></expr></argument>,
						 <argument><expr><call><name>ic_proxy_key_to_str</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>backend</name><operator>-&gt;</operator><name>key</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>uv_strerror</name><argument_list>(<argument><expr><name>nread</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/* should close current pipe and try to reconnect */</comment>
		<expr_stmt><expr><call><name>uv_close</name><argument_list>(<argument><expr><operator>(</operator><name>uv_handle_t</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>backend</name><operator>-&gt;</operator><name>pipe</name></name></expr></argument>, <argument><expr><name>ic_proxy_backend_on_close</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if>
	<comment type="block">/* Equivalent to EAGAIN or EWOULDBLOCK */</comment>
	<if type="elseif">else if <condition>(<expr><name>nread</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* case: nread &gt; 0 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nread</name> <operator>&lt;=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ICProxyPkt</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <name><name>backend</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>backend</name><operator>-&gt;</operator><name>buffer</name></name> <operator>+</operator> <name><name>backend</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>base</name></name></expr></argument>, <argument><expr><name>nread</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>backend</name><operator>-&gt;</operator><name>offset</name></name> <operator>+=</operator> <name>nread</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>backend</name><operator>-&gt;</operator><name>offset</name></name> <operator>&lt;</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ICProxyPkt</name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* we have received a complete HELLO ACK message */</comment>
	<expr_stmt><expr><name>pkt</name> <operator>=</operator> <operator>(</operator><name>ICProxyPkt</name> <operator>*</operator><operator>)</operator><name><name>backend</name><operator>-&gt;</operator><name>buffer</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>ic_proxy_pkt_is</name><argument_list>(<argument><expr><name>pkt</name></expr></argument>, <argument><expr><name>IC_PROXY_MESSAGE_HELLO_ACK</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>uv_read_stop</name><argument_list>(<argument><expr><name>stream</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* assign connection fd after domain socket successfully connected */</comment>
	<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>uv_fileno</name><argument_list>(<argument><expr><operator>(</operator><name>uv_handle_t</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>backend</name><operator>-&gt;</operator><name>pipe</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>backend</name><operator>-&gt;</operator><name>conn</name><operator>-&gt;</operator><name>sockfd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* uv_fileno should not fail here */</comment>
	<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"backend %s: get connection fd failed: %s"</literal></expr></argument>,
			 <argument><expr><call><name>ic_proxy_key_to_str</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>backend</name><operator>-&gt;</operator><name>key</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>uv_strerror</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* ic_tcp compatitble code to modify ChunkTransportStateEntry for receiver */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>backend</name><operator>-&gt;</operator><name>isSender</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ChunkTransportStateEntry</name> <modifier>*</modifier></type><name>pEntry</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>pEntry</name> <operator>=</operator> <call><name>ic_proxy_backend_get_pentry</name><argument_list>(<argument><expr><name>backend</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>MPP_FD_SET</name><argument_list>(<argument><expr><name><name>backend</name><operator>-&gt;</operator><name>conn</name><operator>-&gt;</operator><name>sockfd</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pEntry</name><operator>-&gt;</operator><name>readSet</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>backend</name><operator>-&gt;</operator><name>conn</name><operator>-&gt;</operator><name>sockfd</name></name> <operator>&gt;</operator> <name><name>pEntry</name><operator>-&gt;</operator><name>highReadSock</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>pEntry</name><operator>-&gt;</operator><name>highReadSock</name></name> <operator>=</operator> <name><name>backend</name><operator>-&gt;</operator><name>conn</name><operator>-&gt;</operator><name>sockfd</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *  Allocate HELLO ACK buffer in the libuv style
 *
 *  Ensure the buf len plus offset is equal to the size of ICProxyPkt
 *  This could avoid receiving data after HELLO ACK message.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ic_proxy_pkt_backend_alloc_buffer</name><parameter_list>(<parameter><decl><type><name>uv_handle_t</name> <modifier>*</modifier></type><name>handle</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>suggested_size</name></decl></parameter>, <parameter><decl><type><name>uv_buf_t</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ICProxyBackend</name> <modifier>*</modifier></type><name>backend</name> <init>= <expr><operator>(</operator><name>ICProxyBackend</name> <operator>*</operator><operator>)</operator> <name>handle</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>base</name></name> <operator>=</operator> <name><name>backend</name><operator>-&gt;</operator><name>buffer</name></name> <operator>+</operator> <name><name>backend</name><operator>-&gt;</operator><name>offset</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>len</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ICProxyPkt</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <name><name>backend</name><operator>-&gt;</operator><name>offset</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Backend connected to a proxy.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ic_proxy_backend_on_sent_hello</name><parameter_list>(<parameter><decl><type><name>uv_write_t</name> <modifier>*</modifier></type><name>req</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>status</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ICProxyBackend</name> <modifier>*</modifier></type><name>backend</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>backend</name> <operator>=</operator> <operator>(</operator><name>ICProxyBackend</name> <operator>*</operator><operator>)</operator><name><name>req</name><operator>-&gt;</operator><name>handle</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ic_proxy_free</name><argument_list>(<argument><expr><name>req</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>status</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elogif</name><argument_list>(<argument><expr><name>gp_log_interconnect</name> <operator>&gt;=</operator> <name>GPVARS_VERBOSITY_DEBUG</name></expr></argument>, <argument><expr><name>DEBUG1</name></expr></argument>,
			   <argument><expr><literal type="string">"ic-proxy: backend %s: backend failed to send HELLO: %s"</literal></expr></argument>,
					 <argument><expr><call><name>ic_proxy_key_to_str</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>backend</name><operator>-&gt;</operator><name>key</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>uv_strerror</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>uv_close</name><argument_list>(<argument><expr><operator>(</operator><name>uv_handle_t</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>backend</name><operator>-&gt;</operator><name>pipe</name></name></expr></argument>, <argument><expr><name>ic_proxy_backend_on_close</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* recieve hello ack */</comment>
	<expr_stmt><expr><call><name>elogif</name><argument_list>(<argument><expr><name>gp_log_interconnect</name> <operator>&gt;=</operator> <name>GPVARS_VERBOSITY_DEBUG</name></expr></argument>, <argument><expr><name>DEBUG1</name></expr></argument>,
		   <argument><expr><literal type="string">"ic-proxy: backend %s: backend connected, receiving HELLO ACK"</literal></expr></argument>,
				 <argument><expr><call><name>ic_proxy_key_to_str</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>backend</name><operator>-&gt;</operator><name>key</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>backend</name><operator>-&gt;</operator><name>offset</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>uv_read_start</name><argument_list>(<argument><expr><operator>(</operator><name>uv_stream_t</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>backend</name><operator>-&gt;</operator><name>pipe</name></name></expr></argument>, <argument><expr><name>ic_proxy_pkt_backend_alloc_buffer</name></expr></argument>,
				  <argument><expr><name>ic_proxy_backend_on_read_hello_ack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *  Put backend into connect queue and start connect timer
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ic_proxy_backend_schedule_connect</name><parameter_list>(<parameter><decl><type><name>ICProxyBackend</name> <modifier>*</modifier></type><name>backend</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ICProxyBackendContext</name> <modifier>*</modifier></type><name>context</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>context</name> <operator>=</operator> <name><name>backend</name><operator>-&gt;</operator><name>pipe</name><operator>.</operator><name>loop</name><operator>-&gt;</operator><name>data</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>connectQueue</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>connectQueue</name></name></expr></argument>, <argument><expr><name>backend</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* 
	 * ref the connect timer, refer to connect timer in 
	 * ic_proxy_backend_init_context for detailed explanation.
	 */</comment>
	<expr_stmt><expr><call><name>uv_ref</name><argument_list>(<argument><expr><operator>(</operator><name>uv_handle_t</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>context</name><operator>-&gt;</operator><name>connectTimer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Connect callback
 *
 * Backend connected to a proxy, and begins to send HELLO message.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ic_proxy_backend_on_connected</name><parameter_list>(<parameter><decl><type><name>uv_connect_t</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>status</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ICProxyBackend</name> <modifier>*</modifier></type><name>backend</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uv_write_t</name> <modifier>*</modifier></type><name>req</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uv_buf_t</name></type>	<name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ICProxyPkt</name> <modifier>*</modifier></type><name>pkt</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>backend</name> <operator>=</operator> <operator>(</operator><name>ICProxyBackend</name> <operator>*</operator><operator>)</operator><name><name>conn</name><operator>-&gt;</operator><name>handle</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ic_proxy_free</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>status</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* the proxy might just not get ready yet, retry later */</comment>
		<expr_stmt><expr><call><name>elogif</name><argument_list>(<argument><expr><name>gp_log_interconnect</name> <operator>&gt;=</operator> <name>GPVARS_VERBOSITY_DEBUG</name></expr></argument>, <argument><expr><name>DEBUG1</name></expr></argument>,
			   <argument><expr><literal type="string">"ic-proxy: backend %s: backend failed to connect: %s"</literal></expr></argument>,
					 <argument><expr><call><name>ic_proxy_key_to_str</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>backend</name><operator>-&gt;</operator><name>key</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>uv_strerror</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* retry interval is 100ms and unit of interconnect_setup_timeout is second */</comment>
		<if_stmt><if>if <condition>(<expr><name>interconnect_setup_timeout</name> <operator>*</operator> <literal type="number">1000</literal> <operator>&lt;=</operator>  <name><name>backend</name><operator>-&gt;</operator><name>retryNum</name></name> <operator>*</operator> <name>CONNECT_TIMER_TIMEOUT</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"ic-proxy: backend %s: Interconnect timeout: Unable to "</literal>
						 <literal type="string">"complete setup of connection within time limit %d seconds"</literal></expr></argument>,
						 <argument><expr><call><name>ic_proxy_key_to_str</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>backend</name><operator>-&gt;</operator><name>key</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>interconnect_setup_timeout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>backend</name><operator>-&gt;</operator><name>retryNum</name></name><operator>++</operator></expr>;</expr_stmt>

		<comment type="block">/* should close current pipe and try to reconnect */</comment>
		<expr_stmt><expr><call><name>uv_close</name><argument_list>(<argument><expr><operator>(</operator><name>uv_handle_t</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>backend</name><operator>-&gt;</operator><name>pipe</name></name></expr></argument>, <argument><expr><name>ic_proxy_backend_on_close</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>elogif</name><argument_list>(<argument><expr><name>gp_log_interconnect</name> <operator>&gt;=</operator> <name>GPVARS_VERBOSITY_DEBUG</name></expr></argument>, <argument><expr><name>DEBUG1</name></expr></argument>,
		   <argument><expr><literal type="string">"ic-proxy: backend %s: backend connected, sending HELLO message."</literal></expr></argument>,
				 <argument><expr><call><name>ic_proxy_key_to_str</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>backend</name><operator>-&gt;</operator><name>key</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* 
	 * reuse backend buffer to avoid memory alloc, and thus it should not be freed
	 * in the write cb
	 */</comment>
	<expr_stmt><expr><name><name>backend</name><operator>-&gt;</operator><name>offset</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>pkt</name> <operator>=</operator> <operator>(</operator><name>ICProxyPkt</name> <operator>*</operator><operator>)</operator><name><name>backend</name><operator>-&gt;</operator><name>buffer</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ic_proxy_message_init</name><argument_list>(<argument><expr><name>pkt</name></expr></argument>, <argument><expr><name>IC_PROXY_MESSAGE_HELLO</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>backend</name><operator>-&gt;</operator><name>key</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>req</name> <operator>=</operator> <call><name>ic_proxy_new</name><argument_list>(<argument><expr><name>uv_write_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>buf</name><operator>.</operator><name>base</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>pkt</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>buf</name><operator>.</operator><name>len</name></name> <operator>=</operator> <name><name>pkt</name><operator>-&gt;</operator><name>len</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>uv_write</name><argument_list>(<argument><expr><name>req</name></expr></argument>, <argument><expr><operator>(</operator><name>uv_stream_t</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>backend</name><operator>-&gt;</operator><name>pipe</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>ic_proxy_backend_on_sent_hello</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Timer callback: quick check_for_interrupt
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ic_proxy_backend_on_interrupt_timer</name><parameter_list>(<parameter><decl><type><name>uv_timer_t</name> <modifier>*</modifier></type><name>timer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ChunkTransportState</name> <modifier>*</modifier></type><name>pTransportStates</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>pTransportStates</name> <operator>=</operator> <name><name>timer</name><operator>-&gt;</operator><name>data</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ML_CHECK_FOR_INTERRUPTS</name><argument_list>(<argument><expr><name><name>pTransportStates</name><operator>-&gt;</operator><name>teardownActive</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Timer callback: slow checkForCancelFromQD
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ic_proxy_backend_on_cancel_from_qd_timer</name><parameter_list>(<parameter><decl><type><name>uv_timer_t</name> <modifier>*</modifier></type><name>timer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ChunkTransportState</name> <modifier>*</modifier></type><name>pTransportStates</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>pTransportStates</name> <operator>=</operator> <name><name>timer</name><operator>-&gt;</operator><name>data</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>checkForCancelFromQD</name><argument_list>(<argument><expr><name>pTransportStates</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Timer callback
 *
 * Reconnect all the pending requests in connect queue
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ic_proxy_backend_on_connect_timer</name><parameter_list>(<parameter><decl><type><name>uv_timer_t</name> <modifier>*</modifier></type><name>timer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ICProxyBackendContext</name>	   <modifier>*</modifier></type><name>context</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uv_connect_t</name>   <modifier>*</modifier></type><name>req</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>	   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name>			<name>sockaddr_un</name></name></type> <name>addr</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>context</name> <operator>=</operator> <name><name>timer</name><operator>-&gt;</operator><name>loop</name><operator>-&gt;</operator><name>data</name></name></expr>;</expr_stmt>
	<macro><name>foreach</name> <argument_list>(<argument>cell</argument>, <argument>context-&gt;connectQueue</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ICProxyBackend</name> <modifier>*</modifier></type><name>backend</name> <init>= <expr><operator>(</operator><name>ICProxyBackend</name> <operator>*</operator><operator>)</operator><call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>addr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>addr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>addr</name><operator>.</operator><name>sun_family</name></name> <operator>=</operator> <name>AF_UNIX</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ic_proxy_build_server_sock_path</name><argument_list>(<argument><expr><name><name>addr</name><operator>.</operator><name>sun_path</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>addr</name><operator>.</operator><name>sun_path</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>req</name> <operator>=</operator> <call><name>ic_proxy_new</name><argument_list>(<argument><expr><name>uv_connect_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>uv_pipe_connect</name><argument_list>(<argument><expr><name>req</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>backend</name><operator>-&gt;</operator><name>pipe</name></name></expr></argument>, <argument><expr><name><name>addr</name><operator>.</operator><name>sun_path</name></name></expr></argument>,
						<argument><expr><name>ic_proxy_backend_on_connected</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/* 
	 * unref the connect timer, refer to connect timer in 
	 * ic_proxy_backend_init_context for detailed explanation.
	 */</comment>
	<expr_stmt><expr><call><name>uv_unref</name><argument_list>(<argument><expr><operator>(</operator><name>uv_handle_t</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>context</name><operator>-&gt;</operator><name>connectTimer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>connectQueue</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>connectQueue</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Using walker to close the pipe handle
 *
 * The pipe handles are only maintained by libuv, we could only use uv_walker
 * to access and close these pipe.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ic_proxy_backend_walker</name><parameter_list>(<parameter><decl><type><name>uv_handle_t</name> <modifier>*</modifier></type><name>handle</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name><name>handle</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>UV_NAMED_PIPE</name></expr>:</case>
			<comment type="block">/* 
			 * Passing NULL instead of ic_proxy_backend_on_close as the callback,
			 * since ic_proxy_backend_on_close will schedule a reconnection, but we
			 * just want to close the pipe handle here.
			 */</comment>
			<expr_stmt><expr><call><name>uv_close</name><argument_list>(<argument><expr><name>handle</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<break>break;</break>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 * Putting the connection request into the connect queue and waiting for connect
 * timer to process the connect event when uv_loop is running
 */</comment>
<function><type><name>void</name></type>
<name>ic_proxy_backend_connect</name><parameter_list>(<parameter><decl><type><name>ICProxyBackendContext</name> <modifier>*</modifier></type><name>context</name></decl></parameter>, <parameter><decl><type><name>ChunkTransportStateEntry</name> <modifier>*</modifier></type><name>pEntry</name></decl></parameter>, <parameter><decl><type><name>MotionConn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isSender</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ICProxyBackend</name> <modifier>*</modifier></type><name>backend</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>backend</name> <operator>=</operator> <call><name>ic_proxy_new</name><argument_list>(<argument><expr><name>ICProxyBackend</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>backend</name><operator>-&gt;</operator><name>isSender</name></name> <operator>=</operator> <name>isSender</name></expr>;</expr_stmt>

	<comment type="block">/* TODO: remove conn after we decouple ic_proxy and ic_tcp */</comment>
	<expr_stmt><expr><name><name>backend</name><operator>-&gt;</operator><name>conn</name></name> <operator>=</operator> <name>conn</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>backend</name><operator>-&gt;</operator><name>retryNum</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	
	<comment type="block">/* message key for a HELLO message */</comment>
	<expr_stmt><expr><call><name>ic_proxy_key_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>backend</name><operator>-&gt;</operator><name>key</name></name></expr></argument>,					<comment type="block">/* key itself */</comment>
					  <argument><expr><name>gp_session_id</name></expr></argument>,					<comment type="block">/* sessionId */</comment>
					  <argument><expr><name>gp_command_count</name></expr></argument>,					<comment type="block">/* commandId */</comment>
					  <argument><expr><name><name>pEntry</name><operator>-&gt;</operator><name>sendSlice</name><operator>-&gt;</operator><name>sliceIndex</name></name></expr></argument>,	<comment type="block">/* sendSliceIndex */</comment>
					  <argument><expr><name><name>pEntry</name><operator>-&gt;</operator><name>recvSlice</name><operator>-&gt;</operator><name>sliceIndex</name></name></expr></argument>,	<comment type="block">/* recvSliceIndex */</comment>
					  <argument><expr><name><name>GpIdentity</name><operator>.</operator><name>segindex</name></name></expr></argument>,				<comment type="block">/* localContentId */</comment>
					  <argument><expr><name><name>GpIdentity</name><operator>.</operator><name>dbid</name></name></expr></argument>,					<comment type="block">/* localDbid */</comment>
					  <argument><expr><name>MyProcPid</name></expr></argument>,						<comment type="block">/* localPid */</comment>
					  <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>cdbProc</name><operator>-&gt;</operator><name>contentid</name></name></expr></argument>,			<comment type="block">/* remoteContentId */</comment>
					  <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>cdbProc</name><operator>-&gt;</operator><name>dbid</name></name></expr></argument>,				<comment type="block">/* remoteDbid */</comment>
					  <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>cdbProc</name><operator>-&gt;</operator><name>pid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>				<comment type="block">/* remotePid */</comment>


	<expr_stmt><expr><call><name>uv_pipe_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>context</name><operator>-&gt;</operator><name>loop</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>backend</name><operator>-&gt;</operator><name>pipe</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* put connection into queue */</comment>
	<expr_stmt><expr><call><name>ic_proxy_backend_schedule_connect</name><argument_list>(<argument><expr><name>backend</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Initialize the icproxy backend context
 */</comment>
<function><type><name>void</name></type>
<name>ic_proxy_backend_init_context</name><parameter_list>(<parameter><decl><type><name>ChunkTransportState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ICProxyBackendContext</name> <modifier>*</modifier></type><name>context</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>SIMPLE_FAULT_INJECTOR</name><argument_list>(<argument><expr><literal type="string">"ic_proxy_backend_init_context"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* initialize backend context */</comment>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>proxyContext</name></name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ICProxyBackendContext</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>proxyContext</name><operator>-&gt;</operator><name>transportState</name></name> <operator>=</operator> <name>state</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>context</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>proxyContext</name></name></expr>;</expr_stmt>

	<comment type="block">/* init libuv loop */</comment>
	<expr_stmt><expr><call><name>uv_loop_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>context</name><operator>-&gt;</operator><name>loop</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>loop</name><operator>.</operator><name>data</name></name> <operator>=</operator> <name>context</name></expr>;</expr_stmt>

	<comment type="block">/* interrupt timer */</comment>
	<expr_stmt><expr><call><name>uv_timer_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>context</name><operator>-&gt;</operator><name>loop</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>context</name><operator>-&gt;</operator><name>interruptTimer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>interruptTimer</name><operator>.</operator><name>data</name></name> <operator>=</operator> <name><name>context</name><operator>-&gt;</operator><name>transportState</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>uv_timer_start</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>context</name><operator>-&gt;</operator><name>interruptTimer</name></name></expr></argument>, <argument><expr><name>ic_proxy_backend_on_interrupt_timer</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">500</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>uv_unref</name><argument_list>(<argument><expr><operator>(</operator><name>uv_handle_t</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>context</name><operator>-&gt;</operator><name>interruptTimer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>uv_timer_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>context</name><operator>-&gt;</operator><name>loop</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>context</name><operator>-&gt;</operator><name>cancelFromQDTimer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>cancelFromQDTimer</name><operator>.</operator><name>data</name></name> <operator>=</operator> <name><name>context</name><operator>-&gt;</operator><name>transportState</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>uv_timer_start</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>context</name><operator>-&gt;</operator><name>cancelFromQDTimer</name></name></expr></argument>, <argument><expr><name>ic_proxy_backend_on_cancel_from_qd_timer</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>uv_unref</name><argument_list>(<argument><expr><operator>(</operator><name>uv_handle_t</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>context</name><operator>-&gt;</operator><name>cancelFromQDTimer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* 
	 * Connect timer is used to process the connect/reconnect request in
	 * conenct queue periodically. At the beginng of uv_run, all the
	 * cached connect request in queue will be processed immediately.
	 * If connect failed, the reconnect request will be push back to the
	 * queue, and wait for the connect timer to trigger the reconnect.
	 *
	 * Libuv uses ref/unref to mark whether the event if OK to exit,
	 * the uv_run will stop if all the events are in state of unref.
	 *
	 * When a request is pushed into the queue, we need to call uv_ref
	 * to pin the connect timer, and after we processed all the existing
	 * request in the queue, we should call uv_unref to unpin the timer
	 * to tell uv_loop we are OK to exit.
	 *
	 * Note that ref/unref in libuv is not a reference counting, so call
	 * ref/unref repeatly is safe.
	 */</comment>
	<expr_stmt><expr><call><name>uv_timer_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>context</name><operator>-&gt;</operator><name>loop</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>context</name><operator>-&gt;</operator><name>connectTimer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>uv_timer_start</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>context</name><operator>-&gt;</operator><name>connectTimer</name></name></expr></argument>, <argument><expr><name>ic_proxy_backend_on_connect_timer</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>CONNECT_TIMER_TIMEOUT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>uv_unref</name><argument_list>(<argument><expr><operator>(</operator><name>uv_handle_t</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>context</name><operator>-&gt;</operator><name>connectTimer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Close the icproxy backend context
 */</comment>
<function><type><name>void</name></type>
<name>ic_proxy_backend_close_context</name><parameter_list>(<parameter><decl><type><name>ChunkTransportState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ICProxyBackendContext</name> <modifier>*</modifier></type><name>context</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>state</name><operator>-&gt;</operator><name>proxyContext</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>context</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>proxyContext</name></name></expr>;</expr_stmt>

	<comment type="block">/* close interrupt timer and connect timer */</comment>
	<if_stmt><if>if <condition>(<expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>uv_close</name><argument_list>(<argument><expr><operator>(</operator><name>uv_handle_t</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>context</name><operator>-&gt;</operator><name>cancelFromQDTimer</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>uv_close</name><argument_list>(<argument><expr><operator>(</operator><name>uv_handle_t</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>context</name><operator>-&gt;</operator><name>interruptTimer</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>uv_close</name><argument_list>(<argument><expr><operator>(</operator><name>uv_handle_t</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>context</name><operator>-&gt;</operator><name>connectTimer</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* 
	 * Use walker to close the pipe handle.
	 *
	 * Since we reuse ic-tcp code to handle data flow between backend and proxy,
	 * we have to transfer the owner of pipe fd to MotionConn. The fd is closed
	 * by ic-tcp code, but the pipe handle in libuv loop should be closed by
	 * ourselves before we close the loop. This is tricky and should be fixed
	 * when we retire the ic-tcp code and use libuv to handle data flow between
	 * backend and proxy.
	 */</comment>
	<expr_stmt><expr><call><name>uv_walk</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>context</name><operator>-&gt;</operator><name>loop</name></name></expr></argument>, <argument><expr><name>ic_proxy_backend_walker</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>uv_run</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>context</name><operator>-&gt;</operator><name>loop</name></name></expr></argument>, <argument><expr><name>UV_RUN_DEFAULT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>uv_loop_close</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>context</name><operator>-&gt;</operator><name>loop</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <name>UV_EBUSY</name></expr> )</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,<argument><expr><literal type="string">"ic-proxy-backend: ic_proxy_backend_close_loop failed: %s"</literal></expr></argument>, <argument><expr><call><name>uv_strerror</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>proxyContext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>proxyContext</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Run the libuv main loop
 */</comment>
<function><type><name>void</name></type> <name>ic_proxy_backend_run_loop</name><parameter_list>(<parameter><decl><type><name>ICProxyBackendContext</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>uv_run</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>context</name><operator>-&gt;</operator><name>loop</name></name></expr></argument>, <argument><expr><name>UV_RUN_DEFAULT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
