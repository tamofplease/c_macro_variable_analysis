<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/backend/cdb/cdbvarblock.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * cdbvarblock.c
 *	  A general data package that has variable-length item array that can be
 *    efficiently indexed once complete.
 *
 * (See .h file for usage comments)
 *
 * Portions Copyright (c) 2007-2009, greenplum inc
 * Portions Copyright (c) 2012-Present VMware, Inc. or its affiliates.
 *
 *
 * IDENTIFICATION
 *	    src/backend/cdb/cdbvarblock.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbvarblock.h"</cpp:file></cpp:include>

<function_decl><type><specifier>static</specifier> <name>VarBlockByteLen</name></type> <name>VarBlockGetItemLen</name><parameter_list>(
				   <parameter><decl><type><name>VarBlockReader</name> <modifier>*</modifier></type><name>varBlockReader</name></decl></parameter>,
				   <parameter><decl><type><name>int</name></type> <name>itemIndex</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>VarBlockGetItemPtrAndLen</name><parameter_list>(
						 <parameter><decl><type><name>VarBlockReader</name> <modifier>*</modifier></type><name>varBlockReader</name></decl></parameter>,
						 <parameter><decl><type><name>int</name></type> <name>itemIndex</name></decl></parameter>,
						 <parameter><decl><type><name>uint8</name> <modifier>*</modifier><modifier>*</modifier></type><name>itemPtr</name></decl></parameter>,
						 <parameter><decl><type><name>VarBlockByteLen</name> <modifier>*</modifier></type><name>itemLen</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>VarBlockByteOffset</name></type> <name>VarBlockGetOffset</name><parameter_list>(
				  <parameter><decl><type><name>VarBlockHeader</name> <modifier>*</modifier></type><name>header</name></decl></parameter>,
				  <parameter><decl><type><name>VarBlockByteOffset</name></type> <name>offsetToOffsetArray</name></decl></parameter>,
				  <parameter><decl><type><name>int</name></type> <name>itemIndex</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * Initialize the VarBlock maker.
 *
 * Since we are going to pack the item offset array
 * right after the variable-length item array when
 * finished, we need a temporary buffer for the
 * offsets while we are making the block.  The caller
 * supplies the tempScratchSpace parameter for this
 * purpose.
 *
 * Note that tempScratchSpaceLen in effect
 * serves as the maximum number of items (UNDONE: more on 2-byte vs. 3-byte).
 */</comment>
<function><type><name>void</name></type>
<name>VarBlockMakerInit</name><parameter_list>(
				  <parameter><decl><type><name>VarBlockMaker</name> <modifier>*</modifier></type><name>varBlockMaker</name></decl></parameter>,
				  <parameter><decl><type><name>uint8</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>,
				  <parameter><decl><type><name>VarBlockByteLen</name></type> <name>maxBufferLen</name></decl></parameter>,
				  <parameter><decl><type><name>uint8</name> <modifier>*</modifier></type><name>tempScratchSpace</name></decl></parameter>,
				  <parameter><decl><type><name>int</name></type> <name>tempScratchSpaceLen</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>varBlockMaker</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>buffer</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<comment type="block">/* UNDONE:And ALIGN(4) */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>maxBufferLen</name> <operator>&gt;=</operator> <name>VARBLOCK_HEADER_LEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<comment type="block">/* UNDONE:And even. */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>tempScratchSpace</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<comment type="block">/* UNDONE:And ALIGN(4). */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>tempScratchSpaceLen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<comment type="block">/* UNDONE:And even. */</comment>

	<expr_stmt><expr><name><name>varBlockMaker</name><operator>-&gt;</operator><name>header</name></name> <operator>=</operator> <operator>(</operator><name>VarBlockHeader</name> <operator>*</operator><operator>)</operator> <name>buffer</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>varBlockMaker</name><operator>-&gt;</operator><name>maxBufferLen</name></name> <operator>=</operator> <name>maxBufferLen</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>varBlockMaker</name><operator>-&gt;</operator><name>currentItemLenSum</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>varBlockMaker</name><operator>-&gt;</operator><name>tempScratchSpace</name></name> <operator>=</operator> <name>tempScratchSpace</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>varBlockMaker</name><operator>-&gt;</operator><name>tempScratchSpaceLen</name></name> <operator>=</operator> <name>tempScratchSpaceLen</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>varBlockMaker</name><operator>-&gt;</operator><name>nextItemPtr</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>buffer</name><index>[<expr><name>VARBLOCK_HEADER_LEN</name></expr>]</index></name></expr>;</expr_stmt>

	<comment type="block">/* UNDONE: Fix the constant to be the $MIN of approx. 16k (or 32k) */</comment>
	<comment type="block">/* UNDONE: and maxBufferLen... */</comment>
	<expr_stmt><expr><name><name>varBlockMaker</name><operator>-&gt;</operator><name>last2ByteOffsetPtr</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>buffer</name><index>[<expr><literal type="number">63</literal> <operator>*</operator> <literal type="number">1024</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>varBlockMaker</name><operator>-&gt;</operator><name>currentItemCount</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>varBlockMaker</name><operator>-&gt;</operator><name>maxItemCount</name></name> <operator>=</operator> <name>tempScratchSpaceLen</name> <operator>/</operator> <literal type="number">2</literal></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>VARBLOCK_HEADER_LEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>VarBlockSet_version</name><argument_list>(<argument><expr><name><name>varBlockMaker</name><operator>-&gt;</operator><name>header</name></name></expr></argument>, <argument><expr><name>InitialVersion</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>VarBlockSet_offsetsAreSmall</name><argument_list>(<argument><expr><name><name>varBlockMaker</name><operator>-&gt;</operator><name>header</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Get a pointer to the next variable-length item so it can
 * be filled in.
 *
 * Returns NULL when there is no more space left in the VarBlock.
 */</comment>
<function><type><name>uint8</name> <modifier>*</modifier></type>
<name>VarBlockMakerGetNextItemPtr</name><parameter_list>(
							<parameter><decl><type><name>VarBlockMaker</name> <modifier>*</modifier></type><name>varBlockMaker</name></decl></parameter>,
							<parameter><decl><type><name>VarBlockByteLen</name></type> <name>itemLen</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>currentItemCount</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint8</name>	   <modifier>*</modifier></type><name>buffer</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint8</name>	   <modifier>*</modifier></type><name>nextItemPtr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>VarBlockByteOffset</name></type> <name>nextItemOffset</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>VarBlockByteLen</name></type> <name>newItemLenSum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>VarBlockByteLen</name></type> <name>offsetArrayLenRounded</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>VarBlockByteLen</name></type> <name>newTotalLen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint8</name>	   <modifier>*</modifier></type><name>tempScratchSpace</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>VarBlockByteOffset16</name> <modifier>*</modifier></type><name>tempOffsetArray16</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>VarBlockByteOffset24</name></type> <name>tempOffset24</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>varBlockMaker</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>itemLen</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>currentItemCount</name> <operator>=</operator> <name><name>varBlockMaker</name><operator>-&gt;</operator><name>currentItemCount</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>currentItemCount</name> <operator>&gt;=</operator> <name><name>varBlockMaker</name><operator>-&gt;</operator><name>maxItemCount</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Reached a limit on the number of items based on the scratch
		 * space...
		 */</comment>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>buffer</name> <operator>=</operator> <operator>(</operator><name>uint8</name> <operator>*</operator><operator>)</operator> <name><name>varBlockMaker</name><operator>-&gt;</operator><name>header</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>nextItemPtr</name> <operator>=</operator> <name><name>varBlockMaker</name><operator>-&gt;</operator><name>nextItemPtr</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>nextItemOffset</name> <operator>=</operator> <operator>(</operator><name>VarBlockByteOffset</name><operator>)</operator> <operator>(</operator><name>nextItemPtr</name> <operator>-</operator> <name>buffer</name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>newItemLenSum</name> <operator>=</operator> <name><name>varBlockMaker</name><operator>-&gt;</operator><name>currentItemLenSum</name></name> <operator>+</operator> <name>itemLen</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>tempScratchSpace</name> <operator>=</operator> <name><name>varBlockMaker</name><operator>-&gt;</operator><name>tempScratchSpace</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * We require VarBlocks to given to us on 4 byte boundaries...
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>VarBlockGet_offsetsAreSmall</name><argument_list>(<argument><expr><name><name>varBlockMaker</name><operator>-&gt;</operator><name>header</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>newMaxItemCount</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Will small 2 byte offsets still work?
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>nextItemPtr</name> <operator>&gt;</operator> <name><name>varBlockMaker</name><operator>-&gt;</operator><name>last2ByteOffsetPtr</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>r</name></decl>;</decl_stmt>

			<comment type="block">/*
			 * Try out large 3-byte offsets.
			 */</comment>

			<comment type="block">/*
			 * Round-up to even length.
			 */</comment>
			<expr_stmt><expr><name>offsetArrayLenRounded</name> <operator>=</operator> <operator>(</operator><name>currentItemCount</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator>
				<name>VARBLOCK_BYTE_OFFSET_24_LEN</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>offsetArrayLenRounded</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>offsetArrayLenRounded</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator> <literal type="number">2</literal><operator>)</operator> <operator>*</operator> <literal type="number">2</literal></expr>;</expr_stmt>

			<expr_stmt><expr><name>newTotalLen</name> <operator>=</operator> <name>VARBLOCK_HEADER_LEN</name> <operator>+</operator>
				<operator>(</operator><operator>(</operator><name>newItemLenSum</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator> <literal type="number">2</literal><operator>)</operator> <operator>*</operator> <literal type="number">2</literal> <operator>+</operator>
				<name>offsetArrayLenRounded</name></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>newTotalLen</name> <operator>&gt;</operator> <name><name>varBlockMaker</name><operator>-&gt;</operator><name>maxBufferLen</name></name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
			<comment type="block">/* Out of space. */</comment>

			<expr_stmt><expr><name>newMaxItemCount</name> <operator>=</operator> <name><name>varBlockMaker</name><operator>-&gt;</operator><name>tempScratchSpaceLen</name></name> <operator>/</operator>
				<name>VARBLOCK_BYTE_OFFSET_24_LEN</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>currentItemCount</name> <operator>&gt;=</operator> <name>newMaxItemCount</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * Reached a limit on the number of items based on the scratch
				 * space with large offsets...
				 */</comment>
				<return>return <expr><name>NULL</name></expr>;</return>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>VarBlockSet_offsetsAreSmall</name><argument_list>(<argument><expr><name><name>varBlockMaker</name><operator>-&gt;</operator><name>header</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>varBlockMaker</name><operator>-&gt;</operator><name>maxItemCount</name></name> <operator>=</operator> <name>newMaxItemCount</name></expr>;</expr_stmt>

			<comment type="block">/*
			 * Reverse move to use 3-byte offsets.
			 */</comment>
			<expr_stmt><expr><name>tempOffsetArray16</name> <operator>=</operator> <operator>(</operator><name>VarBlockByteOffset16</name> <operator>*</operator><operator>)</operator> <name>tempScratchSpace</name></expr>;</expr_stmt>
			<for>for <control>(<init><expr><name>r</name> <operator>=</operator> <name>currentItemCount</name></expr>;</init> <condition><expr><name>r</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>r</name><operator>--</operator></expr></incr>)</control>
			<block>{<block_content>
				<expr_stmt><expr><name><name>tempOffset24</name><operator>.</operator><name>byteOffset24</name></name> <operator>=</operator> <name><name>tempOffsetArray16</name><index>[<expr><name>r</name></expr>]</index></name></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>tempScratchSpace</name> <operator>+</operator> <operator>(</operator><name>r</name> <operator>*</operator> <name>VARBLOCK_BYTE_OFFSET_24_LEN</name><operator>)</operator></expr></argument>,
					   <argument><expr><operator>&amp;</operator><name>tempOffset24</name></expr></argument>,
					   <argument><expr><name>VARBLOCK_BYTE_OFFSET_24_LEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></for>

			<expr_stmt><expr><name><name>tempOffset24</name><operator>.</operator><name>byteOffset24</name></name> <operator>=</operator> <name>nextItemOffset</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>tempScratchSpace</name> <operator>+</operator>
				   <operator>(</operator><name>currentItemCount</name> <operator>*</operator> <name>VARBLOCK_BYTE_OFFSET_24_LEN</name><operator>)</operator></expr></argument>,
				   <argument><expr><operator>&amp;</operator><name>tempOffset24</name></expr></argument>,
				   <argument><expr><name>VARBLOCK_BYTE_OFFSET_24_LEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * Normal calculation.
			 */</comment>
			<expr_stmt><expr><name>newTotalLen</name> <operator>=</operator> <name>VARBLOCK_HEADER_LEN</name> <operator>+</operator>
				<operator>(</operator><operator>(</operator><name>newItemLenSum</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator> <literal type="number">2</literal><operator>)</operator> <operator>*</operator> <literal type="number">2</literal> <operator>+</operator>
				<name>currentItemCount</name> <operator>*</operator> <literal type="number">2</literal> <operator>+</operator> <literal type="number">2</literal></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>newTotalLen</name> <operator>&gt;</operator> <name><name>varBlockMaker</name><operator>-&gt;</operator><name>maxBufferLen</name></name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
			<comment type="block">/* Out of space. */</comment>

			<expr_stmt><expr><name>tempOffsetArray16</name> <operator>=</operator> <operator>(</operator><name>VarBlockByteOffset16</name> <operator>*</operator><operator>)</operator> <name>tempScratchSpace</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tempOffsetArray16</name><index>[<expr><name>currentItemCount</name></expr>]</index></name> <operator>=</operator>
				<operator>(</operator><name>VarBlockByteOffset16</name><operator>)</operator> <name>nextItemOffset</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * Large 3 byte ofsets.
		 */</comment>

		<comment type="block">/*
		 * Round-up to even length.
		 */</comment>
		<expr_stmt><expr><name>offsetArrayLenRounded</name> <operator>=</operator> <operator>(</operator><name>currentItemCount</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator>
			<name>VARBLOCK_BYTE_OFFSET_24_LEN</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>offsetArrayLenRounded</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>offsetArrayLenRounded</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator> <literal type="number">2</literal><operator>)</operator> <operator>*</operator> <literal type="number">2</literal></expr>;</expr_stmt>

		<expr_stmt><expr><name>newTotalLen</name> <operator>=</operator> <name>VARBLOCK_HEADER_LEN</name> <operator>+</operator>
			<operator>(</operator><operator>(</operator><name>newItemLenSum</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator> <literal type="number">2</literal><operator>)</operator> <operator>*</operator> <literal type="number">2</literal> <operator>+</operator>
			<name>offsetArrayLenRounded</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>newTotalLen</name> <operator>&gt;</operator> <name><name>varBlockMaker</name><operator>-&gt;</operator><name>maxBufferLen</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
		<comment type="block">/* Out of space. */</comment>

		<expr_stmt><expr><name><name>tempOffset24</name><operator>.</operator><name>byteOffset24</name></name> <operator>=</operator> <name>nextItemOffset</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>tempScratchSpace</name> <operator>+</operator>
			   <operator>(</operator><name>currentItemCount</name> <operator>*</operator> <name>VARBLOCK_BYTE_OFFSET_24_LEN</name><operator>)</operator></expr></argument>,
			   <argument><expr><operator>&amp;</operator><name>tempOffset24</name></expr></argument>,
			   <argument><expr><name>VARBLOCK_BYTE_OFFSET_24_LEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name><name>varBlockMaker</name><operator>-&gt;</operator><name>nextItemPtr</name></name> <operator>+=</operator> <name>itemLen</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>varBlockMaker</name><operator>-&gt;</operator><name>currentItemCount</name></name><operator>++</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>varBlockMaker</name><operator>-&gt;</operator><name>currentItemLenSum</name></name> <operator>=</operator> <name>newItemLenSum</name></expr>;</expr_stmt>

	<return>return <expr><name>nextItemPtr</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Get the variable-length item count.
 */</comment>
<function><type><name>int</name></type>
<name>VarBlockMakerItemCount</name><parameter_list>(
					   <parameter><decl><type><name>VarBlockMaker</name> <modifier>*</modifier></type><name>varBlockMaker</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>varBlockMaker</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>varBlockMaker</name><operator>-&gt;</operator><name>currentItemCount</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Finish making the VarBlock.
 *
 * The item-offsets array will be added to the end.
 */</comment>
<function><type><name>VarBlockByteLen</name></type>
<name>VarBlockMakerFinish</name><parameter_list>(
					<parameter><decl><type><name>VarBlockMaker</name> <modifier>*</modifier></type><name>varBlockMaker</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint8</name>	   <modifier>*</modifier></type><name>buffer</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>itemCount</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>VarBlockByteLen</name></type> <name>itemLenSum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint8</name>	   <modifier>*</modifier></type><name>tempScratchSpace</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>VarBlockByteOffset</name></type> <name>offsetToOffsetArray</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>z</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>multiplier</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>VarBlockByteLen</name></type> <name>offsetArrayLen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>VarBlockByteLen</name></type> <name>offsetArrayLenRounded</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>VarBlockByteLen</name></type> <name>bufferLen</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>varBlockMaker</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>buffer</name> <operator>=</operator> <operator>(</operator><name>uint8</name> <operator>*</operator><operator>)</operator> <name><name>varBlockMaker</name><operator>-&gt;</operator><name>header</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>itemCount</name> <operator>=</operator> <name><name>varBlockMaker</name><operator>-&gt;</operator><name>currentItemCount</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>itemLenSum</name> <operator>=</operator> <name><name>varBlockMaker</name><operator>-&gt;</operator><name>currentItemLenSum</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name>tempScratchSpace</name> <operator>=</operator> <name><name>varBlockMaker</name><operator>-&gt;</operator><name>tempScratchSpace</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * offsetArrays start on even boundary.
	 */</comment>
	<expr_stmt><expr><name>offsetToOffsetArray</name> <operator>=</operator> <name>VARBLOCK_HEADER_LEN</name> <operator>+</operator>
		<operator>(</operator><operator>(</operator><name>itemLenSum</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator> <literal type="number">2</literal><operator>)</operator> <operator>*</operator> <literal type="number">2</literal></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>VarBlockGet_offsetsAreSmall</name><argument_list>(<argument><expr><name><name>varBlockMaker</name><operator>-&gt;</operator><name>header</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>buffer</name><index>[<expr><name>offsetToOffsetArray</name></expr>]</index></name></expr></argument>, <argument><expr><name>tempScratchSpace</name></expr></argument>, <argument><expr><name>itemCount</name> <operator>*</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>multiplier</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>buffer</name><index>[<expr><name>offsetToOffsetArray</name></expr>]</index></name></expr></argument>,
			   <argument><expr><name>tempScratchSpace</name></expr></argument>,
			   <argument><expr><name>itemCount</name> <operator>*</operator> <name>VARBLOCK_BYTE_OFFSET_24_LEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* UNDONE: Zero out odd byte. */</comment>

		<expr_stmt><expr><name>multiplier</name> <operator>=</operator> <name>VARBLOCK_BYTE_OFFSET_24_LEN</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Zero the pad between the last item and the offset array for data
	 * security.
	 */</comment>
	<for>for <control>(<init><expr><name>z</name> <operator>=</operator> <name>VARBLOCK_HEADER_LEN</name> <operator>+</operator> <name>itemLenSum</name></expr>;</init> <condition><expr><name>z</name> <operator>&lt;</operator> <name>offsetToOffsetArray</name></expr>;</condition> <incr><expr><name>z</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>buffer</name><index>[<expr><name>z</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>VarBlockSet_itemLenSum</name><argument_list>(<argument><expr><name><name>varBlockMaker</name><operator>-&gt;</operator><name>header</name></name></expr></argument>, <argument><expr><name>itemLenSum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>VarBlockSet_itemCount</name><argument_list>(<argument><expr><name><name>varBlockMaker</name><operator>-&gt;</operator><name>header</name></name></expr></argument>, <argument><expr><name>itemCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Round-up to even length.
	 */</comment>
	<expr_stmt><expr><name>offsetArrayLen</name> <operator>=</operator> <name>itemCount</name> <operator>*</operator> <name>multiplier</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>offsetArrayLenRounded</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>offsetArrayLen</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator> <literal type="number">2</literal><operator>)</operator> <operator>*</operator> <literal type="number">2</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * Zero the pad between the last offset and the rounded-up end of VarBlock
	 * for data security.
	 */</comment>
	<for>for <control>(<init><expr><name>z</name> <operator>=</operator> <name>offsetToOffsetArray</name> <operator>+</operator> <name>offsetArrayLen</name></expr>;</init>
		 <condition><expr><name>z</name> <operator>&lt;</operator> <name>offsetToOffsetArray</name> <operator>+</operator> <name>offsetArrayLenRounded</name></expr>;</condition>
		 <incr><expr><name>z</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>buffer</name><index>[<expr><name>z</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><name>bufferLen</name> <operator>=</operator> <name>offsetToOffsetArray</name> <operator>+</operator> <name>offsetArrayLenRounded</name></expr>;</expr_stmt>

<comment type="block">/* #ifdef DEBUG */</comment>
<comment type="block">/* 	if(VarBlockIsValid(buffer, bufferLen) != VarBlockCheckOk) */</comment>
<comment type="block">/* 	{ */</comment>
<comment type="block">/* 		// UNDONE: Use elog. */</comment>
<comment type="block">/* 		fprintf(stderr, "VarBlockIsValid not ok (detail = '%s')", */</comment>
<comment type="block">/* 			    VarBlockCheckErrorStr); */</comment>
<comment type="block">/* 		exit(1); */</comment>
<comment type="block">/* 	} */</comment>
<comment type="block">/* #endif */</comment>

	<return>return <expr><name>bufferLen</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VarBlockByteOffset</name></type>
<name>VarBlockGetOffset</name><parameter_list>(
				  <parameter><decl><type><name>VarBlockHeader</name> <modifier>*</modifier></type><name>header</name></decl></parameter>,
				  <parameter><decl><type><name>VarBlockByteOffset</name></type> <name>offsetToOffsetArray</name></decl></parameter>,
				  <parameter><decl><type><name>int</name></type> <name>itemIndex</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint8</name>	   <modifier>*</modifier></type><name>offsetArray</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>header</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>offsetToOffsetArray</name> <operator>&gt;=</operator> <name>VARBLOCK_HEADER_LEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>itemIndex</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>itemIndex</name> <operator>&lt;</operator> <call><name>VarBlockGet_itemCount</name><argument_list>(<argument><expr><name>header</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>offsetArray</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>uint8</name> <operator>*</operator><operator>)</operator> <name>header</name><operator>)</operator> <operator>+</operator> <name>offsetToOffsetArray</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>VarBlockGet_offsetsAreSmall</name><argument_list>(<argument><expr><name>header</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><operator>(</operator><operator>(</operator><name>VarBlockByteOffset16</name> <operator>*</operator><operator>)</operator> <name>offsetArray</name><operator>)</operator><index>[<expr><name>itemIndex</name></expr>]</index></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>VarBlockByteOffset24</name></type> <name>offset24</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>offset24</name></expr></argument>,
			   <argument><expr><name>offsetArray</name> <operator>+</operator> <operator>(</operator><name>itemIndex</name> <operator>*</operator> <name>VARBLOCK_BYTE_OFFSET_24_LEN</name><operator>)</operator></expr></argument>,
			   <argument><expr><name>VARBLOCK_BYTE_OFFSET_24_LEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return <expr><name><name>offset24</name><operator>.</operator><name>byteOffset24</name></name></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_VARBLOCK_CHECK_ERROR_STR</name></cpp:macro> <cpp:value>200</cpp:value></cpp:define>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>VarBlockCheckErrorStr</name><index>[<expr><name>MAX_VARBLOCK_CHECK_ERROR_STR</name></expr>]</index></name> <init>= <expr><literal type="string">"\0"</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Return a string message for the last check error.
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>VarBlockGetCheckErrorStr</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name>VarBlockCheckErrorStr</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Determine if the header looks valid.
 *
 * peekLen must be at least VARBLOCK_HEADER_LEN bytes.
 */</comment>
<function><type><name>VarBlockCheckError</name></type>
<name>VarBlockHeaderIsValid</name><parameter_list>(
					  <parameter><decl><type><name>uint8</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>,
					  <parameter><decl><type><name>VarBlockByteLen</name></type> <name>peekLen</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>VarBlockHeader</name> <modifier>*</modifier></type><name>header</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>buffer</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>peekLen</name> <operator>&gt;=</operator> <name>VARBLOCK_HEADER_LEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>header</name> <operator>=</operator> <operator>(</operator><name>VarBlockHeader</name> <operator>*</operator><operator>)</operator> <name>buffer</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>VarBlockGet_version</name><argument_list>(<argument><expr><name>header</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>InitialVersion</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>VarBlockCheckErrorStr</name></expr></argument>,
				<argument><expr><literal type="string">"Invalid initial version %d (bytes_0_3 0x%08x, bytes_4_7 0x%08x)"</literal></expr></argument>,
				<argument><expr><call><name>VarBlockGet_version</name><argument_list>(<argument><expr><name>header</name></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><name><name>header</name><operator>-&gt;</operator><name>bytes_0_3</name></name></expr></argument>, <argument><expr><name><name>header</name><operator>-&gt;</operator><name>bytes_4_7</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>VarBlockCheckBadVersion</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>VarBlockGet_reserved</name><argument_list>(<argument><expr><name>header</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>VarBlockCheckErrorStr</name></expr></argument>,
				<argument><expr><literal type="string">"Reserved not 0 (bytes_0_3 0x%08x, bytes_4_7 0x%08x)"</literal></expr></argument>,
				<argument><expr><name><name>header</name><operator>-&gt;</operator><name>bytes_0_3</name></name></expr></argument>, <argument><expr><name><name>header</name><operator>-&gt;</operator><name>bytes_4_7</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>VarBlockCheckReservedNot0</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>VarBlockGet_moreReserved</name><argument_list>(<argument><expr><name>header</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>VarBlockCheckErrorStr</name></expr></argument>,
				<argument><expr><literal type="string">"More reserved not 0 (bytes_0_3 0x%08x, bytes_4_7 0x%08x)"</literal></expr></argument>,
				<argument><expr><name><name>header</name><operator>-&gt;</operator><name>bytes_0_3</name></name></expr></argument>, <argument><expr><name><name>header</name><operator>-&gt;</operator><name>bytes_4_7</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>VarBlockCheckMoreReservedNot0</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Can't do checking of itemSumLen and itemCount without access to whole
	 * VarBlock.
	 */</comment>

	<return>return <expr><name>VarBlockCheckOk</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Determine if the whole VarBlock looks valid.
 *
 * bufferLen must be VarBlock length.
 */</comment>
<function><type><name>VarBlockCheckError</name></type>
<name>VarBlockIsValid</name><parameter_list>(
				<parameter><decl><type><name>uint8</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>,
				<parameter><decl><type><name>VarBlockByteLen</name></type> <name>bufferLen</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>VarBlockHeader</name> <modifier>*</modifier></type><name>header</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>headerLen</name> <init>= <expr><name>VARBLOCK_HEADER_LEN</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>VarBlockCheckError</name></type> <name>varBlockCheckError</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>itemLenSum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>itemCount</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>VarBlockByteOffset</name></type> <name>offsetToOffsetArray</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>z</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>buffer</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>bufferLen</name> <operator>&gt;=</operator> <name>VARBLOCK_HEADER_LEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>header</name> <operator>=</operator> <operator>(</operator><name>VarBlockHeader</name> <operator>*</operator><operator>)</operator> <name>buffer</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>varBlockCheckError</name> <operator>=</operator> <call><name>VarBlockHeaderIsValid</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>bufferLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>varBlockCheckError</name> <operator>!=</operator> <name>VarBlockCheckOk</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>varBlockCheckError</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Now do checking of itemSumLen and itemCount.
	 */</comment>
	<expr_stmt><expr><name>itemLenSum</name> <operator>=</operator> <call><name>VarBlockGet_itemLenSum</name><argument_list>(<argument><expr><name>header</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>itemLenSum</name> <operator>&gt;=</operator> <name>bufferLen</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>VarBlockCheckErrorStr</name></expr></argument>,
				<argument><expr><literal type="string">"itemLenSum %d greater than or equal to bufferLen %d (bytes_0_3 0x%08x, bytes_4_7 0x%08x)"</literal></expr></argument>,
				<argument><expr><name>itemLenSum</name></expr></argument>,
				<argument><expr><name>bufferLen</name></expr></argument>,
				<argument><expr><name><name>header</name><operator>-&gt;</operator><name>bytes_0_3</name></name></expr></argument>, <argument><expr><name><name>header</name><operator>-&gt;</operator><name>bytes_4_7</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>VarBlockCheckItemSumLenBad1</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>offsetToOffsetArray</name> <operator>=</operator> <name>VARBLOCK_HEADER_LEN</name> <operator>+</operator>
		<operator>(</operator><operator>(</operator><name>itemLenSum</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator> <literal type="number">2</literal><operator>)</operator> <operator>*</operator> <literal type="number">2</literal></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>offsetToOffsetArray</name> <operator>&gt;</operator> <name>bufferLen</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>VarBlockCheckErrorStr</name></expr></argument>,
				<argument><expr><literal type="string">"offsetToOffsetArray %d greater than bufferLen %d (bytes_0_3 0x%08x, bytes_4_7 0x%08x)"</literal></expr></argument>,
				<argument><expr><name>offsetToOffsetArray</name></expr></argument>,
				<argument><expr><name>bufferLen</name></expr></argument>,
				<argument><expr><name><name>header</name><operator>-&gt;</operator><name>bytes_0_3</name></name></expr></argument>, <argument><expr><name><name>header</name><operator>-&gt;</operator><name>bytes_4_7</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>VarBlockCheckItemSumLenBad2</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Verify the data security zero pad between the last item and the
	 * offset array.
	 */</comment>
	<for>for <control>(<init><expr><name>z</name> <operator>=</operator> <name>VARBLOCK_HEADER_LEN</name> <operator>+</operator> <name>itemLenSum</name></expr>;</init> <condition><expr><name>z</name> <operator>&lt;</operator> <name>offsetToOffsetArray</name></expr>;</condition> <incr><expr><name>z</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>buffer</name><index>[<expr><name>z</name></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>VarBlockCheckErrorStr</name></expr></argument>,
					<argument><expr><literal type="string">"Bad zero pad at offset %d between items and offset array (bytes_0_3 0x%08x, bytes_4_7 0x%08x)"</literal></expr></argument>,
					<argument><expr><name>z</name></expr></argument>,
					<argument><expr><name><name>header</name><operator>-&gt;</operator><name>bytes_0_3</name></name></expr></argument>, <argument><expr><name><name>header</name><operator>-&gt;</operator><name>bytes_4_7</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>VarBlockCheckZeroPadBad1</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><name>itemCount</name> <operator>=</operator> <call><name>VarBlockGet_itemCount</name><argument_list>(<argument><expr><name>header</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>itemCount</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>offsetToOffsetArray</name> <operator>!=</operator> <name>bufferLen</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>VarBlockCheckErrorStr</name></expr></argument>,
					<argument><expr><literal type="string">"offsetToOffsetArray %d should equal bufferLen %d for itemCount 0 (bytes_0_3 0x%08x, bytes_4_7 0x%08x)"</literal></expr></argument>,
					<argument><expr><name>offsetToOffsetArray</name></expr></argument>,
					<argument><expr><name>bufferLen</name></expr></argument>,
					<argument><expr><name><name>header</name><operator>-&gt;</operator><name>bytes_0_3</name></name></expr></argument>, <argument><expr><name><name>header</name><operator>-&gt;</operator><name>bytes_4_7</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>VarBlockCheckItemCountBad1</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>multiplier</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>VarBlockByteLen</name></type> <name>actualOffsetArrayLenRounded</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>VarBlockByteLen</name></type> <name>calculatedOffsetArrayLen</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>VarBlockByteLen</name></type> <name>calculatedOffsetArrayLenRounded</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>VarBlockByteOffset</name></type> <name>offset</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>VarBlockGet_offsetsAreSmall</name><argument_list>(<argument><expr><name>header</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>multiplier</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>multiplier</name> <operator>=</operator> <name>VARBLOCK_BYTE_OFFSET_24_LEN</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name>actualOffsetArrayLenRounded</name> <operator>=</operator> <name>bufferLen</name> <operator>-</operator> <name>offsetToOffsetArray</name></expr>;</expr_stmt>

		<comment type="block">/* Since itemCount was from 24-bits and the multipler is small, */</comment>
		<comment type="block">/* this multiply should be safe. */</comment>
		<expr_stmt><expr><name>calculatedOffsetArrayLen</name> <operator>=</operator> <name>itemCount</name> <operator>*</operator> <name>multiplier</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>calculatedOffsetArrayLenRounded</name> <operator>=</operator>
			<operator>(</operator><operator>(</operator><name>calculatedOffsetArrayLen</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator> <literal type="number">2</literal><operator>)</operator> <operator>*</operator> <literal type="number">2</literal></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>actualOffsetArrayLenRounded</name> <operator>!=</operator> <name>calculatedOffsetArrayLenRounded</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>VarBlockCheckErrorStr</name></expr></argument>,
					<argument><expr><literal type="string">"actual OffsetArray length %d should equal calculated OffsetArray length %d for itemCount %d (bytes_0_3 0x%08x, bytes_4_7 0x%08x)"</literal></expr></argument>,
					<argument><expr><name>actualOffsetArrayLenRounded</name></expr></argument>,
					<argument><expr><name>calculatedOffsetArrayLenRounded</name></expr></argument>,
					<argument><expr><name>itemCount</name></expr></argument>,
					<argument><expr><name><name>header</name><operator>-&gt;</operator><name>bytes_0_3</name></name></expr></argument>, <argument><expr><name><name>header</name><operator>-&gt;</operator><name>bytes_4_7</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>VarBlockCheckItemCountBad2</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * The first offset is right after the header.
		 */</comment>
		<expr_stmt><expr><name>offset</name> <operator>=</operator> <call><name>VarBlockGetOffset</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr><name>offsetToOffsetArray</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>offset</name> <operator>!=</operator> <name>VARBLOCK_HEADER_LEN</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>VarBlockCheckErrorStr</name></expr></argument>,
					<argument><expr><literal type="string">"offset %d at index 0 is bad -- must equal %d (bytes_0_3 0x%08x, bytes_4_7 0x%08x)"</literal></expr></argument>,
					<argument><expr><name>offset</name></expr></argument>,
					<argument><expr><name>headerLen</name></expr></argument>,
					<argument><expr><name><name>header</name><operator>-&gt;</operator><name>bytes_0_3</name></name></expr></argument>, <argument><expr><name><name>header</name><operator>-&gt;</operator><name>bytes_4_7</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>VarBlockCheckOffsetBad1</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>itemCount</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>VarBlockByteOffset</name></type> <name>prevOffset</name> <init>= <expr><name>offset</name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>offset</name> <operator>&lt;</operator> <name>prevOffset</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>VarBlockCheckErrorStr</name></expr></argument>,
						<argument><expr><literal type="string">"offset %d at index %d is bad -- less than previous offset %d (bytes_0_3 0x%08x, bytes_4_7 0x%08x)"</literal></expr></argument>,
						<argument><expr><name>offset</name></expr></argument>,
						<argument><expr><name>i</name></expr></argument>,
						<argument><expr><name>prevOffset</name></expr></argument>,
						<argument><expr><name><name>header</name><operator>-&gt;</operator><name>bytes_0_3</name></name></expr></argument>, <argument><expr><name><name>header</name><operator>-&gt;</operator><name>bytes_4_7</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>VarBlockCheckOffsetBad2</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>offset</name> <operator>&gt;</operator> <name>itemLenSum</name> <operator>+</operator> <name>VARBLOCK_HEADER_LEN</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>VarBlockCheckErrorStr</name></expr></argument>,
						<argument><expr><literal type="string">"offset %d at index %d is bad -- greater than itemLenSum and header %d (bytes_0_3 0x%08x, bytes_4_7 0x%08x)"</literal></expr></argument>,
						<argument><expr><name>offset</name></expr></argument>,
						<argument><expr><name>i</name></expr></argument>,
						<argument><expr><name>itemLenSum</name> <operator>+</operator> <name>headerLen</name></expr></argument>,
						<argument><expr><name><name>header</name><operator>-&gt;</operator><name>bytes_0_3</name></name></expr></argument>, <argument><expr><name><name>header</name><operator>-&gt;</operator><name>bytes_4_7</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>VarBlockCheckOffsetBad3</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>

		<comment type="block">/*
		 * Verify the data security zero pad between the last offset and the
		 * rounded-up end of the VarBlock.
		 */</comment>
		<for>for <control>(<init><expr><name>z</name> <operator>=</operator> <name>offsetToOffsetArray</name> <operator>+</operator> <name>calculatedOffsetArrayLen</name></expr>;</init>
			 <condition><expr><name>z</name> <operator>&lt;</operator> <name>offsetToOffsetArray</name> <operator>+</operator> <name>calculatedOffsetArrayLenRounded</name></expr>;</condition>
			 <incr><expr><name>z</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>buffer</name><index>[<expr><name>z</name></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>VarBlockCheckErrorStr</name></expr></argument>,
						<argument><expr><literal type="string">"Bad zero pad at offset %d between last offset and the rounded-up end of buffer (bytes_0_3 0x%08x, bytes_4_7 0x%08x)"</literal></expr></argument>,
						<argument><expr><name>z</name></expr></argument>,
						<argument><expr><name><name>header</name><operator>-&gt;</operator><name>bytes_0_3</name></name></expr></argument>, <argument><expr><name><name>header</name><operator>-&gt;</operator><name>bytes_4_7</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>VarBlockCheckZeroPadBad2</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>

	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>VarBlockCheckOk</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Initialize the VarBlock reader.
 */</comment>
<function><type><name>void</name></type>
<name>VarBlockReaderInit</name><parameter_list>(
				   <parameter><decl><type><name>VarBlockReader</name> <modifier>*</modifier></type><name>varBlockReader</name></decl></parameter>,
				   <parameter><decl><type><name>uint8</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>,
				   <parameter><decl><type><name>VarBlockByteLen</name></type> <name>bufferLen</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>VarBlockHeader</name> <modifier>*</modifier></type><name>header</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>VarBlockByteLen</name></type> <name>itemLenSum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>VarBlockByteOffset</name></type> <name>offsetToOffsetArray</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>divisor</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>calculatedItemCount</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>varBlockReader</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>buffer</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<comment type="block">/* UNDONE:And ALIGN(4) */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>bufferLen</name> <operator>&gt;=</operator> <name>VARBLOCK_HEADER_LEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<comment type="block">/* UNDONE:And even. */</comment>

	<expr_stmt><expr><name>header</name> <operator>=</operator> <operator>(</operator><name>VarBlockHeader</name> <operator>*</operator><operator>)</operator> <name>buffer</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>varBlockReader</name><operator>-&gt;</operator><name>header</name></name> <operator>=</operator> <name>header</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>varBlockReader</name><operator>-&gt;</operator><name>bufferLen</name></name> <operator>=</operator> <name>bufferLen</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>itemLenSum</name> <operator>=</operator> <call><name>VarBlockGet_itemLenSum</name><argument_list>(<argument><expr><name>header</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * offsetArrays start on even boundary.
	 */</comment>
	<expr_stmt><expr><name>offsetToOffsetArray</name> <operator>=</operator> <name>VARBLOCK_HEADER_LEN</name> <operator>+</operator>
		<operator>(</operator><operator>(</operator><name>itemLenSum</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator> <literal type="number">2</literal><operator>)</operator> <operator>*</operator> <literal type="number">2</literal></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>VarBlockGet_offsetsAreSmall</name><argument_list>(<argument><expr><name>header</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>divisor</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>divisor</name> <operator>=</operator> <name>VARBLOCK_BYTE_OFFSET_24_LEN</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><name>calculatedItemCount</name> <operator>=</operator> <operator>(</operator><name>bufferLen</name> <operator>-</operator> <name>offsetToOffsetArray</name><operator>)</operator> <operator>/</operator> <name>divisor</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>calculatedItemCount</name> <operator>==</operator> <call><name>VarBlockGet_itemCount</name><argument_list>(<argument><expr><name>header</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>varBlockReader</name><operator>-&gt;</operator><name>offsetToOffsetArray</name></name> <operator>=</operator> <name>offsetToOffsetArray</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>varBlockReader</name><operator>-&gt;</operator><name>nextIndex</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>varBlockReader</name><operator>-&gt;</operator><name>nextItemPtr</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>buffer</name><index>[<expr><name>VARBLOCK_HEADER_LEN</name></expr>]</index></name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VarBlockByteLen</name></type>
<name>VarBlockGetItemLen</name><parameter_list>(
				   <parameter><decl><type><name>VarBlockReader</name> <modifier>*</modifier></type><name>varBlockReader</name></decl></parameter>,
				   <parameter><decl><type><name>int</name></type> <name>itemIndex</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>VarBlockHeader</name> <modifier>*</modifier></type><name>header</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>VarBlockByteLen</name></type> <name>itemLen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>VarBlockByteOffset</name></type> <name>offset</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>varBlockReader</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>itemIndex</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>header</name> <operator>=</operator> <name><name>varBlockReader</name><operator>-&gt;</operator><name>header</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name>offset</name> <operator>=</operator> <call><name>VarBlockGetOffset</name><argument_list>(
							   <argument><expr><name>header</name></expr></argument>,
							   <argument><expr><name><name>varBlockReader</name><operator>-&gt;</operator><name>offsetToOffsetArray</name></name></expr></argument>,
							   <argument><expr><name>itemIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>itemIndex</name> <operator>&lt;</operator> <call><name>VarBlockGet_itemCount</name><argument_list>(<argument><expr><name>header</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>VarBlockByteOffset</name></type> <name>nextOffset</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>nextOffset</name> <operator>=</operator> <call><name>VarBlockGetOffset</name><argument_list>(
									   <argument><expr><name>header</name></expr></argument>,
									   <argument><expr><name><name>varBlockReader</name><operator>-&gt;</operator><name>offsetToOffsetArray</name></name></expr></argument>,
									   <argument><expr><name>itemIndex</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>itemLen</name> <operator>=</operator> <name>nextOffset</name> <operator>-</operator> <name>offset</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>itemLen</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>itemIndex</name> <operator>==</operator> <call><name>VarBlockGet_itemCount</name><argument_list>(<argument><expr><name>header</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>itemLen</name> <operator>=</operator>
			<name>VARBLOCK_HEADER_LEN</name> <operator>+</operator>
			<call><name>VarBlockGet_itemLenSum</name><argument_list>(<argument><expr><name>header</name></expr></argument>)</argument_list></call> <operator>-</operator>
			<name>offset</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>itemLen</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>itemLen</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>VarBlockGetItemPtrAndLen</name><parameter_list>(
						 <parameter><decl><type><name>VarBlockReader</name> <modifier>*</modifier></type><name>varBlockReader</name></decl></parameter>,
						 <parameter><decl><type><name>int</name></type> <name>itemIndex</name></decl></parameter>,
						 <parameter><decl><type><name>uint8</name> <modifier>*</modifier><modifier>*</modifier></type><name>itemPtr</name></decl></parameter>,
						 <parameter><decl><type><name>VarBlockByteLen</name> <modifier>*</modifier></type><name>itemLen</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>VarBlockHeader</name> <modifier>*</modifier></type><name>header</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint8</name>	   <modifier>*</modifier></type><name>buffer</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>VarBlockByteOffset</name></type> <name>offset</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>varBlockReader</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>header</name> <operator>=</operator> <name><name>varBlockReader</name><operator>-&gt;</operator><name>header</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>buffer</name> <operator>=</operator> <operator>(</operator><name>uint8</name> <operator>*</operator><operator>)</operator> <name>header</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>offset</name> <operator>=</operator> <call><name>VarBlockGetOffset</name><argument_list>(
							   <argument><expr><name>header</name></expr></argument>,
							   <argument><expr><name><name>varBlockReader</name><operator>-&gt;</operator><name>offsetToOffsetArray</name></name></expr></argument>,
							   <argument><expr><name>itemIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>itemIndex</name> <operator>&lt;</operator> <call><name>VarBlockGet_itemCount</name><argument_list>(<argument><expr><name>header</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>VarBlockByteOffset</name></type> <name>nextOffset</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>nextOffset</name> <operator>=</operator> <call><name>VarBlockGetOffset</name><argument_list>(
									   <argument><expr><name>header</name></expr></argument>,
									   <argument><expr><name><name>varBlockReader</name><operator>-&gt;</operator><name>offsetToOffsetArray</name></name></expr></argument>,
									   <argument><expr><name>itemIndex</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><operator>*</operator><name>itemLen</name> <operator>=</operator> <name>nextOffset</name> <operator>-</operator> <name>offset</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>*</operator><name>itemLen</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>itemIndex</name> <operator>==</operator> <call><name>VarBlockGet_itemCount</name><argument_list>(<argument><expr><name>header</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><operator>*</operator><name>itemLen</name> <operator>=</operator>
			<name>VARBLOCK_HEADER_LEN</name> <operator>+</operator>
			<call><name>VarBlockGet_itemLenSum</name><argument_list>(<argument><expr><name>header</name></expr></argument>)</argument_list></call> <operator>-</operator>
			<name>offset</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>*</operator><name>itemLen</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><operator>*</operator><name>itemPtr</name> <operator>=</operator> <operator>&amp;</operator><name><name>buffer</name><index>[<expr><name>offset</name></expr>]</index></name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Get a pointer to the next variable-length item.
 *
 * Returns NULL when there are no more items.
 */</comment>
<function><type><name>uint8</name> <modifier>*</modifier></type>
<name>VarBlockReaderGetNextItemPtr</name><parameter_list>(
							 <parameter><decl><type><name>VarBlockReader</name> <modifier>*</modifier></type><name>varBlockReader</name></decl></parameter>,
							 <parameter><decl><type><name>VarBlockByteLen</name> <modifier>*</modifier></type><name>itemLen</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint8</name>	   <modifier>*</modifier></type><name>nextItemPtr</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>varBlockReader</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>itemLen</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>varBlockReader</name><operator>-&gt;</operator><name>nextIndex</name></name> <operator>&gt;=</operator>
		<call><name>VarBlockGet_itemCount</name><argument_list>(<argument><expr><name><name>varBlockReader</name><operator>-&gt;</operator><name>header</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><operator>*</operator><name>itemLen</name> <operator>=</operator> <call><name>VarBlockGetItemLen</name><argument_list>(<argument><expr><name>varBlockReader</name></expr></argument>, <argument><expr><name><name>varBlockReader</name><operator>-&gt;</operator><name>nextIndex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>nextItemPtr</name> <operator>=</operator> <name><name>varBlockReader</name><operator>-&gt;</operator><name>nextItemPtr</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>varBlockReader</name><operator>-&gt;</operator><name>nextItemPtr</name></name> <operator>+=</operator> <operator>*</operator><name>itemLen</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>varBlockReader</name><operator>-&gt;</operator><name>nextIndex</name></name><operator>++</operator></expr>;</expr_stmt>

	<return>return <expr><name>nextItemPtr</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Get the variable-length item count.
 */</comment>
<function><type><name>int</name></type>
<name>VarBlockReaderItemCount</name><parameter_list>(
						<parameter><decl><type><name>VarBlockReader</name> <modifier>*</modifier></type><name>varBlockReader</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>varBlockReader</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>VarBlockGet_itemCount</name><argument_list>(<argument><expr><name><name>varBlockReader</name><operator>-&gt;</operator><name>header</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Get a pointer to a variable-length item.
 */</comment>
<function><type><name>uint8</name> <modifier>*</modifier></type>
<name>VarBlockReaderGetItemPtr</name><parameter_list>(
						 <parameter><decl><type><name>VarBlockReader</name> <modifier>*</modifier></type><name>varBlockReader</name></decl></parameter>,
						 <parameter><decl><type><name>int</name></type> <name>itemIndex</name></decl></parameter>,
						 <parameter><decl><type><name>VarBlockByteLen</name> <modifier>*</modifier></type><name>itemLen</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint8</name>	   <modifier>*</modifier></type><name>nextItemPtr</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>varBlockReader</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>itemIndex</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>itemIndex</name> <operator>&lt;</operator> <call><name>VarBlockGet_itemCount</name><argument_list>(<argument><expr><name><name>varBlockReader</name><operator>-&gt;</operator><name>header</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>VarBlockGetItemPtrAndLen</name><argument_list>(<argument><expr><name>varBlockReader</name></expr></argument>, <argument><expr><name>itemIndex</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nextItemPtr</name></expr></argument>, <argument><expr><name>itemLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>nextItemPtr</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>VarBlockByteLen</name></type>
<name>VarBlockCollapseToSingleItem</name><parameter_list>(
							 <parameter><decl><type><name>uint8</name> <modifier>*</modifier></type><name>target</name></decl></parameter>,
							 <parameter><decl><type><name>uint8</name> <modifier>*</modifier></type><name>source</name></decl></parameter>,
							 <parameter><decl><type><name>int32</name></type> <name>sourceLen</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>VarBlockReader</name></type> <name>varBlockReader</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint8</name>	   <modifier>*</modifier></type><name>itemPtr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>VarBlockByteLen</name></type> <name>itemLen</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>VarBlockReaderInit</name><argument_list>(
					   <argument><expr><operator>&amp;</operator><name>varBlockReader</name></expr></argument>,
					   <argument><expr><name>source</name></expr></argument>,
					   <argument><expr><name>sourceLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>VarBlockReaderItemCount</name><argument_list>(<argument><expr><operator>&amp;</operator><name>varBlockReader</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Copy out item, even if it destroys the VarBlock.
	 */</comment>
	<expr_stmt><expr><name>itemPtr</name> <operator>=</operator> <call><name>VarBlockReaderGetItemPtr</name><argument_list>(
									   <argument><expr><operator>&amp;</operator><name>varBlockReader</name></expr></argument>,
									    <comment type="block">/* itemIndex */</comment> <argument><expr><literal type="number">0</literal></expr></argument>,
									   <argument><expr><operator>&amp;</operator><name>itemLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Slide data back. Since we have overlapping data, we use memmove which
	 * knows how to do that instead of memcpy which isn't guaranteed to do
	 * that right.
	 */</comment>
	<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>target</name></expr></argument>,
			<argument><expr><name>itemPtr</name></expr></argument>,
			<argument><expr><name>itemLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>itemLen</name></expr>;</return>
</block_content>}</block></function>
</unit>
