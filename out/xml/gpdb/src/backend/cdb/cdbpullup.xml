<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/backend/cdb/cdbpullup.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * cdbpullup.c
 *    Provides routines supporting plan tree manipulation.
 *
 * Portions Copyright (c) 2006-2008, Greenplum inc
 * Portions Copyright (c) 2012-Present VMware, Inc. or its affiliates.
 *
 *
 * IDENTIFICATION
 *	    src/backend/cdb/cdbpullup.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/hash.h"</cpp:file></cpp:include>		<comment type="block">/* HashEqualStrategyNumber */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>	<comment type="block">/* makeVar() */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/plannodes.h"</cpp:file></cpp:include>	<comment type="block">/* Plan */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/clauses.h"</cpp:file></cpp:include>	<comment type="block">/* expression_tree_walker/mutator */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/tlist.h"</cpp:file></cpp:include>	<comment type="block">/* tlist_member() */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodeFuncs.h"</cpp:file></cpp:include>	<comment type="block">/* exprType() and exprTypmod() */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parsetree.h"</cpp:file></cpp:include>	<comment type="block">/* get_tle_by_resno() */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>	<comment type="block">/* get_opfamily_member() */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbpullup.h"</cpp:file></cpp:include>		<comment type="block">/* me */</comment>


<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>cdbpullup_missingVarWalker</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>targetlist</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Expr</name> <modifier>*</modifier></type><name>cdbpullup_make_expr</name><parameter_list>(<parameter><decl><type><name>Index</name></type> <name>varno</name></decl></parameter>, <parameter><decl><type><name>AttrNumber</name></type> <name>varattno</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>oldexpr</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>modifyOld</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * cdbpullup_expr
 *
 * Suppose there is a Plan node 'P' whose projection is defined by
 * a targetlist 'TL', and which has subplan 'S'.  Given TL and an
 * expr 'X0' whose Var nodes reference the result columns of S, this
 * function returns a new expr 'X1' that is a copy of X0 with Var nodes
 * adjusted to reference the columns of S after their passage through P.
 *
 * Parameters:
 *      expr -&gt; X0, the expr in terms of the subplan S's targetlist
 *      targetlist -&gt; TL (a List of TargetEntry), the plan P's targetlist
 *              (or can be a List of Expr)
 *      newvarlist -&gt; an optional List of Expr, in 1-1 correspondence with
 *              targetlist.  If specified, instead of creating a Var node to
 *              reference a targetlist item, we plug in a copy of the
 *              corresponding newvarlist item.
 *      newvarno = varno to be used in new Var nodes.  Ignored if a non-NULL
 *              newvarlist is given.
 *
 * This function cannot be used set_plan_references(). newvarno should be the
 * RTE index assigned to the result of the projection.
 *
 * At present this function doesn't support pull-up from a subquery into a
 * containing query: there is no provision for adjusting the varlevelsup
 * field in Var nodes for outer references.  This could be added if needed.
 *
 * Returns X1, the expr recast in terms of the given targetlist; or
 * NULL if X0 references a column of S that is not projected in TL.
 */</comment>
<struct>struct <name>pullUpExpr_context</name>
<block>{
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>targetlist</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>newvarlist</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Index</name></type>		<name>newvarno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>notfound</name></decl>;</decl_stmt>
}</block>;</struct>

<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>pullUpExpr_mutator</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>pullUpExpr_context</name></name> <modifier>*</modifier></type><name>ctx</name> <init>= <expr><operator>(</operator>struct <name>pullUpExpr_context</name> <operator>*</operator><operator>)</operator> <name>context</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>newnode</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>var</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>node</name> <operator>||</operator>
		<name><name>ctx</name><operator>-&gt;</operator><name>notfound</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Pull up Var. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>var</name> <operator>=</operator> <operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>node</name></expr>;</expr_stmt>

		<comment type="block">/* Outer reference?  Just copy it. */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>varlevelsup</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>var</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>ctx</name><operator>-&gt;</operator><name>targetlist</name></name></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>fail</name>;</goto></block_content></block></if></if_stmt>

		<comment type="block">/* Is targetlist a List of TargetEntry?  (Plan nodes use this format) */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>targetlist</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>TargetEntry</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>tle</name> <operator>=</operator> <call><name>tlist_member</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>var</name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>targetlist</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Fail if P's result does not include this column. */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>tle</name></expr>)</condition><block type="pseudo"><block_content>
				<goto>goto <name>fail</name>;</goto></block_content></block></if></if_stmt>

			<comment type="block">/* Substitute the corresponding entry from newvarlist, if given. */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>newvarlist</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>newnode</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>copyObject</name><argument_list>(<argument><expr><call><name>list_nth</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>newvarlist</name></name></expr></argument>,
													   <argument><expr><name><name>tle</name><operator>-&gt;</operator><name>resno</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

			<comment type="block">/* Substitute a Var node referencing the targetlist entry. */</comment>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>newnode</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>cdbpullup_make_expr</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>newvarno</name></name></expr></argument>,
													   <argument><expr><name><name>tle</name><operator>-&gt;</operator><name>resno</name></name></expr></argument>,
													   <argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>var</name></expr></argument>,
													   <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if>

		<comment type="block">/* Planner's RelOptInfo targetlists don't have TargetEntry nodes. */</comment>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>tlistexpr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>targetattno</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

			<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>ctx-&gt;targetlist</argument>)</argument_list></macro>
			<block>{<block_content>
				<expr_stmt><expr><name>tlistexpr</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * We don't use equal(), because we want to ignore typmod.
				 * A projection sometimes loses typmod, and that's OK.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>tlistexpr</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>tlistvar</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>tlistexpr</name></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>varno</name></name> <operator>==</operator> <name><name>tlistvar</name><operator>-&gt;</operator><name>varno</name></name> <operator>&amp;&amp;</operator>
						<name><name>var</name><operator>-&gt;</operator><name>varattno</name></name> <operator>==</operator> <name><name>tlistvar</name><operator>-&gt;</operator><name>varattno</name></name> <operator>&amp;&amp;</operator>
						<name><name>var</name><operator>-&gt;</operator><name>varlevelsup</name></name> <operator>==</operator> <name><name>tlistvar</name><operator>-&gt;</operator><name>varlevelsup</name></name></expr>)</condition><block type="pseudo"><block_content>
						<break>break;</break></block_content></block></if></if_stmt>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><name>targetattno</name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>cell</name></expr>)</condition><block type="pseudo"><block_content>
				<goto>goto <name>fail</name>;</goto></block_content></block></if></if_stmt>

			<comment type="block">/* Substitute the corresponding entry from newvarlist, if given. */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>newvarlist</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>newnode</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>copyObject</name><argument_list>(<argument><expr><call><name>list_nth</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>newvarlist</name></name></expr></argument>,
													   <argument><expr><name>targetattno</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

			<comment type="block">/* Substitute a Var node referencing the targetlist entry. */</comment>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>newnode</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>cdbpullup_make_expr</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>newvarno</name></name></expr></argument>,
													   <argument><expr><name>targetattno</name></expr></argument>,
													   <argument><expr><name>tlistexpr</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/* Make sure we haven't inadvertently changed the data type. */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>exprType</name><argument_list>(<argument><expr><name>newnode</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>exprType</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return <expr><name>newnode</name></expr>;</return>
	</block_content>}</block></if>

	<comment type="block">/* The whole expr might be in the targetlist of a Plan node. */</comment>
	<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>List</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			 <name><name>ctx</name><operator>-&gt;</operator><name>targetlist</name></name> <operator>&amp;&amp;</operator>
			 <call><name>IsA</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>targetlist</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>TargetEntry</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			 <name>NULL</name> <operator>!=</operator> <operator>(</operator><name>tle</name> <operator>=</operator> <call><name>tlist_member</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>targetlist</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Substitute the corresponding entry from newvarlist, if given. */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>ctx</name><operator>-&gt;</operator><name>newvarlist</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>newnode</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>copyObject</name><argument_list>(<argument><expr><call><name>list_nth</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>newvarlist</name></name></expr></argument>,
												   <argument><expr><name><name>tle</name><operator>-&gt;</operator><name>resno</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

		<comment type="block">/* Replace expr with a Var node referencing the targetlist entry. */</comment>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>newnode</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>cdbpullup_make_expr</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>newvarno</name></name></expr></argument>,
												   <argument><expr><name><name>tle</name><operator>-&gt;</operator><name>resno</name></name></expr></argument>,
												   <argument><expr><name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/* Make sure we haven't inadvertently changed the data type. */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>exprType</name><argument_list>(<argument><expr><name>newnode</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>exprType</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return <expr><name>newnode</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><call><name>expression_tree_mutator</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>pullUpExpr_mutator</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</return>

	<comment type="block">/* Fail if P's result does not include a referenced column. */</comment>
<label><name>fail</name>:</label>
	<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>notfound</name></name> <operator>=</operator> <name>var</name></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>								<comment type="block">/* pullUpExpr_mutator */</comment>

<function><type><name>Expr</name> <modifier>*</modifier></type>
<name>cdbpullup_expr</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>targetlist</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>newvarlist</name></decl></parameter>, <parameter><decl><type><name>Index</name></type> <name>newvarno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>newexpr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>pullUpExpr_context</name></name></type> <name>ctx</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>targetlist</name> <operator>||</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>targetlist</name></expr></argument>, <argument><expr><name>List</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>newvarlist</name> <operator>||</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>newvarlist</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>targetlist</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>targetlist</name></name> <operator>=</operator> <name>targetlist</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>newvarlist</name></name> <operator>=</operator> <name>newvarlist</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>newvarno</name></name> <operator>=</operator> <name>newvarno</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>notfound</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>newexpr</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>pullUpExpr_mutator</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>ctx</name><operator>.</operator><name>notfound</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>newexpr</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>newexpr</name></expr>;</return>
</block_content>}</block></function>								<comment type="block">/* cdbpullup_expr */</comment>

<comment type="block">/*
 * cdbpullup_findEclassInTargetList
 *
 * Searches the given equivalence class for a member that uses no rels
 * outside the 'relids' set, and either is a member of 'targetlist', or
 * uses no Vars that are not in 'targetlist'. Furthermore, if
 * 'hashOpFamily' is valid, the member must be hashable using that hash
 * operator family.
 *
 * If found, returns the chosen member's expression, otherwise returns
 * NULL.
 *
 * NB: We ignore the presence or absence of a RelabelType node atop either
 * expr in determining whether an EC member expr matches a targetlist expr.
 *
 * (A RelabelType node might have been placed atop an EC member's expr to
 * match its type to the sortop's input operand type, when the types are
 * binary compatible but not identical... such as VARCHAR and TEXT.  The
 * RelabelType node merely documents the representational equivalence but
 * does not affect the semantics.  A RelabelType node might also be found
 * atop an argument of a function or operator, but generally not atop a
 * targetlist expr.)
 */</comment>
<function><type><name>Expr</name> <modifier>*</modifier></type>
<name>cdbpullup_findEclassInTargetList</name><parameter_list>(<parameter><decl><type><name>EquivalenceClass</name> <modifier>*</modifier></type><name>eclass</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>targetlist</name></decl></parameter>,
								 <parameter><decl><type><name>Oid</name></type> <name>hashOpFamily</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>eclass-&gt;ec_members</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>EquivalenceMember</name> <modifier>*</modifier></type><name>em</name> <init>= <expr><operator>(</operator><name>EquivalenceMember</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>key</name> <init>= <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name><name>em</name><operator>-&gt;</operator><name>em_expr</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc_tle</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>hashOpFamily</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<operator>!</operator><call><name>get_opfamily_member</name><argument_list>(<argument><expr><name>hashOpFamily</name></expr></argument>, <argument><expr><name><name>em</name><operator>-&gt;</operator><name>em_datatype</name></name></expr></argument>, <argument><expr><name><name>em</name><operator>-&gt;</operator><name>em_datatype</name></name></expr></argument>,
								 <argument><expr><name>HTEqualStrategyNumber</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* A constant is OK regardless of the target list */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>em</name><operator>-&gt;</operator><name>em_is_const</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>key</name></expr>;</return></block_content></block></if></if_stmt>

		<comment type="block">/*-------
		 * Try to find this EC member in the target list.
		 *
		 * We do the search in a very lenient way:
		 *
		 * 1. Ignore RelabelType nodes on top of both sides, like
		 *    tlist_member_ignore_relabel() does.
		 * 2. Ignore varnoold/varoattno fields in Var nodes, like
		 *    tlist_member_match_var() does.
		 * 3. Also Accept "naked" targetlists, without TargetEntry nodes
		 *
		 * Unfortunately, neither tlist_member_ignore_relabel() nor
		 * tlist_member_match_var() does exactly what we need.
		 *-------
		 */</comment>
		<while>while <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>RelabelType</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>key</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>RelabelType</name> <operator>*</operator><operator>)</operator> <name>key</name><operator>)</operator><operator>-&gt;</operator><name>arg</name></expr>;</expr_stmt></block_content></block></while>

		<macro><name>foreach</name><argument_list>(<argument>lc_tle</argument>, <argument>targetlist</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>tlexpr</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc_tle</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>naked_tlexpr</name></decl>;</decl_stmt>

			<comment type="block">/*
			 * Check if targetlist is a List of TargetEntry. (Planner's
			 * RelOptInfo targetlists don't have TargetEntry nodes.)
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>tlexpr</name></expr></argument>, <argument><expr><name>TargetEntry</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>tlexpr</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <name>tlexpr</name><operator>)</operator><operator>-&gt;</operator><name>expr</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/* ignore RelabelType nodes on both sides */</comment>
			<expr_stmt><expr><name>naked_tlexpr</name> <operator>=</operator> <name>tlexpr</name></expr>;</expr_stmt>
			<while>while <condition>(<expr><name>naked_tlexpr</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>naked_tlexpr</name></expr></argument>, <argument><expr><name>RelabelType</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>naked_tlexpr</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>RelabelType</name> <operator>*</operator><operator>)</operator> <name>naked_tlexpr</name><operator>)</operator><operator>-&gt;</operator><name>arg</name></expr>;</expr_stmt></block_content></block></while>

			<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>naked_tlexpr</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>keyvar</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>key</name></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>tlvar</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>naked_tlexpr</name></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><name><name>keyvar</name><operator>-&gt;</operator><name>varno</name></name> <operator>==</operator> <name><name>tlvar</name><operator>-&gt;</operator><name>varno</name></name> <operator>&amp;&amp;</operator>
						<name><name>keyvar</name><operator>-&gt;</operator><name>varattno</name></name> <operator>==</operator> <name><name>tlvar</name><operator>-&gt;</operator><name>varattno</name></name> <operator>&amp;&amp;</operator>
						<name><name>keyvar</name><operator>-&gt;</operator><name>varlevelsup</name></name> <operator>==</operator> <name><name>tlvar</name><operator>-&gt;</operator><name>varlevelsup</name></name></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>tlexpr</name></expr>;</return></block_content></block></if></if_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><call><name>equal</name><argument_list>(<argument><expr><name>naked_tlexpr</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>tlexpr</name></expr>;</return></block_content></block></if></if_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block>

		<comment type="block">/* Return this item if all referenced Vars are in targetlist. */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<operator>!</operator><call><name>cdbpullup_missingVarWalker</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>targetlist</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>key</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * cdbpullup_truncatePathKeysForTargetList
 *
 * Truncate a list of pathkeys to only those that can be evaluated
 * using the given target list.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>cdbpullup_truncatePathKeysForTargetList</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>pathkeys</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>targetlist</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>new_pathkeys</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>pathkeys</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PathKey</name>	   <modifier>*</modifier></type><name>pk</name> <init>= <expr><operator>(</operator><name>PathKey</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>cdbpullup_findEclassInTargetList</name><argument_list>(<argument><expr><name><name>pk</name><operator>-&gt;</operator><name>pk_eclass</name></name></expr></argument>, <argument><expr><name>targetlist</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>new_pathkeys</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>new_pathkeys</name></expr></argument>, <argument><expr><name>pk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>new_pathkeys</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * cdbpullup_isExprCoveredByTargetlist
 *
 * Returns true if 'expr' is in 'targetlist', or if 'expr' contains no
 * Var node of the current query level that is not in 'targetlist'.
 *
 * If 'expr' is a List, returns false if the above condition is false for
 * some member of the list.
 *
 * 'targetlist' is a List of TargetEntry.
 *
 * NB:  A Var in the expr is considered as matching a Var in the targetlist
 * without regard for whether or not there is a RelabelType node atop the
 * targetlist Var.
 *
 * See also: cdbpullup_missing_var_walker
 */</comment>
<function><type><name>bool</name></type>
<name>cdbpullup_isExprCoveredByTargetlist</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>targetlist</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>

	<comment type="block">/* List of Expr?  Verify that all items are covered. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>List</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>(List *) expr</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>item</name> <init>= <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/* The whole expr or all of its Vars must be in targetlist. */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>tlist_member_ignore_relabel</name><argument_list>(<argument><expr><name>item</name></expr></argument>, <argument><expr><name>targetlist</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
				<call><name>cdbpullup_missingVarWalker</name><argument_list>(<argument><expr><name>item</name></expr></argument>, <argument><expr><name>targetlist</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block>
	</block_content>}</block></if>

	<comment type="block">/* The whole expr or all of its Vars must be in targetlist. */</comment>
	<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>tlist_member_ignore_relabel</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>targetlist</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			 <call><name>cdbpullup_missingVarWalker</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>targetlist</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* expr is evaluable on rows projected thru targetlist */</comment>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>								<comment type="block">/* cdbpullup_isExprCoveredByTlist */</comment>


<comment type="block">/*
 * cdbpullup_make_var
 *
 * Returns a new Var node with given 'varno' and 'varattno', and varlevelsup=0.
 *
 * The caller must provide an 'oldexpr' from which we obtain the vartype and
 * vartypmod for the new Var node.  If 'oldexpr' is a Var node, all fields are
 * copied except for varno, varattno and varlevelsup.
 *
 * The parameter modifyOld determines if varnoold and varoattno are modified or
 * not. Rule of thumb is to use modifyOld = false if called before setrefs.
 *
 * Copying an existing Var node preserves its varnoold and varoattno fields,
 * which are used by EXPLAIN to display the table and column name.
 * Also these fields are tested by equal(), so they may need to be set
 * correctly for successful lookups by list_member(), tlist_member(),
 * make_canonical_pathkey(), etc.
 */</comment>
<function><type><specifier>static</specifier> <name>Expr</name> <modifier>*</modifier></type>
<name>cdbpullup_make_expr</name><parameter_list>(<parameter><decl><type><name>Index</name></type> <name>varno</name></decl></parameter>, <parameter><decl><type><name>AttrNumber</name></type> <name>varattno</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>oldexpr</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>modifyOld</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>oldexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* If caller provided an old Var node, copy and modify it. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>oldexpr</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>var</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>oldexpr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>varno</name></name> <operator>=</operator> <name>varno</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name> <operator>=</operator> <name>varattno</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>modifyOld</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>varoattno</name></name> <operator>=</operator> <name>varattno</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>varnoold</name></name> <operator>=</operator> <name>varno</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>varlevelsup</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<return>return <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>var</name></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>oldexpr</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Const</name>	   <modifier>*</modifier></type><name>constExpr</name> <init>= <expr><call><name>copyObject</name><argument_list>(<argument><expr><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>oldexpr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<return>return <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>constExpr</name></expr>;</return>
	</block_content>}</block></if>
	<comment type="block">/* Make a new Var node. */</comment>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>var</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>oldexpr</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>oldexpr</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>var</name> <operator>=</operator> <call><name>makeVar</name><argument_list>(<argument><expr><name>varno</name></expr></argument>,
					  <argument><expr><name>varattno</name></expr></argument>,
					  <argument><expr><call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>oldexpr</name></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><call><name>exprTypmod</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>oldexpr</name></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><call><name>exprCollation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>oldexpr</name></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>varnoold</name></name> <operator>=</operator> <name>varno</name></expr>;</expr_stmt>	<comment type="block">/* assuming it wasn't ever a plain Var */</comment>
		<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>varoattno</name></name> <operator>=</operator> <name>varattno</name></expr>;</expr_stmt>
		<return>return <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>var</name></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>								<comment type="block">/* cdbpullup_make_var */</comment>


<comment type="block">/*
 * cdbpullup_missingVarWalker
 *
 * Returns true if some Var in expr is not in targetlist.
 * 'targetlist' is either a List of TargetEntry, or a plain List of Expr.
 *
 * NB:  A Var in the expr is considered as matching a Var in the targetlist
 * without regard for whether or not there is a RelabelType node atop the
 * targetlist Var.
 *
 * See also: cdbpullup_isExprCoveredByTargetlist
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>cdbpullup_missingVarWalker</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>targetlist</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>node</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Should also consider PlaceHolderVar in the targetlist.
	 * See github issue: https://github.com/greenplum-db/gpdb/issues/10315
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>PlaceHolderVar</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>targetlist</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

		<comment type="block">/* is targetlist a List of TargetEntry? */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name>targetlist</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>TargetEntry</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>tlist_member_ignore_relabel</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <name>targetlist</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>	<comment type="block">/* this Var ok - go on to check rest of expr */</comment>
		</block_content>}</block></if>

		<comment type="block">/* targetlist must be a List of Expr */</comment>
		<if type="elseif">else if <condition>(<expr><call><name>list_member</name><argument_list>(<argument><expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <name>targetlist</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>		<comment type="block">/* this Var ok - go on to check rest of expr */</comment>

		<return>return <expr><name>true</name></expr>;</return>			<comment type="block">/* Var is not in targetlist - quit the walk */</comment>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>, <argument><expr><name>cdbpullup_missingVarWalker</name></expr></argument>, <argument><expr><name>targetlist</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>								<comment type="block">/* cdbpullup_missingVarWalker */</comment>
</unit>
