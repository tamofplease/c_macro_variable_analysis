<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/backend/cdb/cdbtm.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * cdbtm.c
 *	  Provides routines for performing distributed transaction
 *
 * Portions Copyright (c) 2005-2009, Greenplum inc
 * Portions Copyright (c) 2012-Present VMware, Inc. or its affiliates.
 *
 *
 * IDENTIFICATION
 *	    src/backend/cdb/cdbtm.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;time.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/stat.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/types.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_authid.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbtm.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq/libpq-be.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq/pqformat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/lmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/pmsignal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/s_lock.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/shmem.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/ipc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbdisp.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbdisp_query.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbdisp_dtx.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbdispatchresult.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbdtxcontextinfo.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbvars.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/transam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq-fe.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq-int.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbfts.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lib/stringinfo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/twophase.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/distributedlog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/postmaster.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"port/atomics.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/procarray.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbllize.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/faultinjector.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/guc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/fmgrprotos.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/fmgroids.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/session_state.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/sharedsnapshot.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/snapmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>

<typedef>typedef <type><struct>struct <name>TmControlBlock</name>
<block>{
	<decl_stmt><decl><type><name>bool</name></type>						<name>DtmStarted</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>						<name>CleanupBackends</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pid_t</name></type>						<name>DtxRecoveryPid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DtxRecoveryEvent</name></type>			<name>DtxRecoveryEvents</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>slock_t</name></type>						<name>DtxRecoveryEventLock</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>						<name>NextSnapshotId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>							<name>num_committed_xacts</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>slock_t</name></type>						<name>gxidGenLock</name></decl>;</decl_stmt>

	<comment type="block">/* Array [0..max_tm_gxacts-1] of DistributedTransactionId ptrs is appended starting here */</comment>
	<decl_stmt><decl><type><name>DistributedTransactionId</name></type> <name><name>committed_gxid_array</name><index>[<expr><name>FLEXIBLE_ARRAY_MEMBER</name></expr>]</index></name></decl>;</decl_stmt>
}</block></struct></type>	<name>TmControlBlock</name>;</typedef>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TMCONTROLBLOCK_BYTES</name><parameter_list>(<parameter><type><name>num_gxacts</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>(offsetof(TmControlBlock, committed_gxid_array) + sizeof(DistributedTransactionId) * (num_gxacts))</cpp:value></cpp:define>

<decl_stmt><decl><type><specifier>extern</specifier> <name>bool</name></type> <name>Test_print_direct_dispatch_info</name></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DTX_PHASE2_SLEEP_TIME_BETWEEN_RETRIES_MSECS</name></cpp:macro> <cpp:value>100</cpp:value></cpp:define>

<decl_stmt><decl><type><name>uint32</name> <modifier>*</modifier></type><name>shmNextSnapshotId</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>slock_t</name> <modifier>*</modifier></type><name>shmGxidGenLock</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type>	<name>max_tm_gxacts</name> <init>= <expr><literal type="number">100</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>gp_gxid_prefetch_num</name></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GXID_PRETCH_THRESHOLD</name></cpp:macro> <cpp:value>(gp_gxid_prefetch_num&gt;&gt;1)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TM_ERRDETAIL</name></cpp:macro> <cpp:value>(errdetail("gid=" UINT64_FORMAT ", state=%s", \
		getDistributedTransactionId(),\
		DtxStateToString(MyTmGxactLocal ? MyTmGxactLocal-&gt;state : 0)))</cpp:value></cpp:define>
<comment type="block">/* here are some flag options relationed to the txnOptions field of
 * PQsendGpQuery
 */</comment>

<comment type="block">/*
 * bit 1 is for statement wants DTX transaction
 * bits 2-4 for iso level
 * bit 5 is for read-only
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GP_OPT_NEED_DTX</name></cpp:macro>                           <cpp:value>0x0001</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GP_OPT_ISOLATION_LEVEL_MASK</name></cpp:macro>   					<cpp:value>0x000E</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GP_OPT_READ_UNCOMMITTED</name></cpp:macro>							<cpp:value>(1 &lt;&lt; 1)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GP_OPT_READ_COMMITTED</name></cpp:macro>							<cpp:value>(2 &lt;&lt; 1)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GP_OPT_REPEATABLE_READ</name></cpp:macro>							<cpp:value>(3 &lt;&lt; 1)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GP_OPT_SERIALIZABLE</name></cpp:macro>								<cpp:value>(4 &lt;&lt; 1)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GP_OPT_READ_ONLY</name></cpp:macro>         						<cpp:value>0x0010</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GP_OPT_EXPLICT_BEGIN</name></cpp:macro>      						<cpp:value>0x0020</cpp:value></cpp:define>

<comment type="block">/*=========================================================================
 * FUNCTIONS PROTOTYPES
 */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>doPrepareTransaction</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>doInsertForgetCommitted</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>doNotifyingOnePhaseCommit</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>doNotifyingCommitPrepared</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>doNotifyingAbort</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>retryAbortPrepared</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>doQEDistributedExplicitBegin</name><parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>currentDtxActivate</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>setCurrentDtxState</name><parameter_list>(<parameter><decl><type><name>DtxState</name></type> <name>state</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>isDtxQueryDispatcher</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>performDtxProtocolCommitPrepared</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>gid</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>raiseErrorIfNotFound</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>performDtxProtocolAbortPrepared</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>gid</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>raiseErrorIfNotFound</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>sendWaitGxidsToQD</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>waitGxids</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>extern</specifier> <name>void</name></type> <name>GpDropTempTables</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<function><type><name>void</name></type>
<name>setDistributedTransactionContext</name><parameter_list>(<parameter><decl><type><name>DtxContext</name></type> <name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><operator>(</operator><ternary><condition><expr><name>Debug_print_full_dtm</name></expr> ?</condition><then> <expr><name>LOG</name></expr> </then><else>: <expr><name>DEBUG5</name></expr></else></ternary><operator>)</operator></expr></argument>,
		  <argument><expr><literal type="string">"Setting DistributedTransactionContext to '%s'"</literal></expr></argument>,
		  <argument><expr><call><name>DtxContextToString</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>DistributedTransactionContext</name> <operator>=</operator> <name>context</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>requireDistributedTransactionContext</name><parameter_list>(<parameter><decl><type><name>DtxContext</name></type> <name>requiredCurrentContext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>DistributedTransactionContext</name> <operator>!=</operator> <name>requiredCurrentContext</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"Expected segment distributed transaction context to be '%s', found '%s'"</literal></expr></argument>,
			 <argument><expr><call><name>DtxContextToString</name><argument_list>(<argument><expr><name>requiredCurrentContext</name></expr></argument>)</argument_list></call></expr></argument>,
			 <argument><expr><call><name>DtxContextToString</name><argument_list>(<argument><expr><name>DistributedTransactionContext</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>isDtxContext</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name>DistributedTransactionContext</name> <operator>!=</operator> <name>DTX_CONTEXT_LOCAL_ONLY</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*=========================================================================
 * VISIBLE FUNCTIONS
 */</comment>

<function><type><name>DistributedTransactionId</name></type>
<name>getDistributedTransactionId</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>isDtxContext</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name><name>MyTmGxact</name><operator>-&gt;</operator><name>gxid</name></name></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><name>InvalidDistributedTransactionId</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>getDistributedTransactionIdentifier</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>MyTmGxactLocal</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>isDtxContext</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <name><name>MyTmGxact</name><operator>-&gt;</operator><name>gxid</name></name> <operator>!=</operator> <name>InvalidDistributedTransactionId</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * The length check here requires the identifer have a trailing
		 * NUL character.
		 */</comment>
		<expr_stmt><expr><call><name>dtxFormGid</name><argument_list>(<argument><expr><name>id</name></expr></argument>, <argument><expr><name><name>MyTmGxact</name><operator>-&gt;</operator><name>gxid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>id</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TMGIDSIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>isPreparedDtxTransaction</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>AssertImply</name><argument_list>(<argument><expr><name><name>MyTmGxactLocal</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>DTX_STATE_PREPARED</name></expr></argument>,
				<argument><expr><operator>(</operator><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name> <operator>&amp;&amp;</operator>
				<name>DistributedTransactionContext</name> <operator>==</operator> <name>DTX_CONTEXT_QD_DISTRIBUTED_CAPABLE</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><name><name>MyTmGxactLocal</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>DTX_STATE_PREPARED</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * The executor can avoid starting a distributed transaction if it knows that
 * the current dtx is clean and we aren't in a user-started global transaction.
 */</comment>
<function><type><name>bool</name></type>
<name>isCurrentDtxActivated</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name><name>MyTmGxactLocal</name><operator>-&gt;</operator><name>state</name></name> <operator>!=</operator> <name>DTX_STATE_NONE</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>bumpGxid</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DistributedTransactionId</name></type> <name>nextLimit</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type> <name>nextCount</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Someone else might have done this, so if the lock was blocked and is now
	 * free, just return.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>LWLockAcquireOrWait</name><argument_list>(<argument><expr><name>GxidBumpLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * No need to bump if there have been enough gxid. This is possible if
	 * another bump finished before we tried to lock GxidBumpLock.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>GxidCount</name></name> <operator>&gt;</operator> <name>GXID_PRETCH_THRESHOLD</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>GxidBumpLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* nextLimit should be always multiple of gp_gxid_prefetch_num. */</comment>
	<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><name>shmGxidGenLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>nextCount</name> <operator>=</operator> <name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>GxidCount</name></name> <operator>+</operator> <name>gp_gxid_prefetch_num</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>nextLimit</name> <operator>=</operator> <name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>nextGxid</name></name> <operator>+</operator> <name>nextCount</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>nextLimit</name> <operator>&gt;=</operator> <operator>(</operator><name>LastDistributedTransactionId</name> <operator>-</operator> <name>gp_gxid_prefetch_num</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Will soon reach the limit of global transactions: "</literal><name>UINT64_FORMAT</name></expr></argument>,
						<argument><expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>nextGxid</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><name>shmGxidGenLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* It might be time-consuming, so put it out of the spin locking section. */</comment>
	<expr_stmt><expr><call><name>XLogPutNextGxid</name><argument_list>(<argument><expr><name>nextLimit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><name>shmGxidGenLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>GxidCount</name></name> <operator>+=</operator> <name>gp_gxid_prefetch_num</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><name>shmGxidGenLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Only one bump operation one time, so lock till the end. */</comment>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>GxidBumpLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>currentDtxActivate</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>signal_dtx_recovery</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>GxidCount</name></name> <operator>&lt;=</operator> <name>GXID_PRETCH_THRESHOLD</name> <operator>&amp;&amp;</operator>
		<operator>(</operator><call><name>GetDtxRecoveryEvent</name><argument_list>()</argument_list></call> <operator>&amp;</operator> <name>DTX_RECOVERY_EVENT_BUMP_GXID</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>

		<expr_stmt><expr><name>signal_dtx_recovery</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><name>shmDtxRecoveryEventLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>GetDtxRecoveryEvent</name><argument_list>()</argument_list></call> <operator>&amp;</operator> <name>DTX_RECOVERY_EVENT_BUMP_GXID</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* dtx recovery is not notified, wake up dtx recovery to prefetch. */</comment>
			<expr_stmt><expr><call><name>SetDtxRecoveryEvent</name><argument_list>(<argument><expr><name>DTX_RECOVERY_EVENT_BUMP_GXID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>signal_dtx_recovery</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><name>shmDtxRecoveryEventLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>signal_dtx_recovery</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>SendPostmasterSignal</name><argument_list>(<argument><expr><name>PMSIGNAL_WAKEN_DTX_RECOVERY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * We need to retry since in theory even after gxid bumping, we still can
	 * not get an available gxid if other backends quickly consume all of the
	 * generated gxid. This mostly happens when the system is with high
	 * performance and load but with low gxid prefetch batch size. It should be
	 * rare so far, but in case in the future...
	 */</comment>
	<for>for<control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>GxidCount</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>bumpGxid</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><name>shmGxidGenLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>GxidCount</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>MyTmGxact</name><operator>-&gt;</operator><name>gxid</name></name> <operator>=</operator> <name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>nextGxid</name></name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>GxidCount</name></name><operator>--</operator></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><name>shmGxidGenLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><name>shmGxidGenLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><name><name>MyTmGxact</name><operator>-&gt;</operator><name>sessionId</name></name> <operator>=</operator> <name>gp_session_id</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>setCurrentDtxState</name><argument_list>(<argument><expr><name>DTX_STATE_ACTIVE_DISTRIBUTED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>GxactLockTableInsert</name><argument_list>(<argument><expr><name><name>MyTmGxact</name><operator>-&gt;</operator><name>gxid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>setCurrentDtxState</name><parameter_list>(<parameter><decl><type><name>DtxState</name></type> <name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>MyTmGxactLocal</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>state</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>DtxState</name></type>
<name>getCurrentDtxState</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><ternary><condition><expr><name>MyTmGxactLocal</name></expr> ?</condition><then> <expr><name><name>MyTmGxactLocal</name><operator>-&gt;</operator><name>state</name></name></expr> </then><else>: <expr><name>DTX_STATE_NONE</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>notifyCommittedDtxTransactionIsNeeded</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>DistributedTransactionContext</name> <operator>!=</operator> <name>DTX_CONTEXT_QD_DISTRIBUTED_CAPABLE</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DTM_DEBUG5</name></expr></argument>, <argument><expr><literal type="string">"notifyCommittedDtxTransaction nothing to do (DistributedTransactionContext = '%s')"</literal></expr></argument>,
			 <argument><expr><call><name>DtxContextToString</name><argument_list>(<argument><expr><name>DistributedTransactionContext</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>isCurrentDtxActivated</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DTM_DEBUG5</name></expr></argument>, <argument><expr><literal type="string">"notifyCommittedDtxTransaction nothing to do (two phase not activated)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Notify committed a global transaction, called by user commit
 * or by CommitTransaction
 */</comment>
<function><type><name>void</name></type>
<name>notifyCommittedDtxTransaction</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>DistributedTransactionContext</name> <operator>==</operator> <name>DTX_CONTEXT_QD_DISTRIBUTED_CAPABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>isCurrentDtxActivated</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<switch>switch<condition>(<expr><name><name>MyTmGxactLocal</name><operator>-&gt;</operator><name>state</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>DTX_STATE_INSERTED_COMMITTED</name></expr>:</case>
			<expr_stmt><expr><call><name>doNotifyingCommitPrepared</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>DTX_STATE_NOTIFYING_ONE_PHASE_COMMIT</name></expr>:</case>
		<case>case <expr><name>DTX_STATE_ONE_PHASE_COMMIT</name></expr>:</case>
			<comment type="block">/* Already notified for one phase commit or no need to notify. */</comment>
			<break>break;</break>
		<default>default:</default>
			<empty_stmt>;</empty_stmt>
			<decl_stmt><decl><type><name>TransactionId</name></type> <name>xid</name> <init>= <expr><call><name>GetTopTransactionIdIfAny</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type> <name>markXidCommitted</name> <init>= <expr><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<comment type="block">/*
			 * If local commit xlog is written we can not throw error and then
			 * abort transaction (that will cause panic) so directly panic
			 * for that case with more details.
			 */</comment>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><ternary><condition><expr><name>markXidCommitted</name></expr> ?</condition><then> <expr><name>PANIC</name></expr> </then><else>: <expr><name>ERROR</name></expr></else></ternary></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Unexpected DTX state"</literal></expr></argument>)</argument_list></call><operator>,</operator> <name>TM_ERRDETAIL</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>


	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>MyTmGxactLocal-&gt;waitGxids</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><call><name>GxactLockTableWait</name><argument_list>(<argument><expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>setupDtxTransaction</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsTransactionState</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"DTM transaction is not active"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>isCurrentDtxActivated</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>currentDtxActivate</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>MyTmGxactLocal</name><operator>-&gt;</operator><name>state</name></name> <operator>!=</operator> <name>DTX_STATE_ACTIVE_DISTRIBUTED</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"DTM transaction state (%s) is invalid"</literal></expr></argument>, <argument><expr><call><name>DtxStateToString</name><argument_list>(<argument><expr><name><name>MyTmGxactLocal</name><operator>-&gt;</operator><name>state</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Routine to dispatch internal sub-transaction calls from UDFs to segments.
 * The calls are BeginInternalSubTransaction, ReleaseCurrentSubTransaction and
 * RollbackAndReleaseCurrentSubTransaction.
 */</comment>
<function><type><name>bool</name></type>
<name>doDispatchSubtransactionInternalCmd</name><parameter_list>(<parameter><decl><type><name>DtxProtocolCommand</name></type> <name>cmdType</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>serializedDtxContextInfo</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>serializedDtxContextInfoLen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>gid</name><index>[<expr><name>TMGIDSIZE</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>succeeded</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>currentGxactWriterGangLost</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"writer gang of current global transaction is lost"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>cmdType</name> <operator>==</operator> <name>DTX_PROTOCOL_COMMAND_SUBTRANSACTION_BEGIN_INTERNAL</name> <operator>&amp;&amp;</operator>
		<operator>!</operator><call><name>isCurrentDtxActivated</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>currentDtxActivate</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>serializedDtxContextInfo</name> <operator>=</operator> <call><name>qdSerializeDtxContextInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>serializedDtxContextInfoLen</name></expr></argument>,
														 <argument><expr><name>false</name></expr></argument> <comment type="block">/* wantSnapshot */</comment> ,
														 <argument><expr><name>false</name></expr></argument> <comment type="block">/* inCursor */</comment> ,
														 <argument><expr><call><name>mppTxnOptions</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></argument>,
														 <argument><expr><literal type="string">"doDispatchSubtransactionInternalCmd"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>dtxFormGid</name><argument_list>(<argument><expr><name>gid</name></expr></argument>, <argument><expr><call><name>getDistributedTransactionId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>succeeded</name> <operator>=</operator> <call><name>doDispatchDtxProtocolCommand</name><argument_list>(<argument><expr><name>cmdType</name></expr></argument>,
											 <argument><expr><name>gid</name></expr></argument>,
											 <comment type="block">/* raiseError */</comment> <argument><expr><name>true</name></expr></argument>,
											 <argument><expr><call><name>cdbcomponent_getCdbComponentsList</name><argument_list>()</argument_list></call></expr></argument>,
											 <argument><expr><name>serializedDtxContextInfo</name></expr></argument>, <argument><expr><name>serializedDtxContextInfoLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* send a DTM command to others to tell them about the transaction */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>succeeded</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"dispatching subtransaction internal command failed for gid = \"%s\" due to error"</literal></expr></argument>, <argument><expr><name>gid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>succeeded</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>doPrepareTransaction</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>succeeded</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DTM_DEBUG5</name></expr></argument>, <argument><expr><literal type="string">"doPrepareTransaction entering in state = %s"</literal></expr></argument>,
		 <argument><expr><call><name>DtxStateToString</name><argument_list>(<argument><expr><name><name>MyTmGxactLocal</name><operator>-&gt;</operator><name>state</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Don't allow a cancel while we're dispatching our prepare (we wrap our
	 * state change as well; for good measure.
	 */</comment>
	<expr_stmt><expr><call><name>HOLD_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>MyTmGxactLocal</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>DTX_STATE_ACTIVE_DISTRIBUTED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>setCurrentDtxState</name><argument_list>(<argument><expr><name>DTX_STATE_PREPARING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DTM_DEBUG5</name></expr></argument>, <argument><expr><literal type="string">"doPrepareTransaction moved to state = %s"</literal></expr></argument>, <argument><expr><call><name>DtxStateToString</name><argument_list>(<argument><expr><name><name>MyTmGxactLocal</name><operator>-&gt;</operator><name>state</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>MyTmGxactLocal</name><operator>-&gt;</operator><name>dtxSegments</name></name> <operator>!=</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>succeeded</name> <operator>=</operator> <call><name>currentDtxDispatchProtocolCommand</name><argument_list>(<argument><expr><name>DTX_PROTOCOL_COMMAND_PREPARE</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Now we've cleaned up our dispatched statement, cancels are allowed
	 * again.
	 */</comment>
	<expr_stmt><expr><call><name>RESUME_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>succeeded</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"The distributed transaction 'Prepare' broadcast failed to one or more segments"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				<name>TM_ERRDETAIL</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DTM_DEBUG5</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"The distributed transaction 'Prepare' broadcast succeeded to the segments"</literal></expr></argument>)</argument_list></call><operator>,</operator>
			<name>TM_ERRDETAIL</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>MyTmGxactLocal</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>DTX_STATE_PREPARING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>setCurrentDtxState</name><argument_list>(<argument><expr><name>DTX_STATE_PREPARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>SIMPLE_FAULT_INJECTOR</name><argument_list>(<argument><expr><literal type="string">"dtm_broadcast_prepare"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DTM_DEBUG5</name></expr></argument>, <argument><expr><literal type="string">"doPrepareTransaction leaving in state = %s"</literal></expr></argument>, <argument><expr><call><name>DtxStateToString</name><argument_list>(<argument><expr><name><name>MyTmGxactLocal</name><operator>-&gt;</operator><name>state</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Insert FORGET COMMITTED into the xlog.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>doInsertForgetCommitted</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DTM_DEBUG5</name></expr></argument>, <argument><expr><literal type="string">"doInsertForgetCommitted entering in state = %s"</literal></expr></argument>, <argument><expr><call><name>DtxStateToString</name><argument_list>(<argument><expr><name><name>MyTmGxactLocal</name><operator>-&gt;</operator><name>state</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>setCurrentDtxState</name><argument_list>(<argument><expr><name>DTX_STATE_INSERTING_FORGET_COMMITTED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>RecordDistributedForgetCommitted</name><argument_list>(<argument><expr><call><name>getDistributedTransactionId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>setCurrentDtxState</name><argument_list>(<argument><expr><name>DTX_STATE_INSERTED_FORGET_COMMITTED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>MyTmGxact</name><operator>-&gt;</operator><name>includeInCkpt</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>doNotifyingOnePhaseCommit</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>succeeded</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>MyTmGxactLocal</name><operator>-&gt;</operator><name>dtxSegments</name></name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DTM_DEBUG5</name></expr></argument>, <argument><expr><literal type="string">"doNotifyingOnePhaseCommit entering in state = %s"</literal></expr></argument>, <argument><expr><call><name>DtxStateToString</name><argument_list>(<argument><expr><name><name>MyTmGxactLocal</name><operator>-&gt;</operator><name>state</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>MyTmGxactLocal</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>DTX_STATE_ONE_PHASE_COMMIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>setCurrentDtxState</name><argument_list>(<argument><expr><name>DTX_STATE_NOTIFYING_ONE_PHASE_COMMIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>succeeded</name> <operator>=</operator> <call><name>currentDtxDispatchProtocolCommand</name><argument_list>(<argument><expr><name>DTX_PROTOCOL_COMMAND_COMMIT_ONEPHASE</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>succeeded</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* If error is not thrown after failure then we have to throw it. */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>MyTmGxactLocal</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>DTX_STATE_NOTIFYING_ONE_PHASE_COMMIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"one phase commit notification failed"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				<name>TM_ERRDETAIL</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>doNotifyingCommitPrepared</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>succeeded</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>retry</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>volatile</specifier> <name>int</name></type> <name>savedInterruptHoldoffCount</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name> <init>= <expr><name>CurrentMemoryContext</name></expr></init></decl>;</decl_stmt><empty_stmt>;</empty_stmt>
	<decl_stmt><decl><type><name>time_t</name></type>		<name>retry_time_start</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>retry_timedout</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DTM_DEBUG5</name></expr></argument>, <argument><expr><literal type="string">"doNotifyingCommitPrepared entering in state = %s"</literal></expr></argument>, <argument><expr><call><name>DtxStateToString</name><argument_list>(<argument><expr><name><name>MyTmGxactLocal</name><operator>-&gt;</operator><name>state</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>MyTmGxactLocal</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>DTX_STATE_INSERTED_COMMITTED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>setCurrentDtxState</name><argument_list>(<argument><expr><name>DTX_STATE_NOTIFYING_COMMIT_PREPARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>SIMPLE_FAULT_INJECTOR</name><argument_list>(<argument><expr><literal type="string">"dtm_broadcast_commit_prepared"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Acquire TwophaseCommitLock in shared mode to block any GPDB restore
	 * points from being created while commit prepared messages are being
	 * broadcasted.
	 */</comment>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>TwophaseCommitLock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>savedInterruptHoldoffCount</name> <operator>=</operator> <name>InterruptHoldoffCount</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>MyTmGxactLocal</name><operator>-&gt;</operator><name>dtxSegments</name></name> <operator>!=</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<expr_stmt><expr><name>succeeded</name> <operator>=</operator> <call><name>currentDtxDispatchProtocolCommand</name><argument_list>(<argument><expr><name>DTX_PROTOCOL_COMMAND_COMMIT_PREPARED</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<comment type="block">/*
		 * restore the previous value, which is reset to 0 in errfinish.
		 */</comment>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>InterruptHoldoffCount</name> <operator>=</operator> <name>savedInterruptHoldoffCount</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>succeeded</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>FlushErrorState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>succeeded</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>MyTmGxactLocal</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>DTX_STATE_NOTIFYING_COMMIT_PREPARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DTM_DEBUG5</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"marking retry needed for distributed transaction "</literal>
						<literal type="string">"'Commit Prepared' broadcast to the segments"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				<name>TM_ERRDETAIL</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>setCurrentDtxState</name><argument_list>(<argument><expr><name>DTX_STATE_RETRY_COMMIT_PREPARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>setDistributedTransactionContext</name><argument_list>(<argument><expr><name>DTX_CONTEXT_QD_RETRY_PHASE_2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>retry_timedout</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>dtx_phase2_retry_second</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><name>true</name></expr> </then><else>: <expr><name>false</name></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><name>retry_time_start</name> <operator>=</operator> <call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><operator>!</operator><name>succeeded</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>retry_timedout</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>retry</name><operator>++</operator></expr>;</expr_stmt>
		<comment type="block">/*
		 * Sleep for some time before retry to avoid too many reries for some
		 * scenarios that retry completes soon. Also delay for longer when
		 * retry fails more and more times.
		 */</comment>
		<expr_stmt><expr><call><name>pg_usleep</name><argument_list>(<argument><expr><name>DTX_PHASE2_SLEEP_TIME_BETWEEN_RETRIES_MSECS</name> <operator>*</operator> <literal type="number">1000</literal> <operator>*</operator>
				  <call><name>Min</name><argument_list>(<argument><expr><call><name>Max</name><argument_list>(<argument><expr><name>retry</name> <operator>-</operator> <literal type="number">10</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">50</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"the distributed transaction 'Commit Prepared' broadcast "</literal>
						<literal type="string">"failed to one or more segments. Retrying ... try %d"</literal></expr></argument>, <argument><expr><name>retry</name></expr></argument>)</argument_list></call><operator>,</operator>
				<name>TM_ERRDETAIL</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * We must succeed in delivering the commit to all segment instances,
		 * or any failed segment instances must be marked INVALID.
		 */</comment>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>, <argument><expr><literal type="string">"Releasing segworker group to retry broadcast."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ResetAllGangs</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>savedInterruptHoldoffCount</name> <operator>=</operator> <name>InterruptHoldoffCount</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<block>{<block_content>
			<expr_stmt><expr><name>succeeded</name> <operator>=</operator> <call><name>currentDtxDispatchProtocolCommand</name><argument_list>(<argument><expr><name>DTX_PROTOCOL_COMMAND_RETRY_COMMIT_PREPARED</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
		<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<block>{<block_content>
			<comment type="block">/*
			 * restore the previous value, which is reset to 0 in errfinish.
			 */</comment>
			<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>InterruptHoldoffCount</name> <operator>=</operator> <name>savedInterruptHoldoffCount</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>succeeded</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>FlushErrorState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
		<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>retry_time_start</name><operator>)</operator> <operator>&gt;</operator> <name>dtx_phase2_retry_second</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>retry_timedout</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></while>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>succeeded</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unable to complete 'Commit Prepared' broadcast"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				<name>TM_ERRDETAIL</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DTM_DEBUG5</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"the distributed transaction 'Commit Prepared' broadcast succeeded to all the segments"</literal></expr></argument>)</argument_list></call><operator>,</operator>
			<name>TM_ERRDETAIL</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>SIMPLE_FAULT_INJECTOR</name><argument_list>(<argument><expr><literal type="string">"dtm_before_insert_forget_comitted"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>doInsertForgetCommitted</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We release the TwophaseCommitLock only after writing our distributed
	 * forget record which signifies that all query executors have written
	 * their commit prepared records.
	 */</comment>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>TwophaseCommitLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>retryAbortPrepared</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>retry</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>succeeded</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>volatile</specifier> <name>int</name></type> <name>savedInterruptHoldoffCount</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name> <init>= <expr><name>CurrentMemoryContext</name></expr></init></decl>;</decl_stmt><empty_stmt>;</empty_stmt>
	<decl_stmt><decl><type><name>time_t</name></type> 		<name>retry_time_start</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>retry_timedout</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>retry_timedout</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>dtx_phase2_retry_second</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><name>true</name></expr> </then><else>: <expr><name>false</name></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><name>retry_time_start</name> <operator>=</operator> <call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><operator>!</operator><name>succeeded</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>retry_timedout</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>retry</name><operator>++</operator></expr>;</expr_stmt>
		<comment type="block">/*
		 * By deallocating the gang, we will force a new gang to connect to
		 * all the segment instances.  And, we will abort the transactions in
		 * the segments. What's left are possibily prepared transactions.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>retry</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>, <argument><expr><literal type="string">"Releasing segworker groups to retry broadcast."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/*
			 * Sleep for some time before retry to avoid too many reries for
			 * some scenarios that retry completes soon. Also delay for longer
			 * when retry fails more and more times.
			 */</comment>
			<expr_stmt><expr><call><name>pg_usleep</name><argument_list>(<argument><expr><name>DTX_PHASE2_SLEEP_TIME_BETWEEN_RETRIES_MSECS</name> <operator>*</operator> <literal type="number">1000</literal> <operator>*</operator>
					  <call><name>Min</name><argument_list>(<argument><expr><call><name>Max</name><argument_list>(<argument><expr><name>retry</name> <operator>-</operator> <literal type="number">10</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">50</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>ResetAllGangs</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>savedInterruptHoldoffCount</name> <operator>=</operator> <name>InterruptHoldoffCount</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<block>{<block_content>
			<expr_stmt><expr><name><name>MyTmGxactLocal</name><operator>-&gt;</operator><name>dtxSegments</name></name> <operator>=</operator> <call><name>cdbcomponent_getCdbComponentsList</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>succeeded</name> <operator>=</operator> <call><name>currentDtxDispatchProtocolCommand</name><argument_list>(<argument><expr><name>DTX_PROTOCOL_COMMAND_RETRY_ABORT_PREPARED</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>succeeded</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"the distributed transaction 'Abort' broadcast "</literal>
								<literal type="string">"failed to one or more segments. Retrying ... try %d"</literal></expr></argument>, <argument><expr><name>retry</name></expr></argument>)</argument_list></call><operator>,</operator>
						<name>TM_ERRDETAIL</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block>
		<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<block>{<block_content>
			<comment type="block">/*
			 * restore the previous value, which is reset to 0 in errfinish.
			 */</comment>
			<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>InterruptHoldoffCount</name> <operator>=</operator> <name>savedInterruptHoldoffCount</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>succeeded</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>FlushErrorState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
		<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>retry_time_start</name><operator>)</operator> <operator>&gt;</operator> <name>dtx_phase2_retry_second</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>retry_timedout</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></while>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>succeeded</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ResetAllGangs</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><name>shmDtxRecoveryEventLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SetDtxRecoveryEvent</name><argument_list>(<argument><expr><name>DTX_RECOVERY_EVENT_ABORT_PREPARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><name>shmDtxRecoveryEventLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SendPostmasterSignal</name><argument_list>(<argument><expr><name>PMSIGNAL_WAKEN_DTX_RECOVERY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unable to complete 'Abort' broadcast. The dtx recovery"</literal>
						<literal type="string">" process will continue trying that."</literal></expr></argument>)</argument_list></call><operator>,</operator>
				<name>TM_ERRDETAIL</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DTM_DEBUG5</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"The distributed transaction 'Abort' broadcast succeeded to all the segments"</literal></expr></argument>)</argument_list></call><operator>,</operator>
			<name>TM_ERRDETAIL</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>doNotifyingAbort</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>succeeded</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>volatile</specifier> <name>int</name></type> <name>savedInterruptHoldoffCount</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name> <init>= <expr><name>CurrentMemoryContext</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DTM_DEBUG5</name></expr></argument>, <argument><expr><literal type="string">"doNotifyingAborted entering in state = %s"</literal></expr></argument>, <argument><expr><call><name>DtxStateToString</name><argument_list>(<argument><expr><name><name>MyTmGxactLocal</name><operator>-&gt;</operator><name>state</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><name><name>MyTmGxactLocal</name><operator>-&gt;</operator><name>state</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>DTX_STATE_NOTIFYING_ABORT_NO_PREPARED</name></expr>:</case>
		<block>{<block_content>
				<comment type="block">/*
				 * In some cases, dtmPreCommand said two phase commit is needed, but some errors
				 * occur before the command is actually dispatched, no need to dispatch DTX for
				 * such cases.
				 */</comment> 
				<expr_stmt><expr><name>succeeded</name> <operator>=</operator> <call><name>currentDtxDispatchProtocolCommand</name><argument_list>(<argument><expr><name>DTX_PROTOCOL_COMMAND_ABORT_NO_PREPARED</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>succeeded</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"The distributed transaction 'Abort' broadcast failed to one or more segments"</literal></expr></argument>)</argument_list></call><operator>,</operator>
							 <name>TM_ERRDETAIL</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/*
					 * Reset the dispatch logic and disconnect from any segment
					 * that didn't respond to our abort.
					 */</comment>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>, <argument><expr><literal type="string">"Releasing segworker groups to finish aborting the transaction."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>ResetAllGangs</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DTM_DEBUG5</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"The distributed transaction 'Abort' broadcast succeeded to all the segments"</literal></expr></argument>)</argument_list></call><operator>,</operator>
							 <name>TM_ERRDETAIL</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>

				<break>break;</break>
			</block_content>}</block>

		<case>case <expr><name>DTX_STATE_NOTIFYING_ABORT_SOME_PREPARED</name></expr>:</case>
		<case>case <expr><name>DTX_STATE_NOTIFYING_ABORT_PREPARED</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>DtxProtocolCommand</name></type> <name>dtxProtocolCommand</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>abortString</name></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>MyTmGxactLocal</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>DTX_STATE_NOTIFYING_ABORT_SOME_PREPARED</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>dtxProtocolCommand</name> <operator>=</operator> <name>DTX_PROTOCOL_COMMAND_ABORT_SOME_PREPARED</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>abortString</name> <operator>=</operator> <literal type="string">"Abort [Prepared]"</literal></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<expr_stmt><expr><name>dtxProtocolCommand</name> <operator>=</operator> <name>DTX_PROTOCOL_COMMAND_ABORT_PREPARED</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>abortString</name> <operator>=</operator> <literal type="string">"Abort Prepared"</literal></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>

				<expr_stmt><expr><name>savedInterruptHoldoffCount</name> <operator>=</operator> <name>InterruptHoldoffCount</name></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<block>{<block_content>
					<expr_stmt><expr><name>succeeded</name> <operator>=</operator> <call><name>currentDtxDispatchProtocolCommand</name><argument_list>(<argument><expr><name>dtxProtocolCommand</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block>
				<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<block>{<block_content>
					<comment type="block">/*
					 * restore the previous value, which is reset to 0 in errfinish.
					 */</comment>
					<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>InterruptHoldoffCount</name> <operator>=</operator> <name>savedInterruptHoldoffCount</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>succeeded</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>FlushErrorState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block>
				<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name>succeeded</name></expr>)</condition><block type="pseudo"><block_content>
					<break>break;</break></block_content></block></if></if_stmt>

				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"the distributed transaction broadcast failed "</literal>
								<literal type="string">"to one or more segments"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <name>TM_ERRDETAIL</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>setCurrentDtxState</name><argument_list>(<argument><expr><name>DTX_STATE_RETRY_ABORT_PREPARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>setDistributedTransactionContext</name><argument_list>(<argument><expr><name>DTX_CONTEXT_QD_RETRY_PHASE_2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<comment type="block">/* FALL THRU */</comment>

		<case>case <expr><name>DTX_STATE_RETRY_ABORT_PREPARED</name></expr>:</case>
			<expr_stmt><expr><call><name>retryAbortPrepared</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"Unexpected Dtx state: %s"</literal></expr></argument>, <argument><expr><call><name>DtxStateToString</name><argument_list>(<argument><expr><name><name>MyTmGxactLocal</name><operator>-&gt;</operator><name>state</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>

	<expr_stmt><expr><call><name>SIMPLE_FAULT_INJECTOR</name><argument_list>(<argument><expr><literal type="string">"dtm_broadcast_abort_prepared"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>CurrentDtxIsRollingback</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * prepare a global transaction, called by user commit
 * or by CommitTransaction
 */</comment>
<function><type><name>void</name></type>
<name>prepareDtxTransaction</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>xid</name> <init>= <expr><call><name>GetTopTransactionIdIfAny</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>markXidCommitted</name> <init>= <expr><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>DistributedTransactionContext</name> <operator>!=</operator> <name>DTX_CONTEXT_QD_DISTRIBUTED_CAPABLE</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DTM_DEBUG5</name></expr></argument>, <argument><expr><literal type="string">"prepareDtxTransaction nothing to do (DistributedTransactionContext = '%s')"</literal></expr></argument>,
			 <argument><expr><call><name>DtxContextToString</name><argument_list>(<argument><expr><name>DistributedTransactionContext</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>Gp_role</name> <operator>!=</operator> <name>GP_ROLE_DISPATCH</name> <operator>||</operator> <name><name>MyTmGxact</name><operator>-&gt;</operator><name>gxid</name></name> <operator>==</operator> <name>InvalidDistributedTransactionId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>isCurrentDtxActivated</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>MyTmGxactLocal</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>DTX_STATE_NONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>Gp_role</name> <operator>!=</operator> <name>GP_ROLE_DISPATCH</name> <operator>||</operator> <name><name>MyTmGxact</name><operator>-&gt;</operator><name>gxid</name></name> <operator>==</operator> <name>InvalidDistributedTransactionId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>resetTmGxact</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If only one segment was involved in the transaction, and no local XID
	 * has been assigned on the QD either, or there is no xlog writing related
	 * to this transaction on all segments, we can perform one-phase commit.
	 * Otherwise, broadcast PREPARE TRANSACTION to the segments.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TopXactExecutorDidWriteXLog</name><argument_list>()</argument_list></call> <operator>||</operator>
		<operator>(</operator><operator>!</operator><name>markXidCommitted</name> <operator>&amp;&amp;</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>MyTmGxactLocal</name><operator>-&gt;</operator><name>dtxSegments</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">2</literal><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>setCurrentDtxState</name><argument_list>(<argument><expr><name>DTX_STATE_ONE_PHASE_COMMIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/*
		 * Notify one phase commit to QE before local transaction xlog recording
		 * since if it fails we still have chance of aborting the transaction.
		 */</comment>
		<expr_stmt><expr><call><name>doNotifyingOnePhaseCommit</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DTM_DEBUG5</name></expr></argument>,
		 <argument><expr><literal type="string">"prepareDtxTransaction called with state = %s"</literal></expr></argument>,
		 <argument><expr><call><name>DtxStateToString</name><argument_list>(<argument><expr><name><name>MyTmGxactLocal</name><operator>-&gt;</operator><name>state</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>MyTmGxactLocal</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>DTX_STATE_ACTIVE_DISTRIBUTED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>doPrepareTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * rollback a global transaction, called by user rollback
 * or by AbortTransaction during Postgres automatic rollback
 */</comment>
<function><type><name>void</name></type>
<name>rollbackDtxTransaction</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>DistributedTransactionContext</name> <operator>!=</operator> <name>DTX_CONTEXT_QD_DISTRIBUTED_CAPABLE</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DTM_DEBUG5</name></expr></argument>, <argument><expr><literal type="string">"rollbackDtxTransaction nothing to do (DistributedTransactionContext = '%s')"</literal></expr></argument>,
			 <argument><expr><call><name>DtxContextToString</name><argument_list>(<argument><expr><name>DistributedTransactionContext</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>isCurrentDtxActivated</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DTM_DEBUG5</name></expr></argument>, <argument><expr><literal type="string">"rollbackDtxTransaction nothing to do (two phase not activate)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DTM_DEBUG5</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"rollbackDtxTransaction called"</literal></expr></argument>)</argument_list></call><operator>,</operator>
			<name>TM_ERRDETAIL</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><name><name>MyTmGxactLocal</name><operator>-&gt;</operator><name>state</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>DTX_STATE_ACTIVE_DISTRIBUTED</name></expr>:</case>
		<case>case <expr><name>DTX_STATE_ONE_PHASE_COMMIT</name></expr>:</case>
		<case>case <expr><name>DTX_STATE_NOTIFYING_ONE_PHASE_COMMIT</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>MyTmGxactLocal</name><operator>-&gt;</operator><name>dtxSegments</name></name> <operator>||</operator> <call><name>currentGxactWriterGangLost</name><argument_list>()</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DTM_DEBUG5</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"The distributed transaction 'Abort' broadcast was omitted (segworker group already dead)"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <name>TM_ERRDETAIL</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return;</return>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>setCurrentDtxState</name><argument_list>(<argument><expr><name>DTX_STATE_NOTIFYING_ABORT_NO_PREPARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>DTX_STATE_PREPARING</name></expr>:</case>
			<comment type="block">/*
			 * The writer gang is detected broken during preparing, then it has been destroyed
			 * in AtAbort_DispatcherState(). In this way, we will create a new writer gang to
			 * do the rollback. As this new writer gang is in DTX_CONTEXT_LOCAL_ONLY context,
			 * we need to dispatch DTX_STATE_RETRY_ABORT_PREPARED command instead of
			 * DTX_STATE_NOTIFYING_ABORT_SOME_PREPARED.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>currentGxactWriterGangLost</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>setCurrentDtxState</name><argument_list>(<argument><expr><name>DTX_STATE_RETRY_ABORT_PREPARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>setCurrentDtxState</name><argument_list>(<argument><expr><name>DTX_STATE_NOTIFYING_ABORT_SOME_PREPARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<break>break;</break>

		<case>case <expr><name>DTX_STATE_PREPARED</name></expr>:</case>
			<expr_stmt><expr><call><name>setCurrentDtxState</name><argument_list>(<argument><expr><name>DTX_STATE_NOTIFYING_ABORT_PREPARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>DTX_STATE_NOTIFYING_ABORT_NO_PREPARED</name></expr>:</case>
			<comment type="block">/*
			 * By deallocating the gang, we will force a new gang to connect
			 * to all the segment instances.  And, we will abort the
			 * transactions in the segments.
			 */</comment>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>, <argument><expr><literal type="string">"Releasing segworker groups to finish aborting the transaction."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ResetAllGangs</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>

		<case>case <expr><name>DTX_STATE_NOTIFYING_ABORT_SOME_PREPARED</name></expr>:</case>
		<case>case <expr><name>DTX_STATE_NOTIFYING_ABORT_PREPARED</name></expr>:</case>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Unable to complete the 'Abort Prepared' broadcast"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					<name>TM_ERRDETAIL</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>DTX_STATE_NOTIFYING_COMMIT_PREPARED</name></expr>:</case>
		<case>case <expr><name>DTX_STATE_INSERTING_COMMITTED</name></expr>:</case>
		<case>case <expr><name>DTX_STATE_INSERTED_COMMITTED</name></expr>:</case>
		<case>case <expr><name>DTX_STATE_INSERTING_FORGET_COMMITTED</name></expr>:</case>
		<case>case <expr><name>DTX_STATE_INSERTED_FORGET_COMMITTED</name></expr>:</case>
		<case>case <expr><name>DTX_STATE_RETRY_COMMIT_PREPARED</name></expr>:</case>
		<case>case <expr><name>DTX_STATE_RETRY_ABORT_PREPARED</name></expr>:</case>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DTM_DEBUG5</name></expr></argument>, <argument><expr><literal type="string">"rollbackDtxTransaction dtx state \"%s\" not expected here"</literal></expr></argument>,
				 <argument><expr><call><name>DtxStateToString</name><argument_list>(<argument><expr><name><name>MyTmGxactLocal</name><operator>-&gt;</operator><name>state</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>

		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"Unrecognized dtx state: %d"</literal></expr></argument>,
				 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>MyTmGxactLocal</name><operator>-&gt;</operator><name>state</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>


	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>MyTmGxactLocal</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>DTX_STATE_NOTIFYING_ABORT_NO_PREPARED</name> <operator>||</operator>
			<name><name>MyTmGxactLocal</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>DTX_STATE_NOTIFYING_ABORT_SOME_PREPARED</name> <operator>||</operator>
			<name><name>MyTmGxactLocal</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>DTX_STATE_RETRY_ABORT_PREPARED</name> <operator>||</operator>
			<name><name>MyTmGxactLocal</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>DTX_STATE_NOTIFYING_ABORT_PREPARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * if the process is in the middle of blowing up... then we don't do
	 * anything here.  we can resolve any in-doubt transactions later.
	 *
	 * We can't dispatch -- but we *do* need to free up shared-memory entries.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>proc_exit_inprogress</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Unable to complete distributed abort broadcast with possible
		 * prepared transactions...
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>MyTmGxactLocal</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>DTX_STATE_NOTIFYING_ABORT_SOME_PREPARED</name> <operator>||</operator>
			<name><name>MyTmGxactLocal</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>DTX_STATE_RETRY_ABORT_PREPARED</name> <operator>||</operator>
			<name><name>MyTmGxactLocal</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>DTX_STATE_NOTIFYING_ABORT_PREPARED</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Unable to complete the 'Abort Prepared' broadcast"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					<name>TM_ERRDETAIL</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>MyTmGxactLocal</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>DTX_STATE_NOTIFYING_ABORT_NO_PREPARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * By deallocating the gang, we will force a new gang to connect to
		 * all the segment instances.  And, we will abort the transactions in
		 * the segments.
		 */</comment>
		<expr_stmt><expr><call><name>ResetAllGangs</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>doNotifyingAbort</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<return>return;</return>
</block_content>}</block></function>

<comment type="block">/* get tm share memory size */</comment>
<function><type><name>int</name></type>
<name>tmShmemSize</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>MAXALIGN</name><argument_list>(<argument><expr><call><name>TMCONTROLBLOCK_BYTES</name><argument_list>(<argument><expr><name>max_tm_gxacts</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * tmShmemInit - should be called only once from postmaster and inherit by all
 * postgres processes
 */</comment>
<function><type><name>void</name></type>
<name>tmShmemInit</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TmControlBlock</name> <modifier>*</modifier></type><name>shared</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name> <operator>&amp;&amp;</operator> <name>max_prepared_xacts</name> <operator>&lt;</operator> <name>MaxConnections</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"Better set max_prepared_transactions greater than max_connections"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * max_prepared_transactions is a guc which is postmaster-startup setable
	 * -- it can only be updated by restarting the system. Global transactions
	 *  will all use two-phase commit, so the number of global transactions is
	 *  bound to the number of prepared.
	 *
	 * Note on master, it is possible that some prepared xacts just use partial
	 * gang so on QD the total prepared xacts might be quite large but it is
	 * limited by max_connections since one QD should only have one 2pc one
	 * time, so if we set max_tm_gxacts as max_prepared_transactions as before,
	 * shmCommittedGxactArray might not be able to accommodate committed but
	 * not forgotten transactions (standby recovery will fail if encountering
	 * this issue) if max_prepared_transactions is smaller than max_connections
	 * (though this is not suggested). Not to mention that
	 * max_prepared_transactions might be inconsistent between master/standby
	 * and segments (though this is not suggested).
	 *
	 * We can assign MaxBackends (MaxConnections should be fine also but let's
	 * be conservative) to max_tm_gxacts on master/standby to tolerate various
	 * configuration combinations of max_prepared_transactions and
	 * max_connections. max_tm_gxacts is used on the coordinator only, and the
	 * coordinator might be accessed in dispatch mode or utility mode.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IS_QUERY_DISPATCHER</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>max_tm_gxacts</name> <operator>=</operator> <name>MaxBackends</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>max_tm_gxacts</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name>shared</name> <operator>=</operator> <operator>(</operator><name>TmControlBlock</name> <operator>*</operator><operator>)</operator> <call><name>ShmemInitStruct</name><argument_list>(<argument><expr><literal type="string">"Transaction manager"</literal></expr></argument>, <argument><expr><call><name>tmShmemSize</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>shared</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"could not initialize transaction manager share memory"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Only initialize this if we are the creator of the shared memory */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>latestCompletedGxid</name></name> <operator>=</operator> <name>InvalidDistributedTransactionId</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SpinLockInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>shared</name><operator>-&gt;</operator><name>DtxRecoveryEventLock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SpinLockInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>shared</name><operator>-&gt;</operator><name>gxidGenLock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>shmDtmStarted</name> <operator>=</operator> <operator>&amp;</operator><name><name>shared</name><operator>-&gt;</operator><name>DtmStarted</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>shmCleanupBackends</name> <operator>=</operator> <operator>&amp;</operator><name><name>shared</name><operator>-&gt;</operator><name>CleanupBackends</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>shmDtxRecoveryPid</name> <operator>=</operator> <operator>&amp;</operator><name><name>shared</name><operator>-&gt;</operator><name>DtxRecoveryPid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>shmDtxRecoveryEvents</name> <operator>=</operator> <operator>&amp;</operator><name><name>shared</name><operator>-&gt;</operator><name>DtxRecoveryEvents</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>shmDtxRecoveryEventLock</name> <operator>=</operator> <operator>&amp;</operator><name><name>shared</name><operator>-&gt;</operator><name>DtxRecoveryEventLock</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>shmNextSnapshotId</name> <operator>=</operator> <operator>&amp;</operator><name><name>shared</name><operator>-&gt;</operator><name>NextSnapshotId</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>shmGxidGenLock</name> <operator>=</operator> <operator>&amp;</operator><name><name>shared</name><operator>-&gt;</operator><name>gxidGenLock</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>shmNumCommittedGxacts</name> <operator>=</operator> <operator>&amp;</operator><name><name>shared</name><operator>-&gt;</operator><name>num_committed_xacts</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>shmCommittedGxidArray</name> <operator>=</operator> <operator>&amp;</operator><name><name>shared</name><operator>-&gt;</operator><name>committed_gxid_array</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>IsUnderPostmaster</name></expr>)</condition>
		<comment type="block">/* Initialize locks and shared memory area */</comment>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>shmNextSnapshotId</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>shmDtmStarted</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>shmCleanupBackends</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>shmDtxRecoveryPid</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>shmDtxRecoveryEvents</name> <operator>=</operator> <name>DTX_RECOVERY_EVENT_ABORT_PREPARED</name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>shmNumCommittedGxacts</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* mppTxnOptions:
 * Generates an int containing the appropriate flags to direct the remote
 * segdb QE process to perform any needed transaction commands before or
 * after the statement.
 */</comment>
<function><type><name>int</name></type>
<name>mppTxnOptions</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>needDtx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>options</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DTM_DEBUG5</name></expr></argument>,
		 <argument><expr><literal type="string">"mppTxnOptions DefaultXactIsoLevel = %s, DefaultXactReadOnly = %s, XactIsoLevel = %s, XactReadOnly = %s."</literal></expr></argument>,
		 <argument><expr><call><name>IsoLevelAsUpperString</name><argument_list>(<argument><expr><name>DefaultXactIsoLevel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><name>DefaultXactReadOnly</name></expr> ?</condition><then> <expr><literal type="string">"true"</literal></expr> </then><else>: <expr><literal type="string">"false"</literal></expr></else></ternary><operator>)</operator></expr></argument>,
		 <argument><expr><call><name>IsoLevelAsUpperString</name><argument_list>(<argument><expr><name>XactIsoLevel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><name>XactReadOnly</name></expr> ?</condition><then> <expr><literal type="string">"true"</literal></expr> </then><else>: <expr><literal type="string">"false"</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>needDtx</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>options</name> <operator>|=</operator> <name>GP_OPT_NEED_DTX</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>XactIsoLevel</name> <operator>==</operator> <name>XACT_READ_COMMITTED</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>options</name> <operator>|=</operator> <name>GP_OPT_READ_COMMITTED</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>XactIsoLevel</name> <operator>==</operator> <name>XACT_REPEATABLE_READ</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>options</name> <operator>|=</operator> <name>GP_OPT_REPEATABLE_READ</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>XactIsoLevel</name> <operator>==</operator> <name>XACT_SERIALIZABLE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>options</name> <operator>|=</operator> <name>GP_OPT_SERIALIZABLE</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>XactIsoLevel</name> <operator>==</operator> <name>XACT_READ_UNCOMMITTED</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>options</name> <operator>|=</operator> <name>GP_OPT_READ_UNCOMMITTED</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>XactReadOnly</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>options</name> <operator>|=</operator> <name>GP_OPT_READ_ONLY</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>isCurrentDtxActivated</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <name><name>MyTmGxactLocal</name><operator>-&gt;</operator><name>explicitBeginRemembered</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>options</name> <operator>|=</operator> <name>GP_OPT_EXPLICT_BEGIN</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DTM_DEBUG5</name></expr></argument>,
		 <argument><expr><literal type="string">"mppTxnOptions txnOptions = 0x%x, needDtx = %s, explicitBegin = %s, isoLevel = %s, readOnly = %s."</literal></expr></argument>,
		 <argument><expr><name>options</name></expr></argument>,
		 <argument><expr><operator>(</operator><ternary><condition><expr><call><name>isMppTxOptions_NeedDtx</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="string">"true"</literal></expr> </then><else>: <expr><literal type="string">"false"</literal></expr></else></ternary><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><call><name>isMppTxOptions_ExplicitBegin</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="string">"true"</literal></expr> </then><else>: <expr><literal type="string">"false"</literal></expr></else></ternary><operator>)</operator></expr></argument>,
		 <argument><expr><call><name>IsoLevelAsUpperString</name><argument_list>(<argument><expr><call><name>mppTxOptions_IsoLevel</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><call><name>isMppTxOptions_ReadOnly</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="string">"true"</literal></expr> </then><else>: <expr><literal type="string">"false"</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>options</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name></type>
<name>mppTxOptions_IsoLevel</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>txnOptions</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>txnOptions</name> <operator>&amp;</operator> <name>GP_OPT_ISOLATION_LEVEL_MASK</name><operator>)</operator> <operator>==</operator> <name>GP_OPT_SERIALIZABLE</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>XACT_SERIALIZABLE</name></expr>;</return></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><operator>(</operator><name>txnOptions</name> <operator>&amp;</operator> <name>GP_OPT_ISOLATION_LEVEL_MASK</name><operator>)</operator> <operator>==</operator> <name>GP_OPT_REPEATABLE_READ</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>XACT_REPEATABLE_READ</name></expr>;</return></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><operator>(</operator><name>txnOptions</name> <operator>&amp;</operator> <name>GP_OPT_ISOLATION_LEVEL_MASK</name><operator>)</operator> <operator>==</operator> <name>GP_OPT_READ_COMMITTED</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>XACT_READ_COMMITTED</name></expr>;</return></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><operator>(</operator><name>txnOptions</name> <operator>&amp;</operator> <name>GP_OPT_ISOLATION_LEVEL_MASK</name><operator>)</operator> <operator>==</operator> <name>GP_OPT_READ_UNCOMMITTED</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>XACT_READ_UNCOMMITTED</name></expr>;</return></block_content></block></if></if_stmt>
	<comment type="block">/* QD must set transaction isolation level */</comment>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"transaction options from QD did not include isolation level"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>isMppTxOptions_ReadOnly</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>txnOptions</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><operator>(</operator><operator>(</operator><name>txnOptions</name> <operator>&amp;</operator> <name>GP_OPT_READ_ONLY</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>isMppTxOptions_NeedDtx</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>txnOptions</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><operator>(</operator><operator>(</operator><name>txnOptions</name> <operator>&amp;</operator> <name>GP_OPT_NEED_DTX</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* isMppTxOptions_ExplicitBegin:
 * Return the ExplicitBegin flag.
 */</comment>
<function><type><name>bool</name></type>
<name>isMppTxOptions_ExplicitBegin</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>txnOptions</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><operator>(</operator><operator>(</operator><name>txnOptions</name> <operator>&amp;</operator> <name>GP_OPT_EXPLICT_BEGIN</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*=========================================================================
 * HELPER FUNCTIONS
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>compare_int</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>va</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>vb</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>a</name> <init>= <expr><operator>*</operator><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>int</name> <operator>*</operator><operator>)</operator> <name>va</name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>b</name> <init>= <expr><operator>*</operator><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>int</name> <operator>*</operator><operator>)</operator> <name>vb</name><operator>)</operator></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>a</name> <operator>==</operator> <name>b</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><ternary><condition><expr><operator>(</operator><name>a</name> <operator>&gt;</operator> <name>b</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>currentDtxDispatchProtocolCommand</name><parameter_list>(<parameter><decl><type><name>DtxProtocolCommand</name></type> <name>dtxProtocolCommand</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>raiseError</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type> <name><name>gid</name><index>[<expr><name>TMGIDSIZE</name></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>dtxFormGid</name><argument_list>(<argument><expr><name>gid</name></expr></argument>, <argument><expr><call><name>getDistributedTransactionId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>doDispatchDtxProtocolCommand</name><argument_list>(<argument><expr><name>dtxProtocolCommand</name></expr></argument>, <argument><expr><name>gid</name></expr></argument>, <argument><expr><name>raiseError</name></expr></argument>,
										<argument><expr><name><name>MyTmGxactLocal</name><operator>-&gt;</operator><name>dtxSegments</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>doDispatchDtxProtocolCommand</name><parameter_list>(<parameter><decl><type><name>DtxProtocolCommand</name></type> <name>dtxProtocolCommand</name></decl></parameter>,
							 <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>gid</name></decl></parameter>,
							 <parameter><decl><type><name>bool</name></type> <name>raiseError</name></decl></parameter>,
							 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>dtxSegments</name></decl></parameter>,
							 <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>serializedDtxContextInfo</name></decl></parameter>,
							 <parameter><decl><type><name>int</name></type> <name>serializedDtxContextInfoLen</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
				<decl><type ref="prev"/><name>resultCount</name></decl>,
				<decl><type ref="prev"/><name>numOfFailed</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>dtxProtocolCommandStr</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name><name>struct</name> <name>pg_result</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>results</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldContext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>waitGxids</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>totalWaits</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>dtxSegments</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>dtxProtocolCommandStr</name> <operator>=</operator> <call><name>DtxProtocolCommandToString</name><argument_list>(<argument><expr><name>dtxProtocolCommand</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>Test_print_direct_dispatch_info</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>INFO</name></expr></argument>, <argument><expr><literal type="string">"Distributed transaction command '%s' to %s"</literal></expr></argument>,
			 								<argument><expr><name>dtxProtocolCommandStr</name></expr></argument>,
											<argument><expr><call><name>segmentsToContentStr</name><argument_list>(<argument><expr><name>dtxSegments</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DTM_DEBUG5</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"dispatchDtxProtocolCommand: %d ('%s'), direct content #: %s"</literal></expr></argument>,
					<argument><expr><name>dtxProtocolCommand</name></expr></argument>, <argument><expr><name>dtxProtocolCommandStr</name></expr></argument>,
					<argument><expr><call><name>segmentsToContentStr</name><argument_list>(<argument><expr><name>dtxSegments</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>ErrorData</name> <modifier>*</modifier></type><name>qeError</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>results</name> <operator>=</operator> <call><name>CdbDispatchDtxProtocolCommand</name><argument_list>(<argument><expr><name>dtxProtocolCommand</name></expr></argument>,
											<argument><expr><name>dtxProtocolCommandStr</name></expr></argument>,
											<argument><expr><name>gid</name></expr></argument>,
											<argument><expr><operator>&amp;</operator><name>qeError</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>resultCount</name></expr></argument>, <argument><expr><name>dtxSegments</name></expr></argument>,
											<argument><expr><name>serializedDtxContextInfo</name></expr></argument>, <argument><expr><name>serializedDtxContextInfoLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>qeError</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>raiseError</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"DTM error (gathered results from cmd '%s')"</literal></expr></argument>, <argument><expr><name>dtxProtocolCommandStr</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"QE reported error: %s"</literal></expr></argument>, <argument><expr><name><name>qeError</name><operator>-&gt;</operator><name>message</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>FlushErrorState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ReThrowError</name><argument_list>(<argument><expr><name>qeError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>results</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>numOfFailed</name><operator>++</operator></expr>;</expr_stmt>			<comment type="block">/* If we got no results, we need to treat it
								 * as an error! */</comment>
	</block_content>}</block></if></if_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>resultCount</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>cmdStatus</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ExecStatusType</name></type> <name>resultStatus</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * note: PQresultStatus() is smart enough to deal with results[i] ==
		 * NULL
		 */</comment>
		<expr_stmt><expr><name>resultStatus</name> <operator>=</operator> <call><name>PQresultStatus</name><argument_list>(<argument><expr><name><name>results</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>resultStatus</name> <operator>!=</operator> <name>PGRES_COMMAND_OK</name> <operator>&amp;&amp;</operator>
			<name>resultStatus</name> <operator>!=</operator> <name>PGRES_TUPLES_OK</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>numOfFailed</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * success ? If an error happened during a transaction which
			 * hasn't already been caught when we try a prepare we'll get a
			 * rollback from our prepare ON ONE SEGMENT: so we go look at the
			 * status, otherwise we could issue a COMMIT when we don't want
			 * to!
			 */</comment>
			<expr_stmt><expr><name>cmdStatus</name> <operator>=</operator> <call><name>PQcmdStatus</name><argument_list>(<argument><expr><name><name>results</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG3</name></expr></argument>, <argument><expr><literal type="string">"DTM: status message cmd '%s' [%d] result '%s'"</literal></expr></argument>, <argument><expr><name>dtxProtocolCommandStr</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>cmdStatus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>cmdStatus</name></expr></argument>, <argument><expr><name>dtxProtocolCommandStr</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>cmdStatus</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* failed */</comment>
				<expr_stmt><expr><name>numOfFailed</name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* gather all the waited gxids from segments and remove the duplicates */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>resultCount</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name>totalWaits</name> <operator>+=</operator> <name><name>results</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>nWaits</name></expr>;</expr_stmt></block_content></block></for>

	<if_stmt><if>if <condition>(<expr><name>totalWaits</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>waitGxids</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>totalWaits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>totalWaits</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>resultCount</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name><name>struct</name> <name>pg_result</name></name> <modifier>*</modifier></type><name>result</name> <init>= <expr><name><name>results</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>result</name><operator>-&gt;</operator><name>nWaits</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>waitGxids</name><index>[<expr><name>totalWaits</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>result</name><operator>-&gt;</operator><name>waitGxids</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>result</name><operator>-&gt;</operator><name>nWaits</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>totalWaits</name> <operator>+=</operator> <name><name>result</name><operator>-&gt;</operator><name>nWaits</name></name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><name>totalWaits</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>lastRepeat</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>MyTmGxactLocal</name><operator>-&gt;</operator><name>waitGxids</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name><name>MyTmGxactLocal</name><operator>-&gt;</operator><name>waitGxids</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>MyTmGxactLocal</name><operator>-&gt;</operator><name>waitGxids</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><name>waitGxids</name></expr></argument>, <argument><expr><name>totalWaits</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>compare_int</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>oldContext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>TopTransactionContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>totalWaits</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>waitGxids</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>lastRepeat</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>
			<expr_stmt><expr><name><name>MyTmGxactLocal</name><operator>-&gt;</operator><name>waitGxids</name></name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name><name>MyTmGxactLocal</name><operator>-&gt;</operator><name>waitGxids</name></name></expr></argument>, <argument><expr><name><name>waitGxids</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>lastRepeat</name> <operator>=</operator> <name><name>waitGxids</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>waitGxids</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>waitGxids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>results</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>results</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><operator>(</operator><name>numOfFailed</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>


<function><type><name>bool</name></type>
<name>dispatchDtxCommand</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
				<decl><type ref="prev"/><name>numOfFailed</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>CdbPgResults</name></type> <name>cdb_pgresults</name> <init>= <expr><block>{<expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DTM_DEBUG5</name></expr></argument>, <argument><expr><literal type="string">"dispatchDtxCommand: '%s'"</literal></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>currentGxactWriterGangLost</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"writer gang of current global transaction is lost"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>CdbDispatchCommand</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>DF_NEED_TWO_PHASE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cdb_pgresults</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>cdb_pgresults</name><operator>.</operator><name>numResults</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>			<comment type="block">/* If we got no results, we need to treat it
								 * as an error! */</comment>
	</block_content>}</block></if></if_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>cdb_pgresults</name><operator>.</operator><name>numResults</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>cmdStatus</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ExecStatusType</name></type> <name>resultStatus</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * note: PQresultStatus() is smart enough to deal with results[i] ==
		 * NULL
		 */</comment>
		<expr_stmt><expr><name>resultStatus</name> <operator>=</operator> <call><name>PQresultStatus</name><argument_list>(<argument><expr><name><name>cdb_pgresults</name><operator>.</operator><name>pg_results</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>resultStatus</name> <operator>!=</operator> <name>PGRES_COMMAND_OK</name> <operator>&amp;&amp;</operator>
			<name>resultStatus</name> <operator>!=</operator> <name>PGRES_TUPLES_OK</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>numOfFailed</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * success ? If an error happened during a transaction which
			 * hasn't already been caught when we try a prepare we'll get a
			 * rollback from our prepare ON ONE SEGMENT: so we go look at the
			 * status, otherwise we could issue a COMMIT when we don't want
			 * to!
			 */</comment>
			<expr_stmt><expr><name>cmdStatus</name> <operator>=</operator> <call><name>PQcmdStatus</name><argument_list>(<argument><expr><name><name>cdb_pgresults</name><operator>.</operator><name>pg_results</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG3</name></expr></argument>, <argument><expr><literal type="string">"DTM: status message cmd '%s' [%d] result '%s'"</literal></expr></argument>, <argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>cmdStatus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>cmdStatus</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>cmdStatus</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* failed */</comment>
				<expr_stmt><expr><name>numOfFailed</name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>cdbdisp_clearCdbPgResults</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cdb_pgresults</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><name>numOfFailed</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* reset global transaction context */</comment>
<function><type><name>void</name></type>
<name>resetTmGxact</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>MyTmGxact</name><operator>-&gt;</operator><name>gxid</name></name> <operator>==</operator> <name>InvalidDistributedTransactionId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>MyTmGxact</name><operator>-&gt;</operator><name>xminDistributedSnapshot</name></name> <operator>=</operator> <name>InvalidDistributedTransactionId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>MyTmGxact</name><operator>-&gt;</operator><name>includeInCkpt</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>MyTmGxact</name><operator>-&gt;</operator><name>sessionId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>MyTmGxactLocal</name><operator>-&gt;</operator><name>explicitBeginRemembered</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>MyTmGxactLocal</name><operator>-&gt;</operator><name>writerGangLost</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>MyTmGxactLocal</name><operator>-&gt;</operator><name>dtxSegmentsMap</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>MyTmGxactLocal</name><operator>-&gt;</operator><name>dtxSegments</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>MyTmGxactLocal</name><operator>-&gt;</operator><name>isOnePhaseCommit</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>MyTmGxactLocal</name><operator>-&gt;</operator><name>waitGxids</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name><name>MyTmGxactLocal</name><operator>-&gt;</operator><name>waitGxids</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>MyTmGxactLocal</name><operator>-&gt;</operator><name>waitGxids</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>setCurrentDtxState</name><argument_list>(<argument><expr><name>DTX_STATE_NONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>getNextDistributedXactStatus</name><parameter_list>(<parameter><decl><type><name>TMGALLXACTSTATUS</name> <modifier>*</modifier></type><name>allDistributedXactStatus</name></decl></parameter>, <parameter><decl><type><name>TMGXACTSTATUS</name> <modifier>*</modifier><modifier>*</modifier></type><name>distributedXactStatus</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>allDistributedXactStatus</name><operator>-&gt;</operator><name>next</name></name> <operator>&gt;=</operator> <name><name>allDistributedXactStatus</name><operator>-&gt;</operator><name>count</name></name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><operator>*</operator><name>distributedXactStatus</name> <operator>=</operator> <operator>&amp;</operator><name><name>allDistributedXactStatus</name><operator>-&gt;</operator><name>statusArray</name><index>[<expr><name><name>allDistributedXactStatus</name><operator>-&gt;</operator><name>next</name></name></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>allDistributedXactStatus</name><operator>-&gt;</operator><name>next</name></name><operator>++</operator></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * serializes commits with checkpoint info using PGPROC-&gt;inCommit
 * Change state to DTX_STATE_INSERTING_COMMITTED.
 */</comment>
<function><type><name>void</name></type>
<name>insertingDistributedCommitted</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DTM_DEBUG5</name></expr></argument>,
		 <argument><expr><literal type="string">"insertingDistributedCommitted entering in state = %s"</literal></expr></argument>,
		 <argument><expr><call><name>DtxStateToString</name><argument_list>(<argument><expr><name><name>MyTmGxactLocal</name><operator>-&gt;</operator><name>state</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>MyTmGxactLocal</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>DTX_STATE_PREPARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>setCurrentDtxState</name><argument_list>(<argument><expr><name>DTX_STATE_INSERTING_COMMITTED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Change state to DTX_STATE_INSERTED_COMMITTED.
 */</comment>
<function><type><name>void</name></type>
<name>insertedDistributedCommitted</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>SIMPLE_FAULT_INJECTOR</name><argument_list>(<argument><expr><literal type="string">"start_insertedDistributedCommitted"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DTM_DEBUG5</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"entering insertedDistributedCommitted"</literal></expr></argument>)</argument_list></call><operator>,</operator>
			<name>TM_ERRDETAIL</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>MyTmGxactLocal</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>DTX_STATE_INSERTING_COMMITTED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>setCurrentDtxState</name><argument_list>(<argument><expr><name>DTX_STATE_INSERTED_COMMITTED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We don't have to hold ProcArrayLock here because needIncludedInCkpt is used
	 * during creating checkpoint and we already set delayChkpt before we got here.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>MyPgXact</name><operator>-&gt;</operator><name>delayChkpt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IS_QUERY_DISPATCHER</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>MyTmGxact</name><operator>-&gt;</operator><name>includeInCkpt</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * When called, a SET command is dispatched and the writer gang
 * writes the shared snapshot. This function actually does nothing
 * useful besides making sure that a writer gang is alive and has
 * set the shared snapshot so that the readers could access it.
 *
 * At this point this function is added as a helper for cursor
 * query execution since in MPP cursor queries don't use writer
 * gangs. However, it could be used for other purposes as well.
 *
 * See declaration of assign_gp_write_shared_snapshot(...) for more
 * information.
 */</comment>
<function><type><name>void</name></type>
<name>verify_shared_snapshot_ready</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>cid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name> <argument_list>(<argument><expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * A cursor/bind/exec command may trigger multiple dispatchs (e.g.
	 *    DECLARE s1 CURSOR FOR SELECT * FROM test WHERE a=(SELECT max(b) FROM test))
	 * and all the dispatchs target to the reader gangs only. Since all the dispatchs
	 * are read-only and happens in one user command, it's ok to share one same snapshot.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>MySessionState</name><operator>-&gt;</operator><name>latestCursorCommandId</name></name> <operator>==</operator> <name>cid</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>CdbDispatchCommand</name><argument_list>(<argument><expr><literal type="string">"set gp_write_shared_snapshot=true"</literal></expr></argument>,
					   <argument><expr><name>DF_CANCEL_ON_ERROR</name> <operator>|</operator>
					   <name>DF_WITH_SNAPSHOT</name> <operator>|</operator>
					   <name>DF_NEED_TWO_PHASE</name></expr></argument>,
					   <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>dumpSharedLocalSnapshot_forCursor</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>MySessionState</name><operator>-&gt;</operator><name>latestCursorCommandId</name></name> <operator>=</operator> <name>cid</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Force the writer QE to write the shared snapshot. Will get called
 * after a "set gp_write_shared_snapshot=&lt;true/false&gt;" is executed
 * in dispatch mode.
 *
 * See verify_shared_snapshot_ready(...) for additional information.
 */</comment>
<function><type><name>void</name></type>
<name>assign_gp_write_shared_snapshot</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list>
<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>FALSE</name></expr></cpp:if>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"SET gp_write_shared_snapshot: %s"</literal></expr></argument>,
		 <argument><expr><operator>(</operator><ternary><condition><expr><name>newval</name></expr> ?</condition><then> <expr><literal type="string">"true"</literal></expr> </then><else>: <expr><literal type="string">"false"</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/*
	 * Make sure newval is "true". if it's "false" this could be a part of a
	 * ROLLBACK so we don't want to set the snapshot then.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>newval</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_EXECUTE</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>PushActiveSnapshot</name><argument_list>(<argument><expr><call><name>GetTransactionSnapshot</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>Gp_is_writer</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>dumpSharedLocalSnapshot_forCursor</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>PopActiveSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>doQEDistributedExplicitBegin</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Start a command.
	 */</comment>
	<expr_stmt><expr><call><name>StartTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Here is the explicit BEGIN. */</comment>
	<expr_stmt><expr><call><name>BeginTransactionBlock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Finish the BEGIN command.  It will leave the explict transaction
	 * in-progress.
	 */</comment>
	<expr_stmt><expr><call><name>CommitTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>isDtxQueryDispatcher</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isDtmStarted</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isSharedLocalSnapshotSlotPresent</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>isDtmStarted</name> <operator>=</operator> <operator>(</operator><name>shmDtmStarted</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>shmDtmStarted</name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>isSharedLocalSnapshotSlotPresent</name> <operator>=</operator> <operator>(</operator><name>SharedLocalSnapshotSlot</name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name> <operator>&amp;&amp;</operator>
			<name>isDtmStarted</name> <operator>&amp;&amp;</operator>
			<name>isSharedLocalSnapshotSlotPresent</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Called prior to handling a requested that comes to the QD, or a utility request to a QE.
 *
 * Sets up the distributed transaction context value and does some basic error checking.
 *
 * Essentially:
 *     if the DistributedTransactionContext is already QD_DISTRIBUTED_CAPABLE then leave it
 *     else if the DistributedTransactionContext is already QE_TWO_PHASE_EXPLICIT_WRITER then leave it
 *     else it MUST be a LOCAL_ONLY, and is converted to QD_DISTRIBUTED_CAPABLE if this process is acting
 *          as a QE.
 */</comment>
<function><type><name>void</name></type>
<name>setupRegularDtxContext</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name>DistributedTransactionContext</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>DTX_CONTEXT_QD_DISTRIBUTED_CAPABLE</name></expr>:</case>
			<comment type="block">/* Continue in this context.  Do not touch QEDtxContextInfo, etc. */</comment>
			<break>break;</break>

		<case>case <expr><name>DTX_CONTEXT_QE_TWO_PHASE_EXPLICIT_WRITER</name></expr>:</case>
			<comment type="block">/* Allow this for copy...???  Do not touch QEDtxContextInfo, etc. */</comment>
			<break>break;</break>

		<default>default:</default>
			<if_stmt><if>if <condition>(<expr><name>DistributedTransactionContext</name> <operator>!=</operator> <name>DTX_CONTEXT_LOCAL_ONLY</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * we must be one of:
				 *
				 * DTX_CONTEXT_QD_RETRY_PHASE_2,
				 * DTX_CONTEXT_QE_ENTRY_DB_SINGLETON,
				 * DTX_CONTEXT_QE_AUTO_COMMIT_IMPLICIT,
				 * DTX_CONTEXT_QE_TWO_PHASE_IMPLICIT_WRITER,
				 * DTX_CONTEXT_QE_READER, DTX_CONTEXT_QE_PREPARED
				 */</comment>

				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"setupRegularDtxContext finds unexpected DistributedTransactionContext = '%s'"</literal></expr></argument>,
					 <argument><expr><call><name>DtxContextToString</name><argument_list>(<argument><expr><name>DistributedTransactionContext</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* DistributedTransactionContext is DTX_CONTEXT_LOCAL_ONLY */</comment>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>QEDtxContextInfo</name><operator>.</operator><name>distributedXid</name></name> <operator>==</operator> <name>InvalidDistributedTransactionId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Determine if we are strictly local or a distributed capable QD.
			 */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>DistributedTransactionContext</name> <operator>==</operator> <name>DTX_CONTEXT_LOCAL_ONLY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>isDtxQueryDispatcher</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>setDistributedTransactionContext</name><argument_list>(<argument><expr><name>DTX_CONTEXT_QD_DISTRIBUTED_CAPABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<break>break;</break>
	</block_content>}</block></switch>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DTM_DEBUG5</name></expr></argument>, <argument><expr><literal type="string">"setupRegularDtxContext leaving with DistributedTransactionContext = '%s'."</literal></expr></argument>,
		 <argument><expr><call><name>DtxContextToString</name><argument_list>(<argument><expr><name>DistributedTransactionContext</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
 * Called on the QE when a query to process has been received.
 *
 * This will set up all distributed transaction information and set the state appropriately.
 */</comment>
<function><type><name>void</name></type>
<name>setupQEDtxContext</name><parameter_list>(<parameter><decl><type><name>DtxContextInfo</name> <modifier>*</modifier></type><name>dtxContextInfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DistributedSnapshot</name> <modifier>*</modifier></type><name>distributedSnapshot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>txnOptions</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>needDtx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>explicitBegin</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>haveDistributedSnapshot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isEntryDbSingleton</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isReaderQE</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isWriterQE</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isSharedLocalSnapshotSlotPresent</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>dtxContextInfo</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * DTX Context Info (even when empty) only comes in QE requests.
	 */</comment>
	<expr_stmt><expr><name>distributedSnapshot</name> <operator>=</operator> <operator>&amp;</operator><name><name>dtxContextInfo</name><operator>-&gt;</operator><name>distributedSnapshot</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>txnOptions</name> <operator>=</operator> <name><name>dtxContextInfo</name><operator>-&gt;</operator><name>distributedTxnOptions</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name>needDtx</name> <operator>=</operator> <call><name>isMppTxOptions_NeedDtx</name><argument_list>(<argument><expr><name>txnOptions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>explicitBegin</name> <operator>=</operator> <call><name>isMppTxOptions_ExplicitBegin</name><argument_list>(<argument><expr><name>txnOptions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>haveDistributedSnapshot</name> <operator>=</operator> <name><name>dtxContextInfo</name><operator>-&gt;</operator><name>haveDistributedSnapshot</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>isSharedLocalSnapshotSlotPresent</name> <operator>=</operator> <operator>(</operator><name>SharedLocalSnapshotSlot</name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>DEBUG5</name> <operator>&gt;=</operator> <name>log_min_messages</name> <operator>||</operator> <name>Debug_print_full_dtm</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DTM_DEBUG5</name></expr></argument>,
			 <argument><expr><literal type="string">"setupQEDtxContext inputs (part 1): Gp_role = %s, Gp_is_writer = %s, "</literal>
			 <literal type="string">"txnOptions = 0x%x, needDtx = %s, explicitBegin = %s, isoLevel = %s, readOnly = %s, haveDistributedSnapshot = %s."</literal></expr></argument>,
			 <argument><expr><call><name>role_to_string</name><argument_list>(<argument><expr><name>Gp_role</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><name>Gp_is_writer</name></expr> ?</condition><then> <expr><literal type="string">"true"</literal></expr> </then><else>: <expr><literal type="string">"false"</literal></expr></else></ternary><operator>)</operator></expr></argument>, <argument><expr><name>txnOptions</name></expr></argument>,
			 <argument><expr><operator>(</operator><ternary><condition><expr><name>needDtx</name></expr> ?</condition><then> <expr><literal type="string">"true"</literal></expr> </then><else>: <expr><literal type="string">"false"</literal></expr></else></ternary><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><name>explicitBegin</name></expr> ?</condition><then> <expr><literal type="string">"true"</literal></expr> </then><else>: <expr><literal type="string">"false"</literal></expr></else></ternary><operator>)</operator></expr></argument>,
			 <argument><expr><call><name>IsoLevelAsUpperString</name><argument_list>(<argument><expr><call><name>mppTxOptions_IsoLevel</name><argument_list>(<argument><expr><name>txnOptions</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><call><name>isMppTxOptions_ReadOnly</name><argument_list>(<argument><expr><name>txnOptions</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="string">"true"</literal></expr> </then><else>: <expr><literal type="string">"false"</literal></expr></else></ternary><operator>)</operator></expr></argument>,
			 <argument><expr><operator>(</operator><ternary><condition><expr><name>haveDistributedSnapshot</name></expr> ?</condition><then> <expr><literal type="string">"true"</literal></expr> </then><else>: <expr><literal type="string">"false"</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DTM_DEBUG5</name></expr></argument>,
			 <argument><expr><literal type="string">"setupQEDtxContext inputs (part 2): distributedXid = "</literal><name>UINT64_FORMAT</name><literal type="string">", isSharedLocalSnapshotSlotPresent = %s."</literal></expr></argument>,
			 <argument><expr><name><name>dtxContextInfo</name><operator>-&gt;</operator><name>distributedXid</name></name></expr></argument>,
			 <argument><expr><operator>(</operator><ternary><condition><expr><name>isSharedLocalSnapshotSlotPresent</name></expr> ?</condition><then> <expr><literal type="string">"true"</literal></expr> </then><else>: <expr><literal type="string">"false"</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>haveDistributedSnapshot</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DTM_DEBUG5</name></expr></argument>,
				 <argument><expr><literal type="string">"setupQEDtxContext inputs (part 2a): distributedXid = "</literal><name>UINT64_FORMAT</name><literal type="string">", "</literal>
				 <literal type="string">"distributedSnapshotData (xmin = "</literal><name>UINT64_FORMAT</name><literal type="string">", xmax = "</literal><name>UINT64_FORMAT</name><literal type="string">", xcnt = %u), distributedCommandId = %d"</literal></expr></argument>,
				 <argument><expr><name><name>dtxContextInfo</name><operator>-&gt;</operator><name>distributedXid</name></name></expr></argument>,
				 <argument><expr><name><name>distributedSnapshot</name><operator>-&gt;</operator><name>xmin</name></name></expr></argument>, <argument><expr><name><name>distributedSnapshot</name><operator>-&gt;</operator><name>xmax</name></name></expr></argument>,
				 <argument><expr><name><name>distributedSnapshot</name><operator>-&gt;</operator><name>count</name></name></expr></argument>,
				 <argument><expr><name><name>dtxContextInfo</name><operator>-&gt;</operator><name>curcid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>isSharedLocalSnapshotSlotPresent</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>DTM_DEBUG5</name> <operator>&gt;=</operator> <name>log_min_messages</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name><name>SharedLocalSnapshotSlot</name><operator>-&gt;</operator><name>slotLock</name></name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DTM_DEBUG5</name></expr></argument>,
					 <argument><expr><literal type="string">"setupQEDtxContext inputs (part 2b):  shared local snapshot xid = "</literal> <name>UINT64_FORMAT</name> <literal type="string">" "</literal>
					 <literal type="string">"(xmin: %u xmax: %u xcnt: %u) curcid: %d, QDxid = "</literal><name>UINT64_FORMAT</name><literal type="string">"/%u"</literal></expr></argument>,
					 <argument><expr><call><name>U64FromFullTransactionId</name><argument_list>(<argument><expr><name><name>SharedLocalSnapshotSlot</name><operator>-&gt;</operator><name>fullXid</name></name></expr></argument>)</argument_list></call></expr></argument>,
					 <argument><expr><name><name>SharedLocalSnapshotSlot</name><operator>-&gt;</operator><name>snapshot</name><operator>.</operator><name>xmin</name></name></expr></argument>,
					 <argument><expr><name><name>SharedLocalSnapshotSlot</name><operator>-&gt;</operator><name>snapshot</name><operator>.</operator><name>xmax</name></name></expr></argument>,
					 <argument><expr><name><name>SharedLocalSnapshotSlot</name><operator>-&gt;</operator><name>snapshot</name><operator>.</operator><name>xcnt</name></name></expr></argument>,
					 <argument><expr><name><name>SharedLocalSnapshotSlot</name><operator>-&gt;</operator><name>snapshot</name><operator>.</operator><name>curcid</name></name></expr></argument>,
					 <argument><expr><name><name>SharedLocalSnapshotSlot</name><operator>-&gt;</operator><name>distributedXid</name></name></expr></argument>,
					 <argument><expr><name><name>SharedLocalSnapshotSlot</name><operator>-&gt;</operator><name>segmateSync</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name><name>SharedLocalSnapshotSlot</name><operator>-&gt;</operator><name>slotLock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<switch>switch <condition>(<expr><name>Gp_role</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>GP_ROLE_EXECUTE</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><call><name>IS_QUERY_DISPATCHER</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name>Gp_is_writer</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>isEntryDbSingleton</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/*
				 * NOTE: this is a bit hackish. It appears as though
				 * StartTransaction() gets called during connection setup
				 * before we even have time to setup our shared snapshot slot.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>SharedLocalSnapshotSlot</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name>explicitBegin</name> <operator>||</operator> <name>haveDistributedSnapshot</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"setupQEDtxContext not expecting distributed begin or snapshot when no Snapshot slot exists"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name>Gp_is_writer</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name>isWriterQE</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<expr_stmt><expr><name>isReaderQE</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					</block_content>}</block></else></if_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></else></if_stmt>
			<break>break;</break>

		<default>default:</default>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>DistributedTransactionContext</name> <operator>==</operator> <name>DTX_CONTEXT_LOCAL_ONLY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DTM_DEBUG5</name></expr></argument>,
				 <argument><expr><literal type="string">"setupQEDtxContext leaving context = 'Local Only' for Gp_role = %s"</literal></expr></argument>, <argument><expr><call><name>role_to_string</name><argument_list>(<argument><expr><name>Gp_role</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
	</block_content>}</block></switch>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DTM_DEBUG5</name></expr></argument>,
		 <argument><expr><literal type="string">"setupQEDtxContext intermediate result: isEntryDbSingleton = %s, isWriterQE = %s, isReaderQE = %s."</literal></expr></argument>,
		 <argument><expr><operator>(</operator><ternary><condition><expr><name>isEntryDbSingleton</name></expr> ?</condition><then> <expr><literal type="string">"true"</literal></expr> </then><else>: <expr><literal type="string">"false"</literal></expr></else></ternary><operator>)</operator></expr></argument>,
		 <argument><expr><operator>(</operator><ternary><condition><expr><name>isWriterQE</name></expr> ?</condition><then> <expr><literal type="string">"true"</literal></expr> </then><else>: <expr><literal type="string">"false"</literal></expr></else></ternary><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><name>isReaderQE</name></expr> ?</condition><then> <expr><literal type="string">"true"</literal></expr> </then><else>: <expr><literal type="string">"false"</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Copy to our QE global variable.
	 */</comment>
	<expr_stmt><expr><call><name>DtxContextInfo_Copy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>QEDtxContextInfo</name></expr></argument>, <argument><expr><name>dtxContextInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><name>DistributedTransactionContext</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>DTX_CONTEXT_LOCAL_ONLY</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name>isEntryDbSingleton</name> <operator>&amp;&amp;</operator> <name>haveDistributedSnapshot</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * Later, in GetSnapshotData, we will adopt the QD's
				 * transaction and snapshot information.
				 */</comment>

				<expr_stmt><expr><call><name>setDistributedTransactionContext</name><argument_list>(<argument><expr><name>DTX_CONTEXT_QE_ENTRY_DB_SINGLETON</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name>isReaderQE</name> <operator>&amp;&amp;</operator> <name>haveDistributedSnapshot</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * Later, in GetSnapshotData, we will adopt the QE Writer's
				 * transaction and snapshot information.
				 */</comment>

				<expr_stmt><expr><call><name>setDistributedTransactionContext</name><argument_list>(<argument><expr><name>DTX_CONTEXT_QE_READER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name>isWriterQE</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>explicitBegin</name> <operator>||</operator> <name>needDtx</name><operator>)</operator></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>haveDistributedSnapshot</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DTM_DEBUG5</name></expr></argument>,
						 <argument><expr><literal type="string">"setupQEDtxContext Segment Writer is involved in a distributed transaction without a distributed snapshot..."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>IsTransactionOrTransactionBlock</name><argument_list>()</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Starting an explicit distributed transaction in segment -- cannot already be in a transaction"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><name>explicitBegin</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					 * We set the DistributedTransactionContext BEFORE we
					 * create the transactions to influence the behavior of
					 * StartTransaction.
					 */</comment>
					<expr_stmt><expr><call><name>setDistributedTransactionContext</name><argument_list>(<argument><expr><name>DTX_CONTEXT_QE_TWO_PHASE_EXPLICIT_WRITER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><call><name>doQEDistributedExplicitBegin</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>setDistributedTransactionContext</name><argument_list>(<argument><expr><name>DTX_CONTEXT_QE_TWO_PHASE_IMPLICIT_WRITER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name>haveDistributedSnapshot</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><call><name>IsTransactionOrTransactionBlock</name><argument_list>()</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						 <argument><expr><literal type="string">"Going to start a local implicit transaction in segment using a distribute "</literal>
						 <literal type="string">"snapshot -- cannot already be in a transaction"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/*
				 * Before executing the query, postgres.c make a standard call
				 * to StartTransactionCommand which will begin a local
				 * transaction with StartTransaction.  This is fine.
				 *
				 * However, when the snapshot is created later, the state
				 * below will tell GetSnapshotData to make the local snapshot
				 * from the distributed snapshot.
				 */</comment>
				<expr_stmt><expr><call><name>setDistributedTransactionContext</name><argument_list>(<argument><expr><name>DTX_CONTEXT_QE_AUTO_COMMIT_IMPLICIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>haveDistributedSnapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * A local implicit transaction without reference to a
				 * distributed snapshot.  Stay in NONE state.
				 */</comment>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>DistributedTransactionContext</name> <operator>==</operator> <name>DTX_CONTEXT_LOCAL_ONLY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
			<break>break;</break>

		<case>case <expr><name>DTX_CONTEXT_QE_TWO_PHASE_IMPLICIT_WRITER</name></expr>:</case>
<comment type="block">/*
		elog(NOTICE, "We should have left this transition state '%s' at the end of the previous command...",
			 DtxContextToString(DistributedTransactionContext));
*/</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsTransactionOrTransactionBlock</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>explicitBegin</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Cannot have an explicit BEGIN statement..."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<break>break;</break>

		<case>case <expr><name>DTX_CONTEXT_QE_AUTO_COMMIT_IMPLICIT</name></expr>:</case>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"We should have left this transition state '%s' at the end of the previous command"</literal></expr></argument>,
				 <argument><expr><call><name>DtxContextToString</name><argument_list>(<argument><expr><name>DistributedTransactionContext</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>DTX_CONTEXT_QE_TWO_PHASE_EXPLICIT_WRITER</name></expr>:</case>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsTransactionOrTransactionBlock</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>DTX_CONTEXT_QE_ENTRY_DB_SINGLETON</name></expr>:</case>
		<case>case <expr><name>DTX_CONTEXT_QE_READER</name></expr>:</case>

			<comment type="block">/*
			 * We are playing games with the xact.c code, so we shouldn't test
			 * with the IsTransactionOrTransactionBlock() routine.
			 */</comment>
			<break>break;</break>

		<case>case <expr><name>DTX_CONTEXT_QE_PREPARED</name></expr>:</case>
		<case>case <expr><name>DTX_CONTEXT_QE_FINISH_PREPARED</name></expr>:</case>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"We should not be trying to execute a query in state '%s'"</literal></expr></argument>,
				 <argument><expr><call><name>DtxContextToString</name><argument_list>(<argument><expr><name>DistributedTransactionContext</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"Unexpected segment distribute transaction context value: %d"</literal></expr></argument>,
				 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>DistributedTransactionContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DTM_DEBUG5</name></expr></argument>, <argument><expr><literal type="string">"setupQEDtxContext final result: DistributedTransactionContext = '%s'."</literal></expr></argument>,
		 <argument><expr><call><name>DtxContextToString</name><argument_list>(<argument><expr><name>DistributedTransactionContext</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>haveDistributedSnapshot</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><operator>(</operator><ternary><condition><expr><name>Debug_print_snapshot_dtm</name></expr> ?</condition><then> <expr><name>LOG</name></expr> </then><else>: <expr><name>DEBUG5</name></expr></else></ternary><operator>)</operator></expr></argument>, <argument><expr><literal type="string">"[Distributed Snapshot #%u] *Set QE* currcid = %d (gxid = "</literal><name>UINT64_FORMAT</name><literal type="string">", '%s')"</literal></expr></argument>,
			 <argument><expr><name><name>dtxContextInfo</name><operator>-&gt;</operator><name>distributedSnapshot</name><operator>.</operator><name>distribSnapshotId</name></name></expr></argument>,
			 <argument><expr><name><name>dtxContextInfo</name><operator>-&gt;</operator><name>curcid</name></name></expr></argument>,
			 <argument><expr><call><name>getDistributedTransactionId</name><argument_list>()</argument_list></call></expr></argument>,
			 <argument><expr><call><name>DtxContextToString</name><argument_list>(<argument><expr><name>DistributedTransactionContext</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>
<name>finishDistributedTransactionContext</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>debugCaller</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>aborted</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DistributedTransactionId</name></type> <name>gxid</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * We let the 2 retry states go up to PostgresMain.c, otherwise everything
	 * MUST be complete.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>isCurrentDtxActivated</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
		<operator>(</operator><name><name>MyTmGxactLocal</name><operator>-&gt;</operator><name>state</name></name> <operator>!=</operator> <name>DTX_STATE_RETRY_COMMIT_PREPARED</name> <operator>&amp;&amp;</operator>
		 <name><name>MyTmGxactLocal</name><operator>-&gt;</operator><name>state</name></name> <operator>!=</operator> <name>DTX_STATE_RETRY_ABORT_PREPARED</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Unexpected dtx status (caller = %s)."</literal></expr></argument>, <argument><expr><name>debugCaller</name></expr></argument>)</argument_list></call><operator>,</operator>
				<name>TM_ERRDETAIL</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>gxid</name> <operator>=</operator> <call><name>getDistributedTransactionId</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DTM_DEBUG5</name></expr></argument>,
		 <argument><expr><literal type="string">"finishDistributedTransactionContext called to change DistributedTransactionContext from %s to %s (caller = %s, gxid = "</literal><name>UINT64_FORMAT</name><literal type="string">")"</literal></expr></argument>,
		 <argument><expr><call><name>DtxContextToString</name><argument_list>(<argument><expr><name>DistributedTransactionContext</name></expr></argument>)</argument_list></call></expr></argument>,
		 <argument><expr><call><name>DtxContextToString</name><argument_list>(<argument><expr><name>DTX_CONTEXT_LOCAL_ONLY</name></expr></argument>)</argument_list></call></expr></argument>,
		 <argument><expr><name>debugCaller</name></expr></argument>,
		 <argument><expr><name>gxid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>setDistributedTransactionContext</name><argument_list>(<argument><expr><name>DTX_CONTEXT_LOCAL_ONLY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>DtxContextInfo_Reset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>QEDtxContextInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>rememberDtxExplicitBegin</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name> <argument_list>(<argument><expr><call><name>isCurrentDtxActivated</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>MyTmGxactLocal</name><operator>-&gt;</operator><name>explicitBeginRemembered</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DTM_DEBUG5</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"rememberDtxExplicitBegin explicit BEGIN"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				<name>TM_ERRDETAIL</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>MyTmGxactLocal</name><operator>-&gt;</operator><name>explicitBeginRemembered</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DTM_DEBUG5</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"rememberDtxExplicitBegin already an explicit BEGIN"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				<name>TM_ERRDETAIL</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>isDtxExplicitBegin</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><operator>(</operator><call><name>isCurrentDtxActivated</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <name><name>MyTmGxactLocal</name><operator>-&gt;</operator><name>explicitBeginRemembered</name></name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * This is mostly here because
 * cdbcopy doesn't use cdbdisp's services.
 */</comment>
<function><type><name>void</name></type>
<name>sendDtxExplicitBegin</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>Gp_role</name> <operator>!=</operator> <name>GP_ROLE_DISPATCH</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>setupDtxTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>rememberDtxExplicitBegin</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
 * On the QD, run the Prepare operation.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>performDtxProtocolPrepare</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>gid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>StartTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DTM_DEBUG5</name></expr></argument>, <argument><expr><literal type="string">"performDtxProtocolCommand going to call PrepareTransactionBlock for distributed transaction (id = '%s')"</literal></expr></argument>, <argument><expr><name>gid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PrepareTransactionBlock</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>gid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Prepare of distributed transaction %s failed"</literal></expr></argument>, <argument><expr><name>gid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Calling CommitTransactionCommand will cause the actual COMMIT/PREPARE
	 * work to be performed.
	 */</comment>
	<expr_stmt><expr><call><name>CommitTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DTM_DEBUG5</name></expr></argument>, <argument><expr><literal type="string">"Prepare of distributed transaction succeeded (id = '%s')"</literal></expr></argument>, <argument><expr><name>gid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>setDistributedTransactionContext</name><argument_list>(<argument><expr><name>DTX_CONTEXT_QE_PREPARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>sendWaitGxidsToQD</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>waitGxids</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name>waitGxids</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>pq_beginmessage</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="char">'w'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pq_sendint</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>waitGxids</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pq_sendint</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>pq_endmessage</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<comment type="block" format="doxygen">/**
 * On the QE, run the Commit one-phase operation.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>performDtxProtocolCommitOnePhase</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>gid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DistributedTransactionId</name></type> <name>gxid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>waitGxids</name> <init>= <expr><call><name>list_copy</name><argument_list>(<argument><expr><name><name>MyTmGxactLocal</name><operator>-&gt;</operator><name>waitGxids</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>SIMPLE_FAULT_INJECTOR</name><argument_list>(<argument><expr><literal type="string">"start_performDtxProtocolCommitOnePhase"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DTM_DEBUG5</name></expr></argument>,
		 <argument><expr><literal type="string">"performDtxProtocolCommitOnePhase going to call CommitTransaction for distributed transaction %s"</literal></expr></argument>, <argument><expr><name>gid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>dtxDeformGid</name><argument_list>(<argument><expr><name>gid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>gxid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>gxid</name> <operator>==</operator> <call><name>getDistributedTransactionId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>MyTmGxactLocal</name><operator>-&gt;</operator><name>isOnePhaseCommit</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>StartTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>EndTransactionBlock</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"One-phase Commit of distributed transaction %s failed"</literal></expr></argument>, <argument><expr><name>gid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Calling CommitTransactionCommand will cause the actual COMMIT work to be performed. */</comment>
	<expr_stmt><expr><call><name>CommitTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>finishDistributedTransactionContext</name><argument_list>(<argument><expr><literal type="string">"performDtxProtocolCommitOnePhase -- Commit onephase"</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>MyProc</name><operator>-&gt;</operator><name>localDistribXactData</name><operator>.</operator><name>state</name></name> <operator>=</operator> <name>LOCALDISTRIBXACT_STATE_NONE</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>sendWaitGxidsToQD</name><argument_list>(<argument><expr><name>waitGxids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
 * On the QE, run the Commit Prepared operation.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>performDtxProtocolCommitPrepared</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>gid</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>raiseErrorIfNotFound</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_EXECUTE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DTM_DEBUG5</name></expr></argument>,
		 <argument><expr><literal type="string">"performDtxProtocolCommitPrepared going to call FinishPreparedTransaction for distributed transaction %s"</literal></expr></argument>, <argument><expr><name>gid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>waitGxids</name> <init>= <expr><call><name>list_copy</name><argument_list>(<argument><expr><name><name>MyTmGxactLocal</name><operator>-&gt;</operator><name>waitGxids</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>StartTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Since this call may fail, lets setup a handler.
	 */</comment>
	<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<expr_stmt><expr><call><name>FinishPreparedTransaction</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>gid</name></expr></argument>, <comment type="block">/* isCommit */</comment> <argument><expr><name>true</name></expr></argument>, <argument><expr><name>raiseErrorIfNotFound</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<expr_stmt><expr><call><name>finishDistributedTransactionContext</name><argument_list>(<argument><expr><literal type="string">"performDtxProtocolCommitPrepared -- Commit Prepared (error case)"</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Calling CommitTransactionCommand will cause the actual COMMIT/PREPARE
	 * work to be performed.
	 */</comment>
	<expr_stmt><expr><call><name>CommitTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>sendWaitGxidsToQD</name><argument_list>(<argument><expr><name>waitGxids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>finishDistributedTransactionContext</name><argument_list>(<argument><expr><literal type="string">"performDtxProtocolCommitPrepared -- Commit Prepared"</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
 * On the QE, run the Abort Prepared operation.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>performDtxProtocolAbortPrepared</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>gid</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>raiseErrorIfNotFound</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_EXECUTE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DTM_DEBUG5</name></expr></argument>, <argument><expr><literal type="string">"performDtxProtocolAbortPrepared going to call FinishPreparedTransaction for distributed transaction %s"</literal></expr></argument>, <argument><expr><name>gid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>StartTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Since this call may fail, lets setup a handler.
	 */</comment>
	<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<expr_stmt><expr><call><name>FinishPreparedTransaction</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>gid</name></expr></argument>, <comment type="block">/* isCommit */</comment> <argument><expr><name>false</name></expr></argument>, <argument><expr><name>raiseErrorIfNotFound</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<expr_stmt><expr><call><name>finishDistributedTransactionContext</name><argument_list>(<argument><expr><literal type="string">"performDtxProtocolAbortPrepared -- Abort Prepared (error case)"</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Calling CommitTransactionCommand will cause the actual COMMIT/PREPARE
	 * work to be performed.
	 */</comment>
	<expr_stmt><expr><call><name>CommitTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>finishDistributedTransactionContext</name><argument_list>(<argument><expr><literal type="string">"performDtxProtocolAbortPrepared -- Abort Prepared"</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
 * On the QE, handle a DtxProtocolCommand
 */</comment>
<function><type><name>void</name></type>
<name>performDtxProtocolCommand</name><parameter_list>(<parameter><decl><type><name>DtxProtocolCommand</name></type> <name>dtxProtocolCommand</name></decl></parameter>,
						  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>gid</name></decl></parameter>,
						  <parameter><decl><type><name>DtxContextInfo</name> <modifier>*</modifier></type><name>contextInfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DTM_DEBUG5</name></expr></argument>,
		 <argument><expr><literal type="string">"performDtxProtocolCommand called with DTX protocol = %s, segment distribute transaction context: '%s'"</literal></expr></argument>,
		 <argument><expr><call><name>DtxProtocolCommandToString</name><argument_list>(<argument><expr><name>dtxProtocolCommand</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>DtxContextToString</name><argument_list>(<argument><expr><name>DistributedTransactionContext</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><name>dtxProtocolCommand</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>DTX_PROTOCOL_COMMAND_ABORT_NO_PREPARED</name></expr>:</case>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DTM_DEBUG5</name></expr></argument>,
				 <argument><expr><literal type="string">"performDtxProtocolCommand going to call AbortOutOfAnyTransaction for distributed transaction %s"</literal></expr></argument>, <argument><expr><name>gid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>AbortOutOfAnyTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>DTX_PROTOCOL_COMMAND_PREPARE</name></expr>:</case>
		<case>case <expr><name>DTX_PROTOCOL_COMMAND_COMMIT_ONEPHASE</name></expr>:</case>

			<comment type="block">/*
			 * The QD has directed us to read-only commit or prepare an
			 * implicit or explicit distributed transaction.
			 */</comment>
			<switch>switch <condition>(<expr><name>DistributedTransactionContext</name></expr>)</condition>
			<block>{<block_content>
				<case>case <expr><name>DTX_CONTEXT_LOCAL_ONLY</name></expr>:</case>

					<comment type="block">/*
					 * Spontaneously aborted while we were back at the QD?
					 */</comment>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Distributed transaction %s not found"</literal></expr></argument>, <argument><expr><name>gid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>

				<case>case <expr><name>DTX_CONTEXT_QE_TWO_PHASE_EXPLICIT_WRITER</name></expr>:</case>
				<case>case <expr><name>DTX_CONTEXT_QE_TWO_PHASE_IMPLICIT_WRITER</name></expr>:</case>
					<if_stmt><if>if <condition>(<expr><name>dtxProtocolCommand</name> <operator>==</operator> <name>DTX_PROTOCOL_COMMAND_COMMIT_ONEPHASE</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>performDtxProtocolCommitOnePhase</name><argument_list>(<argument><expr><name>gid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>performDtxProtocolPrepare</name><argument_list>(<argument><expr><name>gid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
					<break>break;</break>

				<case>case <expr><name>DTX_CONTEXT_QD_DISTRIBUTED_CAPABLE</name></expr>:</case>
				<case>case <expr><name>DTX_CONTEXT_QD_RETRY_PHASE_2</name></expr>:</case>
				<case>case <expr><name>DTX_CONTEXT_QE_PREPARED</name></expr>:</case>
				<case>case <expr><name>DTX_CONTEXT_QE_FINISH_PREPARED</name></expr>:</case>
				<case>case <expr><name>DTX_CONTEXT_QE_ENTRY_DB_SINGLETON</name></expr>:</case>
				<case>case <expr><name>DTX_CONTEXT_QE_READER</name></expr>:</case>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"Unexpected segment distribute transaction context: '%s'"</literal></expr></argument>,
						 <argument><expr><call><name>DtxContextToString</name><argument_list>(<argument><expr><name>DistributedTransactionContext</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>

				<default>default:</default>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"Unexpected segment distribute transaction context value: %d"</literal></expr></argument>,
						 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>DistributedTransactionContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
			</block_content>}</block></switch>
			<break>break;</break>

		<case>case <expr><name>DTX_PROTOCOL_COMMAND_ABORT_SOME_PREPARED</name></expr>:</case>
			<switch>switch <condition>(<expr><name>DistributedTransactionContext</name></expr>)</condition>
			<block>{<block_content>
				<case>case <expr><name>DTX_CONTEXT_LOCAL_ONLY</name></expr>:</case>

					<comment type="block">/*
					 * Spontaneously aborted while we were back at the QD?
					 *
					 * It's normal if the transaction doesn't exist. The QD will
					 * call abort on us, even if we didn't finish the prepare yet,
					 * if some other QE reported failure already.
					 */</comment>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DTM_DEBUG3</name></expr></argument>, <argument><expr><literal type="string">"Distributed transaction %s not found during abort"</literal></expr></argument>, <argument><expr><name>gid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>AbortOutOfAnyTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>

				<case>case <expr><name>DTX_CONTEXT_QE_TWO_PHASE_EXPLICIT_WRITER</name></expr>:</case>
				<case>case <expr><name>DTX_CONTEXT_QE_TWO_PHASE_IMPLICIT_WRITER</name></expr>:</case>
					<expr_stmt><expr><call><name>AbortOutOfAnyTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>

				<case>case <expr><name>DTX_CONTEXT_QE_PREPARED</name></expr>:</case>
					<expr_stmt><expr><call><name>setDistributedTransactionContext</name><argument_list>(<argument><expr><name>DTX_CONTEXT_QE_FINISH_PREPARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>performDtxProtocolAbortPrepared</name><argument_list>(<argument><expr><name>gid</name></expr></argument>, <comment type="block">/* raiseErrorIfNotFound */</comment> <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>

				<case>case <expr><name>DTX_CONTEXT_QD_DISTRIBUTED_CAPABLE</name></expr>:</case>
				<case>case <expr><name>DTX_CONTEXT_QD_RETRY_PHASE_2</name></expr>:</case>
				<case>case <expr><name>DTX_CONTEXT_QE_ENTRY_DB_SINGLETON</name></expr>:</case>
				<case>case <expr><name>DTX_CONTEXT_QE_READER</name></expr>:</case>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"Unexpected segment distribute transaction context: '%s'"</literal></expr></argument>,
						 <argument><expr><call><name>DtxContextToString</name><argument_list>(<argument><expr><name>DistributedTransactionContext</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>

				<default>default:</default>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"Unexpected segment distribute transaction context value: %d"</literal></expr></argument>,
						 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>DistributedTransactionContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
			</block_content>}</block></switch>
			<break>break;</break>

		<case>case <expr><name>DTX_PROTOCOL_COMMAND_COMMIT_PREPARED</name></expr>:</case>
			<expr_stmt><expr><call><name>requireDistributedTransactionContext</name><argument_list>(<argument><expr><name>DTX_CONTEXT_QE_PREPARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>setDistributedTransactionContext</name><argument_list>(<argument><expr><name>DTX_CONTEXT_QE_FINISH_PREPARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>performDtxProtocolCommitPrepared</name><argument_list>(<argument><expr><name>gid</name></expr></argument>, <comment type="block">/* raiseErrorIfNotFound */</comment> <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>DTX_PROTOCOL_COMMAND_ABORT_PREPARED</name></expr>:</case>
			<expr_stmt><expr><call><name>requireDistributedTransactionContext</name><argument_list>(<argument><expr><name>DTX_CONTEXT_QE_PREPARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>setDistributedTransactionContext</name><argument_list>(<argument><expr><name>DTX_CONTEXT_QE_FINISH_PREPARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>performDtxProtocolAbortPrepared</name><argument_list>(<argument><expr><name>gid</name></expr></argument>, <comment type="block">/* raiseErrorIfNotFound */</comment> <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>DTX_PROTOCOL_COMMAND_RETRY_COMMIT_PREPARED</name></expr>:</case>
			<expr_stmt><expr><call><name>requireDistributedTransactionContext</name><argument_list>(<argument><expr><name>DTX_CONTEXT_LOCAL_ONLY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>performDtxProtocolCommitPrepared</name><argument_list>(<argument><expr><name>gid</name></expr></argument>, <comment type="block">/* raiseErrorIfNotFound */</comment> <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>DTX_PROTOCOL_COMMAND_RETRY_ABORT_PREPARED</name></expr>:</case>
			<expr_stmt><expr><call><name>requireDistributedTransactionContext</name><argument_list>(<argument><expr><name>DTX_CONTEXT_LOCAL_ONLY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>performDtxProtocolAbortPrepared</name><argument_list>(<argument><expr><name>gid</name></expr></argument>, <comment type="block">/* raiseErrorIfNotFound */</comment> <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>DTX_PROTOCOL_COMMAND_RECOVERY_COMMIT_PREPARED</name></expr>:</case>
			<expr_stmt><expr><call><name>requireDistributedTransactionContext</name><argument_list>(<argument><expr><name>DTX_CONTEXT_LOCAL_ONLY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>performDtxProtocolCommitPrepared</name><argument_list>(<argument><expr><name>gid</name></expr></argument>, <comment type="block">/* raiseErrorIfNotFound */</comment> <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>DTX_PROTOCOL_COMMAND_RECOVERY_ABORT_PREPARED</name></expr>:</case>
			<expr_stmt><expr><call><name>requireDistributedTransactionContext</name><argument_list>(<argument><expr><name>DTX_CONTEXT_LOCAL_ONLY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>performDtxProtocolAbortPrepared</name><argument_list>(<argument><expr><name>gid</name></expr></argument>, <comment type="block">/* raiseErrorIfNotFound */</comment> <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>DTX_PROTOCOL_COMMAND_SUBTRANSACTION_BEGIN_INTERNAL</name></expr>:</case>
			<switch>switch <condition>(<expr><name>DistributedTransactionContext</name></expr>)</condition>
			<block>{<block_content>
				<case>case <expr><name>DTX_CONTEXT_LOCAL_ONLY</name></expr>:</case>

					<comment type="block">/*
					 * QE is not aware of DTX yet. A typical case is SELECT
					 * foo(), where foo() opens internal subtransaction
					 */</comment>
					<expr_stmt><expr><call><name>setupQEDtxContext</name><argument_list>(<argument><expr><name>contextInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>StartTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>DTX_CONTEXT_QE_TWO_PHASE_IMPLICIT_WRITER</name></expr>:</case>

					<comment type="block">/*
					 * We already marked this QE to be writer, and transaction
					 * is open.
					 */</comment>
				<case>case <expr><name>DTX_CONTEXT_QE_TWO_PHASE_EXPLICIT_WRITER</name></expr>:</case>
				<case>case <expr><name>DTX_CONTEXT_QE_READER</name></expr>:</case>
					<break>break;</break>
				<default>default:</default>
					<comment type="block">/* Lets flag this situation out, with explicit crash */</comment>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DTM_DEBUG5</name></expr></argument>,
						 <argument><expr><literal type="string">" SUBTRANSACTION_BEGIN_INTERNAL distributed transaction context invalid: %d"</literal></expr></argument>,
						 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>DistributedTransactionContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
			</block_content>}</block></switch>

			<expr_stmt><expr><call><name>BeginInternalSubTransaction</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>contextInfo</name><operator>-&gt;</operator><name>nestingLevel</name></name> <operator>+</operator> <literal type="number">1</literal> <operator>==</operator> <call><name>GetCurrentTransactionNestLevel</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>DTX_PROTOCOL_COMMAND_SUBTRANSACTION_RELEASE_INTERNAL</name></expr>:</case>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>contextInfo</name><operator>-&gt;</operator><name>nestingLevel</name></name> <operator>==</operator> <call><name>GetCurrentTransactionNestLevel</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ReleaseCurrentSubTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>DTX_PROTOCOL_COMMAND_SUBTRANSACTION_ROLLBACK_INTERNAL</name></expr>:</case>

			<comment type="block">/*
			 * Rollback performs work on master and then dispatches, hence has
			 * nestingLevel its expecting post operation
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>contextInfo</name><operator>-&gt;</operator><name>nestingLevel</name></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>&gt;</operator> <call><name>GetCurrentTransactionNestLevel</name><argument_list>()</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"transaction %s at level %d already processed (current level %d)"</literal></expr></argument>,
								<argument><expr><name>gid</name></expr></argument>, <argument><expr><name><name>contextInfo</name><operator>-&gt;</operator><name>nestingLevel</name></name></expr></argument>, <argument><expr><call><name>GetCurrentTransactionNestLevel</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name> <init>= <expr><call><name>GetCurrentTransactionNestLevel</name><argument_list>()</argument_list></call> <operator>-</operator> <name><name>contextInfo</name><operator>-&gt;</operator><name>nestingLevel</name></name></expr></init></decl>;</decl_stmt>

			<while>while <condition>(<expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>RollbackAndReleaseCurrentSubTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>i</name><operator>--</operator></expr>;</expr_stmt>
			</block_content>}</block></while>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>contextInfo</name><operator>-&gt;</operator><name>nestingLevel</name></name> <operator>==</operator> <call><name>GetCurrentTransactionNestLevel</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Unrecognized dtx protocol command: %d"</literal></expr></argument>,
				 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>dtxProtocolCommand</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DTM_DEBUG5</name></expr></argument>, <argument><expr><literal type="string">"performDtxProtocolCommand successful return for distributed transaction %s"</literal></expr></argument>, <argument><expr><name>gid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>markCurrentGxactWriterGangLost</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>MyTmGxactLocal</name><operator>-&gt;</operator><name>writerGangLost</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>currentGxactWriterGangLost</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name><name>MyTmGxactLocal</name><operator>-&gt;</operator><name>writerGangLost</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Record which segment involved in the two phase commit.
 */</comment>
<function><type><name>void</name></type>
<name>addToGxactDtxSegments</name><parameter_list>(<parameter><decl><type><name>Gang</name> <modifier>*</modifier></type><name>gang</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SegmentDatabaseDescriptor</name> <modifier>*</modifier></type><name>segdbDesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldContext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>segindex</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>isCurrentDtxActivated</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* skip if all segdbs are in the list */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>MyTmGxactLocal</name><operator>-&gt;</operator><name>dtxSegments</name></name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <call><name>getgpsegmentCount</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>oldContext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>TopTransactionContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>gang</name><operator>-&gt;</operator><name>size</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>segdbDesc</name> <operator>=</operator> <name><name>gang</name><operator>-&gt;</operator><name>db_descriptors</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>segdbDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>segindex</name> <operator>=</operator> <name><name>segdbDesc</name><operator>-&gt;</operator><name>segindex</name></name></expr>;</expr_stmt>

		<comment type="block">/* entry db is just a reader, will not involve in two phase commit */</comment>
		<if_stmt><if>if <condition>(<expr><name>segindex</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* skip if record already */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>bms_is_member</name><argument_list>(<argument><expr><name>segindex</name></expr></argument>, <argument><expr><name><name>MyTmGxactLocal</name><operator>-&gt;</operator><name>dtxSegmentsMap</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>MyTmGxactLocal</name><operator>-&gt;</operator><name>dtxSegmentsMap</name></name> <operator>=</operator>
			<call><name>bms_add_member</name><argument_list>(<argument><expr><name><name>MyTmGxactLocal</name><operator>-&gt;</operator><name>dtxSegmentsMap</name></name></expr></argument>, <argument><expr><name>segindex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>MyTmGxactLocal</name><operator>-&gt;</operator><name>dtxSegments</name></name> <operator>=</operator>
			<call><name>lappend_int</name><argument_list>(<argument><expr><name><name>MyTmGxactLocal</name><operator>-&gt;</operator><name>dtxSegments</name></name></expr></argument>, <argument><expr><name>segindex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>CurrentDtxIsRollingback</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><operator>(</operator><name><name>MyTmGxactLocal</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>DTX_STATE_NOTIFYING_ABORT_NO_PREPARED</name> <operator>||</operator>
			<name><name>MyTmGxactLocal</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>DTX_STATE_NOTIFYING_ABORT_SOME_PREPARED</name> <operator>||</operator>
			<name><name>MyTmGxactLocal</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>DTX_STATE_NOTIFYING_ABORT_PREPARED</name> <operator>||</operator>
			<name><name>MyTmGxactLocal</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>DTX_STATE_RETRY_ABORT_PREPARED</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>gp_get_next_gxid</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DistributedTransactionId</name></type> <name>next_gxid</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>superuser</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_PRIVILEGE</name></expr></argument>)</argument_list></call><operator>,</operator>
						<operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Superuser only to execute it"</literal></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><name>shmGxidGenLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>next_gxid</name> <operator>=</operator> <name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>nextGxid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><name>shmGxidGenLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_UINT64</name><argument_list>(<argument><expr><name>next_gxid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
