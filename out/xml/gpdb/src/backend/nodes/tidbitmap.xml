<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/backend/nodes/tidbitmap.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * tidbitmap.c
 *	  PostgreSQL tuple-id (TID) bitmap package
 *
 * This module provides bitmap data structures that are spiritually
 * similar to Bitmapsets, but are specially adapted to store sets of
 * tuple identifiers (TIDs), or ItemPointers.  In particular, the division
 * of an ItemPointer into BlockNumber and OffsetNumber is catered for.
 * Also, since we wish to be able to store very large tuple sets in
 * memory with this data structure, we support "lossy" storage, in which
 * we no longer remember individual tuple offsets on a page but only the
 * fact that a particular page needs to be visited.
 *
 * The "lossy" storage uses one bit per disk page, so at the standard 8K
 * BLCKSZ, we can represent all pages in 64Gb of disk space in about 1Mb
 * of memory.  People pushing around tables of that size should have a
 * couple of Mb to spare, so we don't worry about providing a second level
 * of lossiness.  In theory we could fall back to page ranges at some
 * point, but for now that seems useless complexity.
 *
 *
 * Copyright (c) 2003-2019, PostgreSQL Global Development Group
 *
 * IDENTIFICATION
 *	  src/backend/nodes/tidbitmap.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;limits.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/bitmap.h"</cpp:file></cpp:include>		<comment type="block">/* XXX: remove once pull_stream is generic */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/hashfn.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/instrument.h"</cpp:file></cpp:include>	<comment type="block">/* Instrumentation */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/tidbitmap.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/lwlock.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/dsa.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WORDNUM</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>((x) / TBM_BITS_PER_BITMAPWORD)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BITNUM</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>((x) % TBM_BITS_PER_BITMAPWORD)</cpp:value></cpp:define>

<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>tbm_iterate_page</name><parameter_list>(<parameter><decl><type><name>PagetableEntry</name> <modifier>*</modifier></type><name>page</name></decl></parameter>, <parameter><decl><type><name>TBMIterateResult</name> <modifier>*</modifier></type><name>output</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>PagetableEntry</name> <modifier>*</modifier></type><name>tbm_next_page</name><parameter_list>(<parameter><decl><type><name>TBMIterator</name> <modifier>*</modifier></type><name>iterator</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>more</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>tbm_upd_instrument</name><parameter_list>(<parameter><decl><type><name>TIDBitmap</name> <modifier>*</modifier></type><name>tbm</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * Holds array of pagetable entries.
 */</comment>
<typedef>typedef <type><struct>struct <name>PTEntryArray</name>
<block>{
	<decl_stmt><decl><type><name>pg_atomic_uint32</name></type> <name>refcount</name></decl>;</decl_stmt>	<comment type="block">/* no. of iterator attached */</comment>
	<decl_stmt><decl><type><name>PagetableEntry</name></type> <name><name>ptentry</name><index>[<expr><name>FLEXIBLE_ARRAY_MEMBER</name></expr>]</index></name></decl>;</decl_stmt>
}</block></struct></type> <name>PTEntryArray</name>;</typedef>

<comment type="block">/*
 * We want to avoid the overhead of creating the hashtable, which is
 * comparatively large, when not necessary. Particularly when we are using a
 * bitmap scan on the inside of a nestloop join: a bitmap may well live only
 * long enough to accumulate one entry in such cases.  We therefore avoid
 * creating an actual hashtable until we need two pagetable entries.  When
 * just one pagetable entry is needed, we store it in a fixed field of
 * TIDBitMap.  (NOTE: we don't get rid of the hashtable if the bitmap later
 * shrinks down to zero or one page again.  So, status can be TBM_HASH even
 * when nentries is zero or one.)
 */</comment>
<typedef>typedef <type><enum>enum
<block>{
	<decl><name>TBM_EMPTY</name></decl>,					<comment type="block">/* no hashtable, nentries == 0 */</comment>
	<decl><name>TBM_ONE_PAGE</name></decl>,				<comment type="block">/* entry1 contains the single entry */</comment>
	<decl><name>TBM_HASH</name></decl>					<comment type="block">/* pagetable is valid, entry1 is not */</comment>
}</block></enum></type> <name>TBMStatus</name>;</typedef>

<comment type="block">/*
 * Current iterating state of the TBM.
 */</comment>
<typedef>typedef <type><enum>enum
<block>{
	<decl><name>TBM_NOT_ITERATING</name></decl>,			<comment type="block">/* not yet converted to page and chunk array */</comment>
	<decl><name>TBM_ITERATING_PRIVATE</name></decl>,		<comment type="block">/* converted to local page and chunk array */</comment>
	<decl><name>TBM_ITERATING_SHARED</name></decl>		<comment type="block">/* converted to shared page and chunk array */</comment>
}</block></enum></type> <name>TBMIteratingState</name>;</typedef>

<comment type="block">/*
 * Here is the representation for a whole TIDBitMap:
 */</comment>
<struct>struct <name>TIDBitmap</name>
<block>{
	<decl_stmt><decl><type><name>NodeTag</name></type>		<name>type</name></decl>;</decl_stmt>			<comment type="block">/* to make it a valid Node */</comment>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>mcxt</name></decl>;</decl_stmt>			<comment type="block">/* memory context containing me */</comment>
	<decl_stmt><decl><type><name>TBMStatus</name></type>	<name>status</name></decl>;</decl_stmt>			<comment type="block">/* see codes above */</comment>
	<decl_stmt><decl><type><name><name>struct</name> <name>pagetable_hash</name></name> <modifier>*</modifier></type><name>pagetable</name></decl>;</decl_stmt>	<comment type="block">/* hash table of PagetableEntry's */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>nentries</name></decl>;</decl_stmt>		<comment type="block">/* number of entries in pagetable */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>nentries_hwm</name></decl>;</decl_stmt>	<comment type="block">/* high-water mark for number of entries */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>maxentries</name></decl>;</decl_stmt>		<comment type="block">/* limit on same to meet maxbytes */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>npages</name></decl>;</decl_stmt>			<comment type="block">/* number of exact entries in pagetable */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>nchunks</name></decl>;</decl_stmt>		<comment type="block">/* number of lossy entries in pagetable */</comment>
	<decl_stmt><decl><type><name>TBMIteratingState</name></type> <name>iterating</name></decl>;</decl_stmt>	<comment type="block">/* tbm_begin_iterate called? */</comment>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>lossify_start</name></decl>;</decl_stmt>	<comment type="block">/* offset to start lossifying hashtable at */</comment>
	<decl_stmt><decl><type><name>PagetableEntry</name></type> <name>entry1</name></decl>;</decl_stmt>		<comment type="block">/* used when status == TBM_ONE_PAGE */</comment>
	<comment type="block">/* these are valid when iterating is true: */</comment>
	<decl_stmt><decl><type><name>PagetableEntry</name> <modifier>*</modifier><modifier>*</modifier></type><name>spages</name></decl>;</decl_stmt>	<comment type="block">/* sorted exact-page list, or NULL */</comment>
	<decl_stmt><decl><type><name>PagetableEntry</name> <modifier>*</modifier><modifier>*</modifier></type><name>schunks</name></decl>;</decl_stmt>	<comment type="block">/* sorted lossy-chunk list, or NULL */</comment>
    <decl_stmt><decl><type><name>dsa_pointer</name></type> <name>dsapagetable</name></decl>;</decl_stmt>	<comment type="block">/* dsa_pointer to the element array */</comment>
    <decl_stmt><decl><type><name>dsa_pointer</name></type> <name>dsapagetableold</name></decl>;</decl_stmt>	<comment type="block">/* dsa_pointer to the old element array */</comment>
    <decl_stmt><decl><type><name>dsa_pointer</name></type> <name>ptpages</name></decl>;</decl_stmt>		<comment type="block">/* dsa_pointer to the page array */</comment>
    <decl_stmt><decl><type><name>dsa_pointer</name></type> <name>ptchunks</name></decl>;</decl_stmt>		<comment type="block">/* dsa_pointer to the chunk array */</comment>
    <decl_stmt><decl><type><name>dsa_area</name>   <modifier>*</modifier></type><name>dsa</name></decl>;</decl_stmt>			<comment type="block">/* reference to per-query dsa area */</comment>

	<comment type="block">/* CDB: Statistics for EXPLAIN ANALYZE */</comment>
	<decl_stmt><decl><type><name><name>struct</name> <name>Instrumentation</name></name> <modifier>*</modifier></type><name>instrument</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>bytesperentry</name></decl>;</decl_stmt>
}</block>;</struct>

<comment type="block">/*
 * When iterating over a bitmap in sorted order, a TBMIterator is used to
 * track our progress.  There can be several iterators scanning the same
 * bitmap concurrently.  Note that the bitmap becomes read-only as soon as
 * any iterator is created.
 */</comment>
<struct>struct <name>TBMIterator</name>
<block>{
	<decl_stmt><decl><type><name>TIDBitmap</name>  <modifier>*</modifier></type><name>tbm</name></decl>;</decl_stmt>			<comment type="block">/* TIDBitmap we're iterating over */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>spageptr</name></decl>;</decl_stmt>		<comment type="block">/* next spages index */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>schunkptr</name></decl>;</decl_stmt>		<comment type="block">/* next schunks index */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>schunkbit</name></decl>;</decl_stmt>		<comment type="block">/* next bit to check in current schunk */</comment>
	<decl_stmt><decl><type><name>TBMIterateResult</name></type> <name>output</name></decl>;</decl_stmt>	<comment type="block">/* MUST BE LAST (because variable-size) */</comment>
}</block>;</struct>

<struct>struct <name>GenericBMIterator</name>
<block>{
	<decl_stmt><decl><type><specifier>const</specifier> <name>Node</name> <modifier>*</modifier></type><name>bm</name></decl>;</decl_stmt>				<comment type="block">/* [TID|Stream]Bitmap we're iterating over */</comment>
	<union>union
	<block>{
		<decl_stmt><decl><type><name>TBMIterator</name>		 <modifier>*</modifier></type><name>hash</name></decl>;</decl_stmt>		<comment type="block">/* iterator for TIDBitmap implementation */</comment>
		<decl_stmt><decl><type><name>StreamBMIterator</name> <modifier>*</modifier></type><name>stream</name></decl>;</decl_stmt>	<comment type="block">/* iterator for StreamBitmap implementation */</comment>
	}</block> <decl><name>impl</name></decl>;</union>
}</block>;</struct>

<comment type="block">/*
 * Holds the shared members of the iterator so that multiple processes
 * can jointly iterate.
 */</comment>
<typedef>typedef <type><struct>struct <name>TBMSharedIteratorState</name>
<block>{
	<decl_stmt><decl><type><name>int</name></type>			<name>nentries</name></decl>;</decl_stmt>		<comment type="block">/* number of entries in pagetable */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>maxentries</name></decl>;</decl_stmt>		<comment type="block">/* limit on same to meet maxbytes */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>npages</name></decl>;</decl_stmt>			<comment type="block">/* number of exact entries in pagetable */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>nchunks</name></decl>;</decl_stmt>		<comment type="block">/* number of lossy entries in pagetable */</comment>
	<decl_stmt><decl><type><name>dsa_pointer</name></type> <name>pagetable</name></decl>;</decl_stmt>		<comment type="block">/* dsa pointers to head of pagetable data */</comment>
	<decl_stmt><decl><type><name>dsa_pointer</name></type> <name>spages</name></decl>;</decl_stmt>			<comment type="block">/* dsa pointer to page array */</comment>
	<decl_stmt><decl><type><name>dsa_pointer</name></type> <name>schunks</name></decl>;</decl_stmt>		<comment type="block">/* dsa pointer to chunk array */</comment>
	<decl_stmt><decl><type><name>LWLock</name></type>		<name>lock</name></decl>;</decl_stmt>			<comment type="block">/* lock to protect below members */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>spageptr</name></decl>;</decl_stmt>		<comment type="block">/* next spages index */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>schunkptr</name></decl>;</decl_stmt>		<comment type="block">/* next schunks index */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>schunkbit</name></decl>;</decl_stmt>		<comment type="block">/* next bit to check in current schunk */</comment>
}</block></struct></type> <name>TBMSharedIteratorState</name>;</typedef>

<comment type="block">/*
 * pagetable iteration array.
 */</comment>
<typedef>typedef <type><struct>struct <name>PTIterationArray</name>
<block>{
	<decl_stmt><decl><type><name>pg_atomic_uint32</name></type> <name>refcount</name></decl>;</decl_stmt>	<comment type="block">/* no. of iterator attached */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name><name>index</name><index>[<expr><name>FLEXIBLE_ARRAY_MEMBER</name></expr>]</index></name></decl>;</decl_stmt>	<comment type="block">/* index array */</comment>
}</block></struct></type> <name>PTIterationArray</name>;</typedef>

<comment type="block">/*
 * same as TBMIterator, but it is used for joint iteration, therefore this
 * also holds a reference to the shared state.
 */</comment>
<struct>struct <name>TBMSharedIterator</name>
<block>{
	<decl_stmt><decl><type><name>TBMSharedIteratorState</name> <modifier>*</modifier></type><name>state</name></decl>;</decl_stmt>	<comment type="block">/* shared state */</comment>
	<decl_stmt><decl><type><name>PTEntryArray</name> <modifier>*</modifier></type><name>ptbase</name></decl>;</decl_stmt>		<comment type="block">/* pagetable element array */</comment>
	<decl_stmt><decl><type><name>PTIterationArray</name> <modifier>*</modifier></type><name>ptpages</name></decl>;</decl_stmt>	<comment type="block">/* sorted exact page index list */</comment>
	<decl_stmt><decl><type><name>PTIterationArray</name> <modifier>*</modifier></type><name>ptchunks</name></decl>;</decl_stmt> <comment type="block">/* sorted lossy page index list */</comment>
	<decl_stmt><decl><type><name>TBMIterateResult</name></type> <name>output</name></decl>;</decl_stmt>	<comment type="block">/* MUST BE LAST (because variable-size) */</comment>
}</block>;</struct>

<comment type="block">/* Local function prototypes */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>tbm_union_page</name><parameter_list>(<parameter><decl><type><name>TIDBitmap</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>PagetableEntry</name> <modifier>*</modifier></type><name>bpage</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>tbm_intersect_page</name><parameter_list>(<parameter><decl><type><name>TIDBitmap</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>PagetableEntry</name> <modifier>*</modifier></type><name>apage</name></decl></parameter>,
							   <parameter><decl><type><specifier>const</specifier> <name>TIDBitmap</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>PagetableEntry</name> <modifier>*</modifier></type><name>tbm_find_pageentry</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>TIDBitmap</name> <modifier>*</modifier></type><name>tbm</name></decl></parameter>,
												<parameter><decl><type><name>BlockNumber</name></type> <name>pageno</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>PagetableEntry</name> <modifier>*</modifier></type><name>tbm_get_pageentry</name><parameter_list>(<parameter><decl><type><name>TIDBitmap</name> <modifier>*</modifier></type><name>tbm</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>pageno</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>tbm_page_is_lossy</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>TIDBitmap</name> <modifier>*</modifier></type><name>tbm</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>pageno</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>tbm_mark_page_lossy</name><parameter_list>(<parameter><decl><type><name>TIDBitmap</name> <modifier>*</modifier></type><name>tbm</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>pageno</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>tbm_lossify</name><parameter_list>(<parameter><decl><type><name>TIDBitmap</name> <modifier>*</modifier></type><name>tbm</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>tbm_comparator</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>left</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>right</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>tbm_shared_comparator</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>left</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>right</name></decl></parameter>,
								  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>tbm_stream_set_instrument</name><parameter_list>(<parameter><decl><type><name>StreamNode</name> <modifier>*</modifier></type> <name>self</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>Instrumentation</name></name> <modifier>*</modifier></type><name>instr</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>tbm_stream_upd_instrument</name><parameter_list>(<parameter><decl><type><name>StreamNode</name> <modifier>*</modifier></type> <name>self</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* define hashtable mapping block numbers to PagetableEntry's */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SH_USE_NONDEFAULT_ALLOCATOR</name></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SH_PREFIX</name></cpp:macro> <cpp:value>pagetable</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SH_ELEMENT_TYPE</name></cpp:macro> <cpp:value>PagetableEntry</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SH_KEY_TYPE</name></cpp:macro> <cpp:value>BlockNumber</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SH_KEY</name></cpp:macro> <cpp:value>blockno</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SH_HASH_KEY</name><parameter_list>(<parameter><type><name>tb</name></type></parameter>, <parameter><type><name>key</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>murmurhash32(key)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SH_EQUAL</name><parameter_list>(<parameter><type><name>tb</name></type></parameter>, <parameter><type><name>a</name></type></parameter>, <parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>a == b</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SH_SCOPE</name></cpp:macro> <cpp:value>static inline</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SH_DEFINE</name></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SH_DECLARE</name></cpp:macro></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lib/simplehash.h"</cpp:file></cpp:include>

<function_decl><type><specifier>static</specifier> <name>StreamBMIterator</name> <modifier>*</modifier></type><name>tbm_stream_begin_iterate</name><parameter_list>(<parameter><decl><type><name>StreamNode</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>tbm_stream_end_iterate</name><parameter_list>(<parameter><decl><type><name>StreamBMIterator</name> <modifier>*</modifier></type><name>iterator</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* IndexStream callbacks */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>index_stream_begin_iterate</name><parameter_list>(<parameter><decl><type><name>StreamNode</name> <modifier>*</modifier></type><name>self</name></decl></parameter>, <parameter><decl><type><name>StreamBMIterator</name> <modifier>*</modifier></type><name>iterator</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>tbm_stream_block</name><parameter_list>(<parameter><decl><type><name>StreamBMIterator</name> <modifier>*</modifier></type><name>iterator</name></decl></parameter>, <parameter><decl><type><name>PagetableEntry</name> <modifier>*</modifier></type><name>e</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>index_stream_end_iterate</name><parameter_list>(<parameter><decl><type><name>StreamBMIterator</name> <modifier>*</modifier></type><name>self</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>tbm_stream_free</name><parameter_list>(<parameter><decl><type><name>StreamNode</name> <modifier>*</modifier></type><name>self</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* OpStream callbacks */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>opstream_begin_iterate</name><parameter_list>(<parameter><decl><type><name>StreamNode</name> <modifier>*</modifier></type><name>self</name></decl></parameter>, <parameter><decl><type><name>StreamBMIterator</name> <modifier>*</modifier></type><name>iterator</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>opstream_iterate</name><parameter_list>(<parameter><decl><type><name>StreamBMIterator</name> <modifier>*</modifier></type><name>iterator</name></decl></parameter>, <parameter><decl><type><name>PagetableEntry</name> <modifier>*</modifier></type><name>e</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>opstream_end_iterate</name><parameter_list>(<parameter><decl><type><name>StreamBMIterator</name> <modifier>*</modifier></type><name>self</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>opstream_free</name><parameter_list>(<parameter><decl><type><name>StreamNode</name> <modifier>*</modifier></type><name>self</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * tbm_create - create an initially-empty bitmap
 *
 * The bitmap will live in the memory context that is CurrentMemoryContext
 * at the time of this call.  It will be limited to (approximately) maxbytes
 * total memory consumption.  If the DSA passed to this function is not NULL
 * then the memory for storing elements of the underlying page table will
 * be allocated from the DSA.
 */</comment>
<function><type><name>TIDBitmap</name> <modifier>*</modifier></type>
<name>tbm_create</name><parameter_list>(<parameter><decl><type><name>long</name></type> <name>maxbytes</name></decl></parameter>, <parameter><decl><type><name>dsa_area</name> <modifier>*</modifier></type><name>dsa</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TIDBitmap</name>  <modifier>*</modifier></type><name>tbm</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Ensure that we don't have heap tuple offsets going beyond (INT16_MAX +
	 * 1) or 32768. The executor iterates only over the first 32K tuples for
	 * lossy bitmap pages [MPP-24326].
	 */</comment>
	<expr_stmt><expr><call><name>COMPILE_ASSERT</name><argument_list>(<argument><expr><name>MaxHeapTuplesPerPage</name> <operator>&lt;=</operator> <operator>(</operator><name>INT16_MAX</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Create the TIDBitmap struct and zero all its fields */</comment>
	<expr_stmt><expr><name>tbm</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>TIDBitmap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>tbm</name><operator>-&gt;</operator><name>mcxt</name></name> <operator>=</operator> <name>CurrentMemoryContext</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tbm</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>TBM_EMPTY</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tbm</name><operator>-&gt;</operator><name>instrument</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>tbm</name><operator>-&gt;</operator><name>maxentries</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <call><name>tbm_calculate_entries</name><argument_list>(<argument><expr><name>maxbytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tbm</name><operator>-&gt;</operator><name>lossify_start</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tbm</name><operator>-&gt;</operator><name>dsa</name></name> <operator>=</operator> <name>dsa</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tbm</name><operator>-&gt;</operator><name>dsapagetable</name></name> <operator>=</operator> <name>InvalidDsaPointer</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tbm</name><operator>-&gt;</operator><name>dsapagetableold</name></name> <operator>=</operator> <name>InvalidDsaPointer</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tbm</name><operator>-&gt;</operator><name>ptpages</name></name> <operator>=</operator> <name>InvalidDsaPointer</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tbm</name><operator>-&gt;</operator><name>ptchunks</name></name> <operator>=</operator> <name>InvalidDsaPointer</name></expr>;</expr_stmt>

	<return>return <expr><name>tbm</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Actually create the hashtable.  Since this is a moderately expensive
 * proposition, we don't do it until we have to.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>tbm_create_pagetable</name><parameter_list>(<parameter><decl><type><name>TIDBitmap</name> <modifier>*</modifier></type><name>tbm</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>tbm</name><operator>-&gt;</operator><name>status</name></name> <operator>!=</operator> <name>TBM_HASH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>tbm</name><operator>-&gt;</operator><name>pagetable</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>tbm</name><operator>-&gt;</operator><name>pagetable</name></name> <operator>=</operator> <call><name>pagetable_create</name><argument_list>(<argument><expr><name><name>tbm</name><operator>-&gt;</operator><name>mcxt</name></name></expr></argument>, <argument><expr><literal type="number">128</literal></expr></argument>, <argument><expr><name>tbm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* If entry1 is valid, push it into the hashtable */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>tbm</name><operator>-&gt;</operator><name>status</name></name> <operator>==</operator> <name>TBM_ONE_PAGE</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PagetableEntry</name> <modifier>*</modifier></type><name>page</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name></type>		<name>oldstatus</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>pagetable_insert</name><argument_list>(<argument><expr><name><name>tbm</name><operator>-&gt;</operator><name>pagetable</name></name></expr></argument>,
								<argument><expr><name><name>tbm</name><operator>-&gt;</operator><name>entry1</name><operator>.</operator><name>blockno</name></name></expr></argument>,
								<argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>oldstatus</name> <operator>=</operator> <name><name>page</name><operator>-&gt;</operator><name>status</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tbm</name><operator>-&gt;</operator><name>entry1</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PagetableEntry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>page</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>oldstatus</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>tbm</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>TBM_HASH</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * tbm_free - free a TIDBitmap
 */</comment>
<function><type><name>void</name></type>
<name>tbm_free</name><parameter_list>(<parameter><decl><type><name>TIDBitmap</name> <modifier>*</modifier></type><name>tbm</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>tbm</name><operator>-&gt;</operator><name>instrument</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>tbm_upd_instrument</name><argument_list>(<argument><expr><name>tbm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>tbm</name><operator>-&gt;</operator><name>pagetable</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pagetable_destroy</name><argument_list>(<argument><expr><name><name>tbm</name><operator>-&gt;</operator><name>pagetable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>tbm</name><operator>-&gt;</operator><name>spages</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>tbm</name><operator>-&gt;</operator><name>spages</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>tbm</name><operator>-&gt;</operator><name>schunks</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>tbm</name><operator>-&gt;</operator><name>schunks</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>tbm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * tbm_upd_instrument - Update the Instrumentation attached to a TIDBitmap.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>tbm_upd_instrument</name><parameter_list>(<parameter><decl><type><name>TIDBitmap</name> <modifier>*</modifier></type><name>tbm</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Instrumentation</name> <modifier>*</modifier></type><name>instr</name> <init>= <expr><name><name>tbm</name><operator>-&gt;</operator><name>instrument</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>workmemused</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>instr</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Update page table high-water mark. */</comment>
	<expr_stmt><expr><name><name>tbm</name><operator>-&gt;</operator><name>nentries_hwm</name></name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name><name>tbm</name><operator>-&gt;</operator><name>nentries_hwm</name></name></expr></argument>, <argument><expr><name><name>tbm</name><operator>-&gt;</operator><name>nentries</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* How much of our work_mem quota was actually used? */</comment>
	<expr_stmt><expr><name>workmemused</name> <operator>=</operator> <name><name>tbm</name><operator>-&gt;</operator><name>nentries_hwm</name></name> <operator>*</operator> <name><name>tbm</name><operator>-&gt;</operator><name>bytesperentry</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>instr</name><operator>-&gt;</operator><name>workmemused</name></name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name><name>instr</name><operator>-&gt;</operator><name>workmemused</name></name></expr></argument>, <argument><expr><name>workmemused</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>	<comment type="block">/* tbm_upd_instrument */</comment>


<comment type="block">/*
 * tbm_set_instrument
 *	Attach caller's Instrumentation object to a TIDBitmap, unless the
 *	TIDBitmap already has one.  We want the statistics to be associated
 *	with the plan node which originally created the bitmap, rather than a
 *	downstream consumer of the bitmap.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>tbm_set_instrument</name><parameter_list>(<parameter><decl><type><name>TIDBitmap</name> <modifier>*</modifier></type><name>tbm</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>Instrumentation</name></name> <modifier>*</modifier></type><name>instr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>instr</name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
		<name><name>tbm</name><operator>-&gt;</operator><name>instrument</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>tbm</name><operator>-&gt;</operator><name>instrument</name></name> <operator>=</operator> <name>instr</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>tbm_upd_instrument</name><argument_list>(<argument><expr><name>tbm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>	<comment type="block">/* tbm_set_instrument */</comment>


<comment type="block">/*
 * tbm_free_shared_area - free shared state
 *
 * Free shared iterator state, Also free shared pagetable and iterator arrays
 * memory if they are not referred by any of the shared iterator i.e recount
 * is becomes 0.
 */</comment>
<function><type><name>void</name></type>
<name>tbm_free_shared_area</name><parameter_list>(<parameter><decl><type><name>dsa_area</name> <modifier>*</modifier></type><name>dsa</name></decl></parameter>, <parameter><decl><type><name>dsa_pointer</name></type> <name>dp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TBMSharedIteratorState</name> <modifier>*</modifier></type><name>istate</name> <init>= <expr><call><name>dsa_get_address</name><argument_list>(<argument><expr><name>dsa</name></expr></argument>, <argument><expr><name>dp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PTEntryArray</name> <modifier>*</modifier></type><name>ptbase</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PTIterationArray</name> <modifier>*</modifier></type><name>ptpages</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PTIterationArray</name> <modifier>*</modifier></type><name>ptchunks</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>DsaPointerIsValid</name><argument_list>(<argument><expr><name><name>istate</name><operator>-&gt;</operator><name>pagetable</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>ptbase</name> <operator>=</operator> <call><name>dsa_get_address</name><argument_list>(<argument><expr><name>dsa</name></expr></argument>, <argument><expr><name><name>istate</name><operator>-&gt;</operator><name>pagetable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>pg_atomic_sub_fetch_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ptbase</name><operator>-&gt;</operator><name>refcount</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>dsa_free</name><argument_list>(<argument><expr><name>dsa</name></expr></argument>, <argument><expr><name><name>istate</name><operator>-&gt;</operator><name>pagetable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>DsaPointerIsValid</name><argument_list>(<argument><expr><name><name>istate</name><operator>-&gt;</operator><name>spages</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>ptpages</name> <operator>=</operator> <call><name>dsa_get_address</name><argument_list>(<argument><expr><name>dsa</name></expr></argument>, <argument><expr><name><name>istate</name><operator>-&gt;</operator><name>spages</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>pg_atomic_sub_fetch_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ptpages</name><operator>-&gt;</operator><name>refcount</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>dsa_free</name><argument_list>(<argument><expr><name>dsa</name></expr></argument>, <argument><expr><name><name>istate</name><operator>-&gt;</operator><name>spages</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>DsaPointerIsValid</name><argument_list>(<argument><expr><name><name>istate</name><operator>-&gt;</operator><name>schunks</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>ptchunks</name> <operator>=</operator> <call><name>dsa_get_address</name><argument_list>(<argument><expr><name>dsa</name></expr></argument>, <argument><expr><name><name>istate</name><operator>-&gt;</operator><name>schunks</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>pg_atomic_sub_fetch_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ptchunks</name><operator>-&gt;</operator><name>refcount</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>dsa_free</name><argument_list>(<argument><expr><name>dsa</name></expr></argument>, <argument><expr><name><name>istate</name><operator>-&gt;</operator><name>schunks</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>dsa_free</name><argument_list>(<argument><expr><name>dsa</name></expr></argument>, <argument><expr><name>dp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * tbm_add_tuples - add some tuple IDs to a TIDBitmap
 */</comment>
<function><type><name>void</name></type>
<name>tbm_add_tuples</name><parameter_list>(<parameter><decl><type><name>TIDBitmap</name> <modifier>*</modifier></type><name>tbm</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ItemPointer</name></type> <name>tids</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ntids</name></decl></parameter>,
			   <parameter><decl><type><name>bool</name></type> <name>recheck</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>currblk</name> <init>= <expr><name>InvalidBlockNumber</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PagetableEntry</name> <modifier>*</modifier></type><name>page</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>	<comment type="block">/* only valid when currblk is valid */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>tbm</name><operator>-&gt;</operator><name>iterating</name></name> <operator>==</operator> <name>TBM_NOT_ITERATING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ntids</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>BlockNumber</name></type> <name>blk</name> <init>= <expr><call><name>ItemPointerGetBlockNumber</name><argument_list>(<argument><expr><name>tids</name> <operator>+</operator> <name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>off</name> <init>= <expr><call><name>ItemPointerGetOffsetNumber</name><argument_list>(<argument><expr><name>tids</name> <operator>+</operator> <name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>wordnum</name></decl>,
					<decl><type ref="prev"/><name>bitnum</name></decl>;</decl_stmt>

		<comment type="block">/* safety check to ensure we don't overrun bit array bounds */</comment>

		<comment type="block">/* UNDONE: Turn this off until we convert this module to AO TIDs. */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
		if (off &lt; 1 || off &gt; MAX_TUPLES_PER_PAGE)
			elog(ERROR, "tuple offset out of range: %u", off);
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

		<comment type="block">/*
		 * Look up target page unless we already did.  This saves cycles when
		 * the input includes consecutive tuples on the same page, which is
		 * common enough to justify an extra test here.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>blk</name> <operator>!=</operator> <name>currblk</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>tbm_page_is_lossy</name><argument_list>(<argument><expr><name>tbm</name></expr></argument>, <argument><expr><name>blk</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>page</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>	<comment type="block">/* remember page is lossy */</comment>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>tbm_get_pageentry</name><argument_list>(<argument><expr><name>tbm</name></expr></argument>, <argument><expr><name>blk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<expr_stmt><expr><name>currblk</name> <operator>=</operator> <name>blk</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>page</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>			<comment type="block">/* whole page is already marked */</comment>

		<if_stmt><if>if <condition>(<expr><name><name>page</name><operator>-&gt;</operator><name>ischunk</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* The page is a lossy chunk header, set bit for itself */</comment>
			<expr_stmt><expr><name>wordnum</name> <operator>=</operator> <name>bitnum</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* Page is exact, so set bit for individual tuple */</comment>
			<expr_stmt><expr><name>wordnum</name> <operator>=</operator> <call><name>WORDNUM</name><argument_list>(<argument><expr><name>off</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>bitnum</name> <operator>=</operator> <call><name>BITNUM</name><argument_list>(<argument><expr><name>off</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><name><name>page</name><operator>-&gt;</operator><name>words</name><index>[<expr><name>wordnum</name></expr>]</index></name> <operator>|=</operator> <operator>(</operator><operator>(</operator><name>tbm_bitmapword</name><operator>)</operator> <literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>bitnum</name><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>page</name><operator>-&gt;</operator><name>recheck</name></name> <operator>|=</operator> <name>recheck</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>tbm</name><operator>-&gt;</operator><name>nentries</name></name> <operator>&gt;</operator> <name><name>tbm</name><operator>-&gt;</operator><name>maxentries</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>tbm_lossify</name><argument_list>(<argument><expr><name>tbm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Page could have been converted to lossy, so force new lookup */</comment>
			<expr_stmt><expr><name>currblk</name> <operator>=</operator> <name>InvalidBlockNumber</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * tbm_add_page - add a whole page to a TIDBitmap
 *
 * This causes the whole page to be reported (with the recheck flag)
 * when the TIDBitmap is scanned.
 */</comment>
<function><type><name>void</name></type>
<name>tbm_add_page</name><parameter_list>(<parameter><decl><type><name>TIDBitmap</name> <modifier>*</modifier></type><name>tbm</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>pageno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Enter the page in the bitmap, or mark it lossy if already present */</comment>
	<expr_stmt><expr><call><name>tbm_mark_page_lossy</name><argument_list>(<argument><expr><name>tbm</name></expr></argument>, <argument><expr><name>pageno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* If we went over the memory limit, lossify some more pages */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>tbm</name><operator>-&gt;</operator><name>nentries</name></name> <operator>&gt;</operator> <name><name>tbm</name><operator>-&gt;</operator><name>maxentries</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>tbm_lossify</name><argument_list>(<argument><expr><name>tbm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * tbm_union - set union
 *
 * a is modified in-place, b is not changed
 */</comment>
<function><type><name>void</name></type>
<name>tbm_union</name><parameter_list>(<parameter><decl><type><name>TIDBitmap</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>TIDBitmap</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>a</name><operator>-&gt;</operator><name>iterating</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Nothing to do if b is empty */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>b</name><operator>-&gt;</operator><name>nentries</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>
	<comment type="block">/* Scan through chunks and pages in b, merge into a */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>b</name><operator>-&gt;</operator><name>status</name></name> <operator>==</operator> <name>TBM_ONE_PAGE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>tbm_union_page</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>b</name><operator>-&gt;</operator><name>entry1</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>pagetable_iterator</name></type> <name>i</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PagetableEntry</name> <modifier>*</modifier></type><name>bpage</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>b</name><operator>-&gt;</operator><name>status</name></name> <operator>==</operator> <name>TBM_HASH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pagetable_start_iterate</name><argument_list>(<argument><expr><name><name>b</name><operator>-&gt;</operator><name>pagetable</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<while>while <condition>(<expr><operator>(</operator><name>bpage</name> <operator>=</operator> <call><name>pagetable_iterate</name><argument_list>(<argument><expr><name><name>b</name><operator>-&gt;</operator><name>pagetable</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>i</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>tbm_union_page</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>bpage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Process one page of b during a union op */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>tbm_union_page</name><parameter_list>(<parameter><decl><type><name>TIDBitmap</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>PagetableEntry</name> <modifier>*</modifier></type><name>bpage</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PagetableEntry</name> <modifier>*</modifier></type><name>apage</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>wordnum</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>bpage</name><operator>-&gt;</operator><name>ischunk</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Scan b's chunk, mark each indicated page lossy in a */</comment>
		<for>for <control>(<init><expr><name>wordnum</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>wordnum</name> <operator>&lt;</operator> <name>WORDS_PER_CHUNK</name></expr>;</condition> <incr><expr><name>wordnum</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>tbm_bitmapword</name></type> <name>w</name> <init>= <expr><name><name>bpage</name><operator>-&gt;</operator><name>words</name><index>[<expr><name>wordnum</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>w</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>BlockNumber</name></type> <name>pg</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>pg</name> <operator>=</operator> <name><name>bpage</name><operator>-&gt;</operator><name>blockno</name></name> <operator>+</operator> <operator>(</operator><name>wordnum</name> <operator>*</operator> <name>TBM_BITS_PER_BITMAPWORD</name><operator>)</operator></expr>;</expr_stmt>
				<while>while <condition>(<expr><name>w</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name>w</name> <operator>&amp;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>tbm_mark_page_lossy</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>pg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<expr_stmt><expr><name>pg</name><operator>++</operator></expr>;</expr_stmt>
					<expr_stmt><expr><name>w</name> <operator>&gt;&gt;=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
				</block_content>}</block></while>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>tbm_page_is_lossy</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name><name>bpage</name><operator>-&gt;</operator><name>blockno</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* page is already lossy in a, nothing to do */</comment>
		<return>return;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>apage</name> <operator>=</operator> <call><name>tbm_get_pageentry</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name><name>bpage</name><operator>-&gt;</operator><name>blockno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>apage</name><operator>-&gt;</operator><name>ischunk</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* The page is a lossy chunk header, set bit for itself */</comment>
			<expr_stmt><expr><name><name>apage</name><operator>-&gt;</operator><name>words</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>|=</operator> <operator>(</operator><operator>(</operator><name>tbm_bitmapword</name><operator>)</operator> <literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* Both pages are exact, merge at the bit level */</comment>
			<for>for <control>(<init><expr><name>wordnum</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>wordnum</name> <operator>&lt;</operator> <name>WORDS_PER_PAGE</name></expr>;</condition> <incr><expr><name>wordnum</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>apage</name><operator>-&gt;</operator><name>words</name><index>[<expr><name>wordnum</name></expr>]</index></name> <operator>|=</operator> <name><name>bpage</name><operator>-&gt;</operator><name>words</name><index>[<expr><name>wordnum</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>
			<expr_stmt><expr><name><name>apage</name><operator>-&gt;</operator><name>recheck</name></name> <operator>|=</operator> <name><name>bpage</name><operator>-&gt;</operator><name>recheck</name></name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>nentries</name></name> <operator>&gt;</operator> <name><name>a</name><operator>-&gt;</operator><name>maxentries</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>tbm_lossify</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * tbm_intersect - set intersection
 *
 * a is modified in-place, b is not changed
 */</comment>
<function><type><name>void</name></type>
<name>tbm_intersect</name><parameter_list>(<parameter><decl><type><name>TIDBitmap</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>TIDBitmap</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>a</name><operator>-&gt;</operator><name>iterating</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Nothing to do if a is empty */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>nentries</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>a</name><operator>-&gt;</operator><name>nentries_hwm</name></name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name><name>a</name><operator>-&gt;</operator><name>nentries_hwm</name></name></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>nentries</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Scan through chunks and pages in a, try to match to b */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>status</name></name> <operator>==</operator> <name>TBM_ONE_PAGE</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>tbm_intersect_page</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>entry1</name></name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Page is now empty, remove it from a */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>a</name><operator>-&gt;</operator><name>entry1</name><operator>.</operator><name>ischunk</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>a</name><operator>-&gt;</operator><name>npages</name></name><operator>--</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>a</name><operator>-&gt;</operator><name>nentries</name></name><operator>--</operator></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>a</name><operator>-&gt;</operator><name>nentries</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>a</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>TBM_EMPTY</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>pagetable_iterator</name></type> <name>i</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PagetableEntry</name> <modifier>*</modifier></type><name>apage</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>a</name><operator>-&gt;</operator><name>status</name></name> <operator>==</operator> <name>TBM_HASH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pagetable_start_iterate</name><argument_list>(<argument><expr><name><name>a</name><operator>-&gt;</operator><name>pagetable</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<while>while <condition>(<expr><operator>(</operator><name>apage</name> <operator>=</operator> <call><name>pagetable_iterate</name><argument_list>(<argument><expr><name><name>a</name><operator>-&gt;</operator><name>pagetable</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>i</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>tbm_intersect_page</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>apage</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Page or chunk is now empty, remove it from a */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>apage</name><operator>-&gt;</operator><name>ischunk</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>a</name><operator>-&gt;</operator><name>nchunks</name></name><operator>--</operator></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>a</name><operator>-&gt;</operator><name>npages</name></name><operator>--</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>
				<expr_stmt><expr><name><name>a</name><operator>-&gt;</operator><name>nentries</name></name><operator>--</operator></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pagetable_delete</name><argument_list>(<argument><expr><name><name>a</name><operator>-&gt;</operator><name>pagetable</name></name></expr></argument>, <argument><expr><name><name>apage</name><operator>-&gt;</operator><name>blockno</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"hash table corrupted"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></while>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Process one page of a during an intersection op
 *
 * Returns true if apage is now empty and should be deleted from a
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>tbm_intersect_page</name><parameter_list>(<parameter><decl><type><name>TIDBitmap</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>PagetableEntry</name> <modifier>*</modifier></type><name>apage</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>TIDBitmap</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>PagetableEntry</name> <modifier>*</modifier></type><name>bpage</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>wordnum</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>apage</name><operator>-&gt;</operator><name>ischunk</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Scan each bit in chunk, try to clear */</comment>
		<decl_stmt><decl><type><name>bool</name></type>		<name>candelete</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>wordnum</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>wordnum</name> <operator>&lt;</operator> <name>WORDS_PER_CHUNK</name></expr>;</condition> <incr><expr><name>wordnum</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>tbm_bitmapword</name></type> <name>w</name> <init>= <expr><name><name>apage</name><operator>-&gt;</operator><name>words</name><index>[<expr><name>wordnum</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>w</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>tbm_bitmapword</name></type> <name>neww</name> <init>= <expr><name>w</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>BlockNumber</name></type> <name>pg</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int</name></type>			<name>bitnum</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>pg</name> <operator>=</operator> <name><name>apage</name><operator>-&gt;</operator><name>blockno</name></name> <operator>+</operator> <operator>(</operator><name>wordnum</name> <operator>*</operator> <name>TBM_BITS_PER_BITMAPWORD</name><operator>)</operator></expr>;</expr_stmt>
				<expr_stmt><expr><name>bitnum</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				<while>while <condition>(<expr><name>w</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name>w</name> <operator>&amp;</operator> <literal type="number">1</literal></expr>)</condition>
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>tbm_page_is_lossy</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>pg</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
							<call><name>tbm_find_pageentry</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>pg</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition>
						<block>{<block_content>
							<comment type="block">/* Page is not in b at all, lose lossy bit */</comment>
							<expr_stmt><expr><name>neww</name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><operator>(</operator><name>tbm_bitmapword</name><operator>)</operator> <literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>bitnum</name><operator>)</operator></expr>;</expr_stmt>
						</block_content>}</block></if></if_stmt>
					</block_content>}</block></if></if_stmt>
					<expr_stmt><expr><name>pg</name><operator>++</operator></expr>;</expr_stmt>
					<expr_stmt><expr><name>bitnum</name><operator>++</operator></expr>;</expr_stmt>
					<expr_stmt><expr><name>w</name> <operator>&gt;&gt;=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
				</block_content>}</block></while>
				<expr_stmt><expr><name><name>apage</name><operator>-&gt;</operator><name>words</name><index>[<expr><name>wordnum</name></expr>]</index></name> <operator>=</operator> <name>neww</name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>neww</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>candelete</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
		<return>return <expr><name>candelete</name></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>tbm_page_is_lossy</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name><name>apage</name><operator>-&gt;</operator><name>blockno</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Some of the tuples in 'a' might not satisfy the quals for 'b', but
		 * because the page 'b' is lossy, we don't know which ones. Therefore
		 * we mark 'a' as requiring rechecks, to indicate that at most those
		 * tuples set in 'a' are matches.
		 */</comment>
		<expr_stmt><expr><name><name>apage</name><operator>-&gt;</operator><name>recheck</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type>		<name>candelete</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>bpage</name> <operator>=</operator> <call><name>tbm_find_pageentry</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name><name>apage</name><operator>-&gt;</operator><name>blockno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>bpage</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Both pages are exact, merge at the bit level */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>bpage</name><operator>-&gt;</operator><name>ischunk</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<for>for <control>(<init><expr><name>wordnum</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>wordnum</name> <operator>&lt;</operator> <name>WORDS_PER_PAGE</name></expr>;</condition> <incr><expr><name>wordnum</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<expr_stmt><expr><name><name>apage</name><operator>-&gt;</operator><name>words</name><index>[<expr><name>wordnum</name></expr>]</index></name> <operator>&amp;=</operator> <name><name>bpage</name><operator>-&gt;</operator><name>words</name><index>[<expr><name>wordnum</name></expr>]</index></name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>apage</name><operator>-&gt;</operator><name>words</name><index>[<expr><name>wordnum</name></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>candelete</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></for>
			<expr_stmt><expr><name><name>apage</name><operator>-&gt;</operator><name>recheck</name></name> <operator>|=</operator> <name><name>bpage</name><operator>-&gt;</operator><name>recheck</name></name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* If there is no matching b page, we can just delete the a page */</comment>
		<return>return <expr><name>candelete</name></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * tbm_is_empty - is a TIDBitmap completely empty?
 */</comment>
<function><type><name>bool</name></type>
<name>tbm_is_empty</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>TIDBitmap</name> <modifier>*</modifier></type><name>tbm</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><operator>(</operator><name><name>tbm</name><operator>-&gt;</operator><name>nentries</name></name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * tbm_begin_iterate - prepare to iterate through a TIDBitmap
 *
 * The TBMIterator struct is created in the caller's memory context.
 * For a clean shutdown of the iteration, call tbm_end_iterate; but it's
 * okay to just allow the memory context to be released, too.  It is caller's
 * responsibility not to touch the TBMIterator anymore once the TIDBitmap
 * is freed.
 *
 * NB: after this is called, it is no longer allowed to modify the contents
 * of the bitmap.  However, you can call this multiple times to scan the
 * contents repeatedly, including parallel scans.
 */</comment>
<function><type><name>TBMIterator</name> <modifier>*</modifier></type>
<name>tbm_begin_iterate</name><parameter_list>(<parameter><decl><type><name>TIDBitmap</name> <modifier>*</modifier></type><name>tbm</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TBMIterator</name> <modifier>*</modifier></type><name>iterator</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>tbm</name><operator>-&gt;</operator><name>iterating</name></name> <operator>!=</operator> <name>TBM_ITERATING_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Create the TBMIterator struct, with enough trailing space to serve the
	 * needs of the TBMIterateResult sub-struct.
	 */</comment>
	<expr_stmt><expr><name>iterator</name> <operator>=</operator> <operator>(</operator><name>TBMIterator</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TBMIterator</name></expr></argument>)</argument_list></sizeof> <operator>+</operator>
									  <name>MAX_TUPLES_PER_PAGE</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>OffsetNumber</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>iterator</name><operator>-&gt;</operator><name>tbm</name></name> <operator>=</operator> <name>tbm</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Initialize iteration pointers.
	 */</comment>
	<expr_stmt><expr><name><name>iterator</name><operator>-&gt;</operator><name>spageptr</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>iterator</name><operator>-&gt;</operator><name>schunkptr</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>iterator</name><operator>-&gt;</operator><name>schunkbit</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * If we have a hashtable, create and fill the sorted page lists, unless
	 * we already did that for a previous iterator.  Note that the lists are
	 * attached to the bitmap not the iterator, so they can be used by more
	 * than one iterator.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>tbm</name><operator>-&gt;</operator><name>status</name></name> <operator>==</operator> <name>TBM_HASH</name> <operator>&amp;&amp;</operator> <name><name>tbm</name><operator>-&gt;</operator><name>iterating</name></name> <operator>==</operator> <name>TBM_NOT_ITERATING</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>pagetable_iterator</name></type> <name>i</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PagetableEntry</name> <modifier>*</modifier></type><name>page</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>npages</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>nchunks</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>tbm</name><operator>-&gt;</operator><name>spages</name></name> <operator>&amp;&amp;</operator> <name><name>tbm</name><operator>-&gt;</operator><name>npages</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>tbm</name><operator>-&gt;</operator><name>spages</name></name> <operator>=</operator> <operator>(</operator><name>PagetableEntry</name> <operator>*</operator><operator>*</operator><operator>)</operator>
				<call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name><name>tbm</name><operator>-&gt;</operator><name>mcxt</name></name></expr></argument>,
								   <argument><expr><name><name>tbm</name><operator>-&gt;</operator><name>npages</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PagetableEntry</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>tbm</name><operator>-&gt;</operator><name>schunks</name></name> <operator>&amp;&amp;</operator> <name><name>tbm</name><operator>-&gt;</operator><name>nchunks</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>tbm</name><operator>-&gt;</operator><name>schunks</name></name> <operator>=</operator> <operator>(</operator><name>PagetableEntry</name> <operator>*</operator><operator>*</operator><operator>)</operator>
				<call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name><name>tbm</name><operator>-&gt;</operator><name>mcxt</name></name></expr></argument>,
								   <argument><expr><name><name>tbm</name><operator>-&gt;</operator><name>nchunks</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PagetableEntry</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>npages</name> <operator>=</operator> <name>nchunks</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pagetable_start_iterate</name><argument_list>(<argument><expr><name><name>tbm</name><operator>-&gt;</operator><name>pagetable</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<while>while <condition>(<expr><operator>(</operator><name>page</name> <operator>=</operator> <call><name>pagetable_iterate</name><argument_list>(<argument><expr><name><name>tbm</name><operator>-&gt;</operator><name>pagetable</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>i</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>page</name><operator>-&gt;</operator><name>ischunk</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>tbm</name><operator>-&gt;</operator><name>schunks</name><index>[<expr><name>nchunks</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>page</name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>tbm</name><operator>-&gt;</operator><name>spages</name><index>[<expr><name>npages</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>page</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></while>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>npages</name> <operator>==</operator> <name><name>tbm</name><operator>-&gt;</operator><name>npages</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nchunks</name> <operator>==</operator> <name><name>tbm</name><operator>-&gt;</operator><name>nchunks</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>npages</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><name><name>tbm</name><operator>-&gt;</operator><name>spages</name></name></expr></argument>, <argument><expr><name>npages</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PagetableEntry</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>,
				  <argument><expr><name>tbm_comparator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>nchunks</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><name><name>tbm</name><operator>-&gt;</operator><name>schunks</name></name></expr></argument>, <argument><expr><name>nchunks</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PagetableEntry</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>,
				  <argument><expr><name>tbm_comparator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>tbm</name><operator>-&gt;</operator><name>iterating</name></name> <operator>=</operator> <name>TBM_ITERATING_PRIVATE</name></expr>;</expr_stmt>

	<return>return <expr><name>iterator</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * tbm_stream_begin_iterate - prepare to iterate through a StreamBitmap
 */</comment>
<function><type><specifier>static</specifier> <name>StreamBMIterator</name> <modifier>*</modifier></type>
<name>tbm_stream_begin_iterate</name><parameter_list>(<parameter><decl><type><name>StreamNode</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Create the StreamBMIterator struct, with enough trailing space to serve
	 * the needs of the TBMIterateResult sub-struct.
	 */</comment>
	<decl_stmt><decl><type><name>StreamBMIterator</name> <modifier>*</modifier></type><name>iterator</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>StreamBMIterator</name></expr></argument>)</argument_list></sizeof> <operator>+</operator>
								 <name>MAX_TUPLES_PER_PAGE</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>OffsetNumber</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>iterator</name><operator>-&gt;</operator><name>node</name></name> <operator>=</operator> <name>node</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name><name>node</name><operator>-&gt;</operator><name>begin_iterate</name></name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>iterator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>iterator</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * tbm_generic_begin_iterate - prepare to iterate through either a TIDBitmap or
 * a StreamBitmap
 *
 * The GenericBMIterator struct is created in the caller's memory context.
 * For a clean shutdown of the iteration, call tbm_generic_end_iterate.
 * It is caller's responsibility not to touch the iterator anymore once the
 * Node passed to this function is freed.
 *
 * Similarly to tbm_begin_iterate, after this is called, it is no longer allowed
 * to modify the contents of the bitmap.  However, you can call this multiple
 * times to scan the contents repeatedly, including parallel scans.
 */</comment>
<function><type><name>GenericBMIterator</name> <modifier>*</modifier></type>
<name>tbm_generic_begin_iterate</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>bm</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>GenericBMIterator</name> <modifier>*</modifier></type><name>iterator</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>bm</name></expr></argument>, <argument><expr><name>TIDBitmap</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>bm</name></expr></argument>, <argument><expr><name>StreamBitmap</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Allocate space. */</comment>
	<expr_stmt><expr><name>iterator</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>iterator</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>iterator</name><operator>-&gt;</operator><name>bm</name></name> <operator>=</operator> <name>bm</name></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><name><name>bm</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>T_TIDBitmap</name></expr>:</case>
			<expr_stmt><expr><name><name>iterator</name><operator>-&gt;</operator><name>impl</name><operator>.</operator><name>hash</name></name> <operator>=</operator> <call><name>tbm_begin_iterate</name><argument_list>(<argument><expr><operator>(</operator><name>TIDBitmap</name> <operator>*</operator><operator>)</operator> <name>bm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_StreamBitmap</name></expr>:</case>
		<block>{<block_content>
			<decl_stmt><decl><type><name>StreamBitmap</name> <modifier>*</modifier></type><name>sbm</name> <init>= <expr><operator>(</operator><name>StreamBitmap</name> <operator>*</operator><operator>)</operator> <name>bm</name></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name><name>iterator</name><operator>-&gt;</operator><name>impl</name><operator>.</operator><name>stream</name></name> <operator>=</operator> <call><name>tbm_stream_begin_iterate</name><argument_list>(<argument><expr><name><name>sbm</name><operator>-&gt;</operator><name>streamNode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block>

		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid node type"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>

	<return>return <expr><name>iterator</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * tbm_generic_iterate - scan through next page of a TIDBitmap or a
 * StreamBitmap.
 */</comment>
<function><type><name>TBMIterateResult</name> <modifier>*</modifier></type>
<name>tbm_generic_iterate</name><parameter_list>(<parameter><decl><type><name>GenericBMIterator</name> <modifier>*</modifier></type><name>iterator</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>Node</name> <modifier>*</modifier></type><name>tbm</name> <init>= <expr><name><name>iterator</name><operator>-&gt;</operator><name>bm</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>tbm</name></expr></argument>, <argument><expr><name>TIDBitmap</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>tbm</name></expr></argument>, <argument><expr><name>StreamBitmap</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><name><name>tbm</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>T_TIDBitmap</name></expr>:</case>
			<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ASSERT_CHECKING</name></cpp:ifdef>
				<decl_stmt><decl><type><specifier>const</specifier> <name>TIDBitmap</name> <modifier>*</modifier></type><name>hashBitmap</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>TIDBitmap</name> <operator>*</operator><operator>)</operator> <name>tbm</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
				<decl_stmt><decl><type><name>TBMIterator</name> <modifier>*</modifier></type><name>hashIterator</name> <init>= <expr><name><name>iterator</name><operator>-&gt;</operator><name>impl</name><operator>.</operator><name>hash</name></name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>hashIterator</name><operator>-&gt;</operator><name>tbm</name></name> <operator>==</operator> <name>hashBitmap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>hashBitmap</name><operator>-&gt;</operator><name>iterating</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<return>return <expr><call><name>tbm_iterate</name><argument_list>(<argument><expr><name>hashIterator</name></expr></argument>)</argument_list></call></expr>;</return>
			</block_content>}</block>
		<case>case <expr><name>T_StreamBitmap</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>StreamBMIterator</name> <modifier>*</modifier></type><name>streamIterator</name> <init>= <expr><name><name>iterator</name><operator>-&gt;</operator><name>impl</name><operator>.</operator><name>stream</name></name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>TBMIterateResult</name> <modifier>*</modifier></type><name>output</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>streamIterator</name><operator>-&gt;</operator><name>entry</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PagetableEntry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><call><name><name>streamIterator</name><operator>-&gt;</operator><name>pull</name></name><argument_list>(<argument><expr><name>streamIterator</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>streamIterator</name><operator>-&gt;</operator><name>entry</name></name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>output</name> <operator>=</operator> <operator>&amp;</operator><name><name>streamIterator</name><operator>-&gt;</operator><name>output</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>tbm_iterate_page</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>streamIterator</name><operator>-&gt;</operator><name>entry</name></name></expr></argument>, <argument><expr><name>output</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<return>return <expr><name>output</name></expr>;</return>
			</block_content>}</block>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecoganized node type"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>

	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * tbm_prepare_shared_iterate - prepare shared iteration state for a TIDBitmap.
 *
 * The necessary shared state will be allocated from the DSA passed to
 * tbm_create, so that multiple processes can attach to it and iterate jointly.
 *
 * This will convert the pagetable hash into page and chunk array of the index
 * into pagetable array.
 */</comment>
<function><type><name>dsa_pointer</name></type>
<name>tbm_prepare_shared_iterate</name><parameter_list>(<parameter><decl><type><name>TIDBitmap</name> <modifier>*</modifier></type><name>tbm</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>dsa_pointer</name></type> <name>dp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TBMSharedIteratorState</name> <modifier>*</modifier></type><name>istate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PTEntryArray</name> <modifier>*</modifier></type><name>ptbase</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PTIterationArray</name> <modifier>*</modifier></type><name>ptpages</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PTIterationArray</name> <modifier>*</modifier></type><name>ptchunks</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>tbm</name><operator>-&gt;</operator><name>dsa</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>tbm</name><operator>-&gt;</operator><name>iterating</name></name> <operator>!=</operator> <name>TBM_ITERATING_PRIVATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Allocate TBMSharedIteratorState from DSA to hold the shared members and
	 * lock, this will also be used by multiple worker for shared iterate.
	 */</comment>
	<expr_stmt><expr><name>dp</name> <operator>=</operator> <call><name>dsa_allocate0</name><argument_list>(<argument><expr><name><name>tbm</name><operator>-&gt;</operator><name>dsa</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TBMSharedIteratorState</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>istate</name> <operator>=</operator> <call><name>dsa_get_address</name><argument_list>(<argument><expr><name><name>tbm</name><operator>-&gt;</operator><name>dsa</name></name></expr></argument>, <argument><expr><name>dp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If we're not already iterating, create and fill the sorted page lists.
	 * (If we are, the sorted page lists are already stored in the TIDBitmap,
	 * and we can just reuse them.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>tbm</name><operator>-&gt;</operator><name>iterating</name></name> <operator>==</operator> <name>TBM_NOT_ITERATING</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>pagetable_iterator</name></type> <name>i</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PagetableEntry</name> <modifier>*</modifier></type><name>page</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>idx</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>npages</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>nchunks</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Allocate the page and chunk array memory from the DSA to share
		 * across multiple processes.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>tbm</name><operator>-&gt;</operator><name>npages</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>tbm</name><operator>-&gt;</operator><name>ptpages</name></name> <operator>=</operator> <call><name>dsa_allocate</name><argument_list>(<argument><expr><name><name>tbm</name><operator>-&gt;</operator><name>dsa</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PTIterationArray</name></expr></argument>)</argument_list></sizeof> <operator>+</operator>
										<name><name>tbm</name><operator>-&gt;</operator><name>npages</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>ptpages</name> <operator>=</operator> <call><name>dsa_get_address</name><argument_list>(<argument><expr><name><name>tbm</name><operator>-&gt;</operator><name>dsa</name></name></expr></argument>, <argument><expr><name><name>tbm</name><operator>-&gt;</operator><name>ptpages</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pg_atomic_init_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ptpages</name><operator>-&gt;</operator><name>refcount</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>tbm</name><operator>-&gt;</operator><name>nchunks</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>tbm</name><operator>-&gt;</operator><name>ptchunks</name></name> <operator>=</operator> <call><name>dsa_allocate</name><argument_list>(<argument><expr><name><name>tbm</name><operator>-&gt;</operator><name>dsa</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PTIterationArray</name></expr></argument>)</argument_list></sizeof> <operator>+</operator>
										 <name><name>tbm</name><operator>-&gt;</operator><name>nchunks</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>ptchunks</name> <operator>=</operator> <call><name>dsa_get_address</name><argument_list>(<argument><expr><name><name>tbm</name><operator>-&gt;</operator><name>dsa</name></name></expr></argument>, <argument><expr><name><name>tbm</name><operator>-&gt;</operator><name>ptchunks</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pg_atomic_init_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ptchunks</name><operator>-&gt;</operator><name>refcount</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * If TBM status is TBM_HASH then iterate over the pagetable and
		 * convert it to page and chunk arrays.  But if it's in the
		 * TBM_ONE_PAGE mode then directly allocate the space for one entry
		 * from the DSA.
		 */</comment>
		<expr_stmt><expr><name>npages</name> <operator>=</operator> <name>nchunks</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>tbm</name><operator>-&gt;</operator><name>status</name></name> <operator>==</operator> <name>TBM_HASH</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>ptbase</name> <operator>=</operator> <call><name>dsa_get_address</name><argument_list>(<argument><expr><name><name>tbm</name><operator>-&gt;</operator><name>dsa</name></name></expr></argument>, <argument><expr><name><name>tbm</name><operator>-&gt;</operator><name>dsapagetable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>pagetable_start_iterate</name><argument_list>(<argument><expr><name><name>tbm</name><operator>-&gt;</operator><name>pagetable</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<while>while <condition>(<expr><operator>(</operator><name>page</name> <operator>=</operator> <call><name>pagetable_iterate</name><argument_list>(<argument><expr><name><name>tbm</name><operator>-&gt;</operator><name>pagetable</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>i</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>idx</name> <operator>=</operator> <name>page</name> <operator>-</operator> <name><name>ptbase</name><operator>-&gt;</operator><name>ptentry</name></name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>page</name><operator>-&gt;</operator><name>ischunk</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>ptchunks</name><operator>-&gt;</operator><name>index</name><index>[<expr><name>nchunks</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>idx</name></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>ptpages</name><operator>-&gt;</operator><name>index</name><index>[<expr><name>npages</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>idx</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block></while>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>npages</name> <operator>==</operator> <name><name>tbm</name><operator>-&gt;</operator><name>npages</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nchunks</name> <operator>==</operator> <name><name>tbm</name><operator>-&gt;</operator><name>nchunks</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>tbm</name><operator>-&gt;</operator><name>status</name></name> <operator>==</operator> <name>TBM_ONE_PAGE</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * In one page mode allocate the space for one pagetable entry,
			 * initialize it, and directly store its index (i.e. 0) in the
			 * page array.
			 */</comment>
			<expr_stmt><expr><name><name>tbm</name><operator>-&gt;</operator><name>dsapagetable</name></name> <operator>=</operator> <call><name>dsa_allocate</name><argument_list>(<argument><expr><name><name>tbm</name><operator>-&gt;</operator><name>dsa</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PTEntryArray</name></expr></argument>)</argument_list></sizeof> <operator>+</operator>
											 <sizeof>sizeof<argument_list>(<argument><expr><name>PagetableEntry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>ptbase</name> <operator>=</operator> <call><name>dsa_get_address</name><argument_list>(<argument><expr><name><name>tbm</name><operator>-&gt;</operator><name>dsa</name></name></expr></argument>, <argument><expr><name><name>tbm</name><operator>-&gt;</operator><name>dsapagetable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>ptbase</name><operator>-&gt;</operator><name>ptentry</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tbm</name><operator>-&gt;</operator><name>entry1</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PagetableEntry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>ptpages</name><operator>-&gt;</operator><name>index</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>ptbase</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pg_atomic_init_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ptbase</name><operator>-&gt;</operator><name>refcount</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>npages</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>qsort_arg</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name><name>ptpages</name><operator>-&gt;</operator><name>index</name></name><operator>)</operator></expr></argument>, <argument><expr><name>npages</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>,
					  <argument><expr><name>tbm_shared_comparator</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name><name>ptbase</name><operator>-&gt;</operator><name>ptentry</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>nchunks</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>qsort_arg</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name><name>ptchunks</name><operator>-&gt;</operator><name>index</name></name><operator>)</operator></expr></argument>, <argument><expr><name>nchunks</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>,
					  <argument><expr><name>tbm_shared_comparator</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name><name>ptbase</name><operator>-&gt;</operator><name>ptentry</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Store the TBM members in the shared state so that we can share them
	 * across multiple processes.
	 */</comment>
	<expr_stmt><expr><name><name>istate</name><operator>-&gt;</operator><name>nentries</name></name> <operator>=</operator> <name><name>tbm</name><operator>-&gt;</operator><name>nentries</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>istate</name><operator>-&gt;</operator><name>maxentries</name></name> <operator>=</operator> <name><name>tbm</name><operator>-&gt;</operator><name>maxentries</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>istate</name><operator>-&gt;</operator><name>npages</name></name> <operator>=</operator> <name><name>tbm</name><operator>-&gt;</operator><name>npages</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>istate</name><operator>-&gt;</operator><name>nchunks</name></name> <operator>=</operator> <name><name>tbm</name><operator>-&gt;</operator><name>nchunks</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>istate</name><operator>-&gt;</operator><name>pagetable</name></name> <operator>=</operator> <name><name>tbm</name><operator>-&gt;</operator><name>dsapagetable</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>istate</name><operator>-&gt;</operator><name>spages</name></name> <operator>=</operator> <name><name>tbm</name><operator>-&gt;</operator><name>ptpages</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>istate</name><operator>-&gt;</operator><name>schunks</name></name> <operator>=</operator> <name><name>tbm</name><operator>-&gt;</operator><name>ptchunks</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name>ptbase</name> <operator>=</operator> <call><name>dsa_get_address</name><argument_list>(<argument><expr><name><name>tbm</name><operator>-&gt;</operator><name>dsa</name></name></expr></argument>, <argument><expr><name><name>tbm</name><operator>-&gt;</operator><name>dsapagetable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ptpages</name> <operator>=</operator> <call><name>dsa_get_address</name><argument_list>(<argument><expr><name><name>tbm</name><operator>-&gt;</operator><name>dsa</name></name></expr></argument>, <argument><expr><name><name>tbm</name><operator>-&gt;</operator><name>ptpages</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ptchunks</name> <operator>=</operator> <call><name>dsa_get_address</name><argument_list>(<argument><expr><name><name>tbm</name><operator>-&gt;</operator><name>dsa</name></name></expr></argument>, <argument><expr><name><name>tbm</name><operator>-&gt;</operator><name>ptchunks</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * For every shared iterator, referring to pagetable and iterator array,
	 * increase the refcount by 1 so that while freeing the shared iterator we
	 * don't free pagetable and iterator array until its refcount becomes 0.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>ptbase</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pg_atomic_add_fetch_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ptbase</name><operator>-&gt;</operator><name>refcount</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>ptpages</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pg_atomic_add_fetch_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ptpages</name><operator>-&gt;</operator><name>refcount</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>ptchunks</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pg_atomic_add_fetch_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ptchunks</name><operator>-&gt;</operator><name>refcount</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Initialize the iterator lock */</comment>
	<expr_stmt><expr><call><name>LWLockInitialize</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>istate</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>, <argument><expr><name>LWTRANCHE_TBM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Initialize the shared iterator state */</comment>
	<expr_stmt><expr><name><name>istate</name><operator>-&gt;</operator><name>schunkbit</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>istate</name><operator>-&gt;</operator><name>schunkptr</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>istate</name><operator>-&gt;</operator><name>spageptr</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>tbm</name><operator>-&gt;</operator><name>iterating</name></name> <operator>=</operator> <name>TBM_ITERATING_SHARED</name></expr>;</expr_stmt>

	<return>return <expr><name>dp</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * tbm_extract_page_tuple - extract the tuple offsets from a page
 *
 * The extracted offsets are stored into TBMIterateResult.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type>
<name>tbm_extract_page_tuple</name><parameter_list>(<parameter><decl><type><name>PagetableEntry</name> <modifier>*</modifier></type><name>page</name></decl></parameter>, <parameter><decl><type><name>TBMIterateResult</name> <modifier>*</modifier></type><name>output</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>wordnum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ntuples</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>wordnum</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>wordnum</name> <operator>&lt;</operator> <name>WORDS_PER_PAGE</name></expr>;</condition> <incr><expr><name>wordnum</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>tbm_bitmapword</name></type>	<name>w</name> <init>= <expr><name><name>page</name><operator>-&gt;</operator><name>words</name><index>[<expr><name>wordnum</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>w</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>off</name> <init>= <expr><name>wordnum</name> <operator>*</operator> <name>TBM_BITS_PER_BITMAPWORD</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

			<while>while <condition>(<expr><name>w</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>w</name> <operator>&amp;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>output</name><operator>-&gt;</operator><name>offsets</name><index>[<expr><name>ntuples</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>OffsetNumber</name><operator>)</operator> <name>off</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>off</name><operator>++</operator></expr>;</expr_stmt>
				<expr_stmt><expr><name>w</name> <operator>&gt;&gt;=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			</block_content>}</block></while>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>ntuples</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * tbm_iterate_page - get a TBMIterateResult from a given PagetableEntry.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>tbm_iterate_page</name><parameter_list>(<parameter><decl><type><name>PagetableEntry</name> <modifier>*</modifier></type><name>page</name></decl></parameter>, <parameter><decl><type><name>TBMIterateResult</name> <modifier>*</modifier></type><name>output</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>ntuples</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>page</name><operator>-&gt;</operator><name>ischunk</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>ntuples</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>output</name><operator>-&gt;</operator><name>recheck</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* scan bitmap to extract individual offset numbers */</comment>
		<expr_stmt><expr><name>ntuples</name> <operator>=</operator> <call><name>tbm_extract_page_tuple</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>output</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>output</name><operator>-&gt;</operator><name>recheck</name></name> <operator>=</operator> <name><name>page</name><operator>-&gt;</operator><name>recheck</name></name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name><name>output</name><operator>-&gt;</operator><name>blockno</name></name> <operator>=</operator> <name><name>page</name><operator>-&gt;</operator><name>blockno</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>output</name><operator>-&gt;</operator><name>ntuples</name></name> <operator>=</operator> <name>ntuples</name></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *	tbm_advance_schunkbit - Advance the schunkbit
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>tbm_advance_schunkbit</name><parameter_list>(<parameter><decl><type><name>PagetableEntry</name> <modifier>*</modifier></type><name>chunk</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>schunkbitp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>schunkbit</name> <init>= <expr><operator>*</operator><name>schunkbitp</name></expr></init></decl>;</decl_stmt>

	<while>while <condition>(<expr><name>schunkbit</name> <operator>&lt;</operator> <name>PAGES_PER_CHUNK</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>wordnum</name> <init>= <expr><call><name>WORDNUM</name><argument_list>(<argument><expr><name>schunkbit</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>bitnum</name> <init>= <expr><call><name>BITNUM</name><argument_list>(<argument><expr><name>schunkbit</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>chunk</name><operator>-&gt;</operator><name>words</name><index>[<expr><name>wordnum</name></expr>]</index></name> <operator>&amp;</operator> <operator>(</operator><operator>(</operator><name>tbm_bitmapword</name><operator>)</operator> <literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>bitnum</name><operator>)</operator><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>schunkbit</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><operator>*</operator><name>schunkbitp</name> <operator>=</operator> <name>schunkbit</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * tbm_iterate - scan through next page of a TIDBitmap
 *
 * Gets a TBMIterateResult representing one page, or NULL if there are
 * no more pages to scan.  Pages are guaranteed to be delivered in numerical
 * order.  If result-&gt;ntuples &lt; 0, then the bitmap is "lossy" and failed to
 * remember the exact tuples to look at on this page --- the caller must
 * examine all tuples on the page and check if they meet the intended
 * condition.
 */</comment>
<function><type><name>TBMIterateResult</name> <modifier>*</modifier></type>
<name>tbm_iterate</name><parameter_list>(<parameter><decl><type><name>TBMIterator</name> <modifier>*</modifier></type><name>iterator</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PagetableEntry</name> <modifier>*</modifier></type><name>e</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>more</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TBMIterateResult</name> <modifier>*</modifier></type><name>output</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>iterator</name><operator>-&gt;</operator><name>output</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>e</name> <operator>=</operator> <call><name>tbm_next_page</name><argument_list>(<argument><expr><name>iterator</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>more</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>more</name> <operator>&amp;&amp;</operator> <name>e</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>tbm_iterate_page</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>output</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>output</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * tbm_next_page - actually traverse the TIDBitmap
 *
 * Store the next block of matches in nextpage.
 */</comment>

<function><type><specifier>static</specifier> <name>PagetableEntry</name> <modifier>*</modifier></type>
<name>tbm_next_page</name><parameter_list>(<parameter><decl><type><name>TBMIterator</name> <modifier>*</modifier></type><name>iterator</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>more</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TIDBitmap</name>  <modifier>*</modifier></type><name>tbm</name> <init>= <expr><name><name>iterator</name><operator>-&gt;</operator><name>tbm</name></name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>tbm</name><operator>-&gt;</operator><name>iterating</name></name> <operator>==</operator> <name>TBM_ITERATING_PRIVATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>more</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * If lossy chunk pages remain, make sure we've advanced schunkptr/
	 * schunkbit to the next set bit.
	 */</comment>
	<while>while <condition>(<expr><name><name>iterator</name><operator>-&gt;</operator><name>schunkptr</name></name> <operator>&lt;</operator> <name><name>tbm</name><operator>-&gt;</operator><name>nchunks</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PagetableEntry</name> <modifier>*</modifier></type><name>chunk</name> <init>= <expr><name><name>tbm</name><operator>-&gt;</operator><name>schunks</name><index>[<expr><name><name>iterator</name><operator>-&gt;</operator><name>schunkptr</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>schunkbit</name> <init>= <expr><name><name>iterator</name><operator>-&gt;</operator><name>schunkbit</name></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>tbm_advance_schunkbit</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>schunkbit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>schunkbit</name> <operator>&lt;</operator> <name>PAGES_PER_CHUNK</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>iterator</name><operator>-&gt;</operator><name>schunkbit</name></name> <operator>=</operator> <name>schunkbit</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* advance to next chunk */</comment>
		<expr_stmt><expr><name><name>iterator</name><operator>-&gt;</operator><name>schunkptr</name></name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>iterator</name><operator>-&gt;</operator><name>schunkbit</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></while>

	<comment type="block">/*
	 * If both chunk and per-page data remain, must output the numerically
	 * earlier page.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>iterator</name><operator>-&gt;</operator><name>schunkptr</name></name> <operator>&lt;</operator> <name><name>tbm</name><operator>-&gt;</operator><name>nchunks</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PagetableEntry</name> <modifier>*</modifier></type><name>chunk</name> <init>= <expr><name><name>tbm</name><operator>-&gt;</operator><name>schunks</name><index>[<expr><name><name>iterator</name><operator>-&gt;</operator><name>schunkptr</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PagetableEntry</name> <modifier>*</modifier></type><name>nextpage</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>BlockNumber</name></type> <name>chunk_blockno</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>chunk_blockno</name> <operator>=</operator> <name><name>chunk</name><operator>-&gt;</operator><name>blockno</name></name> <operator>+</operator> <name><name>iterator</name><operator>-&gt;</operator><name>schunkbit</name></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>iterator</name><operator>-&gt;</operator><name>spageptr</name></name> <operator>&gt;=</operator> <name><name>tbm</name><operator>-&gt;</operator><name>npages</name></name> <operator>||</operator>
			<name>chunk_blockno</name> <operator>&lt;</operator> <name><name>tbm</name><operator>-&gt;</operator><name>spages</name><index>[<expr><name><name>iterator</name><operator>-&gt;</operator><name>spageptr</name></name></expr>]</index></name><operator>-&gt;</operator><name>blockno</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Return a lossy page indicator from the chunk */</comment>
			<expr_stmt><expr><name>nextpage</name> <operator>=</operator> <operator>(</operator><name>PagetableEntry</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PagetableEntry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>nextpage</name><operator>-&gt;</operator><name>ischunk</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>nextpage</name><operator>-&gt;</operator><name>blockno</name></name> <operator>=</operator> <name>chunk_blockno</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>iterator</name><operator>-&gt;</operator><name>schunkbit</name></name><operator>++</operator></expr>;</expr_stmt>
			<return>return <expr><name>nextpage</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>iterator</name><operator>-&gt;</operator><name>spageptr</name></name> <operator>&lt;</operator> <name><name>tbm</name><operator>-&gt;</operator><name>npages</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PagetableEntry</name> <modifier>*</modifier></type><name>e</name></decl>;</decl_stmt>

		<comment type="block">/* In ONE_PAGE state, we don't allocate an spages[] array */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>tbm</name><operator>-&gt;</operator><name>status</name></name> <operator>==</operator> <name>TBM_ONE_PAGE</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>e</name> <operator>=</operator> <operator>&amp;</operator><name><name>tbm</name><operator>-&gt;</operator><name>entry1</name></name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>e</name> <operator>=</operator> <name><name>tbm</name><operator>-&gt;</operator><name>spages</name><index>[<expr><name><name>iterator</name><operator>-&gt;</operator><name>spageptr</name></name></expr>]</index></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><name><name>iterator</name><operator>-&gt;</operator><name>spageptr</name></name><operator>++</operator></expr>;</expr_stmt>
		<return>return <expr><name>e</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Nothing more in the bitmap */</comment>
	<expr_stmt><expr><operator>*</operator><name>more</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *	tbm_shared_iterate - scan through next page of a TIDBitmap
 *
 *	As above, but this will iterate using an iterator which is shared
 *	across multiple processes.  We need to acquire the iterator LWLock,
 *	before accessing the shared members.
 */</comment>
<function><type><name>TBMIterateResult</name> <modifier>*</modifier></type>
<name>tbm_shared_iterate</name><parameter_list>(<parameter><decl><type><name>TBMSharedIterator</name> <modifier>*</modifier></type><name>iterator</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TBMIterateResult</name> <modifier>*</modifier></type><name>output</name> <init>= <expr><operator>&amp;</operator><name><name>iterator</name><operator>-&gt;</operator><name>output</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TBMSharedIteratorState</name> <modifier>*</modifier></type><name>istate</name> <init>= <expr><name><name>iterator</name><operator>-&gt;</operator><name>state</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PagetableEntry</name> <modifier>*</modifier></type><name>ptbase</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name>		   <modifier>*</modifier></type><name>idxpages</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name>		   <modifier>*</modifier></type><name>idxchunks</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>iterator</name><operator>-&gt;</operator><name>ptbase</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>ptbase</name> <operator>=</operator> <name><name>iterator</name><operator>-&gt;</operator><name>ptbase</name><operator>-&gt;</operator><name>ptentry</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>iterator</name><operator>-&gt;</operator><name>ptpages</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>idxpages</name> <operator>=</operator> <name><name>iterator</name><operator>-&gt;</operator><name>ptpages</name><operator>-&gt;</operator><name>index</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>iterator</name><operator>-&gt;</operator><name>ptchunks</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>idxchunks</name> <operator>=</operator> <name><name>iterator</name><operator>-&gt;</operator><name>ptchunks</name><operator>-&gt;</operator><name>index</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Acquire the LWLock before accessing the shared members */</comment>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>istate</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If lossy chunk pages remain, make sure we've advanced schunkptr/
	 * schunkbit to the next set bit.
	 */</comment>
	<while>while <condition>(<expr><name><name>istate</name><operator>-&gt;</operator><name>schunkptr</name></name> <operator>&lt;</operator> <name><name>istate</name><operator>-&gt;</operator><name>nchunks</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PagetableEntry</name> <modifier>*</modifier></type><name>chunk</name> <init>= <expr><operator>&amp;</operator><name><name>ptbase</name><index>[<expr><name><name>idxchunks</name><index>[<expr><name><name>istate</name><operator>-&gt;</operator><name>schunkptr</name></name></expr>]</index></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>schunkbit</name> <init>= <expr><name><name>istate</name><operator>-&gt;</operator><name>schunkbit</name></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>tbm_advance_schunkbit</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>schunkbit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>schunkbit</name> <operator>&lt;</operator> <name>PAGES_PER_CHUNK</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>istate</name><operator>-&gt;</operator><name>schunkbit</name></name> <operator>=</operator> <name>schunkbit</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* advance to next chunk */</comment>
		<expr_stmt><expr><name><name>istate</name><operator>-&gt;</operator><name>schunkptr</name></name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>istate</name><operator>-&gt;</operator><name>schunkbit</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></while>

	<comment type="block">/*
	 * If both chunk and per-page data remain, must output the numerically
	 * earlier page.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>istate</name><operator>-&gt;</operator><name>schunkptr</name></name> <operator>&lt;</operator> <name><name>istate</name><operator>-&gt;</operator><name>nchunks</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PagetableEntry</name> <modifier>*</modifier></type><name>chunk</name> <init>= <expr><operator>&amp;</operator><name><name>ptbase</name><index>[<expr><name><name>idxchunks</name><index>[<expr><name><name>istate</name><operator>-&gt;</operator><name>schunkptr</name></name></expr>]</index></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>BlockNumber</name></type> <name>chunk_blockno</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>chunk_blockno</name> <operator>=</operator> <name><name>chunk</name><operator>-&gt;</operator><name>blockno</name></name> <operator>+</operator> <name><name>istate</name><operator>-&gt;</operator><name>schunkbit</name></name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>istate</name><operator>-&gt;</operator><name>spageptr</name></name> <operator>&gt;=</operator> <name><name>istate</name><operator>-&gt;</operator><name>npages</name></name> <operator>||</operator>
			<name>chunk_blockno</name> <operator>&lt;</operator> <name><name>ptbase</name><index>[<expr><name><name>idxpages</name><index>[<expr><name><name>istate</name><operator>-&gt;</operator><name>spageptr</name></name></expr>]</index></name></expr>]</index></name><operator>.</operator><name>blockno</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Return a lossy page indicator from the chunk */</comment>
			<expr_stmt><expr><name><name>output</name><operator>-&gt;</operator><name>blockno</name></name> <operator>=</operator> <name>chunk_blockno</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>output</name><operator>-&gt;</operator><name>ntuples</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>output</name><operator>-&gt;</operator><name>recheck</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>istate</name><operator>-&gt;</operator><name>schunkbit</name></name><operator>++</operator></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>istate</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>output</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>istate</name><operator>-&gt;</operator><name>spageptr</name></name> <operator>&lt;</operator> <name><name>istate</name><operator>-&gt;</operator><name>npages</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PagetableEntry</name> <modifier>*</modifier></type><name>page</name> <init>= <expr><operator>&amp;</operator><name><name>ptbase</name><index>[<expr><name><name>idxpages</name><index>[<expr><name><name>istate</name><operator>-&gt;</operator><name>spageptr</name></name></expr>]</index></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>ntuples</name></decl>;</decl_stmt>

		<comment type="block">/* scan bitmap to extract individual offset numbers */</comment>
		<expr_stmt><expr><name>ntuples</name> <operator>=</operator> <call><name>tbm_extract_page_tuple</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>output</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>output</name><operator>-&gt;</operator><name>blockno</name></name> <operator>=</operator> <name><name>page</name><operator>-&gt;</operator><name>blockno</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>output</name><operator>-&gt;</operator><name>ntuples</name></name> <operator>=</operator> <name>ntuples</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>output</name><operator>-&gt;</operator><name>recheck</name></name> <operator>=</operator> <name><name>page</name><operator>-&gt;</operator><name>recheck</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>istate</name><operator>-&gt;</operator><name>spageptr</name></name><operator>++</operator></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>istate</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return <expr><name>output</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>istate</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Nothing more in the bitmap */</comment>
	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * tbm_end_iterate - finish an iteration over a TIDBitmap
 *
 * Currently this is just a pfree, but it might do more someday.  (For
 * instance, it could be useful to count open iterators and allow the
 * bitmap to return to read/write status when there are no more iterators.)
 */</comment>
<function><type><name>void</name></type>
<name>tbm_end_iterate</name><parameter_list>(<parameter><decl><type><name>TBMIterator</name> <modifier>*</modifier></type><name>iterator</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>iterator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * tbm_stream_end_iterate - finish an iteration over a StreamBitmap
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>tbm_stream_end_iterate</name><parameter_list>(<parameter><decl><type><name>StreamBMIterator</name> <modifier>*</modifier></type><name>iterator</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* end_iterate() will clean up whatever begin_iterate() set up. */</comment>
	<expr_stmt><expr><call><name><name>iterator</name><operator>-&gt;</operator><name>end_iterate</name></name><argument_list>(<argument><expr><name>iterator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>iterator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * tbm_generic_end_iterate - finish an iteration over a TIDBitmap or
 * StreamBitmap
 */</comment>
<function><type><name>void</name></type>
<name>tbm_generic_end_iterate</name><parameter_list>(<parameter><decl><type><name>GenericBMIterator</name> <modifier>*</modifier></type><name>iterator</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>Node</name> <modifier>*</modifier></type><name>bm</name> <init>= <expr><name><name>iterator</name><operator>-&gt;</operator><name>bm</name></name></expr></init></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><name><name>bm</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>T_TIDBitmap</name></expr>:</case>
			<expr_stmt><expr><call><name>tbm_end_iterate</name><argument_list>(<argument><expr><name><name>iterator</name><operator>-&gt;</operator><name>impl</name><operator>.</operator><name>hash</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_StreamBitmap</name></expr>:</case>
		<block>{<block_content>
			<expr_stmt><expr><call><name>tbm_stream_end_iterate</name><argument_list>(<argument><expr><name><name>iterator</name><operator>-&gt;</operator><name>impl</name><operator>.</operator><name>stream</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block>

		<default>default:</default>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name><name>bm</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>T_TIDBitmap</name><operator>)</operator>
				   <operator>||</operator> <operator>(</operator><name><name>bm</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>T_StreamBitmap</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 * tbm_end_shared_iterate - finish a shared iteration over a TIDBitmap
 *
 * This doesn't free any of the shared state associated with the iterator,
 * just our backend-private state.
 */</comment>
<function><type><name>void</name></type>
<name>tbm_end_shared_iterate</name><parameter_list>(<parameter><decl><type><name>TBMSharedIterator</name> <modifier>*</modifier></type><name>iterator</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>iterator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * tbm_find_pageentry - find a PagetableEntry for the pageno
 *
 * Returns NULL if there is no non-lossy entry for the pageno.
 */</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>PagetableEntry</name> <modifier>*</modifier></type>
<name>tbm_find_pageentry</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>TIDBitmap</name> <modifier>*</modifier></type><name>tbm</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>pageno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>PagetableEntry</name> <modifier>*</modifier></type><name>page</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>tbm</name><operator>-&gt;</operator><name>nentries</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>		<comment type="block">/* in case pagetable doesn't exist */</comment>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>tbm</name><operator>-&gt;</operator><name>status</name></name> <operator>==</operator> <name>TBM_ONE_PAGE</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>page</name> <operator>=</operator> <operator>&amp;</operator><name><name>tbm</name><operator>-&gt;</operator><name>entry1</name></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>page</name><operator>-&gt;</operator><name>blockno</name></name> <operator>!=</operator> <name>pageno</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>page</name><operator>-&gt;</operator><name>ischunk</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>page</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>pagetable_lookup</name><argument_list>(<argument><expr><name><name>tbm</name><operator>-&gt;</operator><name>pagetable</name></name></expr></argument>, <argument><expr><name>pageno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>page</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>page</name><operator>-&gt;</operator><name>ischunk</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>			<comment type="block">/* don't want a lossy chunk header */</comment>
	<return>return <expr><name>page</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * tbm_get_pageentry - find or create a PagetableEntry for the pageno
 *
 * If new, the entry is marked as an exact (non-chunk) entry.
 *
 * This may cause the table to exceed the desired memory size.  It is
 * up to the caller to call tbm_lossify() at the next safe point if so.
 */</comment>
<function><type><specifier>static</specifier> <name>PagetableEntry</name> <modifier>*</modifier></type>
<name>tbm_get_pageentry</name><parameter_list>(<parameter><decl><type><name>TIDBitmap</name> <modifier>*</modifier></type><name>tbm</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>pageno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PagetableEntry</name> <modifier>*</modifier></type><name>page</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>tbm</name><operator>-&gt;</operator><name>status</name></name> <operator>==</operator> <name>TBM_EMPTY</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Use the fixed slot */</comment>
		<expr_stmt><expr><name>page</name> <operator>=</operator> <operator>&amp;</operator><name><name>tbm</name><operator>-&gt;</operator><name>entry1</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>found</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tbm</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>TBM_ONE_PAGE</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>tbm</name><operator>-&gt;</operator><name>status</name></name> <operator>==</operator> <name>TBM_ONE_PAGE</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>page</name> <operator>=</operator> <operator>&amp;</operator><name><name>tbm</name><operator>-&gt;</operator><name>entry1</name></name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>page</name><operator>-&gt;</operator><name>blockno</name></name> <operator>==</operator> <name>pageno</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>page</name></expr>;</return></block_content></block></if></if_stmt>
			<comment type="block">/* Time to switch from one page to a hashtable */</comment>
			<expr_stmt><expr><call><name>tbm_create_pagetable</name><argument_list>(<argument><expr><name>tbm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Look up or create an entry */</comment>
		<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>pagetable_insert</name><argument_list>(<argument><expr><name><name>tbm</name><operator>-&gt;</operator><name>pagetable</name></name></expr></argument>, <argument><expr><name>pageno</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Initialize it if not present before */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type>		<name>oldstatus</name> <init>= <expr><name><name>page</name><operator>-&gt;</operator><name>status</name></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PagetableEntry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>page</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>oldstatus</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>page</name><operator>-&gt;</operator><name>blockno</name></name> <operator>=</operator> <name>pageno</name></expr>;</expr_stmt>
		<comment type="block">/* must count it too */</comment>
		<expr_stmt><expr><name><name>tbm</name><operator>-&gt;</operator><name>nentries</name></name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tbm</name><operator>-&gt;</operator><name>npages</name></name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>page</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * tbm_page_is_lossy - is the page marked as lossily stored?
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>tbm_page_is_lossy</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>TIDBitmap</name> <modifier>*</modifier></type><name>tbm</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>pageno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PagetableEntry</name> <modifier>*</modifier></type><name>page</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>chunk_pageno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>bitno</name></decl>;</decl_stmt>

	<comment type="block">/* we can skip the lookup if there are no lossy chunks */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>tbm</name><operator>-&gt;</operator><name>nchunks</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>tbm</name><operator>-&gt;</operator><name>status</name></name> <operator>==</operator> <name>TBM_HASH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>bitno</name> <operator>=</operator> <name>pageno</name> <operator>%</operator> <name>PAGES_PER_CHUNK</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>chunk_pageno</name> <operator>=</operator> <name>pageno</name> <operator>-</operator> <name>bitno</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>pagetable_lookup</name><argument_list>(<argument><expr><name><name>tbm</name><operator>-&gt;</operator><name>pagetable</name></name></expr></argument>, <argument><expr><name>chunk_pageno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>page</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>page</name><operator>-&gt;</operator><name>ischunk</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>wordnum</name> <init>= <expr><call><name>WORDNUM</name><argument_list>(<argument><expr><name>bitno</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>bitnum</name> <init>= <expr><call><name>BITNUM</name><argument_list>(<argument><expr><name>bitno</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>page</name><operator>-&gt;</operator><name>words</name><index>[<expr><name>wordnum</name></expr>]</index></name> <operator>&amp;</operator> <operator>(</operator><operator>(</operator><name>tbm_bitmapword</name><operator>)</operator> <literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>bitnum</name><operator>)</operator><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * tbm_mark_page_lossy - mark the page number as lossily stored
 *
 * This may cause the table to exceed the desired memory size.  It is
 * up to the caller to call tbm_lossify() at the next safe point if so.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>tbm_mark_page_lossy</name><parameter_list>(<parameter><decl><type><name>TIDBitmap</name> <modifier>*</modifier></type><name>tbm</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>pageno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PagetableEntry</name> <modifier>*</modifier></type><name>page</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>chunk_pageno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>bitno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>wordnum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>bitnum</name></decl>;</decl_stmt>

	<comment type="block">/* We force the bitmap into hashtable mode whenever it's lossy */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>tbm</name><operator>-&gt;</operator><name>status</name></name> <operator>!=</operator> <name>TBM_HASH</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>tbm_create_pagetable</name><argument_list>(<argument><expr><name>tbm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>bitno</name> <operator>=</operator> <name>pageno</name> <operator>%</operator> <name>PAGES_PER_CHUNK</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>chunk_pageno</name> <operator>=</operator> <name>pageno</name> <operator>-</operator> <name>bitno</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Remove any extant non-lossy entry for the page.  If the page is its own
	 * chunk header, however, we skip this and handle the case below.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>bitno</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>pagetable_delete</name><argument_list>(<argument><expr><name><name>tbm</name><operator>-&gt;</operator><name>pagetable</name></name></expr></argument>, <argument><expr><name>pageno</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* It was present, so adjust counts */</comment>
			<expr_stmt><expr><name><name>tbm</name><operator>-&gt;</operator><name>nentries_hwm</name></name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name><name>tbm</name><operator>-&gt;</operator><name>nentries_hwm</name></name></expr></argument>, <argument><expr><name><name>tbm</name><operator>-&gt;</operator><name>nentries</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tbm</name><operator>-&gt;</operator><name>nentries</name></name><operator>--</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tbm</name><operator>-&gt;</operator><name>npages</name></name><operator>--</operator></expr>;</expr_stmt>		<comment type="block">/* assume it must have been non-lossy */</comment>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Look up or create entry for chunk-header page */</comment>
	<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>pagetable_insert</name><argument_list>(<argument><expr><name><name>tbm</name><operator>-&gt;</operator><name>pagetable</name></name></expr></argument>, <argument><expr><name>chunk_pageno</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Initialize it if not present before */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type>		<name>oldstatus</name> <init>= <expr><name><name>page</name><operator>-&gt;</operator><name>status</name></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PagetableEntry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>page</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>oldstatus</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>page</name><operator>-&gt;</operator><name>blockno</name></name> <operator>=</operator> <name>chunk_pageno</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>page</name><operator>-&gt;</operator><name>ischunk</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<comment type="block">/* must count it too */</comment>
		<expr_stmt><expr><name><name>tbm</name><operator>-&gt;</operator><name>nentries</name></name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tbm</name><operator>-&gt;</operator><name>nchunks</name></name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><operator>!</operator><name><name>page</name><operator>-&gt;</operator><name>ischunk</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type>		<name>oldstatus</name> <init>= <expr><name><name>page</name><operator>-&gt;</operator><name>status</name></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* chunk header page was formerly non-lossy, make it lossy */</comment>
		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PagetableEntry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>page</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>oldstatus</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>page</name><operator>-&gt;</operator><name>blockno</name></name> <operator>=</operator> <name>chunk_pageno</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>page</name><operator>-&gt;</operator><name>ischunk</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<comment type="block">/* we assume it had some tuple bit(s) set, so mark it lossy */</comment>
		<expr_stmt><expr><name><name>page</name><operator>-&gt;</operator><name>words</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>tbm_bitmapword</name><operator>)</operator> <literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
		<comment type="block">/* adjust counts */</comment>
		<expr_stmt><expr><name><name>tbm</name><operator>-&gt;</operator><name>nchunks</name></name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tbm</name><operator>-&gt;</operator><name>npages</name></name><operator>--</operator></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Now set the original target page's bit */</comment>
	<expr_stmt><expr><name>wordnum</name> <operator>=</operator> <call><name>WORDNUM</name><argument_list>(<argument><expr><name>bitno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>bitnum</name> <operator>=</operator> <call><name>BITNUM</name><argument_list>(<argument><expr><name>bitno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>page</name><operator>-&gt;</operator><name>words</name><index>[<expr><name>wordnum</name></expr>]</index></name> <operator>|=</operator> <operator>(</operator><operator>(</operator><name>tbm_bitmapword</name><operator>)</operator> <literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>bitnum</name><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * tbm_lossify - lose some information to get back under the memory limit
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>tbm_lossify</name><parameter_list>(<parameter><decl><type><name>TIDBitmap</name> <modifier>*</modifier></type><name>tbm</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>pagetable_iterator</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PagetableEntry</name> <modifier>*</modifier></type><name>page</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * XXX Really stupid implementation: this just lossifies pages in
	 * essentially random order.  We should be paying some attention to the
	 * number of bits set in each page, instead.
	 *
	 * Since we are called as soon as nentries exceeds maxentries, we should
	 * push nentries down to significantly less than maxentries, or else we'll
	 * just end up doing this again very soon.  We shoot for maxentries/2.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>tbm</name><operator>-&gt;</operator><name>iterating</name></name> <operator>==</operator> <name>TBM_NOT_ITERATING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>tbm</name><operator>-&gt;</operator><name>status</name></name> <operator>==</operator> <name>TBM_HASH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pagetable_start_iterate_at</name><argument_list>(<argument><expr><name><name>tbm</name><operator>-&gt;</operator><name>pagetable</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>i</name></expr></argument>, <argument><expr><name><name>tbm</name><operator>-&gt;</operator><name>lossify_start</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>page</name> <operator>=</operator> <call><name>pagetable_iterate</name><argument_list>(<argument><expr><name><name>tbm</name><operator>-&gt;</operator><name>pagetable</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>i</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>page</name><operator>-&gt;</operator><name>ischunk</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>			<comment type="block">/* already a chunk header */</comment>

		<comment type="block">/*
		 * If the page would become a chunk header, we won't save anything by
		 * converting it to lossy, so skip it.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>page</name><operator>-&gt;</operator><name>blockno</name></name> <operator>%</operator> <name>PAGES_PER_CHUNK</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* This does the dirty work ... */</comment>
		<expr_stmt><expr><call><name>tbm_mark_page_lossy</name><argument_list>(<argument><expr><name>tbm</name></expr></argument>, <argument><expr><name><name>page</name><operator>-&gt;</operator><name>blockno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>tbm</name><operator>-&gt;</operator><name>nentries</name></name> <operator>&lt;=</operator> <name><name>tbm</name><operator>-&gt;</operator><name>maxentries</name></name> <operator>/</operator> <literal type="number">2</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * We have made enough room. Remember where to start lossifying
			 * next round, so we evenly iterate over the hashtable.
			 */</comment>
			<expr_stmt><expr><name><name>tbm</name><operator>-&gt;</operator><name>lossify_start</name></name> <operator>=</operator> <name><name>i</name><operator>.</operator><name>cur</name></name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Note: tbm_mark_page_lossy may have inserted a lossy chunk into the
		 * hashtable and may have deleted the non-lossy chunk.  We can
		 * continue the same hash table scan, since failure to visit one
		 * element or visiting the newly inserted element, isn't fatal.
		 */</comment>
	</block_content>}</block></while>

	<comment type="block">/*
	 * With a big bitmap and small work_mem, it's possible that we cannot get
	 * under maxentries.  Again, if that happens, we'd end up uselessly
	 * calling tbm_lossify over and over.  To prevent this from becoming a
	 * performance sink, force maxentries up to at least double the current
	 * number of entries.  (In essence, we're admitting inability to fit
	 * within work_mem when we do this.)  Note that this test will not fire if
	 * we broke out of the loop early; and if we didn't, the current number of
	 * entries is simply not reducible any further.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>tbm</name><operator>-&gt;</operator><name>nentries</name></name> <operator>&gt;</operator> <name><name>tbm</name><operator>-&gt;</operator><name>maxentries</name></name> <operator>/</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>tbm</name><operator>-&gt;</operator><name>maxentries</name></name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name><name>tbm</name><operator>-&gt;</operator><name>nentries</name></name></expr></argument>, <argument><expr><operator>(</operator><name>INT_MAX</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call> <operator>*</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * qsort comparator to handle PagetableEntry pointers.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>tbm_comparator</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>left</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>right</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>l</name> <init>= <expr><operator>(</operator><operator>*</operator><operator>(</operator><operator>(</operator><name>PagetableEntry</name> <operator>*</operator><specifier>const</specifier> <operator>*</operator><operator>)</operator> <name>left</name><operator>)</operator><operator>)</operator><operator>-&gt;</operator><name>blockno</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>r</name> <init>= <expr><operator>(</operator><operator>*</operator><operator>(</operator><operator>(</operator><name>PagetableEntry</name> <operator>*</operator><specifier>const</specifier> <operator>*</operator><operator>)</operator> <name>right</name><operator>)</operator><operator>)</operator><operator>-&gt;</operator><name>blockno</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>l</name> <operator>&lt;</operator> <name>r</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>l</name> <operator>&gt;</operator> <name>r</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * As above, but this will get index into PagetableEntry array.  Therefore,
 * it needs to get actual PagetableEntry using the index before comparing the
 * blockno.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>tbm_shared_comparator</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>left</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>right</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PagetableEntry</name> <modifier>*</modifier></type><name>base</name> <init>= <expr><operator>(</operator><name>PagetableEntry</name> <operator>*</operator><operator>)</operator> <name>arg</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PagetableEntry</name> <modifier>*</modifier></type><name>lpage</name> <init>= <expr><operator>&amp;</operator><name><name>base</name><index>[<expr><operator>*</operator><operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <name>left</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PagetableEntry</name> <modifier>*</modifier></type><name>rpage</name> <init>= <expr><operator>&amp;</operator><name><name>base</name><index>[<expr><operator>*</operator><operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <name>right</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>lpage</name><operator>-&gt;</operator><name>blockno</name></name> <operator>&lt;</operator> <name><name>rpage</name><operator>-&gt;</operator><name>blockno</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name><name>lpage</name><operator>-&gt;</operator><name>blockno</name></name> <operator>&gt;</operator> <name><name>rpage</name><operator>-&gt;</operator><name>blockno</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *	tbm_attach_shared_iterate
 *
 *	Allocate a backend-private iterator and attach the shared iterator state
 *	to it so that multiple processed can iterate jointly.
 *
 *	We also converts the DSA pointers to local pointers and store them into
 *	our private iterator.
 */</comment>
<function><type><name>TBMSharedIterator</name> <modifier>*</modifier></type>
<name>tbm_attach_shared_iterate</name><parameter_list>(<parameter><decl><type><name>dsa_area</name> <modifier>*</modifier></type><name>dsa</name></decl></parameter>, <parameter><decl><type><name>dsa_pointer</name></type> <name>dp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TBMSharedIterator</name> <modifier>*</modifier></type><name>iterator</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TBMSharedIteratorState</name> <modifier>*</modifier></type><name>istate</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Create the TBMSharedIterator struct, with enough trailing space to
	 * serve the needs of the TBMIterateResult sub-struct.
	 */</comment>
	<expr_stmt><expr><name>iterator</name> <operator>=</operator> <operator>(</operator><name>TBMSharedIterator</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TBMSharedIterator</name></expr></argument>)</argument_list></sizeof> <operator>+</operator>
											 <name>MAX_TUPLES_PER_PAGE</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>OffsetNumber</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>istate</name> <operator>=</operator> <operator>(</operator><name>TBMSharedIteratorState</name> <operator>*</operator><operator>)</operator> <call><name>dsa_get_address</name><argument_list>(<argument><expr><name>dsa</name></expr></argument>, <argument><expr><name>dp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>iterator</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>istate</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>iterator</name><operator>-&gt;</operator><name>ptbase</name></name> <operator>=</operator> <call><name>dsa_get_address</name><argument_list>(<argument><expr><name>dsa</name></expr></argument>, <argument><expr><name><name>istate</name><operator>-&gt;</operator><name>pagetable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>istate</name><operator>-&gt;</operator><name>npages</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>iterator</name><operator>-&gt;</operator><name>ptpages</name></name> <operator>=</operator> <call><name>dsa_get_address</name><argument_list>(<argument><expr><name>dsa</name></expr></argument>, <argument><expr><name><name>istate</name><operator>-&gt;</operator><name>spages</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>istate</name><operator>-&gt;</operator><name>nchunks</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>iterator</name><operator>-&gt;</operator><name>ptchunks</name></name> <operator>=</operator> <call><name>dsa_get_address</name><argument_list>(<argument><expr><name>dsa</name></expr></argument>, <argument><expr><name><name>istate</name><operator>-&gt;</operator><name>schunks</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>iterator</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * pagetable_allocate
 *
 * Callback function for allocating the memory for hashtable elements.
 * Allocate memory for hashtable elements, using DSA if available.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name> <modifier>*</modifier></type>
<name>pagetable_allocate</name><parameter_list>(<parameter><decl><type><name>pagetable_hash</name> <modifier>*</modifier></type><name>pagetable</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TIDBitmap</name>  <modifier>*</modifier></type><name>tbm</name> <init>= <expr><operator>(</operator><name>TIDBitmap</name> <operator>*</operator><operator>)</operator> <name><name>pagetable</name><operator>-&gt;</operator><name>private_data</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PTEntryArray</name> <modifier>*</modifier></type><name>ptbase</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>tbm</name><operator>-&gt;</operator><name>dsa</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>MemoryContextAllocExtended</name><argument_list>(<argument><expr><name><name>pagetable</name><operator>-&gt;</operator><name>ctx</name></name></expr></argument>, <argument><expr><name>size</name></expr></argument>,
										  <argument><expr><name>MCXT_ALLOC_HUGE</name> <operator>|</operator> <name>MCXT_ALLOC_ZERO</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Save the dsapagetable reference in dsapagetableold before allocating
	 * new memory so that pagetable_free can free the old entry.
	 */</comment>
	<expr_stmt><expr><name><name>tbm</name><operator>-&gt;</operator><name>dsapagetableold</name></name> <operator>=</operator> <name><name>tbm</name><operator>-&gt;</operator><name>dsapagetable</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tbm</name><operator>-&gt;</operator><name>dsapagetable</name></name> <operator>=</operator> <call><name>dsa_allocate_extended</name><argument_list>(<argument><expr><name><name>tbm</name><operator>-&gt;</operator><name>dsa</name></name></expr></argument>,
											  <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PTEntryArray</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name>size</name></expr></argument>,
											  <argument><expr><name>DSA_ALLOC_HUGE</name> <operator>|</operator> <name>DSA_ALLOC_ZERO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ptbase</name> <operator>=</operator> <call><name>dsa_get_address</name><argument_list>(<argument><expr><name><name>tbm</name><operator>-&gt;</operator><name>dsa</name></name></expr></argument>, <argument><expr><name><name>tbm</name><operator>-&gt;</operator><name>dsapagetable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>ptbase</name><operator>-&gt;</operator><name>ptentry</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * pagetable_free
 *
 * Callback function for freeing hash table elements.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>pagetable_free</name><parameter_list>(<parameter><decl><type><name>pagetable_hash</name> <modifier>*</modifier></type><name>pagetable</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pointer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TIDBitmap</name>  <modifier>*</modifier></type><name>tbm</name> <init>= <expr><operator>(</operator><name>TIDBitmap</name> <operator>*</operator><operator>)</operator> <name><name>pagetable</name><operator>-&gt;</operator><name>private_data</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* pfree the input pointer if DSA is not available */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>tbm</name><operator>-&gt;</operator><name>dsa</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>pointer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>DsaPointerIsValid</name><argument_list>(<argument><expr><name><name>tbm</name><operator>-&gt;</operator><name>dsapagetableold</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>dsa_free</name><argument_list>(<argument><expr><name><name>tbm</name><operator>-&gt;</operator><name>dsa</name></name></expr></argument>, <argument><expr><name><name>tbm</name><operator>-&gt;</operator><name>dsapagetableold</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tbm</name><operator>-&gt;</operator><name>dsapagetableold</name></name> <operator>=</operator> <name>InvalidDsaPointer</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * tbm_calculate_entries
 *
 * Estimate number of hashtable entries we can have within maxbytes.
 */</comment>
<function><type><name>long</name></type>
<name>tbm_calculate_entries</name><parameter_list>(<parameter><decl><type><name>double</name></type> <name>maxbytes</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>long</name></type>		<name>nbuckets</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Estimate number of hashtable entries we can have within maxbytes. This
	 * estimates the hash cost as sizeof(PagetableEntry), which is good enough
	 * for our purpose.  Also count an extra Pointer per entry for the arrays
	 * created during iteration readout.
	 */</comment>
	<expr_stmt><expr><name>nbuckets</name> <operator>=</operator> <name>maxbytes</name> <operator>/</operator>
		<operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>PagetableEntry</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Pointer</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Pointer</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>nbuckets</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>nbuckets</name></expr></argument>, <argument><expr><name>INT_MAX</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* safety limit */</comment>
	<expr_stmt><expr><name>nbuckets</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name>nbuckets</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* sanity limit */</comment>

	<return>return <expr><name>nbuckets</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * functions related to streaming
 */</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>opstream_free</name><parameter_list>(<parameter><decl><type><name>StreamNode</name> <modifier>*</modifier></type><name>self</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>input</name> <init>= <expr><name><name>self</name><operator>-&gt;</operator><name>opaque</name></name></expr></init></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>input</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>StreamNode</name> <modifier>*</modifier></type><name>inp</name> <init>= <expr><operator>(</operator><name>StreamNode</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>inp</name><operator>-&gt;</operator><name>free</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name><name>inp</name><operator>-&gt;</operator><name>free</name></name><argument_list>(<argument><expr><name>inp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>opstream_set_instrument</name><parameter_list>(<parameter><decl><type><name>StreamNode</name> <modifier>*</modifier></type><name>self</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>Instrumentation</name></name> <modifier>*</modifier></type><name>instr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>input</name> <init>= <expr><name><name>self</name><operator>-&gt;</operator><name>opaque</name></name></expr></init></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>input</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>StreamNode</name> <modifier>*</modifier></type><name>inp</name> <init>= <expr><operator>(</operator><name>StreamNode</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>inp</name><operator>-&gt;</operator><name>set_instrument</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name><name>inp</name><operator>-&gt;</operator><name>set_instrument</name></name><argument_list>(<argument><expr><name>inp</name></expr></argument>, <argument><expr><name>instr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>opstream_upd_instrument</name><parameter_list>(<parameter><decl><type><name>StreamNode</name> <modifier>*</modifier></type><name>self</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>input</name> <init>= <expr><name><name>self</name><operator>-&gt;</operator><name>opaque</name></name></expr></init></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>input</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>StreamNode</name> <modifier>*</modifier></type><name>inp</name> <init>= <expr><operator>(</operator><name>StreamNode</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>inp</name><operator>-&gt;</operator><name>upd_instrument</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name><name>inp</name><operator>-&gt;</operator><name>upd_instrument</name></name><argument_list>(<argument><expr><name>inp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>OpStream</name> <modifier>*</modifier></type>
<name>make_opstream</name><parameter_list>(<parameter><decl><type><name>StreamType</name></type> <name>kind</name></decl></parameter>, <parameter><decl><type><name>StreamNode</name> <modifier>*</modifier></type><name>n1</name></decl></parameter>, <parameter><decl><type><name>StreamNode</name> <modifier>*</modifier></type><name>n2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OpStream</name>   <modifier>*</modifier></type><name>op</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>kind</name> <operator>==</operator> <name>BMS_OR</name> <operator>||</operator> <name>kind</name> <operator>==</operator> <name>BMS_AND</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>PointerIsValid</name><argument_list>(<argument><expr><name>n1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>op</name> <operator>=</operator> <operator>(</operator><name>OpStream</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>OpStream</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>kind</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>opaque</name></name> <operator>=</operator> <call><name>list_make2</name><argument_list>(<argument><expr><name>n1</name></expr></argument>, <argument><expr><name>n2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>begin_iterate</name></name> <operator>=</operator> <name>opstream_begin_iterate</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>free</name></name> <operator>=</operator> <name>opstream_free</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>set_instrument</name></name> <operator>=</operator> <name>opstream_set_instrument</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>upd_instrument</name></name> <operator>=</operator> <name>opstream_upd_instrument</name></expr>;</expr_stmt>
	<return>return <expr><name>op</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * stream_move_node - move a streamnode from StreamBitMap (source)'s streamnode
 * to given StreamBitMap(destination). Also transfer the ownership of source streamnode by
 * resetting to NULL.
 */</comment>
<function><type><name>void</name></type>
<name>stream_move_node</name><parameter_list>(<parameter><decl><type><name>StreamBitmap</name> <modifier>*</modifier></type><name>destination</name></decl></parameter>, <parameter><decl><type><name>StreamBitmap</name> <modifier>*</modifier></type><name>source</name></decl></parameter>, <parameter><decl><type><name>StreamType</name></type> <name>kind</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>NULL</name> <operator>!=</operator> <name>destination</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>NULL</name> <operator>!=</operator> <name>source</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>stream_add_node</name><argument_list>(<argument><expr><name>destination</name></expr></argument>,
			<argument><expr><name><name>source</name><operator>-&gt;</operator><name>streamNode</name></name></expr></argument>, <argument><expr><name>kind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* destination owns the streamNode and hence resetting it to NULL for source-&gt;streamNode. */</comment>
	<expr_stmt><expr><name><name>source</name><operator>-&gt;</operator><name>streamNode</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * stream_add_node() - add a new node to a bitmap stream
 * node is a base node -- i.e., an index/external
 * kind is one of BMS_INDEX, BMS_OR or BMS_AND
 */</comment>

<function><type><name>void</name></type>
<name>stream_add_node</name><parameter_list>(<parameter><decl><type><name>StreamBitmap</name> <modifier>*</modifier></type><name>sbm</name></decl></parameter>, <parameter><decl><type><name>StreamNode</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>StreamType</name></type> <name>kind</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* CDB: Tell node where to put its statistics for EXPLAIN ANALYZE. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>set_instrument</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name><name>node</name><operator>-&gt;</operator><name>set_instrument</name></name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name><name>sbm</name><operator>-&gt;</operator><name>instrument</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* initialised */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>sbm</name><operator>-&gt;</operator><name>streamNode</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>StreamNode</name> <modifier>*</modifier></type><name>n</name> <init>= <expr><name><name>sbm</name><operator>-&gt;</operator><name>streamNode</name></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* StreamNode is already an index, transform to OpStream */</comment>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>n</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>BMS_AND</name> <operator>&amp;&amp;</operator> <name>kind</name> <operator>==</operator> <name>BMS_AND</name><operator>)</operator> <operator>||</operator>
			<operator>(</operator><name><name>n</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>BMS_OR</name> <operator>&amp;&amp;</operator> <name>kind</name> <operator>==</operator> <name>BMS_OR</name><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* n-&gt;opaque is our list of inputs; append to it */</comment>
			<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>opaque</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>opaque</name></name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><operator>(</operator><name><name>n</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>BMS_AND</name> <operator>&amp;&amp;</operator> <name>kind</name> <operator>!=</operator> <name>BMS_AND</name><operator>)</operator> <operator>||</operator>
				 <operator>(</operator><name><name>n</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>BMS_OR</name> <operator>&amp;&amp;</operator> <name>kind</name> <operator>!=</operator> <name>BMS_OR</name><operator>)</operator> <operator>||</operator>
				 <operator>(</operator><name><name>n</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>BMS_INDEX</name><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>sbm</name><operator>-&gt;</operator><name>streamNode</name></name> <operator>=</operator> <call><name>make_opstream</name><argument_list>(<argument><expr><name>kind</name></expr></argument>, <argument><expr><name><name>sbm</name><operator>-&gt;</operator><name>streamNode</name></name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unknown stream type %i"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>n</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>kind</name> <operator>==</operator> <name>BMS_INDEX</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>sbm</name><operator>-&gt;</operator><name>streamNode</name></name> <operator>=</operator> <name>node</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>sbm</name><operator>-&gt;</operator><name>streamNode</name></name> <operator>=</operator> <call><name>make_opstream</name><argument_list>(<argument><expr><name>kind</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * tbm_create_stream_node() - turn a TIDBitmap into a stream
 */</comment>

<function><type><name>StreamNode</name> <modifier>*</modifier></type>
<name>tbm_create_stream_node</name><parameter_list>(<parameter><decl><type><name>TIDBitmap</name> <modifier>*</modifier></type><name>tbm</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>IndexStream</name> <modifier>*</modifier></type><name>is</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>is</name> <operator>=</operator> <operator>(</operator><name>IndexStream</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>IndexStream</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>is</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>BMS_INDEX</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>is</name><operator>-&gt;</operator><name>opaque</name></name> <operator>=</operator> <name>tbm</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>is</name><operator>-&gt;</operator><name>begin_iterate</name></name> <operator>=</operator> <name>index_stream_begin_iterate</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>is</name><operator>-&gt;</operator><name>free</name></name> <operator>=</operator> <name>tbm_stream_free</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>is</name><operator>-&gt;</operator><name>set_instrument</name></name> <operator>=</operator> <name>tbm_stream_set_instrument</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>is</name><operator>-&gt;</operator><name>upd_instrument</name></name> <operator>=</operator> <name>tbm_stream_upd_instrument</name></expr>;</expr_stmt>

	<return>return <expr><name>is</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * IndexStream iteration callbacks
 */</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>index_stream_begin_iterate</name><parameter_list>(<parameter><decl><type><name>StreamNode</name> <modifier>*</modifier></type><name>self</name></decl></parameter>, <parameter><decl><type><name>StreamBMIterator</name> <modifier>*</modifier></type><name>iterator</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TIDBitmap</name> <modifier>*</modifier></type><name>tbm</name> <init>= <expr><name><name>self</name><operator>-&gt;</operator><name>opaque</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>iterator</name><operator>-&gt;</operator><name>pull</name></name> <operator>=</operator> <name>tbm_stream_block</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>iterator</name><operator>-&gt;</operator><name>end_iterate</name></name> <operator>=</operator> <name>index_stream_end_iterate</name></expr>;</expr_stmt>

	<comment type="block">/* Begin iterating on the underlying TIDBitmap. */</comment>
	<expr_stmt><expr><name><name>iterator</name><operator>-&gt;</operator><name>input</name><operator>.</operator><name>hash</name></name> <operator>=</operator> <call><name>tbm_begin_iterate</name><argument_list>(<argument><expr><name>tbm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>index_stream_end_iterate</name><parameter_list>(<parameter><decl><type><name>StreamBMIterator</name> <modifier>*</modifier></type><name>self</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>tbm_end_iterate</name><argument_list>(<argument><expr><name><name>self</name><operator>-&gt;</operator><name>input</name><operator>.</operator><name>hash</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * tbm_stream_block() - Fetch the next block from TIDBitmap stream
 *
 * Notice that the IndexStream passed in as opaque will tell us the
 * desired block to stream. If the block requrested is greater than or equal
 * to the block we've cached inside the iterator, return that.
 */</comment>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>tbm_stream_block</name><parameter_list>(<parameter><decl><type><name>StreamBMIterator</name> <modifier>*</modifier></type><name>iterator</name></decl></parameter>, <parameter><decl><type><name>PagetableEntry</name> <modifier>*</modifier></type><name>e</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TBMIterator</name> <modifier>*</modifier></type><name>hashIterator</name> <init>= <expr><name><name>iterator</name><operator>-&gt;</operator><name>input</name><operator>.</operator><name>hash</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PagetableEntry</name> <modifier>*</modifier></type><name>next</name> <init>= <expr><name><name>iterator</name><operator>-&gt;</operator><name>nextentry</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>more</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>iterator</name><operator>-&gt;</operator><name>node</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>BMS_INDEX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* have we already got an entry? */</comment>
	<if_stmt><if>if <condition>(<expr><name>next</name> <operator>&amp;&amp;</operator> <name><name>iterator</name><operator>-&gt;</operator><name>nextblock</name></name> <operator>&lt;=</operator> <name><name>next</name><operator>-&gt;</operator><name>blockno</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>next</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PagetableEntry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* we need a new entry */</comment>
	<expr_stmt><expr><name><name>iterator</name><operator>-&gt;</operator><name>nextentry</name></name> <operator>=</operator> <call><name>tbm_next_page</name><argument_list>(<argument><expr><name>hashIterator</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>more</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>more</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>iterator</name><operator>-&gt;</operator><name>nextentry</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name><name>iterator</name><operator>-&gt;</operator><name>nextentry</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PagetableEntry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name><name>iterator</name><operator>-&gt;</operator><name>nextblock</name></name><operator>++</operator></expr>;</expr_stmt>
	<return>return <expr><name>more</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>tbm_stream_free</name><parameter_list>(<parameter><decl><type><name>StreamNode</name> <modifier>*</modifier></type><name>self</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TIDBitmap</name> <modifier>*</modifier></type><name>tbm</name> <init>= <expr><name><name>self</name><operator>-&gt;</operator><name>opaque</name></name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>self</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>BMS_INDEX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>tbm_free</name><argument_list>(<argument><expr><name>tbm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>tbm_stream_set_instrument</name><parameter_list>(<parameter><decl><type><name>StreamNode</name> <modifier>*</modifier></type><name>self</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>Instrumentation</name></name> <modifier>*</modifier></type><name>instr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TIDBitmap</name> <modifier>*</modifier></type><name>tbm</name> <init>= <expr><name><name>self</name><operator>-&gt;</operator><name>opaque</name></name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>self</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>BMS_INDEX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>tbm_set_instrument</name><argument_list>(<argument><expr><name>tbm</name></expr></argument>, <argument><expr><name>instr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>tbm_stream_upd_instrument</name><parameter_list>(<parameter><decl><type><name>StreamNode</name> <modifier>*</modifier></type><name>self</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TIDBitmap</name> <modifier>*</modifier></type><name>tbm</name> <init>= <expr><name><name>self</name><operator>-&gt;</operator><name>opaque</name></name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>self</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>BMS_INDEX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>tbm_upd_instrument</name><argument_list>(<argument><expr><name>tbm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * OpStream iteration callbacks
 */</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>opstream_begin_iterate</name><parameter_list>(<parameter><decl><type><name>StreamNode</name> <modifier>*</modifier></type><name>self</name></decl></parameter>, <parameter><decl><type><name>StreamBMIterator</name> <modifier>*</modifier></type><name>iterator</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	 <modifier>*</modifier></type><name>input</name> <init>= <expr><name><name>self</name><operator>-&gt;</operator><name>opaque</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>iterator</name><operator>-&gt;</operator><name>pull</name></name> <operator>=</operator> <name>opstream_iterate</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>iterator</name><operator>-&gt;</operator><name>end_iterate</name></name> <operator>=</operator> <name>opstream_end_iterate</name></expr>;</expr_stmt>

	<comment type="block">/* Recursively initialize an iterator for each StreamNode. */</comment>
	<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>input</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>StreamNode</name> 		 <modifier>*</modifier></type><name>inNode</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>StreamBMIterator</name> <modifier>*</modifier></type><name>inIter</name> <init>= <expr><call><name>tbm_stream_begin_iterate</name><argument_list>(<argument><expr><name>inNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>iterator</name><operator>-&gt;</operator><name>input</name><operator>.</operator><name>stream</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>iterator</name><operator>-&gt;</operator><name>input</name><operator>.</operator><name>stream</name></name></expr></argument>, <argument><expr><name>inIter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>opstream_end_iterate</name><parameter_list>(<parameter><decl><type><name>StreamBMIterator</name> <modifier>*</modifier></type><name>self</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>

	<comment type="block">/* Recursively free all iterators in the stream "tree". */</comment>
	<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>self-&gt;input.stream</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>StreamBMIterator</name> <modifier>*</modifier></type><name>inIter</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>tbm_stream_end_iterate</name><argument_list>(<argument><expr><name>inIter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name><name>self</name><operator>-&gt;</operator><name>input</name><operator>.</operator><name>stream</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * opstream_iterate()
 *
 * This is an iterator for OpStreams. The function doesn't
 * know anything about the streams it is actually iterating.
 *
 * Returns false when no more results can be obtained, otherwise true.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>opstream_iterate</name><parameter_list>(<parameter><decl><type><name>StreamBMIterator</name> <modifier>*</modifier></type><name>iterator</name></decl></parameter>, <parameter><decl><type><name>PagetableEntry</name> <modifier>*</modifier></type><name>e</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>StreamNode</name>   <modifier>*</modifier></type><name>n</name> <init>= <expr><name><name>iterator</name><operator>-&gt;</operator><name>node</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>				<name>res</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * There are two ways we can do this: either, we could maintain our
	 * own top level BatchWords structure and pull blocks out of that OR
	 * we could maintain batch words for each sub map and union/intersect
	 * those together to get the resulting page entries.
	 *
	 * Now, BatchWords are specific to bitmap indexes so we'd have to
	 * translate TIDBitmaps. All the infrastructure is available to
	 * translate bitmap indexes into the TIDBitmap mechanism so we'll do
	 * that for now.
	 */</comment>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>map</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>minblockno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>wordnum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>matches</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>empty</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>BMS_OR</name> <operator>||</operator> <name><name>n</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>BMS_AND</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * First, iterate through each input bitmap stream and save the block
	 * which is returned. TIDBitmaps are designed such that they do not
	 * return blocks with no matches -- that is, say a TIDBitmap has
	 * matches for block 1, 4 and 5 it store matches only for those
	 * blocks. Therefore, we may have one stream return a match for block
	 * 10, another for block 15 and another yet for block 10 again. In
	 * this case, we cannot include block 15 in the union/intersection
	 * because it represents matches on some page later in the scan. We'll
	 * get around to it in good time.
	 *
	 * In this case, if we're doing a union, we perform the operation
	 * without reference to block 15. If we're performing an intersection
	 * we cannot perform it on block 10 because we didn't get any matches
	 * for block 10 for one of the streams: the intersection with fail.
	 * So, we set the desired block (op-&gt;nextblock) to block 15 and loop
	 * around to the `restart' label.
	 */</comment>
<label><name>restart</name>:</label>
	<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>blockno</name></name> <operator>=</operator> <name>InvalidBlockNumber</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>empty</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>matches</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>minblockno</name> <operator>=</operator> <name>InvalidBlockNumber</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>PointerIsValid</name><argument_list>(<argument><expr><name><name>iterator</name><operator>-&gt;</operator><name>input</name><operator>.</operator><name>stream</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>map</argument>, <argument>iterator-&gt;input.stream</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>StreamBMIterator</name> <modifier>*</modifier></type><name>inIter</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>map</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PagetableEntry</name> <modifier>*</modifier></type><name>new</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>r</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>new</name> <operator>=</operator> <operator>(</operator><name>PagetableEntry</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PagetableEntry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* set the desired block */</comment>
		<expr_stmt><expr><name><name>inIter</name><operator>-&gt;</operator><name>nextblock</name></name> <operator>=</operator> <name><name>iterator</name><operator>-&gt;</operator><name>nextblock</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name><name>inIter</name><operator>-&gt;</operator><name>pull</name></name><argument_list>(<argument><expr><name>inIter</name></expr></argument>, <argument><expr><name>new</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Let to caller know we got a result from some input bitmap. This
		 * doesn't hold true if we're doing an intersection, and that is
		 * handled below
		 */</comment>
		<expr_stmt><expr><name>res</name> <operator>=</operator> <name>res</name> <operator>||</operator> <name>r</name></expr>;</expr_stmt>

		<comment type="block">/* only include a match if the pull function tells us to */</comment>
		<if_stmt><if>if <condition>(<expr><name>r</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>minblockno</name> <operator>==</operator> <name>InvalidBlockNumber</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>minblockno</name> <operator>=</operator> <name><name>new</name><operator>-&gt;</operator><name>blockno</name></name></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><name><name>n</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>BMS_OR</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>minblockno</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>minblockno</name></expr></argument>, <argument><expr><name><name>new</name><operator>-&gt;</operator><name>blockno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>minblockno</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name>minblockno</name></expr></argument>, <argument><expr><name><name>new</name><operator>-&gt;</operator><name>blockno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<expr_stmt><expr><name>matches</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>matches</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>new</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>new</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>n</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>BMS_AND</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * No more results for this stream and since we're doing
				 * an intersection we wont get any valid results from now
				 * on, so tell our caller that
				 */</comment>
				<expr_stmt><expr><name><name>iterator</name><operator>-&gt;</operator><name>nextblock</name></name> <operator>=</operator> <name>minblockno</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>	<comment type="block">/* seems safe */</comment>
				<return>return <expr><name>false</name></expr>;</return>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name><name>n</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>BMS_OR</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * Now we iterate through the actual matches and perform the desired
	 * operation on those from the same minimum block
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>matches</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PagetableEntry</name> <modifier>*</modifier></type><name>tmp</name> <init>= <expr><operator>(</operator><name>PagetableEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>tmp</name><operator>-&gt;</operator><name>blockno</name></name> <operator>==</operator> <name>minblockno</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>e</name><operator>-&gt;</operator><name>blockno</name></name> <operator>==</operator> <name>InvalidBlockNumber</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PagetableEntry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* already initialised, so OR/AND together */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>tmp</name><operator>-&gt;</operator><name>ischunk</name></name> <operator>==</operator> <name>true</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * Okay, new entry is lossy so match our output as lossy
				 */</comment>
				<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>ischunk</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<comment type="block">/* XXX: we can just return now... I think :) */</comment>
				<expr_stmt><expr><name><name>iterator</name><operator>-&gt;</operator><name>nextblock</name></name> <operator>=</operator> <name>minblockno</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>list_free_deep</name><argument_list>(<argument><expr><name>matches</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>res</name></expr>;</return>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* union/intersect existing output and new matches */</comment>
			<for>for <control>(<init><expr><name>wordnum</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>wordnum</name> <operator>&lt;</operator> <name>WORDS_PER_PAGE</name></expr>;</condition> <incr><expr><name>wordnum</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>n</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>BMS_OR</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>words</name><index>[<expr><name>wordnum</name></expr>]</index></name> <operator>|=</operator> <name><name>tmp</name><operator>-&gt;</operator><name>words</name><index>[<expr><name>wordnum</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>words</name><index>[<expr><name>wordnum</name></expr>]</index></name> <operator>&amp;=</operator> <name><name>tmp</name><operator>-&gt;</operator><name>words</name><index>[<expr><name>wordnum</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block></for>
			<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>recheck</name></name> <operator>|=</operator> <name><name>tmp</name><operator>-&gt;</operator><name>recheck</name></name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>n</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>BMS_AND</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * One of our input maps didn't return a block for the desired
			 * block number so, we loop around again.
			 *
			 * Notice that we don't set the next block as minblockno + 1.
			 * We don't know if the other streams will find a match for
			 * minblockno, so we cannot skip past it yet.
			 */</comment>

			<expr_stmt><expr><name><name>iterator</name><operator>-&gt;</operator><name>nextblock</name></name> <operator>=</operator> <name>minblockno</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>empty</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>
	<if_stmt><if>if <condition>(<expr><name>empty</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* start again */</comment>
		<expr_stmt><expr><name>empty</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name><name>e</name><operator>-&gt;</operator><name>words</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>tbm_bitmapword</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>WORDS_PER_PAGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>list_free_deep</name><argument_list>(<argument><expr><name>matches</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>restart</name>;</goto>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>list_free_deep</name><argument_list>(<argument><expr><name>matches</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>res</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>iterator</name><operator>-&gt;</operator><name>nextblock</name></name> <operator>=</operator> <name>minblockno</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * --------- These functions accept either TIDBitmap or StreamBitmap ---------
 */</comment>


<comment type="block">/*
 * tbm_generic_free - free a TIDBitmap or StreamBitmap
 */</comment>
<function><type><name>void</name></type>
<name>tbm_generic_free</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>bm</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>bm</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<switch>switch <condition>(<expr><name><name>bm</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>T_TIDBitmap</name></expr>:</case>
			<expr_stmt><expr><call><name>tbm_free</name><argument_list>(<argument><expr><operator>(</operator><name>TIDBitmap</name> <operator>*</operator><operator>)</operator> <name>bm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_StreamBitmap</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>StreamBitmap</name> <modifier>*</modifier></type><name>sbm</name> <init>= <expr><operator>(</operator><name>StreamBitmap</name> <operator>*</operator><operator>)</operator> <name>bm</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>StreamNode</name> <modifier>*</modifier></type><name>sn</name> <init>= <expr><name><name>sbm</name><operator>-&gt;</operator><name>streamNode</name></name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name><name>sbm</name><operator>-&gt;</operator><name>streamNode</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>sn</name> <operator>&amp;&amp;</operator> <name><name>sn</name><operator>-&gt;</operator><name>free</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name><name>sn</name><operator>-&gt;</operator><name>free</name></name><argument_list>(<argument><expr><name>sn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>sbm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<break>break;</break>
			</block_content>}</block>
		<default>default:</default>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>
</block_content>}</block></function>	<comment type="block">/* tbm_generic_free */</comment>


<comment type="block">/*
 * tbm_generic_set_instrument - attach caller's Instrumentation object to bitmap
 */</comment>
<function><type><name>void</name></type>
<name>tbm_generic_set_instrument</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>bm</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>Instrumentation</name></name> <modifier>*</modifier></type><name>instr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>bm</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<switch>switch <condition>(<expr><name><name>bm</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>T_TIDBitmap</name></expr>:</case>
			<expr_stmt><expr><call><name>tbm_set_instrument</name><argument_list>(<argument><expr><operator>(</operator><name>TIDBitmap</name> <operator>*</operator><operator>)</operator> <name>bm</name></expr></argument>, <argument><expr><name>instr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_StreamBitmap</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>StreamBitmap</name> <modifier>*</modifier></type><name>sbm</name> <init>= <expr><operator>(</operator><name>StreamBitmap</name> <operator>*</operator><operator>)</operator> <name>bm</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>sbm</name><operator>-&gt;</operator><name>streamNode</name></name> <operator>&amp;&amp;</operator>
					<name><name>sbm</name><operator>-&gt;</operator><name>streamNode</name><operator>-&gt;</operator><name>set_instrument</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name><name>sbm</name><operator>-&gt;</operator><name>streamNode</name><operator>-&gt;</operator><name>set_instrument</name></name><argument_list>(<argument><expr><name><name>sbm</name><operator>-&gt;</operator><name>streamNode</name></name></expr></argument>, <argument><expr><name>instr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<break>break;</break>
			</block_content>}</block>
		<default>default:</default>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>
</block_content>}</block></function>	<comment type="block">/* tbm_generic_set_instrument */</comment>


<comment type="block">/*
 * tbm_generic_upd_instrument - update stats in caller's Instrumentation object
 *
 * Some callers don't bother to tbm_free() their bitmaps, but let the storage
 * be reclaimed when the MemoryContext is reset.  Such callers should use this
 * function to make sure the statistics are transferred to the Instrumentation
 * object before the bitmap goes away.
 */</comment>
<function><type><name>void</name></type>
<name>tbm_generic_upd_instrument</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>bm</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>bm</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<switch>switch <condition>(<expr><name><name>bm</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>T_TIDBitmap</name></expr>:</case>
			<expr_stmt><expr><call><name>tbm_upd_instrument</name><argument_list>(<argument><expr><operator>(</operator><name>TIDBitmap</name> <operator>*</operator><operator>)</operator> <name>bm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_StreamBitmap</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>StreamBitmap</name> <modifier>*</modifier></type><name>sbm</name> <init>= <expr><operator>(</operator><name>StreamBitmap</name> <operator>*</operator><operator>)</operator> <name>bm</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>sbm</name><operator>-&gt;</operator><name>streamNode</name></name> <operator>&amp;&amp;</operator>
					<name><name>sbm</name><operator>-&gt;</operator><name>streamNode</name><operator>-&gt;</operator><name>upd_instrument</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name><name>sbm</name><operator>-&gt;</operator><name>streamNode</name><operator>-&gt;</operator><name>upd_instrument</name></name><argument_list>(<argument><expr><name><name>sbm</name><operator>-&gt;</operator><name>streamNode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<break>break;</break>
			</block_content>}</block>
		<default>default:</default>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>
</block_content>}</block></function>	<comment type="block">/* tbm_generic_upd_instrument */</comment>

<function><type><name>void</name></type>
<name>tbm_convert_appendonly_tid_out</name><parameter_list>(<parameter><decl><type><name>ItemPointer</name></type> <name>psudeoHeapTid</name></decl></parameter>, <parameter><decl><type><name>AOTupleId</name> <modifier>*</modifier></type><name>aoTid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* UNDONE: For now, just copy. */</comment>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>aoTid</name></expr></argument>, <argument><expr><name>psudeoHeapTid</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ItemPointerData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
