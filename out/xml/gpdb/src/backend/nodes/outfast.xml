<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/backend/nodes/outfast.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * outfast.c
 *	  Fast serialization functions for Postgres tree nodes.
 *
 * Portions Copyright (c) 2005-2010, Greenplum inc
 * Portions Copyright (c) 2012-Present VMware, Inc. or its affiliates.
 * Portions Copyright (c) 1996-2008, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * NOTES
 *	  Every node type that can appear in an Greenplum Database serialized query or plan
 *    tree must have an output function defined here.
 *
 * 	  There *MUST* be a one-to-one correspondence between this routine
 *    and readfast.c.  If not, you will likely crash the system.
 *
 *     By design, the only user of these routines is the function
 *     serializeNode in cdbsrlz.c.  Other callers beware.
 *
 *    Like readfast.c, this file borrows the definitions of most functions
 *    from outfuncs.c.
 *
 * 	  Rather than serialize to a (somewhat human-readable) string, these
 *    routines create a binary serialization via a simple depth-first walk
 *    of the tree.
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lib/stringinfo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/params.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/parsenodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/plannodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/datum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/heap.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbgang.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/workfile_mgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parsetree.h"</cpp:file></cpp:include>

<comment type="block">/*
 * Macros to simplify output of different kinds of fields.	Use these
 * wherever possible to reduce the chance for silly typos.	Note that these
 * hard-wire conventions about the names of the local variables in an Out
 * routine.
 */</comment>

<comment type="block">/*
 * Write the label for the node type.  nodelabel is accepted for
 * compatibility with outfuncs.c, but is ignored
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WRITE_NODE_TYPE</name><parameter_list>(<parameter><type><name>nodelabel</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>{ int16 nt =nodeTag(node); appendBinaryStringInfo(str, (const char *)&amp;nt, sizeof(int16)); }</cpp:value></cpp:define>

<comment type="block">/* Write an integer field  */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WRITE_INT_FIELD</name><parameter_list>(<parameter><type><name>fldname</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>{ appendBinaryStringInfo(str, (const char *)&amp;node-&gt;fldname, sizeof(int)); }</cpp:value></cpp:define>

<comment type="block">/* Write an integer field  */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WRITE_INT8_FIELD</name><parameter_list>(<parameter><type><name>fldname</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>{ appendBinaryStringInfo(str, (const char *)&amp;node-&gt;fldname, sizeof(int8)); }</cpp:value></cpp:define>

<comment type="block">/* Write an integer field  */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WRITE_INT16_FIELD</name><parameter_list>(<parameter><type><name>fldname</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>{ appendBinaryStringInfo(str, (const char *)&amp;node-&gt;fldname, sizeof(int16)); }</cpp:value></cpp:define>

<comment type="block">/* Write an unsigned integer field */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WRITE_UINT_FIELD</name><parameter_list>(<parameter><type><name>fldname</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>appendBinaryStringInfo(str, (const char *)&amp;node-&gt;fldname, sizeof(int))</cpp:value></cpp:define>

<comment type="block">/* Write an uint64 field */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WRITE_UINT64_FIELD</name><parameter_list>(<parameter><type><name>fldname</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>appendBinaryStringInfo(str, (const char *)&amp;node-&gt;fldname, sizeof(uint64))</cpp:value></cpp:define>

<comment type="block">/* Write an OID field (don't hard-wire assumption that OID is same as uint) */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WRITE_OID_FIELD</name><parameter_list>(<parameter><type><name>fldname</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>appendBinaryStringInfo(str, (const char *)&amp;node-&gt;fldname, sizeof(Oid))</cpp:value></cpp:define>

<comment type="block">/* Write a long-integer field */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WRITE_LONG_FIELD</name><parameter_list>(<parameter><type><name>fldname</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>appendBinaryStringInfo(str, (const char *)&amp;node-&gt;fldname, sizeof(long))</cpp:value></cpp:define>

<comment type="block">/* Write a char field (ie, one ascii character) */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WRITE_CHAR_FIELD</name><parameter_list>(<parameter><type><name>fldname</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>appendBinaryStringInfo(str, &amp;node-&gt;fldname, 1)</cpp:value></cpp:define>

<comment type="block">/* Write an enumerated-type field as an integer code */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WRITE_ENUM_FIELD</name><parameter_list>(<parameter><type><name>fldname</name></type></parameter>, <parameter><type><name>enumtype</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>{ int16 en=node-&gt;fldname; appendBinaryStringInfo(str, (const char *)&amp;en, sizeof(int16)); }</cpp:value></cpp:define>

<comment type="block">/* Write a float field --- the format is accepted but ignored (for compat with outfuncs.c)  */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WRITE_FLOAT_FIELD</name><parameter_list>(<parameter><type><name>fldname</name></type></parameter>,<parameter><type><name>format</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>appendBinaryStringInfo(str, (const char *)&amp;node-&gt;fldname, sizeof(double))</cpp:value></cpp:define>

<comment type="block">/* Write a boolean field */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WRITE_BOOL_FIELD</name><parameter_list>(<parameter><type><name>fldname</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>{ \
		char b = node-&gt;fldname ? 1 : 0; \
		appendBinaryStringInfo(str, (const char *)&amp;b, 1); }</cpp:value></cpp:define>

<comment type="block">/* Write a character-string (possibly NULL) varable */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WRITE_STRING_VAR</name><parameter_list>(<parameter><type><name>var</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>{ int slen = var != NULL ? strlen(var) : 0; \
		appendBinaryStringInfo(str, (const char *)&amp;slen, sizeof(int)); \
		if (slen&gt;0) appendBinaryStringInfo(str, var, slen);}</cpp:value></cpp:define>

<comment type="block">/* Write a character-string (possibly NULL) field */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WRITE_STRING_FIELD</name><parameter_list>(<parameter><type><name>fldname</name></type></parameter>)</parameter_list></cpp:macro>  <cpp:value>WRITE_STRING_VAR(node-&gt;fldname)</cpp:value></cpp:define>

<comment type="block">/* Write a parse location field (actually same as INT case) */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WRITE_LOCATION_FIELD</name><parameter_list>(<parameter><type><name>fldname</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>{ appendBinaryStringInfo(str, (const char *)&amp;node-&gt;fldname, sizeof(int)); }</cpp:value></cpp:define>

<comment type="block">/*
 * Write a Node field
 *
 * If compiled with GP_SERIALIZATION_DEBUG, write the field name in the
 * serialized form, and check that it matches in the read function
 * (READ_NODE_FIELD in readfast.c). That makes it much easier to debug bugs
 * where the out and read functions are not in sync, as you get an error
 * much earlier, and it can print the field name where the mismatch occurred.
 * It makes the serialized plans much larger, though, so we don't want to do
 * it production.
 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>GP_SERIALIZATION_DEBUG</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WRITE_NODE_FIELD</name><parameter_list>(<parameter><type><name>fldname</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>do { \
		const char *xx = CppAsString(fldname); \
		appendBinaryStringInfo(str, xx, strlen(xx) + 1); \
		(_outNode(str, node-&gt;fldname)); \
	} while (0)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WRITE_NODE_FIELD</name><parameter_list>(<parameter><type><name>fldname</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>(_outNode(str, node-&gt;fldname))</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block">/* Write a bitmapset field */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WRITE_BITMAPSET_FIELD</name><parameter_list>(<parameter><type><name>fldname</name></type></parameter>)</parameter_list></cpp:macro> \
	 <cpp:value>_outBitmapset(str, node-&gt;fldname)</cpp:value></cpp:define>

<comment type="block">/* Write a binary field */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WRITE_BINARY_FIELD</name><parameter_list>(<parameter><type><name>fldname</name></type></parameter>, <parameter><type><name>sz</name></type></parameter>)</parameter_list></cpp:macro> \
<cpp:value>{ appendBinaryStringInfo(str, (const char *) &amp;node-&gt;fldname, (sz)); }</cpp:value></cpp:define>

<comment type="block">/* Write a bytea field */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WRITE_BYTEA_FIELD</name><parameter_list>(<parameter><type><name>fldname</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>(_outDatum(str, PointerGetDatum(node-&gt;fldname), -1, false))</cpp:value></cpp:define>

<comment type="block">/* Write a dummy field -- value not displayable or copyable */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WRITE_DUMMY_FIELD</name><parameter_list>(<parameter><type><name>fldname</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>{ <comment type="block">/*int * dummy = 0; appendBinaryStringInfo(str,(const char *)&amp;dummy, sizeof(int *)) ;*/</comment> }</cpp:value></cpp:define>

	<comment type="block">/* Read an integer array */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WRITE_INT_ARRAY</name><parameter_list>(<parameter><type><name>fldname</name></type></parameter>, <parameter><type><name>count</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>StaticAssertStmt(sizeof(node-&gt;fldname[0]) == sizeof(int32), \
					 "WRITE_INT_ARRAY() used on wrong array type"); \
	if ( (count) &gt; 0 ) \
	{ \
		int i; \
		for(i = 0; i &lt; (count); i++) \
		{ \
			appendBinaryStringInfo(str, (const char *)&amp;node-&gt;fldname[i], sizeof(int32)); \
		} \
	}</cpp:value></cpp:define>

<comment type="block">/* Write a boolean array  */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WRITE_BOOL_ARRAY</name><parameter_list>(<parameter><type><name>fldname</name></type></parameter>, <parameter><type><name>count</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>if ( (count) &gt; 0 ) \
	{ \
		int i; \
		for(i = 0; i &lt; (count); i++) \
		{ \
			char b = node-&gt;fldname[i] ? 1 : 0;								\
			appendBinaryStringInfo(str, (const char *)&amp;b, 1); \
		} \
	}</cpp:value></cpp:define>

<comment type="block">/* Write an Trasnaction ID array  */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WRITE_XID_ARRAY</name><parameter_list>(<parameter><type><name>fldname</name></type></parameter>, <parameter><type><name>count</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>if ( (count) &gt; 0 ) \
	{ \
		int i; \
		for(i = 0; i &lt; (count); i++) \
		{ \
			appendBinaryStringInfo(str, (const char *)&amp;node-&gt;fldname[i], sizeof(TransactionId)); \
		} \
	}</cpp:value></cpp:define>

<comment type="block">/* Write an AttrNumber array  */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WRITE_ATTRNUMBER_ARRAY</name><parameter_list>(<parameter><type><name>fldname</name></type></parameter>, <parameter><type><name>count</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>if ( (count) &gt; 0 ) \
	{ \
		int i; \
		for(i = 0; i &lt; (count); i++) \
		{ \
			appendBinaryStringInfo(str, (const char *)&amp;node-&gt;fldname[i], sizeof(AttrNumber)); \
		} \
	}</cpp:value></cpp:define>

<comment type="block">/* Write an Oid array  */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WRITE_OID_ARRAY</name><parameter_list>(<parameter><type><name>fldname</name></type></parameter>, <parameter><type><name>count</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>if ( (count) &gt; 0 ) \
	{ \
		int i; \
		for(i = 0; i &lt; (count); i++) \
		{ \
			appendBinaryStringInfo(str, (const char *)&amp;node-&gt;fldname[i], sizeof(Oid)); \
		} \
	}</cpp:value></cpp:define>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>_outNode</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>obj</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>outDatum</name><parameter_list>(<parameter><type><name>str</name></type></parameter>, <parameter><type><name>value</name></type></parameter>, <parameter><type><name>typlen</name></type></parameter>, <parameter><type><name>typbyval</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>_outDatum(str, value, typlen, typbyval)</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outList</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int16</name></type> <name>tg</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>tg</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int16</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>node</argument>)</argument_list></macro>
	<block>{<block_content>

		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>List</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>_outNode</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>IntList</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>n</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>OidList</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type> <name>n</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>n</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 * _outBitmapset -
 *	   converts a bitmap set of integers
 *
 * Currently bitmapsets do not appear in any node type that is stored in
 * rules, so there is no support in readfast.c for reading this format.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outBitmapset</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Bitmapset</name> <modifier>*</modifier></type><name>bms</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nwords</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>bms</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>nwords</name> <operator>=</operator> <name><name>bms</name><operator>-&gt;</operator><name>nwords</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>nwords</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nwords</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>bms</name><operator>-&gt;</operator><name>words</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bitmapword</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

</block_content>}</block></function>

<comment type="block">/*
 * Print the value of a Datum given its type.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outDatum</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>typlen</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>typbyval</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Size</name></type>		<name>length</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>typbyval</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>s</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>&amp;</operator><name>value</name><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>s</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PointerIsValid</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>length</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>length</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Size</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>typlen</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <call><name>VARATT_IS_EXTERNAL_EXPANDED</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ExpandedObjectHeader</name> <modifier>*</modifier></type><name>eoh</name> <init>= <expr><call><name>DatumGetEOHP</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Size</name></type>		<name>resultsize</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>char</name>		<modifier>*</modifier></type><name>resultptr</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>resultsize</name> <operator>=</operator> <call><name>EOH_get_flat_size</name><argument_list>(<argument><expr><name>eoh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>resultptr</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>resultsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>EOH_flatten_into</name><argument_list>(<argument><expr><name>eoh</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>resultptr</name></expr></argument>, <argument><expr><name>resultsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>resultsize</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Size</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>resultptr</name></expr></argument>, <argument><expr><name>resultsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><name>length</name> <operator>=</operator> <call><name>datumGetSize</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>typbyval</name></expr></argument>, <argument><expr><name>typlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>length</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Size</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COMPILING_BINARY_FUNCS</name></cpp:macro></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"outfuncs.c"</cpp:file></cpp:include>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outCopyStmt</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>CopyStmt</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"COPYSTMT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>attlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>is_from</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>is_program</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>sreh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/*****************************************************************************
 *
 *	Stuff from primnodes.h.
 *
 *****************************************************************************/</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outConst</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>Const</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"CONST"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>consttype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>consttypmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>constcollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>constlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>constbyval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>constisnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>node</name><operator>-&gt;</operator><name>constisnull</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>_outDatum</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>constvalue</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>constlen</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>constbyval</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outBoolExpr</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>BoolExpr</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"BOOLEXPR"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>boolop</name></expr></argument>, <argument><expr><name>BoolExprType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outCurrentOfExpr</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>CurrentOfExpr</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"CURRENTOFEXPR"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_UINT_FIELD</name><argument_list>(<argument><expr><name>cvarno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>cursor_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>cursor_param</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>target_relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outJoinExpr</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>JoinExpr</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"JOINEXPR"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>jointype</name></expr></argument>, <argument><expr><name>JoinType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>isNatural</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>larg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>rarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>usingClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>quals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>alias</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>rtindex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/*****************************************************************************
 *
 *	Stuff from extensible.h
 *
 *****************************************************************************/</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outExtensibleNode</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ExtensibleNode</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>ExtensibleNodeMethods</name> <modifier>*</modifier></type><name>methods</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>methods</name> <operator>=</operator> <call><name>GetExtensibleNodeMethods</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>extnodename</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"EXTENSIBLENODE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>extnodename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* serialize the private fields */</comment>
	<expr_stmt><expr><call><name><name>methods</name><operator>-&gt;</operator><name>nodeOut</name></name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_STRING_VAR</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/*****************************************************************************
 *
 *	Stuff from parsenodes.h.
 *
 *****************************************************************************/</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outCreateExtensionStmt</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>CreateExtensionStmt</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"CREATEEXTENSIONSTMT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>extname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>if_not_exists</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>create_ext_state</name></expr></argument>, <argument><expr><name>CreateExtensionState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outRoleSpec</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>RoleSpec</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"ROLESPEC"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>roletype</name></expr></argument>, <argument><expr><name>RoleSpecType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>rolename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outCreateDomainStmt</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>CreateDomainStmt</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"CREATEDOMAINSTMT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>domainname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>typeName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>collClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>constraints</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outAlterDomainStmt</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>AlterDomainStmt</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"ALTERDOMAINSTMT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_CHAR_FIELD</name><argument_list>(<argument><expr><name>subtype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>typeName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>def</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>behavior</name></expr></argument>, <argument><expr><name>DropBehavior</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>missing_ok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outAlterDatabaseStmt</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>AlterDatabaseStmt</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"ALTERDATABASESTMT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>dbname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outAlterDefaultPrivilegesStmt</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>AlterDefaultPrivilegesStmt</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"ALTERDEFAULTPRIVILEGESSTMT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>action</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outQuery</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"QUERY"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>commandType</name></expr></argument>, <argument><expr><name>CmdType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>querySource</name></expr></argument>, <argument><expr><name>QuerySource</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>canSetTag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>utilityStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>resultRelation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>hasAggs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>hasWindowFuncs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>hasSubLinks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>hasDynamicFunctions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>hasFuncsWithExecRestrictions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>hasDistinctOn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>hasRecursive</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>hasModifyingCTE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>hasForUpdate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>hasRowSecurity</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>canOptSelectLockingClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>cteList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>rtable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>jointree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>targetList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>withCheckOptions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>onConflict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>returningList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>groupClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>groupingSets</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>havingQual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>windowClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>distinctClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>sortClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>scatterClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>isTableValueSelect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>limitOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>limitCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>rowMarks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>setOperations</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>constraintDeps</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>parentStmtType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Don't serialize policy */</comment>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outAExpr</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>A_Expr</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"AEXPR"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>kind</name></expr></argument>, <argument><expr><name>A_Expr_Kind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>kind</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>AEXPR_OP</name></expr>:</case>

			<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AEXPR_OP_ANY</name></expr>:</case>

			<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<break>break;</break>
		<case>case <expr><name>AEXPR_OP_ALL</name></expr>:</case>

			<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<break>break;</break>
		<case>case <expr><name>AEXPR_DISTINCT</name></expr>:</case>

			<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AEXPR_NULLIF</name></expr>:</case>

			<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AEXPR_OF</name></expr>:</case>

			<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AEXPR_IN</name></expr>:</case>

			<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AEXPR_LIKE</name></expr>:</case>

			<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AEXPR_ILIKE</name></expr>:</case>

			<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AEXPR_SIMILAR</name></expr>:</case>

			<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AEXPR_BETWEEN</name></expr>:</case>

			<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AEXPR_NOT_BETWEEN</name></expr>:</case>

			<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AEXPR_BETWEEN_SYM</name></expr>:</case>

			<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AEXPR_NOT_BETWEEN_SYM</name></expr>:</case>

			<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AEXPR_PAREN</name></expr>:</case>

			<break>break;</break>

		<default>default:</default>

			<break>break;</break>
	</block_content>}</block></switch>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>lexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>rexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outValue</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>Value</name> <modifier>*</modifier></type><name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>

	<decl_stmt><decl><type><name>int16</name></type> <name>vt</name> <init>= <expr><name><name>value</name><operator>-&gt;</operator><name>type</name></name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>vt</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int16</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<switch>switch <condition>(<expr><name><name>value</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>T_Integer</name></expr>:</case>
			<expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>value</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>ival</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>long</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_Float</name></expr>:</case>
		<case>case <expr><name>T_String</name></expr>:</case>
		<case>case <expr><name>T_BitString</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>int</name></type> <name>slen</name> <init>= <expr><operator>(</operator><ternary><condition><expr><name><name>value</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>str</name></name> <operator>!=</operator> <name>NULL</name></expr> ?</condition><then> <expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>value</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>str</name></name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
				<expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>slen</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>slen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name><name>value</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>str</name></name></expr></argument>, <argument><expr><name>slen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_Null</name></expr>:</case>
			<comment type="block">/* nothing to do */</comment>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized node type: %d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>value</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outAConst</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>A_Const</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"A_CONST"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outValue</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>node</name><operator>-&gt;</operator><name>val</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/*CDB*/</comment>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outCreateQueueStmt</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>CreateQueueStmt</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"CREATEQUEUESTMT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>queue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* List of DefElem nodes */</comment>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outAlterQueueStmt</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>AlterQueueStmt</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"ALTERQUEUESTMT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>queue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* List of DefElem nodes */</comment>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outCreateResourceGroupStmt</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>CreateResourceGroupStmt</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"CREATERESOURCEGROUPSTMT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* List of DefElem nodes */</comment>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outAlterResourceGroupStmt</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>AlterResourceGroupStmt</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"ALTERRESOURCEGROUPSTMT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* List of DefElem nodes */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * Support for serializing TupleDescs and ParamListInfos.
 *
 * TupleDescs and ParamListInfos are not Nodes as such, but if you wrap them
 * in TupleDescNode and ParamListInfoNode structs, we allow serializing them.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outTupleDescNode</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>TupleDescNode</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>tuple</name><operator>-&gt;</operator><name>tdtypeid</name></name> <operator>==</operator> <name>RECORDOID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"TUPLEDESCNODE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>natts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name><name>tuple</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>node</name><operator>-&gt;</operator><name>tuple</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>tuple</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>ATTRIBUTE_FIXED_PART_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>tuple</name><operator>-&gt;</operator><name>constr</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name><name>tuple</name><operator>-&gt;</operator><name>tdtypeid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name><name>tuple</name><operator>-&gt;</operator><name>tdtypmod</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name><name>tuple</name><operator>-&gt;</operator><name>tdrefcount</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outCookedConstraint</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>CookedConstraint</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"COOKEDCONSTRAINT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>contype</name></expr></argument>,<argument><expr><name>ConstrType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>is_local</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>inhcount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>is_no_inherit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outAlterEnumStmt</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>AlterEnumStmt</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"ALTERENUMSTMT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>typeName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>oldVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>newVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>newValNeighbor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>newValIsAfter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>skipIfNewValExists</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outCreateFdwStmt</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>CreateFdwStmt</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"CREATEFDWSTMT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>fdwname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>func_options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outAlterFdwStmt</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>AlterFdwStmt</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"ALTERFDWSTMT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>fdwname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>func_options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outCreateForeignServerStmt</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>CreateForeignServerStmt</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"CREATEFOREIGNSERVERSTMT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>servername</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>servertype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>version</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>fdwname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outAlterForeignServerStmt</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>AlterForeignServerStmt</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"ALTERFOREIGNSERVERSTMT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>servername</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>version</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>has_version</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outCreateUserMappingStmt</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>CreateUserMappingStmt</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"CREATEUSERMAPPINGSTMT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>user</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>servername</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outAlterUserMappingStmt</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>AlterUserMappingStmt</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"ALTERUSERMAPPINGSTMT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>user</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>servername</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outAlterObjectDependsStmt</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>AlterObjectDependsStmt</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"ALTEROBJECTDEPENDSSTMT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>objectType</name></expr></argument>,<argument><expr><name>ObjectType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>object</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>extname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outCustomScan</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CustomScan</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"CUSTOMSCAN"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outScanInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>Scan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_UINT_FIELD</name><argument_list>(<argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>custom_plans</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>custom_exprs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>custom_private</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>custom_scan_tlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name>custom_relids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name><name>methods</name><operator>-&gt;</operator><name>CustomName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outDropUserMappingStmt</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>DropUserMappingStmt</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"DROPUSERMAPPINGSTMT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>user</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>servername</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>missing_ok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outAccessPriv</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>AccessPriv</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"ACCESSPRIV"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>priv_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>cols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outGpPolicy</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>GpPolicy</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"GPPOLICY"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>ptype</name></expr></argument>, <argument><expr><name>GpPolicyType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>numsegments</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>nattrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_ATTRNUMBER_ARRAY</name><argument_list>(<argument><expr><name>attrs</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>nattrs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_ARRAY</name><argument_list>(<argument><expr><name>opclasses</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>nattrs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outAlterTableMoveAllStmt</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>AlterTableMoveAllStmt</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"ALTERTABLESPACEMOVESTMT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>orig_tablespacename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>objtype</name></expr></argument>, <argument><expr><name>ObjectType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>roles</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>new_tablespacename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>nowait</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outAlterTableSpaceOptionsStmt</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>AlterTableSpaceOptionsStmt</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"ALTERTABLESPACEOPTIONS"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>tablespacename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>isReset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outCreateAmStmt</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CreateAmStmt</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"CREATEAMSTMT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>amname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>handler_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>amtype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outAggExprId</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>AggExprId</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"AGGEXPRID"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outRowIdExpr</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>RowIdExpr</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"ROWIDEXPR"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>rowidexpr_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _outNode -
 *	  converts a Node into binary string and append it to 'str'
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outNode</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>obj</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>obj</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int16</name></type> <name>tg</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>tg</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int16</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>List</name></expr></argument>)</argument_list></call> <operator>||</operator><call><name>IsA</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>IntList</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>OidList</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>_outList</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>Integer</name></expr></argument>)</argument_list></call> <operator>||</operator>
			 <call><name>IsA</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>Float</name></expr></argument>)</argument_list></call> <operator>||</operator>
			 <call><name>IsA</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>String</name></expr></argument>)</argument_list></call> <operator>||</operator>
			 <call><name>IsA</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>Null</name></expr></argument>)</argument_list></call> <operator>||</operator>
			 <call><name>IsA</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>BitString</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>_outValue</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>T_PlannedStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outPlannedStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>,<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_QueryDispatchDesc</name></expr>:</case>
				<expr_stmt><expr><call><name>_outQueryDispatchDesc</name><argument_list>(<argument><expr><name>str</name></expr></argument>,<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_OidAssignment</name></expr>:</case>
				<expr_stmt><expr><call><name>_outOidAssignment</name><argument_list>(<argument><expr><name>str</name></expr></argument>,<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_Plan</name></expr>:</case>
				<expr_stmt><expr><call><name>_outPlan</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_Result</name></expr>:</case>
				<expr_stmt><expr><call><name>_outResult</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_ProjectSet</name></expr>:</case>
				<expr_stmt><expr><call><name>_outProjectSet</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_ModifyTable</name></expr>:</case>
				<expr_stmt><expr><call><name>_outModifyTable</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_Append</name></expr>:</case>
				<expr_stmt><expr><call><name>_outAppend</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_MergeAppend</name></expr>:</case>
				<expr_stmt><expr><call><name>_outMergeAppend</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_Sequence</name></expr>:</case>
				<expr_stmt><expr><call><name>_outSequence</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_RecursiveUnion</name></expr>:</case>
				<expr_stmt><expr><call><name>_outRecursiveUnion</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_BitmapAnd</name></expr>:</case>
				<expr_stmt><expr><call><name>_outBitmapAnd</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_BitmapOr</name></expr>:</case>
				<expr_stmt><expr><call><name>_outBitmapOr</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_Gather</name></expr>:</case>
				<expr_stmt><expr><call><name>_outGather</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_GatherMerge</name></expr>:</case>
				<expr_stmt><expr><call><name>_outGatherMerge</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_Scan</name></expr>:</case>
				<expr_stmt><expr><call><name>_outScan</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_SeqScan</name></expr>:</case>
				<expr_stmt><expr><call><name>_outSeqScan</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_DynamicSeqScan</name></expr>:</case>
				<expr_stmt><expr><call><name>_outDynamicSeqScan</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_SampleScan</name></expr>:</case>
				<expr_stmt><expr><call><name>_outSampleScan</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_CteScan</name></expr>:</case>
				<expr_stmt><expr><call><name>_outCteScan</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_NamedTuplestoreScan</name></expr>:</case>
				<expr_stmt><expr><call><name>_outNamedTuplestoreScan</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_WorkTableScan</name></expr>:</case>
				<expr_stmt><expr><call><name>_outWorkTableScan</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_ForeignScan</name></expr>:</case>
				<expr_stmt><expr><call><name>_outForeignScan</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_CustomScan</name></expr>:</case>
				<expr_stmt><expr><call><name>_outCustomScan</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_ExternalScanInfo</name></expr>:</case>
				<expr_stmt><expr><call><name>_outExternalScanInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_IndexScan</name></expr>:</case>
				<expr_stmt><expr><call><name>_outIndexScan</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_IndexOnlyScan</name></expr>:</case>
				<expr_stmt><expr><call><name>_outIndexOnlyScan</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_DynamicIndexScan</name></expr>:</case>
				<expr_stmt><expr><call><name>_outDynamicIndexScan</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_BitmapIndexScan</name></expr>:</case>
				<expr_stmt><expr><call><name>_outBitmapIndexScan</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_DynamicBitmapIndexScan</name></expr>:</case>
				<expr_stmt><expr><call><name>_outDynamicBitmapIndexScan</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_BitmapHeapScan</name></expr>:</case>
				<expr_stmt><expr><call><name>_outBitmapHeapScan</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_DynamicBitmapHeapScan</name></expr>:</case>
				<expr_stmt><expr><call><name>_outDynamicBitmapHeapScan</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_TidScan</name></expr>:</case>
				<expr_stmt><expr><call><name>_outTidScan</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_SubqueryScan</name></expr>:</case>
				<expr_stmt><expr><call><name>_outSubqueryScan</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_FunctionScan</name></expr>:</case>
				<expr_stmt><expr><call><name>_outFunctionScan</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_TableFuncScan</name></expr>:</case>
				<expr_stmt><expr><call><name>_outTableFuncScan</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_ValuesScan</name></expr>:</case>
				<expr_stmt><expr><call><name>_outValuesScan</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_Join</name></expr>:</case>
				<expr_stmt><expr><call><name>_outJoin</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_NestLoop</name></expr>:</case>
				<expr_stmt><expr><call><name>_outNestLoop</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_MergeJoin</name></expr>:</case>
				<expr_stmt><expr><call><name>_outMergeJoin</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_HashJoin</name></expr>:</case>
				<expr_stmt><expr><call><name>_outHashJoin</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_Agg</name></expr>:</case>
				<expr_stmt><expr><call><name>_outAgg</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_TupleSplit</name></expr>:</case>
				<expr_stmt><expr><call><name>_outTupleSplit</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_DQAExpr</name></expr>:</case>
				<expr_stmt><expr><call><name>_outDQAExpr</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_WindowAgg</name></expr>:</case>
				<expr_stmt><expr><call><name>_outWindowAgg</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_TableFunctionScan</name></expr>:</case>
				<expr_stmt><expr><call><name>_outTableFunctionScan</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_Material</name></expr>:</case>
				<expr_stmt><expr><call><name>_outMaterial</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_ShareInputScan</name></expr>:</case>
				<expr_stmt><expr><call><name>_outShareInputScan</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_Sort</name></expr>:</case>
				<expr_stmt><expr><call><name>_outSort</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_Unique</name></expr>:</case>
				<expr_stmt><expr><call><name>_outUnique</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_SetOp</name></expr>:</case>
				<expr_stmt><expr><call><name>_outSetOp</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_LockRows</name></expr>:</case>
				<expr_stmt><expr><call><name>_outLockRows</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_Limit</name></expr>:</case>
				<expr_stmt><expr><call><name>_outLimit</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_NestLoopParam</name></expr>:</case>
				<expr_stmt><expr><call><name>_outNestLoopParam</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_PlanRowMark</name></expr>:</case>
				<expr_stmt><expr><call><name>_outPlanRowMark</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_PartitionPruneInfo</name></expr>:</case>
				<expr_stmt><expr><call><name>_outPartitionPruneInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_PartitionedRelPruneInfo</name></expr>:</case>
				<expr_stmt><expr><call><name>_outPartitionedRelPruneInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_PartitionPruneStepOp</name></expr>:</case>
				<expr_stmt><expr><call><name>_outPartitionPruneStepOp</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_PartitionPruneStepCombine</name></expr>:</case>
				<expr_stmt><expr><call><name>_outPartitionPruneStepCombine</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_Hash</name></expr>:</case>
				<expr_stmt><expr><call><name>_outHash</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_Motion</name></expr>:</case>
				<expr_stmt><expr><call><name>_outMotion</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_SplitUpdate</name></expr>:</case>
				<expr_stmt><expr><call><name>_outSplitUpdate</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_AssertOp</name></expr>:</case>
				<expr_stmt><expr><call><name>_outAssertOp</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_PartitionSelector</name></expr>:</case>
				<expr_stmt><expr><call><name>_outPartitionSelector</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_Alias</name></expr>:</case>
				<expr_stmt><expr><call><name>_outAlias</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_RangeVar</name></expr>:</case>
				<expr_stmt><expr><call><name>_outRangeVar</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_TableFunc</name></expr>:</case>
				<expr_stmt><expr><call><name>_outTableFunc</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_IntoClause</name></expr>:</case>
				<expr_stmt><expr><call><name>_outIntoClause</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_CopyIntoClause</name></expr>:</case>
				<expr_stmt><expr><call><name>_outCopyIntoClause</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_RefreshClause</name></expr>:</case>
				<expr_stmt><expr><call><name>_outRefreshClause</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_Var</name></expr>:</case>
				<expr_stmt><expr><call><name>_outVar</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_Const</name></expr>:</case>
				<expr_stmt><expr><call><name>_outConst</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_Param</name></expr>:</case>
				<expr_stmt><expr><call><name>_outParam</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_Aggref</name></expr>:</case>
				<expr_stmt><expr><call><name>_outAggref</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_GroupingFunc</name></expr>:</case>
				<expr_stmt><expr><call><name>_outGroupingFunc</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_GroupId</name></expr>:</case>
				<expr_stmt><expr><call><name>_outGroupId</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_GroupingSetId</name></expr>:</case>
				<expr_stmt><expr><call><name>_outGroupingSetId</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_WindowFunc</name></expr>:</case>
				<expr_stmt><expr><call><name>_outWindowFunc</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_SubscriptingRef</name></expr>:</case>
				<expr_stmt><expr><call><name>_outSubscriptingRef</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_FuncExpr</name></expr>:</case>
				<expr_stmt><expr><call><name>_outFuncExpr</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_NamedArgExpr</name></expr>:</case>
				<expr_stmt><expr><call><name>_outNamedArgExpr</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_OpExpr</name></expr>:</case>
				<expr_stmt><expr><call><name>_outOpExpr</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_DistinctExpr</name></expr>:</case>
				<expr_stmt><expr><call><name>_outDistinctExpr</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_ScalarArrayOpExpr</name></expr>:</case>
				<expr_stmt><expr><call><name>_outScalarArrayOpExpr</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_BoolExpr</name></expr>:</case>
				<expr_stmt><expr><call><name>_outBoolExpr</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_SubLink</name></expr>:</case>
				<expr_stmt><expr><call><name>_outSubLink</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_SubPlan</name></expr>:</case>
				<expr_stmt><expr><call><name>_outSubPlan</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_AlternativeSubPlan</name></expr>:</case>
				<expr_stmt><expr><call><name>_outAlternativeSubPlan</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_FieldSelect</name></expr>:</case>
				<expr_stmt><expr><call><name>_outFieldSelect</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_FieldStore</name></expr>:</case>
				<expr_stmt><expr><call><name>_outFieldStore</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_RelabelType</name></expr>:</case>
				<expr_stmt><expr><call><name>_outRelabelType</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_CoerceViaIO</name></expr>:</case>
				<expr_stmt><expr><call><name>_outCoerceViaIO</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_ArrayCoerceExpr</name></expr>:</case>
				<expr_stmt><expr><call><name>_outArrayCoerceExpr</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_ConvertRowtypeExpr</name></expr>:</case>
				<expr_stmt><expr><call><name>_outConvertRowtypeExpr</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_CollateExpr</name></expr>:</case>
				<expr_stmt><expr><call><name>_outCollateExpr</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_CaseExpr</name></expr>:</case>
				<expr_stmt><expr><call><name>_outCaseExpr</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_CaseWhen</name></expr>:</case>
				<expr_stmt><expr><call><name>_outCaseWhen</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_CaseTestExpr</name></expr>:</case>
				<expr_stmt><expr><call><name>_outCaseTestExpr</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_ArrayExpr</name></expr>:</case>
				<expr_stmt><expr><call><name>_outArrayExpr</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_RowExpr</name></expr>:</case>
				<expr_stmt><expr><call><name>_outRowExpr</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_RowCompareExpr</name></expr>:</case>
				<expr_stmt><expr><call><name>_outRowCompareExpr</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_CoalesceExpr</name></expr>:</case>
				<expr_stmt><expr><call><name>_outCoalesceExpr</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_MinMaxExpr</name></expr>:</case>
				<expr_stmt><expr><call><name>_outMinMaxExpr</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_NullIfExpr</name></expr>:</case>
				<expr_stmt><expr><call><name>_outNullIfExpr</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_NullTest</name></expr>:</case>
				<expr_stmt><expr><call><name>_outNullTest</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_BooleanTest</name></expr>:</case>
				<expr_stmt><expr><call><name>_outBooleanTest</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_SQLValueFunction</name></expr>:</case>
				<expr_stmt><expr><call><name>_outSQLValueFunction</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_XmlExpr</name></expr>:</case>
				<expr_stmt><expr><call><name>_outXmlExpr</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_CoerceToDomain</name></expr>:</case>
				<expr_stmt><expr><call><name>_outCoerceToDomain</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_CoerceToDomainValue</name></expr>:</case>
				<expr_stmt><expr><call><name>_outCoerceToDomainValue</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_SetToDefault</name></expr>:</case>
				<expr_stmt><expr><call><name>_outSetToDefault</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_CurrentOfExpr</name></expr>:</case>
				<expr_stmt><expr><call><name>_outCurrentOfExpr</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_NextValueExpr</name></expr>:</case>
				<expr_stmt><expr><call><name>_outNextValueExpr</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_InferenceElem</name></expr>:</case>
				<expr_stmt><expr><call><name>_outInferenceElem</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_TargetEntry</name></expr>:</case>
				<expr_stmt><expr><call><name>_outTargetEntry</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_RangeTblRef</name></expr>:</case>
				<expr_stmt><expr><call><name>_outRangeTblRef</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_JoinExpr</name></expr>:</case>
				<expr_stmt><expr><call><name>_outJoinExpr</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_FromExpr</name></expr>:</case>
				<expr_stmt><expr><call><name>_outFromExpr</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_OnConflictExpr</name></expr>:</case>
				<expr_stmt><expr><call><name>_outOnConflictExpr</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_CreateExtensionStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outCreateExtensionStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_GrantStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outGrantStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_AccessPriv</name></expr>:</case>
				<expr_stmt><expr><call><name>_outAccessPriv</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_ObjectWithArgs</name></expr>:</case>
				<expr_stmt><expr><call><name>_outObjectWithArgs</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_GrantRoleStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outGrantRoleStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_LockStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outLockStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_ExtensibleNode</name></expr>:</case>
				<expr_stmt><expr><call><name>_outExtensibleNode</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_CreateStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outCreateStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_CreateForeignTableStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outCreateForeignTableStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_DistributionKeyElem</name></expr>:</case>
				<expr_stmt><expr><call><name>_outDistributionKeyElem</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_ColumnReferenceStorageDirective</name></expr>:</case>
				<expr_stmt><expr><call><name>_outColumnReferenceStorageDirective</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_RoleSpec</name></expr>:</case>
				<expr_stmt><expr><call><name>_outRoleSpec</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_SegfileMapNode</name></expr>:</case>
				<expr_stmt><expr><call><name>_outSegfileMapNode</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_ExtTableTypeDesc</name></expr>:</case>
				<expr_stmt><expr><call><name>_outExtTableTypeDesc</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
            <case>case <expr><name>T_CreateExternalStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outCreateExternalStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_IndexStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outIndexStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_ReindexStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outReindexStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_ConstraintsSetStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outConstraintsSetStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_CreateFunctionStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outCreateFunctionStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_FunctionParameter</name></expr>:</case>
				<expr_stmt><expr><call><name>_outFunctionParameter</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_AlterFunctionStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outAlterFunctionStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_AlterObjectDependsStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outAlterObjectDependsStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_DefineStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outDefineStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>,<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_CompositeTypeStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outCompositeTypeStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>,<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_CreateEnumStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outCreateEnumStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>,<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_CreateRangeStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outCreateRangeStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_AlterEnumStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outAlterEnumStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_CreateCastStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outCreateCastStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>,<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_CreateOpClassStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outCreateOpClassStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>,<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_CreateOpClassItem</name></expr>:</case>
				<expr_stmt><expr><call><name>_outCreateOpClassItem</name><argument_list>(<argument><expr><name>str</name></expr></argument>,<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_CreateOpFamilyStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outCreateOpFamilyStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>,<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_AlterOpFamilyStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outAlterOpFamilyStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>,<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_CreateConversionStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outCreateConversionStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>,<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>


			<case>case <expr><name>T_ViewStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outViewStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_RuleStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outRuleStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_DropStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outDropStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_DropOwnedStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outDropOwnedStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_ReassignOwnedStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outReassignOwnedStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_TruncateStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outTruncateStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_ReplicaIdentityStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outReplicaIdentityStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_AlterTableStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outAlterTableStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_AlterTableCmd</name></expr>:</case>
				<expr_stmt><expr><call><name>_outAlterTableCmd</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_AlteredTableInfo</name></expr>:</case>
				<expr_stmt><expr><call><name>_outAlteredTableInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_NewConstraint</name></expr>:</case>
				<expr_stmt><expr><call><name>_outNewConstraint</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_NewColumnValue</name></expr>:</case>
				<expr_stmt><expr><call><name>_outNewColumnValue</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_CreateRoleStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outCreateRoleStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_DropRoleStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outDropRoleStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_AlterRoleStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outAlterRoleStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_AlterRoleSetStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outAlterRoleSetStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_AlterSystemStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outAlterSystemStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_AlterObjectSchemaStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outAlterObjectSchemaStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_AlterOwnerStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outAlterOwnerStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_RenameStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outRenameStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_CreateSeqStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outCreateSeqStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_AlterSeqStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outAlterSeqStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_ClusterStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outClusterStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_CreatedbStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outCreatedbStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_DropdbStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outDropdbStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_CreateDomainStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outCreateDomainStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_AlterDatabaseStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outAlterDatabaseStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_AlterDomainStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outAlterDomainStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_AlterDefaultPrivilegesStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outAlterDefaultPrivilegesStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_TransactionStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outTransactionStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_CreateStatsStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outCreateStatsStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_NotifyStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outNotifyStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_DeclareCursorStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outDeclareCursorStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_SingleRowErrorDesc</name></expr>:</case>
				<expr_stmt><expr><call><name>_outSingleRowErrorDesc</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_CopyStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outCopyStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_SelectStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outSelectStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_InsertStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outInsertStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_DeleteStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outDeleteStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_UpdateStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outUpdateStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_ColumnDef</name></expr>:</case>
				<expr_stmt><expr><call><name>_outColumnDef</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_TypeName</name></expr>:</case>
				<expr_stmt><expr><call><name>_outTypeName</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_SortBy</name></expr>:</case>
				<expr_stmt><expr><call><name>_outSortBy</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_TypeCast</name></expr>:</case>
				<expr_stmt><expr><call><name>_outTypeCast</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_CollateClause</name></expr>:</case>
				<expr_stmt><expr><call><name>_outCollateClause</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_IndexElem</name></expr>:</case>
				<expr_stmt><expr><call><name>_outIndexElem</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_Query</name></expr>:</case>
				<expr_stmt><expr><call><name>_outQuery</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_WithCheckOption</name></expr>:</case>
				<expr_stmt><expr><call><name>_outWithCheckOption</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_SortGroupClause</name></expr>:</case>
				<expr_stmt><expr><call><name>_outSortGroupClause</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_GroupingSet</name></expr>:</case>
				<expr_stmt><expr><call><name>_outGroupingSet</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_WindowClause</name></expr>:</case>
				<expr_stmt><expr><call><name>_outWindowClause</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_RowMarkClause</name></expr>:</case>
				<expr_stmt><expr><call><name>_outRowMarkClause</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_WithClause</name></expr>:</case>
				<expr_stmt><expr><call><name>_outWithClause</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_CommonTableExpr</name></expr>:</case>
				<expr_stmt><expr><call><name>_outCommonTableExpr</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_SetOperationStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outSetOperationStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_RangeTblEntry</name></expr>:</case>
				<expr_stmt><expr><call><name>_outRangeTblEntry</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_RangeTblFunction</name></expr>:</case>
				<expr_stmt><expr><call><name>_outRangeTblFunction</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_TableSampleClause</name></expr>:</case>
				<expr_stmt><expr><call><name>_outTableSampleClause</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_A_Expr</name></expr>:</case>
				<expr_stmt><expr><call><name>_outAExpr</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_ColumnRef</name></expr>:</case>
				<expr_stmt><expr><call><name>_outColumnRef</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_ParamRef</name></expr>:</case>
				<expr_stmt><expr><call><name>_outParamRef</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_RawStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outRawStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_A_Const</name></expr>:</case>
				<expr_stmt><expr><call><name>_outAConst</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_A_Star</name></expr>:</case>
				<expr_stmt><expr><call><name>_outA_Star</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_A_Indices</name></expr>:</case>
				<expr_stmt><expr><call><name>_outA_Indices</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_A_Indirection</name></expr>:</case>
				<expr_stmt><expr><call><name>_outA_Indirection</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_A_ArrayExpr</name></expr>:</case>
				<expr_stmt><expr><call><name>_outA_ArrayExpr</name><argument_list>(<argument><expr><name>str</name></expr></argument>,<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_ResTarget</name></expr>:</case>
				<expr_stmt><expr><call><name>_outResTarget</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_MultiAssignRef</name></expr>:</case>
				<expr_stmt><expr><call><name>_outMultiAssignRef</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_Constraint</name></expr>:</case>
				<expr_stmt><expr><call><name>_outConstraint</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_FuncCall</name></expr>:</case>
				<expr_stmt><expr><call><name>_outFuncCall</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_DefElem</name></expr>:</case>
				<expr_stmt><expr><call><name>_outDefElem</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_TableLikeClause</name></expr>:</case>
				<expr_stmt><expr><call><name>_outTableLikeClause</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_LockingClause</name></expr>:</case>
				<expr_stmt><expr><call><name>_outLockingClause</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_XmlSerialize</name></expr>:</case>
				<expr_stmt><expr><call><name>_outXmlSerialize</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_TriggerTransition</name></expr>:</case>
				<expr_stmt><expr><call><name>_outTriggerTransition</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_PartitionElem</name></expr>:</case>
				<expr_stmt><expr><call><name>_outPartitionElem</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_PartitionSpec</name></expr>:</case>
				<expr_stmt><expr><call><name>_outPartitionSpec</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_PartitionBoundSpec</name></expr>:</case>
				<expr_stmt><expr><call><name>_outPartitionBoundSpec</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_PartitionRangeDatum</name></expr>:</case>
				<expr_stmt><expr><call><name>_outPartitionRangeDatum</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_PartitionCmd</name></expr>:</case>
				<expr_stmt><expr><call><name>_outPartitionCmd</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_GpAlterPartitionId</name></expr>:</case>
				<expr_stmt><expr><call><name>_outGpAlterPartitionId</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_GpDropPartitionCmd</name></expr>:</case>
				<expr_stmt><expr><call><name>_outGpDropPartitionCmd</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_GpAlterPartitionCmd</name></expr>:</case>
				<expr_stmt><expr><call><name>_outGpAlterPartitionCmd</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_CreateSchemaStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outCreateSchemaStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_CreatePLangStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outCreatePLangStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_VacuumStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outVacuumStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_VacuumRelation</name></expr>:</case>
				<expr_stmt><expr><call><name>_outVacuumRelation</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_CdbProcess</name></expr>:</case>
				<expr_stmt><expr><call><name>_outCdbProcess</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_SliceTable</name></expr>:</case>
				<expr_stmt><expr><call><name>_outSliceTable</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_CursorPosInfo</name></expr>:</case>
				<expr_stmt><expr><call><name>_outCursorPosInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_VariableSetStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outVariableSetStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_DMLActionExpr</name></expr>:</case>
				<expr_stmt><expr><call><name>_outDMLActionExpr</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_CreateTrigStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outCreateTrigStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_CreateTableSpaceStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outCreateTableSpaceStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_DropTableSpaceStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outDropTableSpaceStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_CreateQueueStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outCreateQueueStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_AlterQueueStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outAlterQueueStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_DropQueueStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outDropQueueStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_CreateResourceGroupStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outCreateResourceGroupStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_DropResourceGroupStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outDropResourceGroupStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_AlterResourceGroupStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outAlterResourceGroupStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

            <case>case <expr><name>T_CommentStmt</name></expr>:</case>
                <expr_stmt><expr><call><name>_outCommentStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
			<case>case <expr><name>T_TableValueExpr</name></expr>:</case>
				<expr_stmt><expr><call><name>_outTableValueExpr</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
			<case>case <expr><name>T_DenyLoginInterval</name></expr>:</case>
				<expr_stmt><expr><call><name>_outDenyLoginInterval</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_DenyLoginPoint</name></expr>:</case>
				<expr_stmt><expr><call><name>_outDenyLoginPoint</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_AlterTypeStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outAlterTypeStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_AlterExtensionStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outAlterExtensionStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_AlterExtensionContentsStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outAlterExtensionContentsStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_TupleDescNode</name></expr>:</case>
				<expr_stmt><expr><call><name>_outTupleDescNode</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_SerializedParams</name></expr>:</case>
				<expr_stmt><expr><call><name>_outSerializedParams</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_AlterTSConfigurationStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outAlterTSConfigurationStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_AlterTSDictionaryStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outAlterTSDictionaryStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_CookedConstraint</name></expr>:</case>
				<expr_stmt><expr><call><name>_outCookedConstraint</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_DropUserMappingStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outDropUserMappingStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_AlterUserMappingStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outAlterUserMappingStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_CreateUserMappingStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outCreateUserMappingStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_AlterForeignServerStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outAlterForeignServerStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_CreateForeignServerStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outCreateForeignServerStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_AlterFdwStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outAlterFdwStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_CreateFdwStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outCreateFdwStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_GpPolicy</name></expr>:</case>
				<expr_stmt><expr><call><name>_outGpPolicy</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_DistributedBy</name></expr>:</case>
				<expr_stmt><expr><call><name>_outDistributedBy</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_ImportForeignSchemaStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outImportForeignSchemaStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_AlterTableMoveAllStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outAlterTableMoveAllStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_AlterTableSpaceOptionsStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outAlterTableSpaceOptionsStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_CreatePublicationStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outCreatePublicationStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_AlterPublicationStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outAlterPublicationStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_CreateSubscriptionStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outCreateSubscriptionStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_DropSubscriptionStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outDropSubscriptionStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_AlterSubscriptionStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outAlterSubscriptionStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_CreatePolicyStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outCreatePolicyStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_AlterPolicyStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outAlterPolicyStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_CreateTransformStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outCreateTransformStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_CreateAmStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outCreateAmStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_AggExprId</name></expr>:</case>
				<expr_stmt><expr><call><name>_outAggExprId</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_RowIdExpr</name></expr>:</case>
				<expr_stmt><expr><call><name>_outRowIdExpr</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_RestrictInfo</name></expr>:</case>
				<expr_stmt><expr><call><name>_outRestrictInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<default>default:</default>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not serialize unrecognized node type: %d"</literal></expr></argument>,
						 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>nodeTag</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
		</block_content>}</block></switch>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * nodeToBinaryStringFast -
 *	   returns a binary representation of the Node as a palloc'd string
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>nodeToBinaryStringFast</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>obj</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>length</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>str</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int16</name></type> <name>tg</name> <init>= <expr><operator>(</operator><name>int16</name><operator>)</operator> <literal type="number">0xDEAD</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/* see stringinfo.h for an explanation of this maneuver */</comment>
	<expr_stmt><expr><call><name>initStringInfoOfSize</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><literal type="number">4096</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outNode</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Add something special at the end that we can check in readfast.c */</comment>
	<expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>tg</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int16</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>length</name> <operator>=</operator> <name><name>str</name><operator>.</operator><name>len</name></name></expr>;</expr_stmt>
	<return>return <expr><name><name>str</name><operator>.</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>
</unit>
