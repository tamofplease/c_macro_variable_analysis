<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/backend/nodes/readfast.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * readfast.c
 *	  Binary Reader functions for Postgres tree nodes.
 *
 * Portions Copyright (c) 2005-2010, Greenplum inc
 * Portions Copyright (c) 2012-Present VMware, Inc. or its affiliates.
 * Portions Copyright (c) 1996-2008, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 * These routines must be exactly the inverse of the routines in
 * outfast.c.
 *
 * For most node types, these routines are identical to the text reader
 * functions, in readfuncs.c. To avoid code duplication and merge hazards
 * (readfast.c is a Greenplum addon), most read routines borrow the source
 * definition from readfuncs.c, we just compile it with different READ_*
 * macros.
 *
 * The way that works is that readfast.c defines all the necessary macros,
 * as well as COMPILING_BINARY_FUNCS, and then #includes readfuncs.c. For
 * those node types where the binary and text functions are different,
 * the function in readfuncs.c is put in a #ifndef COMPILING_BINARY_FUNCS
 * block, and readfast.c provides the binary version of the function.
 * outfast.c and outfuncs.c have a similar relationship.
 *
 * By this, CDB could link only readfast.o (#includes readfuncs.c) to get all
 * the fast version deserializing functions, outfast.o likewise.
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;math.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/parsenodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/plannodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/readfuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/aocatalog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_class.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/heap.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbgang.h"</cpp:file></cpp:include>

<comment type="block">/*
 * Macros to simplify reading of different kinds of fields.  Use these
 * wherever possible to reduce the chance for silly typos.
 */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>READ_TEMP_LOCALS</name><parameter_list>()</parameter_list></cpp:macro></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>READ_LOCALS</name><parameter_list>(<parameter><type><name>nodeTypeName</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>nodeTypeName *local_node = makeNode(nodeTypeName)</cpp:value></cpp:define>

<comment type="block">/*
 * no difference between READ_LOCALS and READ_LOCALS_NO_FIELDS in readfast.c,
 * but define both for compatibility.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>READ_LOCALS_NO_FIELDS</name><parameter_list>(<parameter><type><name>nodeTypeName</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>READ_LOCALS(nodeTypeName)</cpp:value></cpp:define>

<comment type="block">/* Allocate non-node variable */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ALLOCATE_LOCAL</name><parameter_list>(<parameter><type><name>local</name></type></parameter>, <parameter><type><name>typeName</name></type></parameter>, <parameter><type><name>size</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>local = (typeName *)palloc0(sizeof(typeName) * size)</cpp:value></cpp:define>

<comment type="block">/* Read an integer field  */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>READ_INT_FIELD</name><parameter_list>(<parameter><type><name>fldname</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>memcpy(&amp;local_node-&gt;fldname, read_str_ptr, sizeof(int));  read_str_ptr+=sizeof(int)</cpp:value></cpp:define>

<comment type="block">/* Read an int8 field  */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>READ_INT8_FIELD</name><parameter_list>(<parameter><type><name>fldname</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>memcpy(&amp;local_node-&gt;fldname, read_str_ptr, sizeof(int8));  read_str_ptr+=sizeof(int8)</cpp:value></cpp:define>

<comment type="block">/* Read an int16 field  */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>READ_INT16_FIELD</name><parameter_list>(<parameter><type><name>fldname</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>memcpy(&amp;local_node-&gt;fldname, read_str_ptr, sizeof(int16));  read_str_ptr+=sizeof(int16)</cpp:value></cpp:define>

<comment type="block">/* Read an unsigned integer field) */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>READ_UINT_FIELD</name><parameter_list>(<parameter><type><name>fldname</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>memcpy(&amp;local_node-&gt;fldname, read_str_ptr, sizeof(int)); read_str_ptr+=sizeof(int)</cpp:value></cpp:define>

<comment type="block">/* Read an uint64 field) */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>READ_UINT64_FIELD</name><parameter_list>(<parameter><type><name>fldname</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>memcpy(&amp;local_node-&gt;fldname, read_str_ptr, sizeof(uint64)); read_str_ptr+=sizeof(uint64)</cpp:value></cpp:define>

<comment type="block">/* Read an OID field (don't hard-wire assumption that OID is same as uint) */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>READ_OID_FIELD</name><parameter_list>(<parameter><type><name>fldname</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>memcpy(&amp;local_node-&gt;fldname, read_str_ptr, sizeof(Oid)); read_str_ptr+=sizeof(Oid)</cpp:value></cpp:define>

<comment type="block">/* Read a long-integer field  */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>READ_LONG_FIELD</name><parameter_list>(<parameter><type><name>fldname</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>memcpy(&amp;local_node-&gt;fldname, read_str_ptr, sizeof(long)); read_str_ptr+=sizeof(long)</cpp:value></cpp:define>

<comment type="block">/* Read a char field (ie, one ascii character) */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>READ_CHAR_FIELD</name><parameter_list>(<parameter><type><name>fldname</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>memcpy(&amp;local_node-&gt;fldname, read_str_ptr, 1); read_str_ptr++</cpp:value></cpp:define>

<comment type="block">/* Read an enumerated-type field that was written as a short integer code */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>READ_ENUM_FIELD</name><parameter_list>(<parameter><type><name>fldname</name></type></parameter>, <parameter><type><name>enumtype</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>{ int16 ent; memcpy(&amp;ent, read_str_ptr, sizeof(int16));  read_str_ptr+=sizeof(int16);local_node-&gt;fldname = (enumtype) ent; }</cpp:value></cpp:define>

<comment type="block">/* Read a float field */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>READ_FLOAT_FIELD</name><parameter_list>(<parameter><type><name>fldname</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>memcpy(&amp;local_node-&gt;fldname, read_str_ptr, sizeof(double)); read_str_ptr+=sizeof(double)</cpp:value></cpp:define>

<comment type="block">/* Read a boolean field */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>READ_BOOL_FIELD</name><parameter_list>(<parameter><type><name>fldname</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>local_node-&gt;fldname = read_str_ptr[0] != 0;  Assert(read_str_ptr[0]==1 || read_str_ptr[0]==0); read_str_ptr++</cpp:value></cpp:define>

<comment type="block">/* Read a character-string variable */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>READ_STRING_VAR</name><parameter_list>(<parameter><type><name>var</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>{ int slen; char * nn = NULL; \
		memcpy(&amp;slen, read_str_ptr, sizeof(int)); \
		read_str_ptr+=sizeof(int); \
		if (slen&gt;0) { \
		    nn = palloc(slen+1); \
		    memcpy(nn,read_str_ptr,slen); \
		    read_str_ptr+=(slen); nn[slen]='\0'; \
		} \
		var = nn;  }</cpp:value></cpp:define>

<comment type="block">/* Read a character-string field */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>READ_STRING_FIELD</name><parameter_list>(<parameter><type><name>fldname</name></type></parameter>)</parameter_list></cpp:macro>  <cpp:value>READ_STRING_VAR(local_node-&gt;fldname)</cpp:value></cpp:define>

<comment type="block">/* Read a parse location field (and throw away the value, per notes above) */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>READ_LOCATION_FIELD</name><parameter_list>(<parameter><type><name>fldname</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>READ_INT_FIELD(fldname)</cpp:value></cpp:define>

<comment type="block">/* Read a Node field */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>GP_SERIALIZATION_DEBUG</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>READ_NODE_FIELD</name><parameter_list>(<parameter><type><name>fldname</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>do { \
		char *xexpected = CppAsString(fldname); \
		char got[100]; \
		\
		memcpy(got, read_str_ptr, strlen(xexpected) + 1); \
		read_str_ptr += strlen(xexpected) + 1; \
		if (strcmp(xexpected, got) != 0) \
			elog(ERROR, "deserialization lost sync: %s vs %02x%02x%02x", xexpected, (unsigned char) got[0], (unsigned char) got[1], (unsigned char) got[2]); \
		\
		local_node-&gt;fldname = readNodeBinary(); \
	} while(0)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>READ_NODE_FIELD</name><parameter_list>(<parameter><type><name>fldname</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>local_node-&gt;fldname = readNodeBinary()</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Read a bitmapset field */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>READ_BITMAPSET_FIELD</name><parameter_list>(<parameter><type><name>fldname</name></type></parameter>)</parameter_list></cpp:macro> \
	 <cpp:value>local_node-&gt;fldname = _readBitmapset()</cpp:value></cpp:define>

<comment type="block">/* Read in a binary field */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>READ_BINARY_FIELD</name><parameter_list>(<parameter><type><name>fldname</name></type></parameter>, <parameter><type><name>sz</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>memcpy(&amp;local_node-&gt;fldname, read_str_ptr, (sz)); read_str_ptr += (sz)</cpp:value></cpp:define>

<comment type="block">/* Read a bytea field */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>READ_BYTEA_FIELD</name><parameter_list>(<parameter><type><name>fldname</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>local_node-&gt;fldname = (bytea *) DatumGetPointer(readDatumBinary(false))</cpp:value></cpp:define>

<comment type="block">/* Read a dummy field */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>READ_DUMMY_FIELD</name><parameter_list>(<parameter><type><name>fldname</name></type></parameter>,<parameter><type><name>fldvalue</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>{ local_node-&gt;fldname = (0); <comment type="block">/*read_str_ptr += sizeof(int*);*/</comment> }</cpp:value></cpp:define>

<comment type="block">/* Routine exit */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>READ_DONE</name><parameter_list>()</parameter_list></cpp:macro> \
	<cpp:value>return local_node</cpp:value></cpp:define>

<comment type="block">/* Read an integer array  */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>READ_ARRAY_OF_TYPE</name><parameter_list>(<parameter><type><name>fldname</name></type></parameter>, <parameter><type><name>count</name></type></parameter>, <parameter><type><name>Type</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>if ( (count) &gt; 0 ) \
	{ \
		int i; \
		local_node-&gt;fldname = (Type *)palloc((count) * sizeof(Type)); \
		for(i = 0; i &lt; (count); i++) \
		{ \
			memcpy(&amp;local_node-&gt;fldname[i], read_str_ptr, sizeof(Type)); read_str_ptr+=sizeof(Type); \
		} \
	}</cpp:value></cpp:define>

<comment type="block">/* Read a bool array  */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>READ_BOOL_ARRAY</name><parameter_list>(<parameter><type><name>fldname</name></type></parameter>, <parameter><type><name>count</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>if ( (count) &gt; 0 ) \
	{ \
		int i; \
		local_node-&gt;fldname = (bool *) palloc((count) * sizeof(bool)); \
		for(i = 0; i &lt; (count); i++) \
		{ \
			local_node-&gt;fldname[i] = *read_str_ptr ? true : false; \
			read_str_ptr++; \
		} \
	}</cpp:value></cpp:define>

<comment type="block">/* Read an attribute number array  */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>READ_ATTRNUMBER_ARRAY</name><parameter_list>(<parameter><type><name>fldname</name></type></parameter>, <parameter><type><name>count</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>READ_ARRAY_OF_TYPE(fldname, count, AttrNumber)</cpp:value></cpp:define>

<comment type="block">/* Read an Oid array  */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>READ_OID_ARRAY</name><parameter_list>(<parameter><type><name>fldname</name></type></parameter>, <parameter><type><name>count</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>READ_ARRAY_OF_TYPE(fldname, count, Oid)</cpp:value></cpp:define>

<comment type="block">/* Read an int array  */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>READ_INT_ARRAY</name><parameter_list>(<parameter><type><name>fldname</name></type></parameter>, <parameter><type><name>count</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>READ_ARRAY_OF_TYPE(fldname, count, int)</cpp:value></cpp:define>


<function_decl><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type><name>readNodeBinary</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>Datum</name></type> <name>readDatumBinary</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>typbyval</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>readDatum</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>readDatumBinary(x)</cpp:value></cpp:define>

<function_decl><type><specifier>static</specifier> <name>Bitmapset</name> <modifier>*</modifier></type><name>_readBitmapset</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * Current position in the message that we are processing. We can keep
 * this in a global variable because readNodeFromBinaryString() is not
 * re-entrant. This is similar to the current position that pg_strtok()
 * keeps, used by the normal stringToNode() function.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>read_str_ptr</name></decl>;</decl_stmt>

<comment type="block">/*
 * For most structs, we reuse the definitions from readfuncs.c. See comment
 * in readfuncs.c.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COMPILING_BINARY_FUNCS</name></cpp:macro></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"readfuncs.c"</cpp:file></cpp:include>

<comment type="block">/*
 * For some structs, we have to provide a read functions because it differs
 * from the text version (or the text version doesn't exist at all).
 */</comment>

<comment type="block">/*
 * _readQuery
 */</comment>
<function><type><specifier>static</specifier> <name>Query</name> <modifier>*</modifier></type>
<name>_readQuery</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name>commandType</name></expr></argument>, <argument><expr><name>CmdType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>local_node</name><operator>-&gt;</operator><name>commandType</name></name> <operator>&lt;=</operator> <name>CMD_NOTHING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name>querySource</name></expr></argument>, <argument><expr><name>QuerySource</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>local_node</name><operator>-&gt;</operator><name>querySource</name></name> <operator>&lt;=</operator> <name>QSRC_PLANNER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>canSetTag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>utilityStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>resultRelation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>hasAggs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>hasWindowFuncs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>hasSubLinks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>hasDynamicFunctions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>hasFuncsWithExecRestrictions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>hasDistinctOn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>hasRecursive</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>hasModifyingCTE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>hasForUpdate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>hasRowSecurity</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>canOptSelectLockingClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>cteList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>rtable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>jointree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>targetList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>withCheckOptions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>onConflict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>returningList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>groupClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>groupingSets</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>havingQual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>windowClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>distinctClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>sortClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>scatterClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>isTableValueSelect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>limitOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>limitCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>rowMarks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>setOperations</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>constraintDeps</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>parentStmtType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* policy not serialized */</comment>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>DMLActionExpr</name> <modifier>*</modifier></type>
<name>_readDMLActionExpr</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>DMLActionExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *	Stuff from primnodes.h.
 */</comment>

<comment type="block">/*
 * _readConst
 */</comment>
<function><type><specifier>static</specifier> <name>Const</name> <modifier>*</modifier></type>
<name>_readConst</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>consttype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>consttypmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>constcollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>constlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>constbyval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>constisnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>local_node</name><operator>-&gt;</operator><name>constisnull</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>local_node</name><operator>-&gt;</operator><name>constvalue</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>local_node</name><operator>-&gt;</operator><name>constvalue</name></name> <operator>=</operator> <call><name>readDatumBinary</name><argument_list>(<argument><expr><name><name>local_node</name><operator>-&gt;</operator><name>constbyval</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ResTarget</name> <modifier>*</modifier></type>
<name>_readResTarget</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>ResTarget</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_STRING_FIELD</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>indirection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>MultiAssignRef</name> <modifier>*</modifier></type>
<name>_readMultiAssignRef</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>MultiAssignRef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>source</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>colno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>ncolumns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>DropOwnedStmt</name> <modifier>*</modifier></type>
<name>_readDropOwnedStmt</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>DropOwnedStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>roles</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name>behavior</name></expr></argument>, <argument><expr><name>DropBehavior</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ReassignOwnedStmt</name> <modifier>*</modifier></type>
<name>_readReassignOwnedStmt</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>ReassignOwnedStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>roles</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>newrole</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>AlterObjectDependsStmt</name> <modifier>*</modifier></type>
<name>_readAlterObjectDependsStmt</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>AlterObjectDependsStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name>objectType</name></expr></argument>,<argument><expr><name>ObjectType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>object</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>extname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>SelectStmt</name> <modifier>*</modifier></type>
<name>_readSelectStmt</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>SelectStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>distinctClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>intoClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>targetList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>fromClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>whereClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>groupClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>havingClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>windowClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>valuesLists</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>sortClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>scatterClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>limitOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>limitCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>lockingClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>withClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>SetOperation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>all</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>larg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>rarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>disableLockingOptimization</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>InsertStmt</name> <modifier>*</modifier></type>
<name>_readInsertStmt</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>InsertStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>cols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>selectStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>returningList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>withClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>DeleteStmt</name> <modifier>*</modifier></type>
<name>_readDeleteStmt</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>DeleteStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>usingClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>whereClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>returningList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>withClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>UpdateStmt</name> <modifier>*</modifier></type>
<name>_readUpdateStmt</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>UpdateStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>targetList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>whereClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>fromClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>returningList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>withClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>A_Const</name> <modifier>*</modifier></type>
<name>_readAConst</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>A_Const</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name><name>val</name><operator>.</operator><name>type</name></name></expr></argument>, <argument><expr><name>NodeTag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><name><name>local_node</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>type</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>T_Integer</name></expr>:</case>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>local_node</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>val</name><operator>.</operator><name>ival</name></name></expr></argument>, <argument><expr><name>read_str_ptr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>long</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>read_str_ptr</name><operator>+=</operator><sizeof>sizeof<argument_list>(<argument><expr><name>long</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_Float</name></expr>:</case>
		<case>case <expr><name>T_String</name></expr>:</case>
		<case>case <expr><name>T_BitString</name></expr>:</case>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type> <name>slen</name></decl>;</decl_stmt> <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type> <name>nn</name></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>slen</name></expr></argument>, <argument><expr><name>read_str_ptr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>read_str_ptr</name><operator>+=</operator><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
			<expr_stmt><expr><name>nn</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>slen</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>nn</name></expr></argument>,<argument><expr><name>read_str_ptr</name></expr></argument>,<argument><expr><name>slen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>nn</name><index>[<expr><name>slen</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>local_node</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>val</name><operator>.</operator><name>str</name></name> <operator>=</operator> <name>nn</name></expr>;</expr_stmt> <expr_stmt><expr><name>read_str_ptr</name><operator>+=</operator><name>slen</name></expr>;</expr_stmt>
		</block_content>}</block>
			<break>break;</break>
	 	<case>case <expr><name>T_Null</name></expr>:</case>
	 	<default>default:</default>
	 		<break>break;</break>
	</block_content>}</block></switch>

    <expr_stmt><expr><call><name>READ_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>   <comment type="block">/*CDB*/</comment>
	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>A_Star</name> <modifier>*</modifier></type>
<name>_readA_Star</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>A_Star</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>A_Indices</name> <modifier>*</modifier></type>
<name>_readA_Indices</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>A_Indices</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>is_slice</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>lidx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>uidx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>A_Indirection</name> <modifier>*</modifier></type>
<name>_readA_Indirection</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>A_Indirection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>indirection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>RoleSpec</name> <modifier>*</modifier></type>
<name>_readRoleSpec</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>RoleSpec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name>roletype</name></expr></argument>, <argument><expr><name>RoleSpecType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_STRING_FIELD</name><argument_list>(<argument><expr><name>rolename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>A_Expr</name> <modifier>*</modifier></type>
<name>_readAExpr</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>A_Expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name>kind</name></expr></argument>, <argument><expr><name>A_Expr_Kind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>local_node</name><operator>-&gt;</operator><name>kind</name></name> <operator>&lt;=</operator> <name>AEXPR_PAREN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><name><name>local_node</name><operator>-&gt;</operator><name>kind</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>AEXPR_OP</name></expr>:</case>

			<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AEXPR_OP_ANY</name></expr>:</case>

			<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<break>break;</break>
		<case>case <expr><name>AEXPR_OP_ALL</name></expr>:</case>

			<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<break>break;</break>
		<case>case <expr><name>AEXPR_DISTINCT</name></expr>:</case>

			<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AEXPR_NULLIF</name></expr>:</case>

			<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AEXPR_OF</name></expr>:</case>

			<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AEXPR_IN</name></expr>:</case>

			<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AEXPR_LIKE</name></expr>:</case>

			<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AEXPR_ILIKE</name></expr>:</case>

			<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AEXPR_SIMILAR</name></expr>:</case>

			<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AEXPR_BETWEEN</name></expr>:</case>

			<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AEXPR_NOT_BETWEEN</name></expr>:</case>

			<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AEXPR_BETWEEN_SYM</name></expr>:</case>

			<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AEXPR_NOT_BETWEEN_SYM</name></expr>:</case>

			<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AEXPR_PAREN</name></expr>:</case>

			<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,<argument><expr><literal type="string">"Unable to understand A_Expr node "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>lexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>rexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readOpExpr
 */</comment>
<function><type><specifier>static</specifier> <name>OpExpr</name> <modifier>*</modifier></type>
<name>_readOpExpr</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>OpExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>opno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>opfuncid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * The opfuncid is stored in the textual format primarily for debugging
	 * and documentation reasons.  We want to always read it as zero to force
	 * it to be re-looked-up in the pg_operator entry.	This ensures that
	 * stored rules don't have hidden dependencies on operators' functions.
	 * (We don't currently support an ALTER OPERATOR command, but might
	 * someday.)
	 */</comment>
<comment type="block">/*	local_node-&gt;opfuncid = InvalidOid; */</comment>

	<expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>opresulttype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>opretset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>opcollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>inputcollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readBoolExpr
 */</comment>
<function><type><specifier>static</specifier> <name>BoolExpr</name> <modifier>*</modifier></type>
<name>_readBoolExpr</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>BoolExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name>boolop</name></expr></argument>, <argument><expr><name>BoolExprType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *	Stuff from parsenodes.h.
 */</comment>


<comment type="block">/*
 * _readCollateClause
 */</comment>
<function><type><specifier>static</specifier> <name>CollateClause</name> <modifier>*</modifier></type>
<name>_readCollateClause</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>CollateClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>collname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ExtensibleNode</name> <modifier>*</modifier></type>
<name>_readExtensibleNode</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>ExtensibleNodeMethods</name> <modifier>*</modifier></type><name>methods</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExtensibleNode</name> <modifier>*</modifier></type><name>local_node</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>extnodename</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>save_strtok</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>save_begin</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type> <name>save_strtok_ptr</name> <init>= <expr><operator>&amp;</operator><name>save_strtok</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type> <name>save_begin_ptr</name> <init>= <expr><operator>&amp;</operator><name>save_begin</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>READ_STRING_VAR</name><argument_list>(<argument><expr><name>extnodename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>extnodename</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"extnodename has to be supplied"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>methods</name> <operator>=</operator> <call><name>GetExtensibleNodeMethods</name><argument_list>(<argument><expr><name>extnodename</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>local_node</name> <operator>=</operator> <operator>(</operator><name>ExtensibleNode</name> <operator>*</operator><operator>)</operator> <call><name>newNode</name><argument_list>(<argument><expr><name><name>methods</name><operator>-&gt;</operator><name>node_size</name></name></expr></argument>,
											<argument><expr><name>T_ExtensibleNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>local_node</name><operator>-&gt;</operator><name>extnodename</name></name> <operator>=</operator> <name>extnodename</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_STRING_VAR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * deserialize the private fields
	 */</comment>

	<comment type="block">/* set the states for pg_strtok(), let methods-&gt;nodeRead() to process str */</comment>
	<expr_stmt><expr><call><name>save_strtok_states</name><argument_list>(<argument><expr><name>save_strtok_ptr</name></expr></argument>, <argument><expr><name>save_begin_ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>set_strtok_states</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* do reading */</comment>
	<expr_stmt><expr><call><name><name>methods</name><operator>-&gt;</operator><name>nodeRead</name></name><argument_list>(<argument><expr><name>local_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* set the states for pg_strtok() back */</comment>
	<expr_stmt><expr><call><name>set_strtok_states</name><argument_list>(<argument><expr><name>save_strtok</name></expr></argument>, <argument><expr><name>save_begin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Greenplum Database additions for serialization support
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/plannodes.h"</cpp:file></cpp:include>

<function><type><specifier>static</specifier> <name>CreateExtensionStmt</name> <modifier>*</modifier></type>
<name>_readCreateExtensionStmt</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>CreateExtensionStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_STRING_FIELD</name><argument_list>(<argument><expr><name>extname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>if_not_exists</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name>create_ext_state</name></expr></argument>, <argument><expr><name>CreateExtensionState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_readCreateStmt_common</name><parameter_list>(<parameter><decl><type><name>CreateStmt</name> <modifier>*</modifier></type><name>local_node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>tableElts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>inhRelations</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>partspec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>partbound</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>ofTypename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>constraints</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name>oncommit</name></expr></argument>,<argument><expr><name>OnCommitAction</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_STRING_FIELD</name><argument_list>(<argument><expr><name>tablespacename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_STRING_FIELD</name><argument_list>(<argument><expr><name>accessMethod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>if_not_exists</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>gp_style_alter_part</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>distributedBy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>partitionBy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_CHAR_FIELD</name><argument_list>(<argument><expr><name>relKind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>ownerid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>buildAoBlkdir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>attr_encodings</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>isCtas</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>intoQuery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>intoPolicy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>part_idx_oids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>part_idx_names</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Some extra checks to make sure we didn't get lost
	 * during serialization/deserialization
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>local_node</name><operator>-&gt;</operator><name>relKind</name></name> <operator>==</operator> <name>RELKIND_RELATION</name> <operator>||</operator>
		   <name><name>local_node</name><operator>-&gt;</operator><name>relKind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name> <operator>||</operator>
		   <name><name>local_node</name><operator>-&gt;</operator><name>relKind</name></name> <operator>==</operator> <name>RELKIND_INDEX</name> <operator>||</operator>
		   <name><name>local_node</name><operator>-&gt;</operator><name>relKind</name></name> <operator>==</operator> <name>RELKIND_SEQUENCE</name> <operator>||</operator>
		   <name><name>local_node</name><operator>-&gt;</operator><name>relKind</name></name> <operator>==</operator> <name>RELKIND_TOASTVALUE</name> <operator>||</operator>
		   <name><name>local_node</name><operator>-&gt;</operator><name>relKind</name></name> <operator>==</operator> <name>RELKIND_VIEW</name> <operator>||</operator>
		   <name><name>local_node</name><operator>-&gt;</operator><name>relKind</name></name> <operator>==</operator> <name>RELKIND_COMPOSITE_TYPE</name> <operator>||</operator>
		   <name><name>local_node</name><operator>-&gt;</operator><name>relKind</name></name> <operator>==</operator> <name>RELKIND_FOREIGN_TABLE</name> <operator>||</operator>
		   <name><name>local_node</name><operator>-&gt;</operator><name>relKind</name></name> <operator>==</operator> <name>RELKIND_MATVIEW</name> <operator>||</operator>
		   <call><name>IsAppendonlyMetadataRelkind</name><argument_list>(<argument><expr><name><name>local_node</name><operator>-&gt;</operator><name>relKind</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>local_node</name><operator>-&gt;</operator><name>oncommit</name></name> <operator>&lt;=</operator> <name>ONCOMMIT_DROP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>CreateStmt</name> <modifier>*</modifier></type>
<name>_readCreateStmt</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>CreateStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_readCreateStmt_common</name><argument_list>(<argument><expr><name>local_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>CreateRangeStmt</name> <modifier>*</modifier></type>
<name>_readCreateRangeStmt</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>CreateRangeStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>typeName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>CreateForeignTableStmt</name> <modifier>*</modifier></type>
<name>_readCreateForeignTableStmt</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>CreateForeignTableStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_readCreateStmt_common</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>local_node</name><operator>-&gt;</operator><name>base</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_STRING_FIELD</name><argument_list>(<argument><expr><name>servername</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>distributedBy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ColumnReferenceStorageDirective</name> <modifier>*</modifier></type>
<name>_readColumnReferenceStorageDirective</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>ColumnReferenceStorageDirective</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_STRING_FIELD</name><argument_list>(<argument><expr><name>column</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>deflt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>AlterDomainStmt</name> <modifier>*</modifier></type>
<name>_readAlterDomainStmt</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>AlterDomainStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_CHAR_FIELD</name><argument_list>(<argument><expr><name>subtype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>typeName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_STRING_FIELD</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>def</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name>behavior</name></expr></argument>, <argument><expr><name>DropBehavior</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>local_node</name><operator>-&gt;</operator><name>behavior</name></name> <operator>&lt;=</operator> <name>DROP_CASCADE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>missing_ok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>AlterDefaultPrivilegesStmt</name> <modifier>*</modifier></type>
<name>_readAlterDefaultPrivilegesStmt</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>AlterDefaultPrivilegesStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>action</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>CopyStmt</name> <modifier>*</modifier></type>
<name>_readCopyStmt</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>CopyStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>attlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>is_from</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>is_program</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_STRING_FIELD</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>sreh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>GrantRoleStmt</name> <modifier>*</modifier></type>
<name>_readGrantRoleStmt</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>GrantRoleStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>granted_roles</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>grantee_roles</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>is_grant</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>admin_opt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>grantor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name>behavior</name></expr></argument>, <argument><expr><name>DropBehavior</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>local_node</name><operator>-&gt;</operator><name>behavior</name></name> <operator>&lt;=</operator> <name>DROP_CASCADE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>QueryDispatchDesc</name> <modifier>*</modifier></type>
<name>_readQueryDispatchDesc</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>QueryDispatchDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>intoCreateStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>paramInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>oidAssignments</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>sliceTable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>cursorPositions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_STRING_FIELD</name><argument_list>(<argument><expr><name>parallelCursorName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>useChangedAOOpts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>secContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>SerializedParams</name> <modifier>*</modifier></type>
<name>_readSerializedParams</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>SerializedParams</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>nExternParams</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>local_node</name><operator>-&gt;</operator><name>externParams</name></name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name><name>local_node</name><operator>-&gt;</operator><name>nExternParams</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>SerializedParamExternData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>local_node</name><operator>-&gt;</operator><name>nExternParams</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name><name>externParams</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name><name>externParams</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name><name>externParams</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ptype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name><name>externParams</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>plen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name><name>externParams</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pbyval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>local_node</name><operator>-&gt;</operator><name>externParams</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>local_node</name><operator>-&gt;</operator><name>externParams</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>value</name> <operator>=</operator> <call><name>readDatum</name><argument_list>(<argument><expr><name><name>local_node</name><operator>-&gt;</operator><name>externParams</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pbyval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>nExecParams</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>local_node</name><operator>-&gt;</operator><name>execParams</name></name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name><name>local_node</name><operator>-&gt;</operator><name>nExecParams</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>SerializedParamExecData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>local_node</name><operator>-&gt;</operator><name>nExecParams</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name><name>execParams</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name><name>execParams</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>isvalid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name><name>execParams</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>plen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name><name>execParams</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pbyval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>local_node</name><operator>-&gt;</operator><name>execParams</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>isvalid</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>local_node</name><operator>-&gt;</operator><name>execParams</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>local_node</name><operator>-&gt;</operator><name>execParams</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>value</name> <operator>=</operator> <call><name>readDatum</name><argument_list>(<argument><expr><name><name>local_node</name><operator>-&gt;</operator><name>execParams</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pbyval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name><name>execParams</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pbyval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>transientTypes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>OidAssignment</name> <modifier>*</modifier></type>
<name>_readOidAssignment</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>OidAssignment</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>catalog</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_STRING_FIELD</name><argument_list>(<argument><expr><name>objname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>namespaceOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>keyOid1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>keyOid2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Sequence</name> <modifier>*</modifier></type>
<name>_readSequence</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>Sequence</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ReadCommonPlan</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>local_node</name><operator>-&gt;</operator><name>plan</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>subplans</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>DynamicSeqScan</name> <modifier>*</modifier></type>
<name>_readDynamicSeqScan</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>DynamicSeqScan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReadCommonScan</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>local_node</name><operator>-&gt;</operator><name>seqscan</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>partOids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>part_prune_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>join_prune_paramids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readExternalScanInfo
 */</comment>
<function><type><specifier>static</specifier> <name>ExternalScanInfo</name> <modifier>*</modifier></type>
<name>_readExternalScanInfo</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>ExternalScanInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>uriList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_CHAR_FIELD</name><argument_list>(<argument><expr><name>fmtType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>isMasterOnly</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>rejLimit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>rejLimitInRows</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_CHAR_FIELD</name><argument_list>(<argument><expr><name>logErrors</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>scancounter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>extOptions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>CustomScan</name> <modifier>*</modifier></type>
<name>_readCustomScan</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>custom_name</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>CustomScanMethods</name> <modifier>*</modifier></type><name>methods</name></decl>;</decl_stmt>
	
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>CustomScan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReadCommonScan</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>local_node</name><operator>-&gt;</operator><name>scan</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_UINT_FIELD</name><argument_list>(<argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>custom_plans</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>custom_exprs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>custom_private</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>custom_scan_tlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name>custom_relids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_STRING_VAR</name><argument_list>(<argument><expr><name>custom_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* find custom scan methods from hash table. */</comment>
	<expr_stmt><expr><name>methods</name> <operator>=</operator> <call><name>GetCustomScanMethods</name><argument_list>(<argument><expr><name>custom_name</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>local_node</name><operator>-&gt;</operator><name>methods</name></name> <operator>=</operator> <name>methods</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readShareInputScan
 */</comment>
<function><type><specifier>static</specifier> <name>ShareInputScan</name> <modifier>*</modifier></type>
<name>_readShareInputScan</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>ShareInputScan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>cross_slice</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>share_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>producer_slice_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>this_slice_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>nconsumers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReadCommonPlan</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>local_node</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readMotion
 */</comment>
<function><type><specifier>static</specifier> <name>Motion</name> <modifier>*</modifier></type>
<name>_readMotion</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>Motion</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>motionID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name>motionType</name></expr></argument>, <argument><expr><name>MotionType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>local_node</name><operator>-&gt;</operator><name>motionType</name></name> <operator>==</operator> <name>MOTIONTYPE_GATHER</name> <operator>||</operator>
		   <name><name>local_node</name><operator>-&gt;</operator><name>motionType</name></name> <operator>==</operator> <name>MOTIONTYPE_GATHER_SINGLE</name> <operator>||</operator>
		   <name><name>local_node</name><operator>-&gt;</operator><name>motionType</name></name> <operator>==</operator> <name>MOTIONTYPE_HASH</name> <operator>||</operator>
		   <name><name>local_node</name><operator>-&gt;</operator><name>motionType</name></name> <operator>==</operator> <name>MOTIONTYPE_BROADCAST</name> <operator>||</operator>
		   <name><name>local_node</name><operator>-&gt;</operator><name>motionType</name></name> <operator>==</operator> <name>MOTIONTYPE_EXPLICIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>sendSorted</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>hashExprs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_OID_ARRAY</name><argument_list>(<argument><expr><name>hashFuncs</name></expr></argument>, <argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>local_node</name><operator>-&gt;</operator><name>hashExprs</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>numSortCols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_ATTRNUMBER_ARRAY</name><argument_list>(<argument><expr><name>sortColIdx</name></expr></argument>, <argument><expr><name><name>local_node</name><operator>-&gt;</operator><name>numSortCols</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_OID_ARRAY</name><argument_list>(<argument><expr><name>sortOperators</name></expr></argument>, <argument><expr><name><name>local_node</name><operator>-&gt;</operator><name>numSortCols</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_OID_ARRAY</name><argument_list>(<argument><expr><name>collations</name></expr></argument>, <argument><expr><name><name>local_node</name><operator>-&gt;</operator><name>numSortCols</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_ARRAY</name><argument_list>(<argument><expr><name>nullsFirst</name></expr></argument>, <argument><expr><name><name>local_node</name><operator>-&gt;</operator><name>numSortCols</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>segidColIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>numHashSegments</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReadCommonPlan</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>local_node</name><operator>-&gt;</operator><name>plan</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readSplitUpdate
 */</comment>
<function><type><specifier>static</specifier> <name>SplitUpdate</name> <modifier>*</modifier></type>
<name>_readSplitUpdate</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>SplitUpdate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>actionColIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>insertColIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>deleteColIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>numHashSegments</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>numHashAttrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_ATTRNUMBER_ARRAY</name><argument_list>(<argument><expr><name>hashAttnos</name></expr></argument>, <argument><expr><name><name>local_node</name><operator>-&gt;</operator><name>numHashAttrs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_OID_ARRAY</name><argument_list>(<argument><expr><name>hashFuncs</name></expr></argument>, <argument><expr><name><name>local_node</name><operator>-&gt;</operator><name>numHashAttrs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReadCommonPlan</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>local_node</name><operator>-&gt;</operator><name>plan</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readAssertOp
 */</comment>
<function><type><specifier>static</specifier> <name>AssertOp</name> <modifier>*</modifier></type>
<name>_readAssertOp</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>AssertOp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>errmessage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>errcode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReadCommonPlan</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>local_node</name><operator>-&gt;</operator><name>plan</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readPartitionSelector
 */</comment>
<function><type><specifier>static</specifier> <name>PartitionSelector</name> <modifier>*</modifier></type>
<name>_readPartitionSelector</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>PartitionSelector</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>paramid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>part_prune_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReadCommonPlan</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>local_node</name><operator>-&gt;</operator><name>plan</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Bitmapset</name> <modifier>*</modifier></type>
<name>_readBitmapset</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>bms</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nwords</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>nwords</name></expr></argument>, <argument><expr><name>read_str_ptr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>read_str_ptr</name><operator>+=</operator><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>nwords</name><operator>==</operator><literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>bms</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>bms</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>Bitmapset</name></expr></argument>, <argument><expr><name>words</name></expr></argument>)</argument_list></call><operator>+</operator><name>nwords</name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>bitmapword</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>bms</name><operator>-&gt;</operator><name>nwords</name></name> <operator>=</operator> <name>nwords</name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nwords</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>bms</name><operator>-&gt;</operator><name>words</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>read_str_ptr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bitmapword</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>read_str_ptr</name><operator>+=</operator><sizeof>sizeof<argument_list>(<argument><expr><name>bitmapword</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>bms</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>CreateTrigStmt</name> <modifier>*</modifier></type>
<name>_readCreateTrigStmt</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>CreateTrigStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_STRING_FIELD</name><argument_list>(<argument><expr><name>trigname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>funcname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>timing</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>events</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>columns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>whenClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>isconstraint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>transitionRels</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>deferrable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>initdeferred</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>constrrel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>TriggerTransition</name> <modifier>*</modifier></type>
<name>_readTriggerTransition</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>TriggerTransition</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_STRING_FIELD</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>isNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>isTable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>CreateTableSpaceStmt</name> <modifier>*</modifier></type>
<name>_readCreateTableSpaceStmt</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>CreateTableSpaceStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_STRING_FIELD</name><argument_list>(<argument><expr><name>tablespacename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>owner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_STRING_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>CreateAmStmt</name> <modifier>*</modifier></type>
<name>_readCreateAmStmt</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>CreateAmStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_STRING_FIELD</name><argument_list>(<argument><expr><name>amname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>handler_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>amtype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>AlterTableMoveAllStmt</name> <modifier>*</modifier></type>
<name>_readAlterTableMoveAllStmt</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>AlterTableMoveAllStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_STRING_FIELD</name><argument_list>(<argument><expr><name>orig_tablespacename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name>objtype</name></expr></argument>, <argument><expr><name>ObjectType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>roles</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_STRING_FIELD</name><argument_list>(<argument><expr><name>new_tablespacename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>nowait</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>AlterTableSpaceOptionsStmt</name> <modifier>*</modifier></type>
<name>_readAlterTableSpaceOptionsStmt</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>AlterTableSpaceOptionsStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_STRING_FIELD</name><argument_list>(<argument><expr><name>tablespacename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>isReset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>DropTableSpaceStmt</name> <modifier>*</modifier></type>
<name>_readDropTableSpaceStmt</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>DropTableSpaceStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_STRING_FIELD</name><argument_list>(<argument><expr><name>tablespacename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>missing_ok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>CreateQueueStmt</name> <modifier>*</modifier></type>
<name>_readCreateQueueStmt</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>CreateQueueStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_STRING_FIELD</name><argument_list>(<argument><expr><name>queue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>AlterQueueStmt</name> <modifier>*</modifier></type>
<name>_readAlterQueueStmt</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>AlterQueueStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_STRING_FIELD</name><argument_list>(<argument><expr><name>queue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>DropQueueStmt</name> <modifier>*</modifier></type>
<name>_readDropQueueStmt</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>DropQueueStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_STRING_FIELD</name><argument_list>(<argument><expr><name>queue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>CreateResourceGroupStmt</name> <modifier>*</modifier></type>
<name>_readCreateResourceGroupStmt</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>CreateResourceGroupStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_STRING_FIELD</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>DropResourceGroupStmt</name> <modifier>*</modifier></type>
<name>_readDropResourceGroupStmt</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>DropResourceGroupStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_STRING_FIELD</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>AlterResourceGroupStmt</name> <modifier>*</modifier></type>
<name>_readAlterResourceGroupStmt</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>AlterResourceGroupStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_STRING_FIELD</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>CommentStmt</name> <modifier>*</modifier></type>
<name>_readCommentStmt</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>CommentStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name>objtype</name></expr></argument>, <argument><expr><name>ObjectType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>object</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_STRING_FIELD</name><argument_list>(<argument><expr><name>comment</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>TupleDescNode</name> <modifier>*</modifier></type>
<name>_readTupleDescNode</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>TupleDescNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>natts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>local_node</name><operator>-&gt;</operator><name>tuple</name></name> <operator>=</operator> <call><name>CreateTemplateTupleDesc</name><argument_list>(<argument><expr><name><name>local_node</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name><name>tuple</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>local_node</name><operator>-&gt;</operator><name>tuple</name><operator>-&gt;</operator><name>natts</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<for>for <control>(<init>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>local_node</name><operator>-&gt;</operator><name>tuple</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>local_node</name><operator>-&gt;</operator><name>tuple</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>read_str_ptr</name></expr></argument>, <argument><expr><name>ATTRIBUTE_FIXED_PART_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>read_str_ptr</name><operator>+=</operator><name>ATTRIBUTE_FIXED_PART_SIZE</name></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name><name>tuple</name><operator>-&gt;</operator><name>tdtypeid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name><name>tuple</name><operator>-&gt;</operator><name>tdtypmod</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name><name>tuple</name><operator>-&gt;</operator><name>tdrefcount</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="line">// Transient type don't have constraint.</comment>
	<expr_stmt><expr><name><name>local_node</name><operator>-&gt;</operator><name>tuple</name><operator>-&gt;</operator><name>constr</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>local_node</name><operator>-&gt;</operator><name>tuple</name><operator>-&gt;</operator><name>tdtypeid</name></name> <operator>==</operator> <name>RECORDOID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>AlterExtensionStmt</name> <modifier>*</modifier></type>
<name>_readAlterExtensionStmt</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>AlterExtensionStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_STRING_FIELD</name><argument_list>(<argument><expr><name>extname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name>update_ext_state</name></expr></argument>, <argument><expr><name>UpdateExtensionState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>AlterExtensionContentsStmt</name> <modifier>*</modifier></type>
<name>_readAlterExtensionContentsStmt</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>AlterExtensionContentsStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_STRING_FIELD</name><argument_list>(<argument><expr><name>extname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>action</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name>objtype</name></expr></argument>, <argument><expr><name>ObjectType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>object</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>AlterTSConfigurationStmt</name> <modifier>*</modifier></type>
<name>_readAlterTSConfigurationStmt</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>AlterTSConfigurationStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>cfgname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>tokentype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>dicts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>override</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>replace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>missing_ok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>AlterTSDictionaryStmt</name> <modifier>*</modifier></type>
<name>_readAlterTSDictionaryStmt</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>AlterTSDictionaryStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>dictname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>CookedConstraint</name> <modifier>*</modifier></type>
<name>_readCookedConstraint</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>CookedConstraint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name>contype</name></expr></argument>,<argument><expr><name>ConstrType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_STRING_FIELD</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>is_local</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>inhcount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>is_no_inherit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>AlterEnumStmt</name> <modifier>*</modifier></type>
<name>_readAlterEnumStmt</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>AlterEnumStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>typeName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_STRING_FIELD</name><argument_list>(<argument><expr><name>oldVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_STRING_FIELD</name><argument_list>(<argument><expr><name>newVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_STRING_FIELD</name><argument_list>(<argument><expr><name>newValNeighbor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>newValIsAfter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>skipIfNewValExists</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>CreateFdwStmt</name> <modifier>*</modifier></type>
<name>_readCreateFdwStmt</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>CreateFdwStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_STRING_FIELD</name><argument_list>(<argument><expr><name>fdwname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>func_options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>DistributedBy</name><modifier>*</modifier></type>
<name>_readDistributedBy</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>DistributedBy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name>ptype</name></expr></argument>, <argument><expr><name>GpPolicyType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>numsegments</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>keyCols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ImportForeignSchemaStmt</name><modifier>*</modifier></type>
<name>_readImportForeignSchemaStmt</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>ImportForeignSchemaStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_STRING_FIELD</name><argument_list>(<argument><expr><name>server_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_STRING_FIELD</name><argument_list>(<argument><expr><name>remote_schema</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_STRING_FIELD</name><argument_list>(<argument><expr><name>local_schema</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name>list_type</name></expr></argument>, <argument><expr><name>ImportForeignSchemaType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>table_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>AlterFdwStmt</name> <modifier>*</modifier></type>
<name>_readAlterFdwStmt</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>AlterFdwStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_STRING_FIELD</name><argument_list>(<argument><expr><name>fdwname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>func_options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>CreateForeignServerStmt</name> <modifier>*</modifier></type>
<name>_readCreateForeignServerStmt</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>CreateForeignServerStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_STRING_FIELD</name><argument_list>(<argument><expr><name>servername</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_STRING_FIELD</name><argument_list>(<argument><expr><name>servertype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_STRING_FIELD</name><argument_list>(<argument><expr><name>version</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_STRING_FIELD</name><argument_list>(<argument><expr><name>fdwname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>AlterForeignServerStmt</name> <modifier>*</modifier></type>
<name>_readAlterForeignServerStmt</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>AlterForeignServerStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_STRING_FIELD</name><argument_list>(<argument><expr><name>servername</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_STRING_FIELD</name><argument_list>(<argument><expr><name>version</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>has_version</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>CreateUserMappingStmt</name> <modifier>*</modifier></type>
<name>_readCreateUserMappingStmt</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>CreateUserMappingStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>user</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_STRING_FIELD</name><argument_list>(<argument><expr><name>servername</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>AlterUserMappingStmt</name> <modifier>*</modifier></type>
<name>_readAlterUserMappingStmt</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>AlterUserMappingStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>user</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_STRING_FIELD</name><argument_list>(<argument><expr><name>servername</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>DropUserMappingStmt</name> <modifier>*</modifier></type>
<name>_readDropUserMappingStmt</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>DropUserMappingStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>user</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_STRING_FIELD</name><argument_list>(<argument><expr><name>servername</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>missing_ok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>AccessPriv</name> <modifier>*</modifier></type>
<name>_readAccessPriv</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>AccessPriv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_STRING_FIELD</name><argument_list>(<argument><expr><name>priv_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>cols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>LockingClause</name> <modifier>*</modifier></type>
<name>_readLockingClause</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>LockingClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>lockedRels</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name>strength</name></expr></argument>, <argument><expr><name>LockClauseStrength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>AggExprId</name> <modifier>*</modifier></type>
<name>_readAggExprId</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>AggExprId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>RowIdExpr</name> <modifier>*</modifier></type>
<name>_readRowIdExpr</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>RowIdExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>rowidexpr_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>_readValue</name><parameter_list>(<parameter><decl><type><name>NodeTag</name></type> <name>nt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type> <name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>nt</name> <operator>==</operator> <name>T_Integer</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>long</name></type> <name>ival</name></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ival</name></expr></argument>, <argument><expr><name>read_str_ptr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>long</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>read_str_ptr</name><operator>+=</operator><sizeof>sizeof<argument_list>(<argument><expr><name>long</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeInteger</name><argument_list>(<argument><expr><name>ival</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>nt</name> <operator>==</operator> <name>T_Null</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Value</name> <modifier>*</modifier></type><name>val</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>Value</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>val</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>T_Null</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name>val</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>slen</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type> <name>nn</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>slen</name></expr></argument>, <argument><expr><name>read_str_ptr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>read_str_ptr</name><operator>+=</operator><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

		<comment type="block">/*
		 * For the String case we want to create an empty string if slen is
		 * equal to zero, since otherwise we'll set the string to NULL, which
		 * has a different meaning and the NULL case is handed above.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>slen</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>nt</name> <operator>==</operator> <name>T_String</name></expr>)</condition>
		<block>{<block_content>
		    <expr_stmt><expr><name>nn</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>slen</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>slen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>nn</name></expr></argument>, <argument><expr><name>read_str_ptr</name></expr></argument>, <argument><expr><name>slen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		    <expr_stmt><expr><name>read_str_ptr</name> <operator>+=</operator> <operator>(</operator><name>slen</name><operator>)</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>nn</name><index>[<expr><name>slen</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>nt</name> <operator>==</operator> <name>T_Float</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeFloat</name><argument_list>(<argument><expr><name>nn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name>nt</name> <operator>==</operator> <name>T_String</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeString</name><argument_list>(<argument><expr><name>nn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name>nt</name> <operator>==</operator> <name>T_BitString</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeBitString</name><argument_list>(<argument><expr><name>nn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unknown Value node type %i"</literal></expr></argument>, <argument><expr><name>nt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>

</block_content>}</block></function>

<comment type="block">/*
 * _readGpPolicy
 */</comment>
<function><type><specifier>static</specifier> <name>GpPolicy</name> <modifier>*</modifier></type>
<name>_readGpPolicy</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>GpPolicy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name>ptype</name></expr></argument>, <argument><expr><name>GpPolicyType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>numsegments</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>nattrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_ATTRNUMBER_ARRAY</name><argument_list>(<argument><expr><name>attrs</name></expr></argument>, <argument><expr><name><name>local_node</name><operator>-&gt;</operator><name>nattrs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_OID_ARRAY</name><argument_list>(<argument><expr><name>opclasses</name></expr></argument>, <argument><expr><name><name>local_node</name><operator>-&gt;</operator><name>nattrs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type>
<name>readNodeBinary</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>void</name>	   <modifier>*</modifier></type><name>return_value</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NodeTag</name></type> 	<name>nt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int16</name></type>       <name>ntt</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ntt</name></expr></argument>, <argument><expr><name>read_str_ptr</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int16</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>read_str_ptr</name><operator>+=</operator><sizeof>sizeof<argument_list>(<argument><expr><name>int16</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name>nt</name> <operator>=</operator> <operator>(</operator><name>NodeTag</name><operator>)</operator> <name>ntt</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>nt</name><operator>==</operator><literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>nt</name> <operator>==</operator> <name>T_List</name> <operator>||</operator> <name>nt</name> <operator>==</operator> <name>T_IntList</name> <operator>||</operator> <name>nt</name> <operator>==</operator> <name>T_OidList</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>l</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>listsize</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>listsize</name></expr></argument>,<argument><expr><name>read_str_ptr</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>read_str_ptr</name><operator>+=</operator><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>nt</name> <operator>==</operator> <name>T_IntList</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type> <name>val</name></decl>;</decl_stmt>
			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>listsize</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>val</name></expr></argument>,<argument><expr><name>read_str_ptr</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>read_str_ptr</name><operator>+=</operator><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
				<expr_stmt><expr><name>l</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></for>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>nt</name> <operator>==</operator> <name>T_OidList</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type> <name>val</name></decl>;</decl_stmt>
			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>listsize</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>val</name></expr></argument>,<argument><expr><name>read_str_ptr</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>read_str_ptr</name><operator>+=</operator><sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
				<expr_stmt><expr><name>l</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></for>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>

			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>listsize</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<expr_stmt><expr><name>l</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><call><name>readNodeBinary</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></for>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>l</name><operator>-&gt;</operator><name>length</name></name><operator>==</operator><name>listsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return <expr><name>l</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>nt</name> <operator>==</operator> <name>T_Integer</name> <operator>||</operator> <name>nt</name> <operator>==</operator> <name>T_Float</name> <operator>||</operator> <name>nt</name> <operator>==</operator> <name>T_String</name> <operator>||</operator>
	   	<name>nt</name> <operator>==</operator> <name>T_BitString</name> <operator>||</operator> <name>nt</name> <operator>==</operator> <name>T_Null</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><call><name>_readValue</name><argument_list>(<argument><expr><name>nt</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<switch>switch<condition>(<expr><name>nt</name></expr>)</condition>
	<block>{<block_content>
			<case>case <expr><name>T_PlannedStmt</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readPlannedStmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_QueryDispatchDesc</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readQueryDispatchDesc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_OidAssignment</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readOidAssignment</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_Plan</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readPlan</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_Result</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readResult</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_ProjectSet</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readProjectSet</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_Append</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readAppend</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_MergeAppend</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readMergeAppend</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_Sequence</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readSequence</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_RecursiveUnion</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readRecursiveUnion</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_BitmapAnd</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readBitmapAnd</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_BitmapOr</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readBitmapOr</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_Gather</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readGather</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_GatherMerge</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readGatherMerge</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_Scan</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readScan</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_SeqScan</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readSeqScan</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_DynamicSeqScan</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readDynamicSeqScan</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_ExternalScanInfo</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readExternalScanInfo</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_IndexScan</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readIndexScan</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_IndexOnlyScan</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readIndexOnlyScan</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_DynamicIndexScan</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readDynamicIndexScan</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_BitmapIndexScan</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readBitmapIndexScan</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_DynamicBitmapIndexScan</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readDynamicBitmapIndexScan</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_BitmapHeapScan</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readBitmapHeapScan</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_DynamicBitmapHeapScan</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readDynamicBitmapHeapScan</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_CteScan</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readCteScan</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_NamedTuplestoreScan</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readNamedTuplestoreScan</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_WorkTableScan</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readWorkTableScan</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_TidScan</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readTidScan</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_SubqueryScan</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readSubqueryScan</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_FunctionScan</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readFunctionScan</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_TableFuncScan</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readTableFuncScan</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_ValuesScan</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readValuesScan</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_ForeignScan</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readForeignScan</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_CustomScan</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readCustomScan</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_SampleScan</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readSampleScan</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_Join</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readJoin</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_NestLoop</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readNestLoop</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_MergeJoin</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readMergeJoin</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_HashJoin</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readHashJoin</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_Agg</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readAgg</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_TupleSplit</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readTupleSplit</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_DQAExpr</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readDQAExpr</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_WindowAgg</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readWindowAgg</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_TableFunctionScan</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readTableFunctionScan</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_Material</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readMaterial</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_ShareInputScan</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readShareInputScan</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_Sort</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readSort</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_Unique</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readUnique</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_SetOp</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readSetOp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_Limit</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readLimit</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_NestLoopParam</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readNestLoopParam</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_PlanRowMark</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readPlanRowMark</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_PartitionPruneInfo</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readPartitionPruneInfo</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_PartitionedRelPruneInfo</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readPartitionedRelPruneInfo</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_PartitionPruneStepOp</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readPartitionPruneStepOp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_PartitionPruneStepCombine</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readPartitionPruneStepCombine</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_PlanInvalItem</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readPlanInvalItem</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_Hash</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readHash</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_Motion</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readMotion</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_SplitUpdate</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readSplitUpdate</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_AssertOp</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readAssertOp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_PartitionSelector</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readPartitionSelector</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_Alias</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readAlias</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_RangeVar</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readRangeVar</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_TableFunc</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readTableFunc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_IntoClause</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readIntoClause</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_CopyIntoClause</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readCopyIntoClause</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_RefreshClause</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readRefreshClause</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_Var</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readVar</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_Const</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readConst</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_Param</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readParam</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_Aggref</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readAggref</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_GroupingFunc</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readGroupingFunc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_GroupId</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readGroupId</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_GroupingSetId</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readGroupingSetId</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_WindowFunc</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readWindowFunc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_SubscriptingRef</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readSubscriptingRef</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_FuncExpr</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readFuncExpr</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_NamedArgExpr</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readNamedArgExpr</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_OpExpr</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readOpExpr</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_DistinctExpr</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readDistinctExpr</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_ScalarArrayOpExpr</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readScalarArrayOpExpr</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_BoolExpr</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readBoolExpr</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_SubLink</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readSubLink</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_SubPlan</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readSubPlan</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_AlternativeSubPlan</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readAlternativeSubPlan</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_FieldSelect</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readFieldSelect</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_FieldStore</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readFieldStore</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_RelabelType</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readRelabelType</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_CoerceViaIO</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readCoerceViaIO</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_ArrayCoerceExpr</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readArrayCoerceExpr</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_ConvertRowtypeExpr</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readConvertRowtypeExpr</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_CollateExpr</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readCollateExpr</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_CaseExpr</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readCaseExpr</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_CaseWhen</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readCaseWhen</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_CaseTestExpr</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readCaseTestExpr</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_ArrayExpr</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readArrayExpr</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_A_ArrayExpr</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readA_ArrayExpr</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_RowExpr</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readRowExpr</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_RowCompareExpr</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readRowCompareExpr</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_CoalesceExpr</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readCoalesceExpr</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_MinMaxExpr</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readMinMaxExpr</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_NullIfExpr</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readNullIfExpr</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_NullTest</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readNullTest</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_BooleanTest</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readBooleanTest</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_SQLValueFunction</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readSQLValueFunction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_XmlExpr</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readXmlExpr</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_CoerceToDomain</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readCoerceToDomain</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_CoerceToDomainValue</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readCoerceToDomainValue</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_SetToDefault</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readSetToDefault</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_CurrentOfExpr</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readCurrentOfExpr</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_NextValueExpr</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readNextValueExpr</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_InferenceElem</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readInferenceElem</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_TargetEntry</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readTargetEntry</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_RangeTblRef</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readRangeTblRef</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_RangeTblFunction</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readRangeTblFunction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_TableSampleClause</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readTableSampleClause</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_JoinExpr</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readJoinExpr</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_FromExpr</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readFromExpr</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_OnConflictExpr</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readOnConflictExpr</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_GrantStmt</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readGrantStmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_AccessPriv</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readAccessPriv</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_ObjectWithArgs</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readObjectWithArgs</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_GrantRoleStmt</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readGrantRoleStmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_LockStmt</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readLockStmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_PartitionSpec</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readPartitionSpec</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_PartitionElem</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readPartitionElem</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_PartitionRangeDatum</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readPartitionRangeDatum</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_PartitionCmd</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readPartitionCmd</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_DistributionKeyElem</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readDistributionKeyElem</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_PartitionBoundSpec</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readPartitionBoundSpec</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_RestrictInfo</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readRestrictInfo</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_ExtensibleNode</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readExtensibleNode</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_CreateStmt</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readCreateStmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_CreateForeignTableStmt</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readCreateForeignTableStmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_ColumnReferenceStorageDirective</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readColumnReferenceStorageDirective</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_SegfileMapNode</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readSegfileMapNode</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_ExtTableTypeDesc</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readExtTableTypeDesc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_CreateExternalStmt</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readCreateExternalStmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_CreateExtensionStmt</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readCreateExtensionStmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_IndexStmt</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readIndexStmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_ReindexStmt</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readReindexStmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_ConstraintsSetStmt</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readConstraintsSetStmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_CreateFunctionStmt</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readCreateFunctionStmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_FunctionParameter</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readFunctionParameter</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_AlterFunctionStmt</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readAlterFunctionStmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_DefineStmt</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readDefineStmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_CompositeTypeStmt</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readCompositeTypeStmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_CreateEnumStmt</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readCreateEnumStmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_CreateRangeStmt</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readCreateRangeStmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_AlterEnumStmt</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readAlterEnumStmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_CreateCastStmt</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readCreateCastStmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_CreateOpClassStmt</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readCreateOpClassStmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_CreateOpClassItem</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readCreateOpClassItem</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_CreateOpFamilyStmt</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readCreateOpFamilyStmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_AlterOpFamilyStmt</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readAlterOpFamilyStmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_CreateConversionStmt</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readCreateConversionStmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_ViewStmt</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readViewStmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_RuleStmt</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readRuleStmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_DropStmt</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readDropStmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_DropOwnedStmt</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readDropOwnedStmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_ReassignOwnedStmt</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readReassignOwnedStmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_TruncateStmt</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readTruncateStmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_ReplicaIdentityStmt</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readReplicaIdentityStmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_AlterDatabaseStmt</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readAlterDatabaseStmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
			<case>case <expr><name>T_AlterTableStmt</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readAlterTableStmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_AlterTableCmd</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readAlterTableCmd</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_AlteredTableInfo</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readAlteredTableInfo</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_NewConstraint</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readNewConstraint</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_NewColumnValue</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readNewColumnValue</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_CreateRoleStmt</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readCreateRoleStmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_DropRoleStmt</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readDropRoleStmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_AlterRoleStmt</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readAlterRoleStmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_AlterRoleSetStmt</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readAlterRoleSetStmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_AlterObjectDependsStmt</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readAlterObjectDependsStmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_AlterSystemStmt</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readAlterSystemStmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_AlterObjectSchemaStmt</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readAlterObjectSchemaStmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_AlterOwnerStmt</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readAlterOwnerStmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_RenameStmt</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readRenameStmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_CreateSeqStmt</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readCreateSeqStmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_AlterSeqStmt</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readAlterSeqStmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_ClusterStmt</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readClusterStmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_CreatedbStmt</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readCreatedbStmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_DropdbStmt</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readDropdbStmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_CreateDomainStmt</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readCreateDomainStmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_AlterDomainStmt</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readAlterDomainStmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_AlterDefaultPrivilegesStmt</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readAlterDefaultPrivilegesStmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_NotifyStmt</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readNotifyStmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_DeclareCursorStmt</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readDeclareCursorStmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_SingleRowErrorDesc</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readSingleRowErrorDesc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_CopyStmt</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readCopyStmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_SelectStmt</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readSelectStmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_InsertStmt</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readInsertStmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_DeleteStmt</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readDeleteStmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_UpdateStmt</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readUpdateStmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_ColumnDef</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readColumnDef</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_TypeName</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readTypeName</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_SortBy</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readSortBy</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_TypeCast</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readTypeCast</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_CollateClause</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readCollateClause</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_IndexElem</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readIndexElem</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_Query</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readQuery</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_WithCheckOption</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readWithCheckOption</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_SortGroupClause</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readSortGroupClause</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_DMLActionExpr</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readDMLActionExpr</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_GroupingSet</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readGroupingSet</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_WindowClause</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readWindowClause</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_RowMarkClause</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readRowMarkClause</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_WithClause</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readWithClause</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_CommonTableExpr</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readCommonTableExpr</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_RoleSpec</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readRoleSpec</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_SetOperationStmt</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readSetOperationStmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_RangeTblEntry</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readRangeTblEntry</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_A_Expr</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readAExpr</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_ColumnRef</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readColumnRef</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_A_Const</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readAConst</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_A_Star</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readA_Star</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_A_Indices</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readA_Indices</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_A_Indirection</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readA_Indirection</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_ResTarget</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readResTarget</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_MultiAssignRef</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readMultiAssignRef</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_Constraint</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readConstraint</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_FuncCall</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readFuncCall</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_DefElem</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readDefElem</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_CreateSchemaStmt</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readCreateSchemaStmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_CreatePLangStmt</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readCreatePLangStmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_VacuumStmt</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readVacuumStmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_VacuumRelation</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readVacuumRelation</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_CdbProcess</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readCdbProcess</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_SliceTable</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readSliceTable</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_CursorPosInfo</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readCursorPosInfo</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_VariableSetStmt</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readVariableSetStmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_CreateTrigStmt</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readCreateTrigStmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_TriggerTransition</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readTriggerTransition</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_CreateTableSpaceStmt</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readCreateTableSpaceStmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_AlterTableSpaceOptionsStmt</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readAlterTableSpaceOptionsStmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_DropTableSpaceStmt</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readDropTableSpaceStmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_CreateQueueStmt</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readCreateQueueStmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_AlterQueueStmt</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readAlterQueueStmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_DropQueueStmt</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readDropQueueStmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_CreateResourceGroupStmt</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readCreateResourceGroupStmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_DropResourceGroupStmt</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readDropResourceGroupStmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_AlterResourceGroupStmt</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readAlterResourceGroupStmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_CommentStmt</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readCommentStmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_DenyLoginInterval</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readDenyLoginInterval</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_DenyLoginPoint</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readDenyLoginPoint</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_TableValueExpr</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readTableValueExpr</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_AlterTypeStmt</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readAlterTypeStmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_AlterExtensionStmt</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readAlterExtensionStmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_AlterExtensionContentsStmt</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readAlterExtensionContentsStmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_TupleDescNode</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readTupleDescNode</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_SerializedParams</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readSerializedParams</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_AlterTSConfigurationStmt</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readAlterTSConfigurationStmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_AlterTSDictionaryStmt</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readAlterTSDictionaryStmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_CookedConstraint</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readCookedConstraint</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_DropUserMappingStmt</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readDropUserMappingStmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_AlterUserMappingStmt</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readAlterUserMappingStmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_CreateUserMappingStmt</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readCreateUserMappingStmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_AlterForeignServerStmt</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readAlterForeignServerStmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_CreateForeignServerStmt</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readCreateForeignServerStmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_AlterFdwStmt</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readAlterFdwStmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_CreateFdwStmt</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readCreateFdwStmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_ModifyTable</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readModifyTable</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_LockRows</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readLockRows</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_GpPolicy</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readGpPolicy</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_DistributedBy</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readDistributedBy</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_ImportForeignSchemaStmt</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readImportForeignSchemaStmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_AlterTableMoveAllStmt</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readAlterTableMoveAllStmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_CreatePublicationStmt</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readCreatePublicationStmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_AlterPublicationStmt</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readAlterPublicationStmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_CreateSubscriptionStmt</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readCreateSubscriptionStmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_DropSubscriptionStmt</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readDropSubscriptionStmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_AlterSubscriptionStmt</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readAlterSubscriptionStmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_CreatePolicyStmt</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readCreatePolicyStmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_AlterPolicyStmt</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readAlterPolicyStmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_CreateTransformStmt</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readCreateTransformStmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_CreateAmStmt</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readCreateAmStmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_LockingClause</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readLockingClause</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_AggExprId</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readAggExprId</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_RowIdExpr</name></expr>:</case>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readRowIdExpr</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<default>default:</default>
				<expr_stmt><expr><name>return_value</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt> <comment type="block">/* keep the compiler silent */</comment>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not deserialize unrecognized node type: %d"</literal></expr></argument>,
						 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>nt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
	</block_content>}</block></switch>

	<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator><name>return_value</name></expr>;</return>
</block_content>}</block></function>

<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type>
<name>readNodeFromBinaryString</name><argument_list>(<argument><expr><specifier>const</specifier> <name>char</name> <operator>*</operator><name>str_arg</name></expr></argument>, <argument><expr><name>int</name> <name>len</name> <call><name>pg_attribute_unused</name><argument_list>()</argument_list></call></expr></argument>)</argument_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>node</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int16</name></type>		<name>tg</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>read_str_ptr</name> <operator>=</operator> <name>str_arg</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>node</name> <operator>=</operator> <call><name>readNodeBinary</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tg</name></expr></argument>, <argument><expr><name>read_str_ptr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int16</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>tg</name> <operator>!=</operator> <operator>(</operator><name>int16</name><operator>)</operator><literal type="number">0xDEAD</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,<argument><expr><literal type="string">"Deserialization lost sync."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>node</name></expr>;</return>

</block_content>}</block></decl></decl_stmt>
<comment type="block">/*
 * readDatumBinary
 *
 * Like readDatum() in readfuncs.c.
 */</comment>
<function><type><specifier>static</specifier> <name>Datum</name></type>
<name>readDatumBinary</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>typbyval</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Size</name></type>		<name>length</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Datum</name></type>		<name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>typbyval</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>res</name></expr></argument>, <argument><expr><name>read_str_ptr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>read_str_ptr</name><operator>+=</operator><sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>length</name></expr></argument>, <argument><expr><name>read_str_ptr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Size</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>read_str_ptr</name><operator>+=</operator><sizeof>sizeof<argument_list>(<argument><expr><name>Size</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	  	<if_stmt><if>if <condition>(<expr><name>length</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>res</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>s</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>length</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>read_str_ptr</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>read_str_ptr</name><operator>+=</operator><name>length</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>s</name><index>[<expr><name>length</name></expr>]</index></name><operator>=</operator><literal type="char">'\0'</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>
</unit>
