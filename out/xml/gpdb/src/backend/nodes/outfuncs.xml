<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/backend/nodes/outfuncs.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * outfuncs.c
 *	  Output functions for Postgres tree nodes.
 *
 * Portions Copyright (c) 2005-2010, Greenplum inc
 * Portions Copyright (c) 2012-Present VMware, Inc. or its affiliates.
 * Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/nodes/outfuncs.c
 *
 * NOTES
 *	  Every node type that can appear in stored rules' parsetrees *must*
 *	  have an output function defined here (as well as an input function
 *	  in readfuncs.c).  In addition, plan nodes should have input and
 *	  output functions so that they can be sent to parallel workers.
 *
 *	  For use in debugging, we also provide output functions for nodes
 *	  that appear in raw parsetrees and planner Paths.  These node types
 *	  need not have input functions.  Output support for raw parsetrees
 *	  is somewhat incomplete, too; in particular, utility statements are
 *	  almost entirely unsupported.  We try to support everything that can
 *	  appear in a raw SELECT, though.
 *
 *    N.B. Faster variants of these functions (producing illegible output)
 *         are supplied in outfast.c for use in Greenplum Database serialization.  The
 *         function in this file are intended to produce legible output.
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lib/stringinfo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/extensible.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/pathnodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/plannodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/datum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbgang.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/altertablenodes.h"</cpp:file></cpp:include>


<comment type="block">/*
 * outfuncs.c is compiled normally into outfuncs.o, but it's also
 * #included from outfast.c. When #included, outfast.c defines
 * COMPILING_BINARY_FUNCS, and provides replacements WRITE_* macros. See
 * comments at top of readfast.c.
 */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>COMPILING_BINARY_FUNCS</name></cpp:ifndef>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>outChar</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>c</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * Macros to simplify output of different kinds of fields.  Use these
 * wherever possible to reduce the chance for silly typos.  Note that these
 * hard-wire conventions about the names of the local variables in an Out
 * routine.
 */</comment>

<comment type="block">/* Write the label for the node type */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WRITE_NODE_TYPE</name><parameter_list>(<parameter><type><name>nodelabel</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>appendStringInfoLiteral(str, nodelabel)</cpp:value></cpp:define>

<comment type="block">/* Write an integer field (anything written as ":fldname %d") */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WRITE_INT_FIELD</name><parameter_list>(<parameter><type><name>fldname</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>appendStringInfo(str, " :" CppAsString(fldname) " %d", node-&gt;fldname)</cpp:value></cpp:define>

<comment type="block">/* Write an unsigned integer field (anything written as ":fldname %u") */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WRITE_UINT_FIELD</name><parameter_list>(<parameter><type><name>fldname</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>appendStringInfo(str, " :" CppAsString(fldname) " %u", node-&gt;fldname)</cpp:value></cpp:define>

<comment type="block">/* Write an unsigned integer field (anything written with UINT64_FORMAT) */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WRITE_UINT64_FIELD</name><parameter_list>(<parameter><type><name>fldname</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>appendStringInfo(str, " :" CppAsString(fldname) " " UINT64_FORMAT, \
					 node-&gt;fldname)</cpp:value></cpp:define>

<comment type="block">/* Write an OID field (don't hard-wire assumption that OID is same as uint) */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WRITE_OID_FIELD</name><parameter_list>(<parameter><type><name>fldname</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>appendStringInfo(str, " :" CppAsString(fldname) " %u", node-&gt;fldname)</cpp:value></cpp:define>

<comment type="block">/* CDB: Write an OID field, renamed */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WRITE_OID_FIELD_AS</name><parameter_list>(<parameter><type><name>fldname</name></type></parameter>, <parameter><type><name>asname</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>appendStringInfo(str, " :" CppAsString(asname) " %u", node-&gt;fldname)</cpp:value></cpp:define>

<comment type="block">/* Write a long-integer field */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WRITE_LONG_FIELD</name><parameter_list>(<parameter><type><name>fldname</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>appendStringInfo(str, " :" CppAsString(fldname) " %ld", node-&gt;fldname)</cpp:value></cpp:define>

<comment type="block">/* Write a char field (ie, one ascii character) */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WRITE_CHAR_FIELD</name><parameter_list>(<parameter><type><name>fldname</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>(appendStringInfo(str, " :" CppAsString(fldname) " "), \
	 outChar(str, node-&gt;fldname))</cpp:value></cpp:define>

<comment type="block">/* Write an enumerated-type field as an integer code */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WRITE_ENUM_FIELD</name><parameter_list>(<parameter><type><name>fldname</name></type></parameter>, <parameter><type><name>enumtype</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>appendStringInfo(str, " :" CppAsString(fldname) " %d", \
					 (int) node-&gt;fldname)</cpp:value></cpp:define>

<comment type="block">/* Write a float field --- caller must give format to define precision */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WRITE_FLOAT_FIELD</name><parameter_list>(<parameter><type><name>fldname</name></type></parameter>,<parameter><type><name>format</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>appendStringInfo(str, " :" CppAsString(fldname) " " format, node-&gt;fldname)</cpp:value></cpp:define>

<comment type="block">/* Write a boolean field */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WRITE_BOOL_FIELD</name><parameter_list>(<parameter><type><name>fldname</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>appendStringInfo(str, " :" CppAsString(fldname) " %s", \
					 booltostr(node-&gt;fldname))</cpp:value></cpp:define>

<comment type="block">/* Write a character-string (possibly NULL) field */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WRITE_STRING_FIELD</name><parameter_list>(<parameter><type><name>fldname</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>(appendStringInfoString(str, " :" CppAsString(fldname) " "), \
	 outToken(str, node-&gt;fldname))</cpp:value></cpp:define>

<comment type="block">/* Write a parse location field (actually same as INT case) */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WRITE_LOCATION_FIELD</name><parameter_list>(<parameter><type><name>fldname</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>appendStringInfo(str, " :" CppAsString(fldname) " %d", node-&gt;fldname)</cpp:value></cpp:define>

<comment type="block">/* Write a Node field */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WRITE_NODE_FIELD</name><parameter_list>(<parameter><type><name>fldname</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>(appendStringInfoString(str, " :" CppAsString(fldname) " "), \
	 outNode(str, node-&gt;fldname))</cpp:value></cpp:define>

<comment type="block">/* CDB: Write a Node field, renamed */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WRITE_NODE_FIELD_AS</name><parameter_list>(<parameter><type><name>fldname</name></type></parameter>, <parameter><type><name>asname</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>(appendStringInfo(str, " :" CppAsString(asname) " "), \
	 outNode(str, node-&gt;fldname))</cpp:value></cpp:define>

<comment type="block">/* Write a bitmapset field */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WRITE_BITMAPSET_FIELD</name><parameter_list>(<parameter><type><name>fldname</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>(appendStringInfoString(str, " :" CppAsString(fldname) " "), \
	 outBitmapset(str, node-&gt;fldname))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WRITE_ATTRNUMBER_ARRAY</name><parameter_list>(<parameter><type><name>fldname</name></type></parameter>, <parameter><type><name>len</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>do { \
		appendStringInfoString(str, " :" CppAsString(fldname) " "); \
		for (int i = 0; i &lt; len; i++) \
			appendStringInfo(str, " %d", node-&gt;fldname[i]); \
	} while(0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WRITE_OID_ARRAY</name><parameter_list>(<parameter><type><name>fldname</name></type></parameter>, <parameter><type><name>len</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>do { \
		appendStringInfoString(str, " :" CppAsString(fldname) " "); \
		for (int i = 0; i &lt; len; i++) \
			appendStringInfo(str, " %u", node-&gt;fldname[i]); \
	} while(0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WRITE_INT_ARRAY</name><parameter_list>(<parameter><type><name>fldname</name></type></parameter>, <parameter><type><name>len</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>do { \
		appendStringInfoString(str, " :" CppAsString(fldname) " "); \
		for (int i = 0; i &lt; len; i++) \
			appendStringInfo(str, " %d", node-&gt;fldname[i]); \
	} while(0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WRITE_BOOL_ARRAY</name><parameter_list>(<parameter><type><name>fldname</name></type></parameter>, <parameter><type><name>len</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>do { \
		appendStringInfoString(str, " :" CppAsString(fldname) " "); \
		for (int i = 0; i &lt; len; i++) \
			appendStringInfo(str, " %s", booltostr(node-&gt;fldname[i])); \
	} while(0)</cpp:value></cpp:define>

<comment type="block">/* Write a bytea field */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WRITE_BYTEA_FIELD</name><parameter_list>(<parameter><type><name>fldname</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>(_outDatum(str, PointerGetDatum(node-&gt;fldname), -1, false))</cpp:value></cpp:define>

<comment type="block">/* Write a dummy field -- value not displayable or copyable */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WRITE_DUMMY_FIELD</name><parameter_list>(<parameter><type><name>fldname</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>(appendStringInfo(str, " :" CppAsString(fldname) " "), \
	 outToken(str, NULL))</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* COMPILING_BINARY_FUNCS */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>booltostr</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro>  <cpp:value>((x) ? "true" : "false")</cpp:value></cpp:define>


<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>COMPILING_BINARY_FUNCS</name></cpp:ifndef>
<comment type="block">/*
 * outToken
 *	  Convert an ordinary string (eg, an identifier) into a form that
 *	  will be decoded back to a plain token by read.c's functions.
 *
 *	  If a null or empty string is given, it is encoded as "&lt;&gt;".
 */</comment>
<function><type><name>void</name></type>
<name>outToken</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>s</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>*</operator><name>s</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"&lt;&gt;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Look for characters or patterns that are treated specially by read.c
	 * (either in pg_strtok() or in nodeRead()), and therefore need a
	 * protective backslash.
	 */</comment>
	<comment type="block">/* These characters only need to be quoted at the start of the string */</comment>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>s</name> <operator>==</operator> <literal type="char">'&lt;'</literal> <operator>||</operator>
		<operator>*</operator><name>s</name> <operator>==</operator> <literal type="char">'"'</literal> <operator>||</operator>
		<call><name>isdigit</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>s</name></expr></argument>)</argument_list></call> <operator>||</operator>
		<operator>(</operator><operator>(</operator><operator>*</operator><name>s</name> <operator>==</operator> <literal type="char">'+'</literal> <operator>||</operator> <operator>*</operator><name>s</name> <operator>==</operator> <literal type="char">'-'</literal><operator>)</operator> <operator>&amp;&amp;</operator>
		 <operator>(</operator><call><name>isdigit</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <name><name>s</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>||</operator> <name><name>s</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'.'</literal><operator>)</operator><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="char">'\\'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<while>while <condition>(<expr><operator>*</operator><name>s</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* These chars must be backslashed anywhere in the string */</comment>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>s</name> <operator>==</operator> <literal type="char">' '</literal> <operator>||</operator> <operator>*</operator><name>s</name> <operator>==</operator> <literal type="char">'\n'</literal> <operator>||</operator> <operator>*</operator><name>s</name> <operator>==</operator> <literal type="char">'\t'</literal> <operator>||</operator>
			<operator>*</operator><name>s</name> <operator>==</operator> <literal type="char">'('</literal> <operator>||</operator> <operator>*</operator><name>s</name> <operator>==</operator> <literal type="char">')'</literal> <operator>||</operator> <operator>*</operator><name>s</name> <operator>==</operator> <literal type="char">'{'</literal> <operator>||</operator> <operator>*</operator><name>s</name> <operator>==</operator> <literal type="char">'}'</literal> <operator>||</operator>
			<operator>*</operator><name>s</name> <operator>==</operator> <literal type="char">'\\'</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="char">'\\'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>*</operator><name>s</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/*
 * Convert one char.  Goes through outToken() so that special characters are
 * escaped.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>outChar</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>in</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>in</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>in</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>outToken</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>in</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outList</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>List</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>IntList</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="char">'i'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>OidList</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="char">'o'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>node</argument>)</argument_list></macro>
	<block>{<block_content>
		<comment type="block">/*
		 * For the sake of backward compatibility, we emit a slightly
		 * different whitespace format for lists of nodes vs. other types of
		 * lists. XXX: is this necessary?
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>List</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>outNode</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>lnext</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>IntList</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" %d"</literal></expr></argument>, <argument><expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>OidList</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" %u"</literal></expr></argument>, <argument><expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized list node type: %d"</literal></expr></argument>,
				 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>node</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* COMPILING_BINARY_FUNCS */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>COMPILING_BINARY_FUNCS</name></cpp:ifndef>
<comment type="block">/*
 * outBitmapset -
 *	   converts a bitmap set of integers
 *
 * Note: the output format is "(b int int ...)", similar to an integer List.
 */</comment>
<function><type><name>void</name></type>
<name>outBitmapset</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Bitmapset</name> <modifier>*</modifier></type><name>bms</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>x</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="char">'b'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>x</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>x</name> <operator>=</operator> <call><name>bms_next_member</name><argument_list>(<argument><expr><name>bms</name></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" %d"</literal></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Print the value of a Datum given its type.
 */</comment>
<function><type><name>void</name></type>
<name>outDatum</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>typlen</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>typbyval</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Size</name></type>		<name>length</name></decl>,
				<decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>length</name> <operator>=</operator> <call><name>datumGetSize</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>typbyval</name></expr></argument>, <argument><expr><name>typlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>typbyval</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>s</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>&amp;</operator><name>value</name><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"%u [ "</literal></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator> <name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <operator>(</operator><name>Size</name><operator>)</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"%d "</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="char">']'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>s</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PointerIsValid</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"0 [ ]"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"%u [ "</literal></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator> <name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>length</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"%d "</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
			<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="char">']'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* COMPILING_BINARY_FUNCS */</comment>

<comment type="block">/*
 *	Stuff from plannodes.h
 */</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outPlannedStmt</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>PlannedStmt</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"PLANNEDSTMT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>commandType</name></expr></argument>, <argument><expr><name>CmdType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>planGen</name></expr></argument>, <argument><expr><name>PlanGenerator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_UINT64_FIELD</name><argument_list>(<argument><expr><name>queryId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>hasReturning</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>hasModifyingCTE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>canSetTag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>transientPlan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>oneoffPlan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>simplyUpdatableRel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>dependsOnRole</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>parallelModeNeeded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>jitFlags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>planTree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>rtable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>resultRelations</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>rootResultRelations</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>subplans</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name>rewindPlanIDs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>rowMarks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>relationOids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/*
	 * Don't serialize invalItems when dispatching. The TIDs of the invalidated items wouldn't
	 * make sense in segments.
	 */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>COMPILING_BINARY_FUNCS</name></cpp:ifndef>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>invalItems</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* COMPILING_BINARY_FUNCS */</comment>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>paramExecTypes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>utilityStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>WRITE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>stmt_location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>WRITE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>stmt_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_INT_ARRAY</name><argument_list>(<argument><expr><name>subplan_sliceIds</name></expr></argument>, <argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>subplans</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>numSlices</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>node</name><operator>-&gt;</operator><name>numSlices</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name><name>slices</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sliceIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name><name>slices</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>parentIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name><name>slices</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>gangType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name><name>slices</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>numsegments</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name><name>slices</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>segindex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name><name>slices</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>directDispatch</name><operator>.</operator><name>isDirectDispatch</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name><name>slices</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>directDispatch</name><operator>.</operator><name>contentIds</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>WRITE_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name>rewindPlanIDs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>intoPolicy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_UINT64_FIELD</name><argument_list>(<argument><expr><name>query_mem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>total_memory_coordinator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>nsegments_coordinator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>intoClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>copyIntoClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>refreshClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>metricsQueryType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outQueryDispatchDesc</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>QueryDispatchDesc</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"QUERYDISPATCHDESC"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>intoCreateStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>paramInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>oidAssignments</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>sliceTable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>cursorPositions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>parallelCursorName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>useChangedAOOpts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>secContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outSerializedParams</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>SerializedParams</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"SERIALIZEDPARAMS"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>nExternParams</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>node</name><operator>-&gt;</operator><name>nExternParams</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name><name>externParams</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name><name>externParams</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name><name>externParams</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ptype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name><name>externParams</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>plen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name><name>externParams</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pbyval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>node</name><operator>-&gt;</operator><name>externParams</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>outDatum</name><argument_list>(<argument><expr><name>str</name></expr></argument>,
					 <argument><expr><name><name>node</name><operator>-&gt;</operator><name>externParams</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>value</name></expr></argument>,
					 <argument><expr><name><name>node</name><operator>-&gt;</operator><name>externParams</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>plen</name></expr></argument>,
					 <argument><expr><name><name>node</name><operator>-&gt;</operator><name>externParams</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pbyval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>nExecParams</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>node</name><operator>-&gt;</operator><name>nExecParams</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name><name>execParams</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name><name>execParams</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>isvalid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name><name>execParams</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>plen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name><name>execParams</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pbyval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>execParams</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>isvalid</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>node</name><operator>-&gt;</operator><name>execParams</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>outDatum</name><argument_list>(<argument><expr><name>str</name></expr></argument>,
					 <argument><expr><name><name>node</name><operator>-&gt;</operator><name>execParams</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>value</name></expr></argument>,
					 <argument><expr><name><name>node</name><operator>-&gt;</operator><name>execParams</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>plen</name></expr></argument>,
					 <argument><expr><name><name>node</name><operator>-&gt;</operator><name>execParams</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pbyval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name><name>execParams</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>pbyval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * No text output function for TupleDescNodes. But that's OK, we
	 * only support text output for debugging purposes.
	 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>COMPILING_BINARY_FUNCS</name></cpp:ifdef>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>transientTypes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outOidAssignment</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>OidAssignment</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"OIDASSIGNMENT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>catalog</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>objname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>namespaceOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>keyOid1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>keyOid2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * print the basic stuff of all nodes that inherit from Plan
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outPlanInfo</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Plan</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_FLOAT_FIELD</name><argument_list>(<argument><expr><name>startup_cost</name></expr></argument>, <argument><expr><literal type="string">"%.2f"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_FLOAT_FIELD</name><argument_list>(<argument><expr><name>total_cost</name></expr></argument>, <argument><expr><literal type="string">"%.2f"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_FLOAT_FIELD</name><argument_list>(<argument><expr><name>plan_rows</name></expr></argument>, <argument><expr><literal type="string">"%.0f"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>plan_width</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>parallel_aware</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>parallel_safe</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>plan_node_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>targetlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>qual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>lefttree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>righttree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>initPlan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name>extParam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name>allParam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* 'flow' is only needed during planning. */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>COMPILING_BINARY_FUNCS</name></cpp:ifndef>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>flow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* COMPILING_BINARY_FUNCS */</comment>

	<expr_stmt><expr><call><name>WRITE_UINT64_FIELD</name><argument_list>(<argument><expr><name>operatorMemKB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * print the basic stuff of all nodes that inherit from Scan
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outScanInfo</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Scan</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>_outPlanInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>Plan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_UINT_FIELD</name><argument_list>(<argument><expr><name>scanrelid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * print the basic stuff of all nodes that inherit from Join
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outJoinPlanInfo</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Join</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>_outPlanInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>Plan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>prefetch_inner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>prefetch_joinqual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>prefetch_qual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>jointype</name></expr></argument>, <argument><expr><name>JoinType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>inner_unique</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>joinqual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outPlan</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Plan</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"PLAN"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outPlanInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>Plan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outResult</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Result</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"RESULT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outPlanInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>Plan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>resconstantqual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>numHashFilterCols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_ATTRNUMBER_ARRAY</name><argument_list>(<argument><expr><name>hashFilterColIdx</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>numHashFilterCols</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_ARRAY</name><argument_list>(<argument><expr><name>hashFilterFuncs</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>numHashFilterCols</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outProjectSet</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ProjectSet</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"PROJECTSET"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outPlanInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>Plan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outModifyTable</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ModifyTable</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"MODIFYTABLE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outPlanInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>Plan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>operation</name></expr></argument>, <argument><expr><name>CmdType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>canSetTag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_UINT_FIELD</name><argument_list>(<argument><expr><name>nominalRelation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_UINT_FIELD</name><argument_list>(<argument><expr><name>rootRelation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>partColsUpdated</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>resultRelations</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>resultRelIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>rootResultRelIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>plans</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>withCheckOptionLists</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>returningLists</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>fdwPrivLists</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name>fdwDirectModifyPlans</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>rowMarks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>epqParam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>onConflictAction</name></expr></argument>, <argument><expr><name>OnConflictAction</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>arbiterIndexes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>onConflictSet</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>onConflictWhere</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_UINT_FIELD</name><argument_list>(<argument><expr><name>exclRelRTI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>exclRelTlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>isSplitUpdates</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>forceTupleRouting</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outAppend</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Append</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"APPEND"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outPlanInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>Plan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>appendplans</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>first_partial_plan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>part_prune_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>join_prune_paramids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outSequence</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Sequence</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"SEQUENCE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>_outPlanInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>subplans</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outMergeAppend</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>MergeAppend</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"MERGEAPPEND"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outPlanInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>Plan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>mergeplans</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>numCols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_ATTRNUMBER_ARRAY</name><argument_list>(<argument><expr><name>sortColIdx</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>numCols</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_ARRAY</name><argument_list>(<argument><expr><name>sortOperators</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>numCols</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_ARRAY</name><argument_list>(<argument><expr><name>collations</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>numCols</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_ARRAY</name><argument_list>(<argument><expr><name>nullsFirst</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>numCols</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>part_prune_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>join_prune_paramids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outRecursiveUnion</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>RecursiveUnion</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"RECURSIVEUNION"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outPlanInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>Plan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>wtParam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>numCols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_ATTRNUMBER_ARRAY</name><argument_list>(<argument><expr><name>dupColIdx</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>numCols</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_ARRAY</name><argument_list>(<argument><expr><name>dupOperators</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>numCols</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_ARRAY</name><argument_list>(<argument><expr><name>dupCollations</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>numCols</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_LONG_FIELD</name><argument_list>(<argument><expr><name>numGroups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outBitmapAnd</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BitmapAnd</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"BITMAPAND"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outPlanInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>Plan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>bitmapplans</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outBitmapOr</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BitmapOr</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"BITMAPOR"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outPlanInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>Plan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>isshared</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>bitmapplans</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outGather</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Gather</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"GATHER"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outPlanInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>Plan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>num_workers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>rescan_param</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>single_copy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>invisible</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name>initParam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outGatherMerge</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>GatherMerge</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"GATHERMERGE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outPlanInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>Plan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>num_workers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>rescan_param</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>numCols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_ATTRNUMBER_ARRAY</name><argument_list>(<argument><expr><name>sortColIdx</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>numCols</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_ARRAY</name><argument_list>(<argument><expr><name>sortOperators</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>numCols</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_ARRAY</name><argument_list>(<argument><expr><name>collations</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>numCols</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_ARRAY</name><argument_list>(<argument><expr><name>nullsFirst</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>numCols</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name>initParam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outScan</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Scan</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"SCAN"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outScanInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outSeqScan</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>SeqScan</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"SEQSCAN"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outScanInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>Scan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outDynamicSeqScan</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>DynamicSeqScan</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"DYNAMICSEQSCAN"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outScanInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><name>Scan</name> <operator>*</operator><operator>)</operator><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>partOids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>part_prune_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>join_prune_paramids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outSampleScan</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>SampleScan</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"SAMPLESCAN"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outScanInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>Scan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>tablesample</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outExternalScanInfo</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ExternalScanInfo</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"EXTERNALSCANINFO"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>uriList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_CHAR_FIELD</name><argument_list>(<argument><expr><name>fmtType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>isMasterOnly</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>rejLimit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>rejLimitInRows</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_CHAR_FIELD</name><argument_list>(<argument><expr><name>logErrors</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>scancounter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>extOptions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>outIndexScanFields</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>IndexScan</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>_outScanInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>Scan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>indexid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>indexqual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>indexqualorig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>indexorderby</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>indexorderbyorig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>indexorderbyops</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>indexorderdir</name></expr></argument>, <argument><expr><name>ScanDirection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outIndexScan</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>IndexScan</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"INDEXSCAN"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>outIndexScanFields</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outIndexOnlyScan</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>IndexOnlyScan</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"INDEXONLYSCAN"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outScanInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>Scan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>indexid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>indexqual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>indexorderby</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>indextlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>indexorderdir</name></expr></argument>, <argument><expr><name>ScanDirection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outDynamicIndexScan</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>DynamicIndexScan</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"DYNAMICINDEXSCAN"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>outIndexScanFields</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>indexscan</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>partOids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>part_prune_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>join_prune_paramids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outBitmapIndexScanFields</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BitmapIndexScan</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>_outScanInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><name>Scan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>indexid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>isshared</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>indexqual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>indexqualorig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outBitmapIndexScan</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BitmapIndexScan</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"BITMAPINDEXSCAN"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outBitmapIndexScanFields</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outDynamicBitmapIndexScan</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>DynamicBitmapIndexScan</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"DYNAMICBITMAPINDEXSCAN"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outBitmapIndexScanFields</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>biscan</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>outBitmapHeapScanFields</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BitmapHeapScan</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>_outScanInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>Scan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>bitmapqualorig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outBitmapHeapScan</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BitmapHeapScan</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"BITMAPHEAPSCAN"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>outBitmapHeapScanFields</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outDynamicBitmapHeapScan</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>DynamicBitmapHeapScan</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"DYNAMICBITMAPHEAPSCAN"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>outBitmapHeapScanFields</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>bitmapheapscan</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>partOids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>part_prune_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>join_prune_paramids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outTidScan</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>TidScan</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"TIDSCAN"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outScanInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>Scan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>tidquals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outSubqueryScan</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>SubqueryScan</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"SUBQUERYSCAN"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outScanInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>Scan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>subplan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outFunctionScan</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>FunctionScan</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"FUNCTIONSCAN"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outScanInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>Scan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>functions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>funcordinality</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>param</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>resultInTupleStore</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>initplanId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outTableFuncScan</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>TableFuncScan</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"TABLEFUNCSCAN"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outScanInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>Scan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>tablefunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outValuesScan</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ValuesScan</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"VALUESSCAN"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outScanInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>Scan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>values_lists</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outCteScan</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CteScan</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"CTESCAN"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outScanInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>Scan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>ctePlanId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>cteParam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outNamedTuplestoreScan</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>NamedTuplestoreScan</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"NAMEDTUPLESTORESCAN"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outScanInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>Scan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>enrname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outWorkTableScan</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>WorkTableScan</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"WORKTABLESCAN"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outScanInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>Scan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>wtParam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outForeignScan</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ForeignScan</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"FOREIGNSCAN"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outScanInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>Scan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>operation</name></expr></argument>, <argument><expr><name>CmdType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>fs_server</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>fdw_exprs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>fdw_private</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>fdw_scan_tlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>fdw_recheck_quals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name>fs_relids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>fsSystemCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>COMPILING_BINARY_FUNCS</name></cpp:ifndef>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outCustomScan</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CustomScan</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"CUSTOMSCAN"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outScanInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>Scan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_UINT_FIELD</name><argument_list>(<argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>custom_plans</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>custom_exprs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>custom_private</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>custom_scan_tlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name>custom_relids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* CustomName is a key to lookup CustomScanMethods */</comment>
	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" :methods "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>outToken</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>methods</name><operator>-&gt;</operator><name>CustomName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* COMPILING_BINARY_FUNCS */</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outJoin</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Join</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"JOIN"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outJoinPlanInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>Join</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outNestLoop</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>NestLoop</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"NESTLOOP"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outJoinPlanInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>Join</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>nestParams</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>shared_outer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>singleton_outer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/*CDB-OLAP*/</comment>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outMergeJoin</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>MergeJoin</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>numCols</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"MERGEJOIN"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outJoinPlanInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>Join</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>skip_mark_restore</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>mergeclauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>numCols</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>mergeclauses</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_OID_ARRAY</name><argument_list>(<argument><expr><name>mergeFamilies</name></expr></argument>, <argument><expr><name>numCols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_ARRAY</name><argument_list>(<argument><expr><name>mergeCollations</name></expr></argument>, <argument><expr><name>numCols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_ARRAY</name><argument_list>(<argument><expr><name>mergeStrategies</name></expr></argument>, <argument><expr><name>numCols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_ARRAY</name><argument_list>(<argument><expr><name>mergeNullsFirst</name></expr></argument>, <argument><expr><name>numCols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>unique_outer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outHashJoin</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>HashJoin</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"HASHJOIN"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outJoinPlanInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>Join</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>hashclauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>hashqualclauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outAgg</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Agg</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"AGG"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outPlanInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>Plan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>aggstrategy</name></expr></argument>, <argument><expr><name>AggStrategy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>aggsplit</name></expr></argument>, <argument><expr><name>AggSplit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>numCols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_ATTRNUMBER_ARRAY</name><argument_list>(<argument><expr><name>grpColIdx</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>numCols</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_ARRAY</name><argument_list>(<argument><expr><name>grpOperators</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>numCols</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_ARRAY</name><argument_list>(<argument><expr><name>grpCollations</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>numCols</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_LONG_FIELD</name><argument_list>(<argument><expr><name>numGroups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name>aggParams</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>groupingSets</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>chain</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>streaming</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_UINT_FIELD</name><argument_list>(<argument><expr><name>agg_expr_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outDQAExpr</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>DQAExpr</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"DQAExpr"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>agg_expr_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>WRITE_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name>agg_args_id_bms</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>agg_filter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outTupleSplit</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>TupleSplit</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"TupleSplit"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outPlanInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>Plan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>numCols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_ATTRNUMBER_ARRAY</name><argument_list>(<argument><expr><name>grpColIdx</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>numCols</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>dqa_expr_lst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outWindowAgg</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>WindowAgg</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"WINDOWAGG"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outPlanInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>Plan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_UINT_FIELD</name><argument_list>(<argument><expr><name>winref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>partNumCols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_ATTRNUMBER_ARRAY</name><argument_list>(<argument><expr><name>partColIdx</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>partNumCols</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_ARRAY</name><argument_list>(<argument><expr><name>partOperators</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>partNumCols</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_ARRAY</name><argument_list>(<argument><expr><name>partCollations</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>partNumCols</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>ordNumCols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_ATTRNUMBER_ARRAY</name><argument_list>(<argument><expr><name>ordColIdx</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>ordNumCols</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_ARRAY</name><argument_list>(<argument><expr><name>ordOperators</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>ordNumCols</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_ARRAY</name><argument_list>(<argument><expr><name>ordCollations</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>ordNumCols</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>firstOrderCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>firstOrderCmpOperator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>firstOrderNullsFirst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>frameOptions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>startOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>endOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>startInRangeFunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>endInRangeFunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>inRangeColl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>inRangeAsc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>inRangeNullsFirst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outTableFunctionScan</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>TableFunctionScan</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"TABLEFUNCTIONSCAN"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outScanInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><name>Scan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>function</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outMaterial</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Material</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"MATERIAL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outPlanInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>cdb_strict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>cdb_shield_child_from_rescans</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outShareInputScan</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ShareInputScan</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"SHAREINPUTSCAN"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>cross_slice</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>share_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>producer_slice_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>this_slice_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>nconsumers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outPlanInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outSort</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Sort</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"SORT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outPlanInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>Plan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>numCols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>WRITE_ATTRNUMBER_ARRAY</name><argument_list>(<argument><expr><name>sortColIdx</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>numCols</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>WRITE_OID_ARRAY</name><argument_list>(<argument><expr><name>sortOperators</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>numCols</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>WRITE_OID_ARRAY</name><argument_list>(<argument><expr><name>collations</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>numCols</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>WRITE_BOOL_ARRAY</name><argument_list>(<argument><expr><name>nullsFirst</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>numCols</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outUnique</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Unique</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"UNIQUE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outPlanInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>Plan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>numCols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_ATTRNUMBER_ARRAY</name><argument_list>(<argument><expr><name>uniqColIdx</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>numCols</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_ARRAY</name><argument_list>(<argument><expr><name>uniqOperators</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>numCols</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_ARRAY</name><argument_list>(<argument><expr><name>uniqCollations</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>numCols</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outHash</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Hash</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"HASH"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outPlanInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>Plan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>rescannable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>          <comment type="block">/*CDB*/</comment>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>skewTable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>skewColumn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>skewInherit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_FLOAT_FIELD</name><argument_list>(<argument><expr><name>rows_total</name></expr></argument>, <argument><expr><literal type="string">"%.0f"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outSetOp</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>SetOp</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"SETOP"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outPlanInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>Plan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>SetOpCmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>strategy</name></expr></argument>, <argument><expr><name>SetOpStrategy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>numCols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_ATTRNUMBER_ARRAY</name><argument_list>(<argument><expr><name>dupColIdx</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>numCols</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_ARRAY</name><argument_list>(<argument><expr><name>dupOperators</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>numCols</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_ARRAY</name><argument_list>(<argument><expr><name>dupCollations</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>numCols</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>flagColIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>firstFlag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_LONG_FIELD</name><argument_list>(<argument><expr><name>numGroups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outLockRows</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>LockRows</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"LOCKROWS"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outPlanInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>Plan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>rowMarks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>epqParam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outLimit</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Limit</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"LIMIT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outPlanInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>Plan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>limitOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>limitCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outNestLoopParam</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>NestLoopParam</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"NESTLOOPPARAM"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>paramno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>paramval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outPlanRowMark</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>PlanRowMark</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"PLANROWMARK"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_UINT_FIELD</name><argument_list>(<argument><expr><name>rti</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_UINT_FIELD</name><argument_list>(<argument><expr><name>prti</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_UINT_FIELD</name><argument_list>(<argument><expr><name>rowmarkId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>markType</name></expr></argument>, <argument><expr><name>RowMarkType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>allMarkTypes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>strength</name></expr></argument>, <argument><expr><name>LockClauseStrength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>waitPolicy</name></expr></argument>, <argument><expr><name>LockWaitPolicy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>isParent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>canOptSelectLockingClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outPartitionPruneInfo</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>PartitionPruneInfo</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"PARTITIONPRUNEINFO"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>prune_infos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name>other_subplans</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outPartitionedRelPruneInfo</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>PartitionedRelPruneInfo</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"PARTITIONEDRELPRUNEINFO"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_UINT_FIELD</name><argument_list>(<argument><expr><name>rtindex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name>present_parts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>nparts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_ARRAY</name><argument_list>(<argument><expr><name>subplan_map</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>nparts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_ARRAY</name><argument_list>(<argument><expr><name>subpart_map</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>nparts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_ARRAY</name><argument_list>(<argument><expr><name>relid_map</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>nparts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>initial_pruning_steps</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>exec_pruning_steps</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name>execparamids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outPartitionPruneStepOp</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>PartitionPruneStepOp</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"PARTITIONPRUNESTEPOP"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name><name>step</name><operator>.</operator><name>step_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>opstrategy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>exprs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>cmpfns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name>nullkeys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outPartitionPruneStepCombine</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>PartitionPruneStepCombine</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"PARTITIONPRUNESTEPCOMBINE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name><name>step</name><operator>.</operator><name>step_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>combineOp</name></expr></argument>, <argument><expr><name>PartitionPruneCombineOp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>source_stepids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>COMPILING_BINARY_FUNCS</name></cpp:ifndef>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outPlanInvalItem</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>PlanInvalItem</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"PLANINVALITEM"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>cacheId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_UINT_FIELD</name><argument_list>(<argument><expr><name>hashValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* COMPILING_BINARY_FUNCS */</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outMotion</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Motion</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"MOTION"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>motionID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>motionType</name></expr></argument>, <argument><expr><name>MotionType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>sendSorted</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>hashExprs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_ARRAY</name><argument_list>(<argument><expr><name>hashFuncs</name></expr></argument>, <argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>hashExprs</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>numSortCols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_ATTRNUMBER_ARRAY</name><argument_list>(<argument><expr><name>sortColIdx</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>numSortCols</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_ARRAY</name><argument_list>(<argument><expr><name>sortOperators</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>numSortCols</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_ARRAY</name><argument_list>(<argument><expr><name>collations</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>numSortCols</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_ARRAY</name><argument_list>(<argument><expr><name>nullsFirst</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>numSortCols</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>segidColIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>numHashSegments</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* senderSliceInfo is intentionally omitted. It's only used during planning */</comment>

	<expr_stmt><expr><call><name>_outPlanInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _outSplitUpdate
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outSplitUpdate</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>SplitUpdate</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"SplitUpdate"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>actionColIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>insertColIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>deleteColIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>numHashSegments</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>numHashAttrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_ATTRNUMBER_ARRAY</name><argument_list>(<argument><expr><name>hashAttnos</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>numHashAttrs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_ARRAY</name><argument_list>(<argument><expr><name>hashFuncs</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>numHashAttrs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outPlanInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _outAssertOp
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outAssertOp</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>AssertOp</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"AssertOp"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>errmessage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>errcode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outPlanInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _outPartitionSelector
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outPartitionSelector</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>PartitionSelector</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"PartitionSelector"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>paramid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>part_prune_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outPlanInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/*****************************************************************************
 *
 *	Stuff from primnodes.h.
 *
 *****************************************************************************/</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outAlias</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Alias</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"ALIAS"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>aliasname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>colnames</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outRangeVar</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>RangeVar</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"RANGEVAR"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * we deliberately ignore catalogname here, since it is presently not
	 * semantically meaningful
	 */</comment>
	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>catalogname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>schemaname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>relname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>inh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_CHAR_FIELD</name><argument_list>(<argument><expr><name>relpersistence</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>alias</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outTableFunc</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>TableFunc</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"TABLEFUNC"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>ns_uris</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>ns_names</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>docexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>rowexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>colnames</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>coltypes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>coltypmods</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>colcollations</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>colexprs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>coldefexprs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name>notnulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>ordinalitycol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outIntoClause</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>IntoClause</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"INTOCLAUSE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>colNames</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>accessMethod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>onCommit</name></expr></argument>, <argument><expr><name>OnCommitAction</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>tableSpaceName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>viewQuery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>skipData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>distributedBy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outCopyIntoClause</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CopyIntoClause</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"COPYINTOCLAUSE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>attlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>is_program</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outRefreshClause</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>RefreshClause</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"REFRESHCLAUSE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>concurrent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>skipData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outVar</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Var</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"VAR"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_UINT_FIELD</name><argument_list>(<argument><expr><name>varno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>varattno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>vartype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>vartypmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>varcollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_UINT_FIELD</name><argument_list>(<argument><expr><name>varlevelsup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_UINT_FIELD</name><argument_list>(<argument><expr><name>varnoold</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>varoattno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>COMPILING_BINARY_FUNCS</name></cpp:ifndef>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outConst</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Const</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"CONST"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>consttype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>consttypmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>constcollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>constlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>constbyval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>constisnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" :constvalue "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>constisnull</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"&lt;&gt;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>outDatum</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>constvalue</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>constlen</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>constbyval</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* COMPILING_BINARY_FUNCS */</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outParam</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Param</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"PARAM"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>paramkind</name></expr></argument>, <argument><expr><name>ParamKind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>paramid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>paramtype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>paramtypmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>paramcollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outAggref</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Aggref</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"AGGREF"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>aggfnoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>aggtype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>aggcollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>inputcollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>aggtranstype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>aggargtypes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>aggdirectargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>aggorder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>aggdistinct</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>aggfilter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>aggstar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>aggvariadic</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_CHAR_FIELD</name><argument_list>(<argument><expr><name>aggkind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_UINT_FIELD</name><argument_list>(<argument><expr><name>agglevelsup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>aggsplit</name></expr></argument>, <argument><expr><name>AggSplit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>agg_expr_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outGroupingFunc</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>GroupingFunc</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"GROUPINGFUNC"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>refs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>cols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_UINT_FIELD</name><argument_list>(<argument><expr><name>agglevelsup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outGroupId</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>GroupId</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"GROUPID"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>agglevelsup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outGroupingSetId</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>GroupingSetId</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"GROUPINGSETID"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outWindowFunc</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>WindowFunc</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"WINDOWFUNC"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>winfnoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>wintype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>wincollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>inputcollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>aggfilter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_UINT_FIELD</name><argument_list>(<argument><expr><name>winref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>winstar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>winagg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>windistinct</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outSubscriptingRef</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>SubscriptingRef</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"SUBSCRIPTINGREF"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>refcontainertype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>refelemtype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>reftypmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>refcollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>refupperindexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>reflowerindexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>refexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>refassgnexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outFuncExpr</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>FuncExpr</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"FUNCEXPR"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>funcid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>funcresulttype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>funcretset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>funcvariadic</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>funcformat</name></expr></argument>, <argument><expr><name>CoercionForm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>funccollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>inputcollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>is_tablefunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* GPDB */</comment>
	<expr_stmt><expr><call><name>WRITE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outNamedArgExpr</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>NamedArgExpr</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"NAMEDARGEXPR"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>argnumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outOpExpr</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>OpExpr</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"OPEXPR"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>opno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>opfuncid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>opresulttype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>opretset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>opcollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>inputcollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outDistinctExpr</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>DistinctExpr</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"DISTINCTEXPR"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>opno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>opfuncid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>opresulttype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>opretset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>opcollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>inputcollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outNullIfExpr</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>NullIfExpr</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"NULLIFEXPR"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>opno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>opfuncid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>opresulttype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>opretset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>opcollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>inputcollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outScalarArrayOpExpr</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ScalarArrayOpExpr</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"SCALARARRAYOPEXPR"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>opno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>opfuncid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>useOr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>inputcollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>COMPILING_BINARY_FUNCS</name></cpp:ifndef>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outBoolExpr</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BoolExpr</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>opstr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"BOOLEXPR"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* do-it-yourself enum representation */</comment>
	<switch>switch <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>boolop</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>AND_EXPR</name></expr>:</case>
			<expr_stmt><expr><name>opstr</name> <operator>=</operator> <literal type="string">"and"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>OR_EXPR</name></expr>:</case>
			<expr_stmt><expr><name>opstr</name> <operator>=</operator> <literal type="string">"or"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>NOT_EXPR</name></expr>:</case>
			<expr_stmt><expr><name>opstr</name> <operator>=</operator> <literal type="string">"not"</literal></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" :boolop "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>outToken</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>opstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* COMPILING_BINARY_FUNCS */</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outSubLink</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>SubLink</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"SUBLINK"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>subLinkType</name></expr></argument>, <argument><expr><name>SubLinkType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>subLinkId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>testexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>operName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>subselect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outSubPlan</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>SubPlan</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"SUBPLAN"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>subLinkType</name></expr></argument>, <argument><expr><name>SubLinkType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>testexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>paramIds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>plan_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>plan_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>firstColType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>firstColTypmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>firstColCollation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>useHashTable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>unknownEqFalse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>parallel_safe</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>is_initplan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/*CDB*/</comment>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>is_multirow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/*CDB*/</comment>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>setParam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>parParam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>extParam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_FLOAT_FIELD</name><argument_list>(<argument><expr><name>startup_cost</name></expr></argument>, <argument><expr><literal type="string">"%.2f"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_FLOAT_FIELD</name><argument_list>(<argument><expr><name>per_call_cost</name></expr></argument>, <argument><expr><literal type="string">"%.2f"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outAlternativeSubPlan</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>AlternativeSubPlan</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"ALTERNATIVESUBPLAN"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>subplans</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outFieldSelect</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>FieldSelect</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"FIELDSELECT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>fieldnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>resulttype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>resulttypmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>resultcollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outFieldStore</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>FieldStore</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"FIELDSTORE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>newvals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>fieldnums</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>resulttype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outRelabelType</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>RelabelType</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"RELABELTYPE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>resulttype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>resulttypmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>resultcollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>relabelformat</name></expr></argument>, <argument><expr><name>CoercionForm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outCoerceViaIO</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CoerceViaIO</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"COERCEVIAIO"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>resulttype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>resultcollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>coerceformat</name></expr></argument>, <argument><expr><name>CoercionForm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outArrayCoerceExpr</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ArrayCoerceExpr</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"ARRAYCOERCEEXPR"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>elemexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>resulttype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>resulttypmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>resultcollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>coerceformat</name></expr></argument>, <argument><expr><name>CoercionForm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outConvertRowtypeExpr</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ConvertRowtypeExpr</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"CONVERTROWTYPEEXPR"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>resulttype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>convertformat</name></expr></argument>, <argument><expr><name>CoercionForm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outCollateExpr</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CollateExpr</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"COLLATE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>collOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outCaseExpr</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CaseExpr</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"CASE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>casetype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>casecollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>defresult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outCaseWhen</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CaseWhen</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"WHEN"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outCaseTestExpr</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CaseTestExpr</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"CASETESTEXPR"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>typeId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>typeMod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>collation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outArrayExpr</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ArrayExpr</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"ARRAY"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>array_typeid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>array_collid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>element_typeid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>elements</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>multidims</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outRowExpr</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>RowExpr</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"ROW"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>row_typeid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>row_format</name></expr></argument>, <argument><expr><name>CoercionForm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>colnames</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outRowCompareExpr</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>RowCompareExpr</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"ROWCOMPARE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>rctype</name></expr></argument>, <argument><expr><name>RowCompareType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>opnos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>opfamilies</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>inputcollids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>largs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>rargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outCoalesceExpr</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CoalesceExpr</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"COALESCE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>coalescetype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>coalescecollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outMinMaxExpr</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>MinMaxExpr</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"MINMAX"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>minmaxtype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>minmaxcollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>inputcollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>MinMaxOp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outSQLValueFunction</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>SQLValueFunction</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"SQLVALUEFUNCTION"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>SQLValueFunctionOp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>typmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outXmlExpr</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XmlExpr</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"XMLEXPR"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>XmlExprOp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>named_args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>arg_names</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>xmloption</name></expr></argument>, <argument><expr><name>XmlOptionType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>typmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outNullTest</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>NullTest</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"NULLTEST"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>nulltesttype</name></expr></argument>, <argument><expr><name>NullTestType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>argisrow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outBooleanTest</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BooleanTest</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"BOOLEANTEST"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>booltesttype</name></expr></argument>, <argument><expr><name>BoolTestType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outCoerceToDomain</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CoerceToDomain</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"COERCETODOMAIN"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>resulttype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>resulttypmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>resultcollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>coercionformat</name></expr></argument>, <argument><expr><name>CoercionForm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outCoerceToDomainValue</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CoerceToDomainValue</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"COERCETODOMAINVALUE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>typeId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>typeMod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>collation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outSetToDefault</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>SetToDefault</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"SETTODEFAULT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>typeId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>typeMod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>collation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>COMPILING_BINARY_FUNCS</name></cpp:ifndef>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outCurrentOfExpr</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CurrentOfExpr</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"CURRENTOFEXPR"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>cvarno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>cursor_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>cursor_param</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>target_relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* some attributes omitted as they're bound only just before executor dispatch */</comment>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* COMPILING_BINARY_FUNCS */</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outNextValueExpr</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>NextValueExpr</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"NEXTVALUEEXPR"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>seqid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>typeId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outInferenceElem</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>InferenceElem</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"INFERENCEELEM"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>infercollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>inferopclass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outTargetEntry</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>TargetEntry</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"TARGETENTRY"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>resno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>resname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_UINT_FIELD</name><argument_list>(<argument><expr><name>ressortgroupref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>resorigtbl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>resorigcol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>resjunk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outRangeTblRef</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>RangeTblRef</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"RANGETBLREF"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>rtindex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>COMPILING_BINARY_FUNCS</name></cpp:ifndef>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outJoinExpr</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>JoinExpr</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"JOINEXPR"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>jointype</name></expr></argument>, <argument><expr><name>JoinType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>isNatural</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>larg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>rarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>usingClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>quals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>alias</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>rtindex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* COMPILING_BINARY_FUNCS */</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outFromExpr</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>FromExpr</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"FROMEXPR"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>fromlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>quals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outOnConflictExpr</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>OnConflictExpr</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"ONCONFLICTEXPR"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>action</name></expr></argument>, <argument><expr><name>OnConflictAction</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>arbiterElems</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>arbiterWhere</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>constraint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>onConflictSet</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>onConflictWhere</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>exclRelIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>exclRelTlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* 'flow' is only needed during planning. */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>COMPILING_BINARY_FUNCS</name></cpp:ifndef>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outFlow</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Flow</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"FLOW"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>flotype</name></expr></argument>, <argument><expr><name>FlowType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>locustype</name></expr></argument>, <argument><expr><name>CdbLocusType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>segindex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>numsegments</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* COMPILING_BINARY_FUNCS */</comment>

<comment type="block" format="doxygen">/*****************************************************************************
 *
 *	Stuff from cdbpathlocus.h.
 *
 *****************************************************************************/</comment>

<comment type="block">/*
 * _outCdbPathLocus
 */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>COMPILING_BINARY_FUNCS</name></cpp:ifndef>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outCdbPathLocus</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CdbPathLocus</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>locustype</name></expr></argument>, <argument><expr><name>CdbLocusType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>distkey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>numsegments</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>                               <comment type="block">/* _outCdbPathLocus */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* COMPILING_BINARY_FUNCS */</comment>

<comment type="block" format="doxygen">/*****************************************************************************
 *
 *	Stuff from pathnodes.h.
 *
 *****************************************************************************/</comment>

<comment type="block">/*
 * None of this stuff is needed after planning, and doesn't need to be
 * dispatched to QEs.
 */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>COMPILING_BINARY_FUNCS</name></cpp:ifndef>

<comment type="block">/*
 * print the basic stuff of all nodes that inherit from Path
 *
 * Note we do NOT print the parent, else we'd be in infinite recursion.
 * We can print the parent's relids for identification purposes, though.
 * We print the pathtarget only if it's not the default one for the rel.
 * We also do not print the whole of param_info, since it's printed by
 * _outRelOptInfo; it's sufficient and less cluttering to print just the
 * required outer relids.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outPathInfo</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Path</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>pathtype</name></expr></argument>, <argument><expr><name>NodeTag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" :parent_relids "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>outBitmapset</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>pathtarget</name></name> <operator>!=</operator> <name><name>node</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>reltarget</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>pathtarget</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" :required_outer "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>param_info</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>outBitmapset</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>param_info</name><operator>-&gt;</operator><name>ppi_req_outer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>outBitmapset</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>parallel_aware</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>parallel_safe</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>parallel_workers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_FLOAT_FIELD</name><argument_list>(<argument><expr><name>rows</name></expr></argument>, <argument><expr><literal type="string">"%.0f"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_FLOAT_FIELD</name><argument_list>(<argument><expr><name>startup_cost</name></expr></argument>, <argument><expr><literal type="string">"%.2f"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_FLOAT_FIELD</name><argument_list>(<argument><expr><name>total_cost</name></expr></argument>, <argument><expr><literal type="string">"%.2f"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>_outCdbPathLocus</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>locus</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>pathkeys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * print the basic stuff of all nodes that inherit from JoinPath
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outJoinPathInfo</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>JoinPath</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>_outPathInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>Path</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>jointype</name></expr></argument>, <argument><expr><name>JoinType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>inner_unique</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>outerjoinpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>innerjoinpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>joinrestrictinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outPath</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Path</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"PATH"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outPathInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>Path</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outIndexPath</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>IndexPath</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"INDEXPATH"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outPathInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>Path</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>indexinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>indexclauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>indexorderbys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>indexorderbycols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>indexscandir</name></expr></argument>, <argument><expr><name>ScanDirection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_FLOAT_FIELD</name><argument_list>(<argument><expr><name>indextotalcost</name></expr></argument>, <argument><expr><literal type="string">"%.2f"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_FLOAT_FIELD</name><argument_list>(<argument><expr><name>indexselectivity</name></expr></argument>, <argument><expr><literal type="string">"%.4f"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>num_leading_eq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outBitmapHeapPath</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BitmapHeapPath</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"BITMAPHEAPPATH"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outPathInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>Path</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>bitmapqual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outBitmapAndPath</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BitmapAndPath</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"BITMAPANDPATH"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outPathInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>Path</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>bitmapquals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_FLOAT_FIELD</name><argument_list>(<argument><expr><name>bitmapselectivity</name></expr></argument>, <argument><expr><literal type="string">"%.4f"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outBitmapOrPath</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BitmapOrPath</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"BITMAPORPATH"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outPathInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>Path</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>bitmapquals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_FLOAT_FIELD</name><argument_list>(<argument><expr><name>bitmapselectivity</name></expr></argument>, <argument><expr><literal type="string">"%.4f"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outTidPath</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>TidPath</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"TIDPATH"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outPathInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>Path</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>tidquals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outSubqueryScanPath</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>SubqueryScanPath</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"SUBQUERYSCANPATH"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outPathInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>Path</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>subpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outTableFunctionScanPath</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>TableFunctionScanPath</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"TABLEFUNCTIONSCANPATH"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outPathInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>Path</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>subpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outForeignPath</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ForeignPath</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"FOREIGNPATH"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outPathInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>Path</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>fdw_outerpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>fdw_private</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outCustomPath</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CustomPath</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"CUSTOMPATH"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outPathInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>Path</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_UINT_FIELD</name><argument_list>(<argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>custom_paths</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>custom_private</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" :methods "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>outToken</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>methods</name><operator>-&gt;</operator><name>CustomName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outAppendPath</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>AppendPath</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"APPENDPATH"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outPathInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>Path</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>partitioned_rels</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>subpaths</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>first_partial_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_FLOAT_FIELD</name><argument_list>(<argument><expr><name>limit_tuples</name></expr></argument>, <argument><expr><literal type="string">"%.0f"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outMergeAppendPath</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>MergeAppendPath</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"MERGEAPPENDPATH"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outPathInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>Path</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>partitioned_rels</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>subpaths</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_FLOAT_FIELD</name><argument_list>(<argument><expr><name>limit_tuples</name></expr></argument>, <argument><expr><literal type="string">"%.0f"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outAppendOnlyPath</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>AppendOnlyPath</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"APPENDONLYPATH"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outPathInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outAOCSPath</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>AOCSPath</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"APPENDONLYPATH"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outPathInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><name>Path</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outGroupResultPath</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>GroupResultPath</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"GROUPRESULTPATH"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outPathInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>Path</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>quals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outMaterialPath</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>MaterialPath</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"MATERIALPATH"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outPathInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>Path</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>cdb_strict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>cdb_shield_child_from_rescans</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>subpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outUniquePath</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>UniquePath</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"UNIQUEPATH"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outPathInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>Path</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>subpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>umethod</name></expr></argument>, <argument><expr><name>UniquePathMethod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>in_operators</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>uniq_exprs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outGatherPath</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>GatherPath</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"GATHERPATH"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outPathInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>Path</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>subpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>single_copy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>num_workers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outProjectionPath</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ProjectionPath</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"PROJECTIONPATH"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outPathInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>Path</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>subpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>dummypp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outProjectSetPath</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ProjectSetPath</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"PROJECTSETPATH"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outPathInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>Path</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>subpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outSortPath</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>SortPath</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"SORTPATH"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outPathInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>Path</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>subpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outGroupPath</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>GroupPath</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"GROUPPATH"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outPathInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>Path</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>subpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>groupClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>qual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outUpperUniquePath</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>UpperUniquePath</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"UPPERUNIQUEPATH"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outPathInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>Path</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>subpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>numkeys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outAggPath</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>AggPath</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"AGGPATH"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outPathInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>Path</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>subpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>aggstrategy</name></expr></argument>, <argument><expr><name>AggStrategy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>aggsplit</name></expr></argument>, <argument><expr><name>AggSplit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_FLOAT_FIELD</name><argument_list>(<argument><expr><name>numGroups</name></expr></argument>, <argument><expr><literal type="string">"%.0f"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>groupClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>qual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>streaming</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outRollupData</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>RollupData</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"ROLLUP"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>groupClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>gsets</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>gsets_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_FLOAT_FIELD</name><argument_list>(<argument><expr><name>numGroups</name></expr></argument>, <argument><expr><literal type="string">"%.0f"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>hashable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>is_hashed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outGroupingSetData</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>GroupingSetData</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"GSDATA"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>set</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_FLOAT_FIELD</name><argument_list>(<argument><expr><name>numGroups</name></expr></argument>, <argument><expr><literal type="string">"%.0f"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outGroupingSetsPath</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>GroupingSetsPath</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"GROUPINGSETSPATH"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outPathInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>Path</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>subpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>aggstrategy</name></expr></argument>, <argument><expr><name>AggStrategy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>rollups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>qual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outMinMaxAggPath</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>MinMaxAggPath</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"MINMAXAGGPATH"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outPathInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>Path</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>mmaggregates</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>quals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outWindowAggPath</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>WindowAggPath</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"WINDOWAGGPATH"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outPathInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>Path</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>subpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>winclause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outSetOpPath</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>SetOpPath</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"SETOPPATH"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outPathInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>Path</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>subpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>SetOpCmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>strategy</name></expr></argument>, <argument><expr><name>SetOpStrategy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>distinctList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>flagColIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>firstFlag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_FLOAT_FIELD</name><argument_list>(<argument><expr><name>numGroups</name></expr></argument>, <argument><expr><literal type="string">"%.0f"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outRecursiveUnionPath</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>RecursiveUnionPath</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"RECURSIVEUNIONPATH"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outPathInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>Path</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>leftpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>rightpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>distinctList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>wtParam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_FLOAT_FIELD</name><argument_list>(<argument><expr><name>numGroups</name></expr></argument>, <argument><expr><literal type="string">"%.0f"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outLockRowsPath</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>LockRowsPath</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"LOCKROWSPATH"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outPathInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>Path</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>subpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>rowMarks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>epqParam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outModifyTablePath</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ModifyTablePath</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"MODIFYTABLEPATH"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outPathInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>Path</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>operation</name></expr></argument>, <argument><expr><name>CmdType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>canSetTag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_UINT_FIELD</name><argument_list>(<argument><expr><name>nominalRelation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_UINT_FIELD</name><argument_list>(<argument><expr><name>rootRelation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>partColsUpdated</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>resultRelations</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>subpaths</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>subroots</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>withCheckOptionLists</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>returningLists</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>rowMarks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>onconflict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>epqParam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outLimitPath</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>LimitPath</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"LIMITPATH"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outPathInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>Path</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>subpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>limitOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>limitCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outGatherMergePath</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>GatherMergePath</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"GATHERMERGEPATH"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outPathInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>Path</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>subpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>num_workers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outNestPath</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>NestPath</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"NESTPATH"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outJoinPathInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>JoinPath</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outMergePath</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>MergePath</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"MERGEPATH"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outJoinPathInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>JoinPath</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>path_mergeclauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>outersortkeys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>innersortkeys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>skip_mark_restore</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>materialize_inner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outHashPath</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>HashPath</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"HASHPATH"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outJoinPathInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>JoinPath</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>path_hashclauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>num_batches</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_FLOAT_FIELD</name><argument_list>(<argument><expr><name>inner_rows_total</name></expr></argument>, <argument><expr><literal type="string">"%.0f"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outCdbMotionPath</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CdbMotionPath</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"MOTIONPATH"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>_outPathInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>subpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outPlannerGlobal</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>PlannerGlobal</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"PLANNERGLOBAL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* NB: this isn't a complete set of fields */</comment>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>subplans</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name>rewindPlanIDs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>finalrtable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>finalrowmarks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>resultRelations</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>rootResultRelations</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>relationOids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>invalItems</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>paramExecTypes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_UINT_FIELD</name><argument_list>(<argument><expr><name>lastPHId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_UINT_FIELD</name><argument_list>(<argument><expr><name>lastRowMarkId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>lastPlanNodeId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>transientPlan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>oneoffPlan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name><name>share</name><operator>.</operator><name>motStack</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name><name>share</name><operator>.</operator><name>qdShares</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>dependsOnRole</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>parallelModeOK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>parallelModeNeeded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_CHAR_FIELD</name><argument_list>(<argument><expr><name>maxParallelHazard</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>COMPILING_BINARY_FUNCS</name></cpp:ifndef>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outPlannerInfo</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>PlannerInfo</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"PLANNERINFO"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* NB: this isn't a complete set of fields */</comment>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>parse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>glob</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_UINT_FIELD</name><argument_list>(<argument><expr><name>query_level</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>plan_params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name>outer_params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name>all_baserels</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name>nullable_baserels</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>join_rel_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>join_cur_level</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>init_plans</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>cte_plan_ids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>multiexpr_params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>eq_classes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>canon_pathkeys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>left_join_clauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>right_join_clauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>full_join_clauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>join_info_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>append_rel_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>rowMarks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>placeholder_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>fkey_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>query_pathkeys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>group_pathkeys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>window_pathkeys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>distinct_pathkeys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>sort_pathkeys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>processed_tlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>minmax_aggs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_FLOAT_FIELD</name><argument_list>(<argument><expr><name>total_table_pages</name></expr></argument>, <argument><expr><literal type="string">"%.0f"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_FLOAT_FIELD</name><argument_list>(<argument><expr><name>tuple_fraction</name></expr></argument>, <argument><expr><literal type="string">"%.4f"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_FLOAT_FIELD</name><argument_list>(<argument><expr><name>limit_tuples</name></expr></argument>, <argument><expr><literal type="string">"%.0f"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_UINT_FIELD</name><argument_list>(<argument><expr><name>qual_security_level</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>inhTargetKind</name></expr></argument>, <argument><expr><name>InheritanceKind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>hasJoinRTEs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>hasLateralRTEs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>hasHavingQual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>hasPseudoConstantQuals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>hasRecursion</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>wt_param_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name>curOuterRels</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>curOuterParams</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>partColsUpdated</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* COMPILING_BINARY_FUNCS */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>COMPILING_BINARY_FUNCS</name></cpp:ifndef>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outRelOptInfo</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>RelOptInfo</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"RELOPTINFO"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* NB: this isn't a complete set of fields */</comment>
	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>reloptkind</name></expr></argument>, <argument><expr><name>RelOptKind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name>relids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_FLOAT_FIELD</name><argument_list>(<argument><expr><name>rows</name></expr></argument>, <argument><expr><literal type="string">"%.0f"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>consider_startup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>consider_param_startup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>consider_parallel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>reltarget</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>pathlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>ppilist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>partial_pathlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>cheapest_startup_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>cheapest_total_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>cheapest_unique_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>cheapest_parameterized_paths</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name>direct_lateral_relids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name>lateral_relids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_UINT_FIELD</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>reltablespace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>rtekind</name></expr></argument>, <argument><expr><name>RTEKind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>min_attr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>max_attr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>lateral_vars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name>lateral_referencers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>indexlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>statlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_UINT_FIELD</name><argument_list>(<argument><expr><name>pages</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_FLOAT_FIELD</name><argument_list>(<argument><expr><name>tuples</name></expr></argument>, <argument><expr><literal type="string">"%.0f"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_FLOAT_FIELD</name><argument_list>(<argument><expr><name>allvisfrac</name></expr></argument>, <argument><expr><literal type="string">"%.6f"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>subroot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>subplan_params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>rel_parallel_workers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>serverid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>userid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>useridiscurrent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* we don't try to print fdwroutine or fdw_private */</comment>
	<comment type="block">/* can't print unique_for_rels/non_unique_for_rels; BMSes aren't Nodes */</comment>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>baserestrictinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_UINT_FIELD</name><argument_list>(<argument><expr><name>baserestrict_min_security</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>joininfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>has_eclass_joins</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>consider_partitionwise_join</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name>top_parent_relids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>partitioned_child_rels</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* COMPILING_BINARY_FUNCS */</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outIndexOptInfo</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>IndexOptInfo</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"INDEXOPTINFO"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* NB: this isn't a complete set of fields */</comment>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>indexoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Do NOT print rel field, else infinite recursion */</comment>
	<expr_stmt><expr><call><name>WRITE_UINT_FIELD</name><argument_list>(<argument><expr><name>pages</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_FLOAT_FIELD</name><argument_list>(<argument><expr><name>tuples</name></expr></argument>, <argument><expr><literal type="string">"%.0f"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>tree_height</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>ncolumns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* array fields aren't really worth the trouble to print */</comment>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>relam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* indexprs is redundant since we print indextlist */</comment>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>indpred</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>indextlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>indrestrictinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>predOK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>unique</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>immediate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>hypothetical</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* we don't bother with fields copied from the index AM's API struct */</comment>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* COMPILING_BINARY_FUNCS */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>COMPILING_BINARY_FUNCS</name></cpp:ifndef>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outForeignKeyOptInfo</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ForeignKeyOptInfo</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"FOREIGNKEYOPTINFO"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_UINT_FIELD</name><argument_list>(<argument><expr><name>con_relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_UINT_FIELD</name><argument_list>(<argument><expr><name>ref_relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>nkeys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_ATTRNUMBER_ARRAY</name><argument_list>(<argument><expr><name>conkey</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>nkeys</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_ATTRNUMBER_ARRAY</name><argument_list>(<argument><expr><name>confkey</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>nkeys</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_ARRAY</name><argument_list>(<argument><expr><name>conpfeqop</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>nkeys</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>nmatched_ec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>nmatched_rcols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>nmatched_ri</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* for compactness, just print the number of matches per column: */</comment>
	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" :eclass"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>node</name><operator>-&gt;</operator><name>nkeys</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" %d"</literal></expr></argument>, <argument><expr><operator>(</operator><name><name>node</name><operator>-&gt;</operator><name>eclass</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" :rinfos"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>node</name><operator>-&gt;</operator><name>nkeys</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" %d"</literal></expr></argument>, <argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>rinfos</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outStatisticExtInfo</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>StatisticExtInfo</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"STATISTICEXTINFO"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* NB: this isn't a complete set of fields */</comment>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>statOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* don't write rel, leads to infinite recursion in plan tree dump */</comment>
	<expr_stmt><expr><call><name>WRITE_CHAR_FIELD</name><argument_list>(<argument><expr><name>kind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name>keys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outEquivalenceClass</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>EquivalenceClass</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * To simplify reading, we just chase up to the topmost merged EC and
	 * print that, without bothering to show the merge-ees separately.
	 */</comment>
	<while>while <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>ec_merged</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>node</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>ec_merged</name></name></expr>;</expr_stmt></block_content></block></while>

	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"EQUIVALENCECLASS"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>ec_opfamilies</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>ec_collation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>ec_members</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>ec_sources</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>ec_derives</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name>ec_relids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>ec_has_const</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>ec_has_volatile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>ec_below_outer_join</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>ec_broken</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_UINT_FIELD</name><argument_list>(<argument><expr><name>ec_sortref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_UINT_FIELD</name><argument_list>(<argument><expr><name>ec_min_security</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_UINT_FIELD</name><argument_list>(<argument><expr><name>ec_max_security</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outEquivalenceMember</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>EquivalenceMember</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"EQUIVALENCEMEMBER"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>em_expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name>em_relids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name>em_nullable_relids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>em_is_const</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>em_is_child</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>em_datatype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outPathKey</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>PathKey</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"PATHKEY"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>pk_eclass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>pk_opfamily</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>pk_strategy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>pk_nulls_first</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outDistributionKey</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>DistributionKey</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"DISTRIBUTIONKEY"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>dk_eclasses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>dk_opfamily</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outPathTarget</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>PathTarget</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"PATHTARGET"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>exprs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>sortgrouprefs</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" :sortgrouprefs"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>exprs</name></name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" %u"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>sortgrouprefs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>WRITE_FLOAT_FIELD</name><argument_list>(<argument><expr><name><name>cost</name><operator>.</operator><name>startup</name></name></expr></argument>, <argument><expr><literal type="string">"%.2f"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_FLOAT_FIELD</name><argument_list>(<argument><expr><name><name>cost</name><operator>.</operator><name>per_tuple</name></name></expr></argument>, <argument><expr><literal type="string">"%.2f"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>width</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outParamPathInfo</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ParamPathInfo</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"PARAMPATHINFO"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name>ppi_req_outer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_FLOAT_FIELD</name><argument_list>(<argument><expr><name>ppi_rows</name></expr></argument>, <argument><expr><literal type="string">"%.0f"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>ppi_clauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* COMPILING_BINARY_FUNCS */</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outRestrictInfo</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>RestrictInfo</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"RESTRICTINFO"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* NB: this isn't a complete set of fields */</comment>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>clause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>is_pushed_down</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>outerjoin_delayed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>can_join</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>pseudoconstant</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>leakproof</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>WRITE_UINT_FIELD</name><argument_list>(<argument><expr><name>security_level</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>contain_outer_query_references</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name>clause_relids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name>required_relids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name>outer_relids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name>nullable_relids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name>left_relids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name>right_relids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>orclause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* don't write parent_ec, leads to infinite recursion in plan tree dump */</comment>
	<expr_stmt><expr><call><name>WRITE_FLOAT_FIELD</name><argument_list>(<argument><expr><name>norm_selec</name></expr></argument>, <argument><expr><literal type="string">"%.4f"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_FLOAT_FIELD</name><argument_list>(<argument><expr><name>outer_selec</name></expr></argument>, <argument><expr><literal type="string">"%.4f"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>mergeopfamilies</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* don't write left_ec, leads to infinite recursion in plan tree dump */</comment>
	<comment type="block">/* don't write right_ec, leads to infinite recursion in plan tree dump */</comment>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>left_em</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>right_em</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>outer_is_left</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>hashjoinoperator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>COMPILING_BINARY_FUNCS</name></cpp:ifndef>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outIndexClause</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>IndexClause</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"INDEXCLAUSE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>rinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>indexquals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>lossy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>indexcol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>indexcols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outPlaceHolderVar</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>PlaceHolderVar</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"PLACEHOLDERVAR"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>phexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name>phrels</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_UINT_FIELD</name><argument_list>(<argument><expr><name>phid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_UINT_FIELD</name><argument_list>(<argument><expr><name>phlevelsup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outSpecialJoinInfo</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>SpecialJoinInfo</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"SPECIALJOININFO"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name>min_lefthand</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name>min_righthand</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name>syn_lefthand</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name>syn_righthand</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>jointype</name></expr></argument>, <argument><expr><name>JoinType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>lhs_strict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>delay_upper_joins</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>semi_can_btree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>semi_can_hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>semi_operators</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>semi_rhs_exprs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outAppendRelInfo</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>AppendRelInfo</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"APPENDRELINFO"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_UINT_FIELD</name><argument_list>(<argument><expr><name>parent_relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_UINT_FIELD</name><argument_list>(<argument><expr><name>child_relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>parent_reltype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>child_reltype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>translated_vars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>parent_reloid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outPlaceHolderInfo</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>PlaceHolderInfo</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"PLACEHOLDERINFO"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_UINT_FIELD</name><argument_list>(<argument><expr><name>phid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>ph_var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name>ph_eval_at</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name>ph_lateral</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name>ph_needed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>ph_width</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outMinMaxAggInfo</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>MinMaxAggInfo</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"MINMAXAGGINFO"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>aggfnoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>aggsortop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* We intentionally omit subroot --- too large, not interesting enough */</comment>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_FLOAT_FIELD</name><argument_list>(<argument><expr><name>pathcost</name></expr></argument>, <argument><expr><literal type="string">"%.2f"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>param</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outPlannerParamItem</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>PlannerParamItem</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"PLANNERPARAMITEM"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>paramId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* COMPILING_BINARY_FUNCS */</comment>

<comment type="block" format="doxygen">/*****************************************************************************
 *
 *	Stuff from extensible.h
 *
 *****************************************************************************/</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>COMPILING_BINARY_FUNCS</name></cpp:ifndef>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outExtensibleNode</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ExtensibleNode</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>ExtensibleNodeMethods</name> <modifier>*</modifier></type><name>methods</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>methods</name> <operator>=</operator> <call><name>GetExtensibleNodeMethods</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>extnodename</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"EXTENSIBLENODE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>extnodename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* serialize the private fields */</comment>
	<expr_stmt><expr><call><name><name>methods</name><operator>-&gt;</operator><name>nodeOut</name></name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* COMPILING_BINARY_FUNCS */</comment>

<comment type="block" format="doxygen">/*****************************************************************************
 *
 *	Stuff from parsenodes.h.
 *
 *****************************************************************************/</comment>

<comment type="block">/*
 * print the basic stuff of all nodes that inherit from CreateStmt
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outCreateStmtInfo</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CreateStmt</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>tableElts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>inhRelations</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>partspec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>partbound</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>ofTypename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>constraints</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>oncommit</name></expr></argument>, <argument><expr><name>OnCommitAction</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>tablespacename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>accessMethod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>if_not_exists</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>gp_style_alter_part</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>distributedBy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>partitionBy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_CHAR_FIELD</name><argument_list>(<argument><expr><name>relKind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>ownerid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>buildAoBlkdir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>attr_encodings</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>isCtas</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>intoQuery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>intoPolicy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>part_idx_oids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>part_idx_names</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Some extra checks to make sure we didn't get lost
	 * during serialization/deserialization
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>relKind</name></name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>oncommit</name></name> <operator>&lt;=</operator> <name>ONCOMMIT_DROP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outCreateStmt</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CreateStmt</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"CREATESTMT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outCreateStmtInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>CreateStmt</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outCreateForeignTableStmt</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CreateForeignTableStmt</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"CREATEFOREIGNTABLESTMT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outCreateStmtInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>CreateStmt</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>servername</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>distributedBy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outDistributionKeyElem</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>DistributionKeyElem</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"DISTRIBUTIONKEYELEM"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>opclass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outColumnReferenceStorageDirective</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ColumnReferenceStorageDirective</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"COLUMNREFERENCESTORAGEDIRECTIVE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>column</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>deflt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outExtTableTypeDesc</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ExtTableTypeDesc</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"EXTTABLETYPEDESC"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>exttabletype</name></expr></argument>, <argument><expr><name>ExtTableType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>location_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>on_clause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>command_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outCreateExternalStmt</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CreateExternalStmt</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"CREATEEXTERNALSTMT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>tableElts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>exttypedesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>format</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>formatOpts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>isweb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>iswritable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>sreh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>extOptions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>distributedBy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outDistributedBy</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>DistributedBy</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"DISTRIBUTEDBY"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>ptype</name></expr></argument>, <argument><expr><name>GpPolicyType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>numsegments</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>keyCols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outImportForeignSchemaStmt</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ImportForeignSchemaStmt</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"IMPORTFOREIGNSCHEMASTMT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>server_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>remote_schema</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>local_schema</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>list_type</name></expr></argument>, <argument><expr><name>ImportForeignSchemaType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>table_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outIndexStmt</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>IndexStmt</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"INDEXSTMT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>idxname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>relationOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>accessMethod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>tableSpace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>indexParams</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>indexIncludingParams</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>whereClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>excludeOpNames</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>idxcomment</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>indexOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>oldNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>unique</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>primary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>isconstraint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>deferrable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>initdeferred</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>transformed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>concurrent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>if_not_exists</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>reset_default_tblspc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outReindexStmt</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ReindexStmt</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"REINDEXSTMT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>kind</name></expr></argument>,<argument><expr><name>ReindexObjectType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outViewStmt</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ViewStmt</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"VIEWSTMT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>view</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>aliases</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>replace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outRuleStmt</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>RuleStmt</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"RULESTMT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>rulename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>whereClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>event</name></expr></argument>, <argument><expr><name>CmdType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>instead</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>actions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>replace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outDropStmt</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>DropStmt</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"DROPSTMT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>objects</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>removeType</name></expr></argument>, <argument><expr><name>ObjectType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>behavior</name></expr></argument>, <argument><expr><name>DropBehavior</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>missing_ok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>concurrent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outDropOwnedStmt</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>DropOwnedStmt</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"DROPOWNEDSTMT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>roles</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>behavior</name></expr></argument>, <argument><expr><name>DropBehavior</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outReassignOwnedStmt</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ReassignOwnedStmt</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"REASSIGNOWNEDSTMT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>roles</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>newrole</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outTruncateStmt</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>TruncateStmt</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"TRUNCATESTMT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>relations</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>behavior</name></expr></argument>, <argument><expr><name>DropBehavior</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outReplicaIdentityStmt</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ReplicaIdentityStmt</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"REPLICAIDENTITYSTMT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_CHAR_FIELD</name><argument_list>(<argument><expr><name>identity_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outAlterTableStmt</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>AlterTableStmt</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"ALTERTABLESTMT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>cmds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>relkind</name></expr></argument>, <argument><expr><name>ObjectType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/*
	 * AlteredTableInfos are not Nodes in upstream, so make sure the node tags
	 * are set correctly before trying to serialize them.
	 */</comment>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>node-&gt;wqueue</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AlteredTableInfo</name> <modifier>*</modifier></type><name>e</name> <init>= <expr><operator>(</operator><name>AlteredTableInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>T_AlteredTableInfo</name></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>wqueue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outAlterTableCmd</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>AlterTableCmd</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"ALTERTABLECMD"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>subtype</name></expr></argument>, <argument><expr><name>AlterTableType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>newowner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>def</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>transform</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>behavior</name></expr></argument>, <argument><expr><name>DropBehavior</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>missing_ok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>backendId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>policy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>wrapStringList</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>list</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>list</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>str</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call> <operator>=</operator> <call><name>makeString</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>unwrapStringList</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>list</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>list</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Value</name>	   <modifier>*</modifier></type><name>val</name> <init>= <expr><operator>(</operator><name>Value</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call> <operator>=</operator> <call><name>strVal</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outAlteredTableInfo</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>AlteredTableInfo</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"ALTEREDTABLEINFO"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_CHAR_FIELD</name><argument_list>(<argument><expr><name>relkind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* oldDesc is omitted */</comment>

	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>AT_NUM_PASSES</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name><name>subcmds</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

	<comment type="block">/*
	 * These aren't Nodes in upstream, so make sure the node tags
	 * are set correctly before trying to serialize them.
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>node-&gt;constraints</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>NewConstraint</name> <modifier>*</modifier></type><name>e</name> <init>= <expr><operator>(</operator><name>NewConstraint</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>T_NewConstraint</name></expr>;</expr_stmt>
	</block_content>}</block>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>node-&gt;newvals</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>NewColumnValue</name> <modifier>*</modifier></type><name>e</name> <init>= <expr><operator>(</operator><name>NewColumnValue</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>T_NewColumnValue</name></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>constraints</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>newvals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>verify_new_notnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>rewrite</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>newAccessMethod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>dist_opfamily_changed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>new_opclass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>newTableSpace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>chgPersistence</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_CHAR_FIELD</name><argument_list>(<argument><expr><name>newrelpersistence</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>partition_constraint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>validate_default</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>changedConstraintOids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* node-&gt;changedConstraintDefs is a list of naked strings, so
	 * we can't use WRITE_NODE_FIELD on it. Temporarily wrap them in Values.
	 */</comment>
	<expr_stmt><expr><call><name>wrapStringList</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>changedConstraintDefs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>changedConstraintDefs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* unwrap them again */</comment>
	<expr_stmt><expr><call><name>unwrapStringList</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>changedConstraintDefs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>changedIndexOids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>wrapStringList</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>changedIndexDefs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>changedIndexDefs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>unwrapStringList</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>changedIndexDefs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outNewConstraint</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>NewConstraint</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"NEWCONSTRAINT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>contype</name></expr></argument>, <argument><expr><name>ConstrType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>refrelid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>refindid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>conid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>qual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* can't serialize qualstate */</comment>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outNewColumnValue</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>NewColumnValue</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"NEWCOLUMNVALUE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* can't serialize exprstate */</comment>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>is_generated</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outCreateRoleStmt</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CreateRoleStmt</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"CREATEROLESTMT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>stmt_type</name></expr></argument>, <argument><expr><name>RoleStmtType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>role</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outDenyLoginInterval</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>DenyLoginInterval</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"DENYLOGININTERVAL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outDenyLoginPoint</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>DenyLoginPoint</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"DENYLOGINPOINT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>day</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier>  <name>void</name></type>
<name>_outDropRoleStmt</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>DropRoleStmt</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"DROPROLESTMT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>roles</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>missing_ok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier>  <name>void</name></type>
<name>_outAlterRoleStmt</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>AlterRoleStmt</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"ALTERROLESTMT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>role</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>action</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier>  <name>void</name></type>
<name>_outAlterRoleSetStmt</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>AlterRoleSetStmt</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"ALTERROLESETSTMT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>role</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>setstmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier>  <name>void</name></type>
<name>_outAlterSystemStmt</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>AlterSystemStmt</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"ALTERSYSTEMSTMT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>setstmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier>  <name>void</name></type>
<name>_outAlterOwnerStmt</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>AlterOwnerStmt</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"ALTEROWNERSTMT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>objectType</name></expr></argument>,<argument><expr><name>ObjectType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>object</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>newowner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outRenameStmt</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>RenameStmt</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"RENAMESTMT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>renameType</name></expr></argument>, <argument><expr><name>ObjectType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>relationType</name></expr></argument>, <argument><expr><name>ObjectType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>objid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>object</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>subname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>newname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>behavior</name></expr></argument>,<argument><expr><name>DropBehavior</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>missing_ok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outAlterObjectSchemaStmt</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>AlterObjectSchemaStmt</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"ALTEROBJECTSCHEMASTMT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>object</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>newschema</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>missing_ok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>objectType</name></expr></argument>,<argument><expr><name>ObjectType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outCreateSeqStmt</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CreateSeqStmt</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"CREATESEQSTMT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>sequence</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>ownerId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>for_identity</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>if_not_exists</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outAlterSeqStmt</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>AlterSeqStmt</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"ALTERSEQSTMT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>sequence</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>for_identity</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>missing_ok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outClusterStmt</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ClusterStmt</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"CLUSTERSTMT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>indexname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outCreatedbStmt</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CreatedbStmt</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"CREATEDBSTMT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>dbname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outDropdbStmt</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>DropdbStmt</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"DROPDBSTMT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>dbname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>missing_ok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>COMPILING_BINARY_FUNCS</name></cpp:ifndef>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outCreateDomainStmt</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CreateDomainStmt</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"CREATEDOMAINSTMT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>domainname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD_AS</name><argument_list>(<argument><expr><name>typeName</name></expr></argument>, <argument><expr><name>typename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>collClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>constraints</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* COMPILING_BINARY_FUNCS */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>COMPILING_BINARY_FUNCS</name></cpp:ifndef>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outAlterDomainStmt</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>AlterDomainStmt</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"ALTERDOMAINSTMT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_CHAR_FIELD</name><argument_list>(<argument><expr><name>subtype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD_AS</name><argument_list>(<argument><expr><name>typeName</name></expr></argument>, <argument><expr><name>typename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>def</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>behavior</name></expr></argument>, <argument><expr><name>DropBehavior</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>missing_ok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* COMPILING_BINARY_FUNCS */</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outCreateFunctionStmt</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CreateFunctionStmt</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"CREATEFUNCSTMT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>is_procedure</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>replace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>funcname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>parameters</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>returnType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outFunctionParameter</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>FunctionParameter</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"FUNCTIONPARAMETER"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>argType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>mode</name></expr></argument>, <argument><expr><name>FunctionParameterMode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>defexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outAlterFunctionStmt</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>AlterFunctionStmt</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"ALTERFUNCTIONSTMT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>objtype</name></expr></argument>,<argument><expr><name>ObjectType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>actions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outSegfileMapNode</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>SegfileMapNode</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"SEGFILEMAPNODE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>segno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outDefineStmt</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>DefineStmt</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"DEFINESTMT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>kind</name></expr></argument>, <argument><expr><name>ObjectType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>oldstyle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>defnames</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>definition</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>if_not_exists</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>replace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>trusted</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* CDB */</comment>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outCompositeTypeStmt</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CompositeTypeStmt</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"COMPTYPESTMT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>typevar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>coldeflist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outCreateEnumStmt</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CreateEnumStmt</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"CREATEENUMSTMT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>typeName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>vals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outCreateRangeStmt</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CreateRangeStmt</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"CREATERANGESTMT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>typeName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outCreateCastStmt</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CreateCastStmt</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"CREATECAST"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>sourcetype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>targettype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>CoercionContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>inout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outCreateOpClassStmt</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CreateOpClassStmt</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"CREATEOPCLASS"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>opclassname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>opfamilyname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>amname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>datatype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>items</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>isDefault</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outCreateOpClassItem</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CreateOpClassItem</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"CREATEOPCLASSITEM"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>itemtype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>number</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>order_family</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>class_args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>storedtype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outCreateOpFamilyStmt</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CreateOpFamilyStmt</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"CREATEOPFAMILY"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>opfamilyname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>amname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outAlterOpFamilyStmt</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>AlterOpFamilyStmt</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"ALTEROPFAMILY"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>opfamilyname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>amname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>isDrop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>items</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outCreatePolicyStmt</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CreatePolicyStmt</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"CREATEPOLICYSTMT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>policy_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>cmd_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>permissive</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>roles</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>qual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>with_check</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outAlterPolicyStmt</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>AlterPolicyStmt</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"ALTERPOLICYSTMT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>policy_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>roles</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>qual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>with_check</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outCreateTransformStmt</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CreateTransformStmt</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"CREATETRANSFORMSTMT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>replace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>type_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>lang</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>fromsql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>tosql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outCreateConversionStmt</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CreateConversionStmt</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"CREATECONVERSION"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>conversion_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>for_encoding_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>to_encoding_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>func_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>def</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outTransactionStmt</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>TransactionStmt</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"TRANSACTIONSTMT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>kind</name></expr></argument>, <argument><expr><name>TransactionStmtKind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outCreateStatsStmt</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CreateStatsStmt</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"CREATESTATSSTMT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>defnames</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>stat_types</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>exprs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>relations</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>stxcomment</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>if_not_exists</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outNotifyStmt</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>NotifyStmt</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"NOTIFY"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>conditionname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>payload</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outDeclareCursorStmt</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>DeclareCursorStmt</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"DECLARECURSOR"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>portalname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outSingleRowErrorDesc</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>SingleRowErrorDesc</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"SINGLEROWERRORDESC"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>rejectlimit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>is_limit_in_rows</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_CHAR_FIELD</name><argument_list>(<argument><expr><name>log_error_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>COMPILING_BINARY_FUNCS</name></cpp:ifndef>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outCopyStmt</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CopyStmt</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"COPYSTMT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>attlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>is_from</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>is_program</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>sreh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif><comment type="block">/* COMPILING_BINARY_FUNCS */</comment>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outGrantStmt</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>GrantStmt</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"GRANTSTMT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>is_grant</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>targtype</name></expr></argument>,<argument><expr><name>GrantTargetType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>objtype</name></expr></argument>,<argument><expr><name>ObjectType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>objects</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>privileges</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>grantees</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>grant_option</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>behavior</name></expr></argument>, <argument><expr><name>DropBehavior</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outObjectWithArgs</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ObjectWithArgs</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"OBJECTWITHARGS"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>objname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>objargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>args_unspecified</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outGrantRoleStmt</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>GrantRoleStmt</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"GRANTROLESTMT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>granted_roles</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>grantee_roles</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>is_grant</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>admin_opt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>grantor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>behavior</name></expr></argument>, <argument><expr><name>DropBehavior</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outLockStmt</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>LockStmt</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"LOCKSTMT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>relations</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>nowait</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outConstraintsSetStmt</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ConstraintsSetStmt</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"CONSTRAINTSSETSTMT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>constraints</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>deferred</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * SelectStmt's are never written to the catalog, they only exist
 * between parse and parseTransform.  The only use of this function
 * is for debugging purposes.
 *
 * In GPDB, these are also dispatched from QD to QEs, so we need full
 * out/read support.
 *
 * If the Nodes Struct changed, we need to maintain these funtions.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outSelectStmt</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>SelectStmt</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"SELECT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>distinctClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>intoClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>targetList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>fromClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>whereClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>groupClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>havingClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>windowClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>valuesLists</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>sortClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>scatterClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>limitOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>limitCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>lockingClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>withClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>SetOperation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>all</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>larg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>rarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>disableLockingOptimization</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outInsertStmt</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>InsertStmt</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"INSERT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>cols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>selectStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>returningList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>withClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outDeleteStmt</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>DeleteStmt</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"DELETE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>usingClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>whereClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>returningList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>withClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outUpdateStmt</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>UpdateStmt</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"UPDATE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>targetList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>whereClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>fromClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>returningList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>withClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outFuncCall</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>FuncCall</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"FUNCCALL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>funcname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>agg_order</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>agg_filter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>agg_within_group</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>agg_star</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>agg_distinct</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>func_variadic</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>over</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outDefElem</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>DefElem</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"DEFELEM"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>defnamespace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>defname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>defaction</name></expr></argument>, <argument><expr><name>DefElemAction</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outTableLikeClause</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>TableLikeClause</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"TABLELIKECLAUSE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_UINT_FIELD</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outLockingClause</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>LockingClause</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"LOCKINGCLAUSE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>lockedRels</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>strength</name></expr></argument>, <argument><expr><name>LockClauseStrength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>waitPolicy</name></expr></argument>, <argument><expr><name>LockWaitPolicy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outXmlSerialize</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XmlSerialize</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"XMLSERIALIZE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>xmloption</name></expr></argument>, <argument><expr><name>XmlOptionType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>typeName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outDMLActionExpr</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>DMLActionExpr</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"DMLACTIONEXPR"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outTriggerTransition</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>TriggerTransition</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"TRIGGERTRANSITION"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>isNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>isTable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outColumnDef</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ColumnDef</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"COLUMNDEF"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>colname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>typeName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>inhcount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>is_local</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>is_not_null</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>is_from_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>storage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>raw_default</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>cooked_default</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>hasCookedMissingVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>missingIsNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>hasCookedMissingVal</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>node</name><operator>-&gt;</operator><name>missingIsNull</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>outDatum</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>missingVal</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>WRITE_CHAR_FIELD</name><argument_list>(<argument><expr><name>identity</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>identitySequence</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_CHAR_FIELD</name><argument_list>(<argument><expr><name>generated</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>collClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>collOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>constraints</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>fdwoptions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outTypeName</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>TypeName</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"TYPENAME"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>names</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>typeOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>setof</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>pct_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>typmods</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>typemod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>arrayBounds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outTypeCast</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>TypeCast</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"TYPECAST"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>typeName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outCollateClause</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CollateClause</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"COLLATECLAUSE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>collname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outIndexElem</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>IndexElem</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"INDEXELEM"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>indexcolname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>collation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>opclass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>ordering</name></expr></argument>, <argument><expr><name>SortByDir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>nulls_ordering</name></expr></argument>, <argument><expr><name>SortByNulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outVariableSetStmt</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VariableSetStmt</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"VARIABLESETSTMT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>kind</name></expr></argument>, <argument><expr><name>VariableSetKind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>is_local</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>COMPILING_BINARY_FUNCS</name></cpp:ifndef>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outQuery</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Query</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"QUERY"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>commandType</name></expr></argument>, <argument><expr><name>CmdType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>querySource</name></expr></argument>, <argument><expr><name>QuerySource</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* we intentionally do not print the queryId field */</comment>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>canSetTag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Hack to work around missing outfuncs routines for a lot of the
	 * utility-statement node types.  (The only one we actually *need* for
	 * rules support is NotifyStmt.)  Someday we ought to support 'em all, but
	 * for the meantime do this to avoid getting lots of warnings when running
	 * with debug_print_parse on.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>utilityStmt</name></name></expr>)</condition>
	<block>{<block_content>
		<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>utilityStmt</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>T_CreateStmt</name></expr>:</case>
			<case>case <expr><name>T_CreateExternalStmt</name></expr>:</case>
			<case>case <expr><name>T_DropStmt</name></expr>:</case>
			<case>case <expr><name>T_TruncateStmt</name></expr>:</case>
			<case>case <expr><name>T_AlterTableStmt</name></expr>:</case>
			<case>case <expr><name>T_AlterTableCmd</name></expr>:</case>
			<case>case <expr><name>T_ViewStmt</name></expr>:</case>
			<case>case <expr><name>T_RuleStmt</name></expr>:</case>

			<case>case <expr><name>T_CreateRoleStmt</name></expr>:</case>
			<case>case <expr><name>T_AlterRoleStmt</name></expr>:</case>
			<case>case <expr><name>T_AlterRoleSetStmt</name></expr>:</case>
			<case>case <expr><name>T_DropRoleStmt</name></expr>:</case>

			<case>case <expr><name>T_CreateSchemaStmt</name></expr>:</case>
			<case>case <expr><name>T_CreatePLangStmt</name></expr>:</case>
			<case>case <expr><name>T_AlterOwnerStmt</name></expr>:</case>
			<case>case <expr><name>T_AlterObjectSchemaStmt</name></expr>:</case>

			<case>case <expr><name>T_CreateTableSpaceStmt</name></expr>:</case>

			<case>case <expr><name>T_RenameStmt</name></expr>:</case>
			<case>case <expr><name>T_IndexStmt</name></expr>:</case>
			<case>case <expr><name>T_NotifyStmt</name></expr>:</case>
			<case>case <expr><name>T_DeclareCursorStmt</name></expr>:</case>
			<case>case <expr><name>T_VacuumStmt</name></expr>:</case>
			<case>case <expr><name>T_CreateSeqStmt</name></expr>:</case>
			<case>case <expr><name>T_AlterSeqStmt</name></expr>:</case>
			<case>case <expr><name>T_CreatedbStmt</name></expr>:</case>
			<case>case <expr><name>T_AlterDatabaseSetStmt</name></expr>:</case>
			<case>case <expr><name>T_DropdbStmt</name></expr>:</case>
			<case>case <expr><name>T_CreateDomainStmt</name></expr>:</case>
			<case>case <expr><name>T_AlterDomainStmt</name></expr>:</case>
			<case>case <expr><name>T_ClusterStmt</name></expr>:</case>

			<case>case <expr><name>T_CreateFunctionStmt</name></expr>:</case>
			<case>case <expr><name>T_AlterFunctionStmt</name></expr>:</case>

			<case>case <expr><name>T_TransactionStmt</name></expr>:</case>
			<case>case <expr><name>T_GrantStmt</name></expr>:</case>
			<case>case <expr><name>T_GrantRoleStmt</name></expr>:</case>
			<case>case <expr><name>T_LockStmt</name></expr>:</case>
			<case>case <expr><name>T_CopyStmt</name></expr>:</case>
			<case>case <expr><name>T_ReindexStmt</name></expr>:</case>
			<case>case <expr><name>T_ConstraintsSetStmt</name></expr>:</case>
			<case>case <expr><name>T_VariableSetStmt</name></expr>:</case>
			<case>case <expr><name>T_CreateTrigStmt</name></expr>:</case>
			<case>case <expr><name>T_DefineStmt</name></expr>:</case>
			<case>case <expr><name>T_CompositeTypeStmt</name></expr>:</case>
			<case>case <expr><name>T_CreateCastStmt</name></expr>:</case>
			<case>case <expr><name>T_CreateOpClassStmt</name></expr>:</case>
			<case>case <expr><name>T_CreateOpClassItem</name></expr>:</case>
			<case>case <expr><name>T_CreateConversionStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>utilityStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<default>default:</default>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" :utilityStmt ?"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"%u"</literal></expr></argument>, <argument><expr><call><name>nodeTag</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>utilityStmt</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
		</block_content>}</block></switch>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" :utilityStmt &lt;&gt;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>resultRelation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>hasAggs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>hasWindowFuncs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>hasTargetSRFs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>hasSubLinks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>hasDynamicFunctions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>hasFuncsWithExecRestrictions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>hasDistinctOn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>hasRecursive</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>hasModifyingCTE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>hasForUpdate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>hasRowSecurity</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>canOptSelectLockingClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>cteList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>rtable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>jointree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>targetList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>override</name></expr></argument>, <argument><expr><name>OverridingKind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>onConflict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>returningList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>groupClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>groupingSets</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>havingQual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>windowClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>distinctClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>sortClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>scatterClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>isTableValueSelect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>limitOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>limitCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>rowMarks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>setOperations</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>constraintDeps</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>withCheckOptions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>stmt_location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>stmt_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>parentStmtType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Don't serialize policy */</comment>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* COMPILING_BINARY_FUNCS */</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outWithCheckOption</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>WithCheckOption</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"WITHCHECKOPTION"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>kind</name></expr></argument>, <argument><expr><name>WCOKind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>relname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>polname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>qual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>cascaded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outSortGroupClause</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>SortGroupClause</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"SORTGROUPCLAUSE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_UINT_FIELD</name><argument_list>(<argument><expr><name>tleSortGroupRef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>eqop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>sortop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>nulls_first</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>hashable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outGroupingSet</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>GroupingSet</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"GROUPINGSET"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>kind</name></expr></argument>, <argument><expr><name>GroupingSetKind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>content</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outWindowClause</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>WindowClause</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"WINDOWCLAUSE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>refname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>partitionClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>orderClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>frameOptions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>startOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>endOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>startInRangeFunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>endInRangeFunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>inRangeColl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>inRangeAsc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>inRangeNullsFirst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_UINT_FIELD</name><argument_list>(<argument><expr><name>winref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>copiedOrder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outRowMarkClause</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>RowMarkClause</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"ROWMARKCLAUSE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_UINT_FIELD</name><argument_list>(<argument><expr><name>rti</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>strength</name></expr></argument>, <argument><expr><name>LockClauseStrength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>waitPolicy</name></expr></argument>, <argument><expr><name>LockWaitPolicy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>pushedDown</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outWithClause</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>WithClause</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"WITHCLAUSE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>ctes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>recursive</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outCommonTableExpr</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CommonTableExpr</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"COMMONTABLEEXPR"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>ctename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>aliascolnames</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>ctematerialized</name></expr></argument>, <argument><expr><name>CTEMaterialize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>ctequery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>cterecursive</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>cterefcount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>ctecolnames</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>ctecoltypes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>ctecoltypmods</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>ctecolcollations</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outSetOperationStmt</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>SetOperationStmt</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"SETOPERATIONSTMT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>SetOperation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>all</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>larg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>rarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>colTypes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>colTypmods</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>colCollations</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>groupClauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outRangeTblEntry</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>RangeTblEntry</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"RTE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* put alias + eref first to make dump more legible */</comment>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>alias</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>eref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>rtekind</name></expr></argument>, <argument><expr><name>RTEKind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>rtekind</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>RTE_RELATION</name></expr>:</case>
			<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>WRITE_CHAR_FIELD</name><argument_list>(<argument><expr><name>relkind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>rellockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>tablesample</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>RTE_SUBQUERY</name></expr>:</case>
			<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>subquery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>security_barrier</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>RTE_JOIN</name></expr>:</case>
			<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>jointype</name></expr></argument>, <argument><expr><name>JoinType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>joinaliasvars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>RTE_FUNCTION</name></expr>:</case>
			<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>functions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>funcordinality</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>RTE_TABLEFUNCTION</name></expr>:</case>
			<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>subquery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>functions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>funcordinality</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>RTE_TABLEFUNC</name></expr>:</case>
			<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>tablefunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>RTE_VALUES</name></expr>:</case>
			<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>values_lists</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>coltypes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>coltypmods</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>colcollations</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>RTE_CTE</name></expr>:</case>
			<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>ctename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>WRITE_UINT_FIELD</name><argument_list>(<argument><expr><name>ctelevelsup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>self_reference</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>coltypes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>coltypmods</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>colcollations</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>RTE_NAMEDTUPLESTORE</name></expr>:</case>
			<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>enrname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>WRITE_FLOAT_FIELD</name><argument_list>(<argument><expr><name>enrtuples</name></expr></argument>, <argument><expr><literal type="string">"%.0f"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>coltypes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>coltypmods</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>colcollations</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>RTE_RESULT</name></expr>:</case>
			<comment type="block">/* no extra fields */</comment>
			<break>break;</break>
        <case>case <expr><name>RTE_VOID</name></expr>:</case>                                                  <comment type="block">/*CDB*/</comment>
            <break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized RTE kind: %d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>node</name><operator>-&gt;</operator><name>rtekind</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>lateral</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>inh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>inFromCl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_UINT_FIELD</name><argument_list>(<argument><expr><name>requiredPerms</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>checkAsUser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name>selectedCols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name>insertedCols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name>updatedCols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name>extraUpdatedCols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>securityQuals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>forceDistRandom</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outRangeTblFunction</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>RangeTblFunction</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"RANGETBLFUNCTION"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>funcexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>funccolcount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>funccolnames</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>funccoltypes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>funccoltypmods</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>funccolcollations</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* funcuserdata is only serialized in binary out/read functions */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>COMPILING_BINARY_FUNCS</name></cpp:ifdef>
	<expr_stmt><expr><call><name>WRITE_BYTEA_FIELD</name><argument_list>(<argument><expr><name>funcuserdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><call><name>WRITE_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name>funcparams</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outTableSampleClause</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>TableSampleClause</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"TABLESAMPLECLAUSE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>tsmhandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>repeatable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>COMPILING_BINARY_FUNCS</name></cpp:ifndef>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outAExpr</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>A_Expr</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"AEXPR"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>kind</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>AEXPR_OP</name></expr>:</case>
			<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AEXPR_OP_ANY</name></expr>:</case>
			<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" ANY "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AEXPR_OP_ALL</name></expr>:</case>
			<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" ALL "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AEXPR_DISTINCT</name></expr>:</case>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" DISTINCT "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AEXPR_NOT_DISTINCT</name></expr>:</case>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" NOT_DISTINCT "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AEXPR_NULLIF</name></expr>:</case>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" NULLIF "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AEXPR_OF</name></expr>:</case>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" OF "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AEXPR_IN</name></expr>:</case>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" IN "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AEXPR_LIKE</name></expr>:</case>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" LIKE "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AEXPR_ILIKE</name></expr>:</case>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" ILIKE "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AEXPR_SIMILAR</name></expr>:</case>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" SIMILAR "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AEXPR_BETWEEN</name></expr>:</case>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" BETWEEN "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AEXPR_NOT_BETWEEN</name></expr>:</case>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" NOT_BETWEEN "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AEXPR_BETWEEN_SYM</name></expr>:</case>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" BETWEEN_SYM "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AEXPR_NOT_BETWEEN_SYM</name></expr>:</case>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" NOT_BETWEEN_SYM "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AEXPR_PAREN</name></expr>:</case>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" PAREN"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" ??"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>lexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>rexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* COMPILING_BINARY_FUNCS */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>COMPILING_BINARY_FUNCS</name></cpp:ifndef>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outValue</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Value</name> <modifier>*</modifier></type><name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name><name>value</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>T_Integer</name></expr>:</case>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><name><name>value</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>ival</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_Float</name></expr>:</case>

			<comment type="block">/*
			 * We assume the value is a valid numeric literal and so does not
			 * need quoting.
			 */</comment>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name><name>value</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>str</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_String</name></expr>:</case>

			<comment type="block">/*
			 * We use outToken to provide escaping of the string's content,
			 * but we don't want it to do anything with an empty string.
			 */</comment>
			<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="char">'"'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>value</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>str</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>outToken</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name><name>value</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>str</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="char">'"'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_BitString</name></expr>:</case>
			<comment type="block">/* internal representation already has leading 'b' */</comment>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name><name>value</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>str</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_Null</name></expr>:</case>
			<comment type="block">/* this is seen only within A_Const, not in transformed trees */</comment>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"NULL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized node type: %d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>value</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* COMPILING_BINARY_FUNCS */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>COMPILING_BINARY_FUNCS</name></cpp:ifndef>
<decl_stmt><decl><type><specifier>static</specifier> <name>void</name></type>
<name>_outNull</name><argument_list>(<argument><expr><name>StringInfo</name> <name>str</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>Node</name> <operator>*</operator><name>n</name> <call><name>pg_attribute_unused</name><argument_list>()</argument_list></call></expr></argument>)</argument_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"NULL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* COMPILING_BINARY_FUNCS */</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outColumnRef</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ColumnRef</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"COLUMNREF"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>fields</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outParamRef</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ParamRef</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"PARAMREF"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>number</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Node types found in raw parse trees (supported for debug purposes)
 */</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outRawStmt</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>RawStmt</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"RAWSTMT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>stmt_location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>stmt_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>COMPILING_BINARY_FUNCS</name></cpp:ifndef>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outAConst</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>A_Const</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"A_CONST"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" :val "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>_outValue</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>node</name><operator>-&gt;</operator><name>val</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* COMPILING_BINARY_FUNCS */</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outA_Star</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>A_Star</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"A_STAR"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outA_Indices</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>A_Indices</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"A_INDICES"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>is_slice</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>lidx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>uidx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outA_Indirection</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>A_Indirection</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"A_INDIRECTION"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>indirection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outA_ArrayExpr</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>A_ArrayExpr</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"A_ARRAYEXPR"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>elements</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outResTarget</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ResTarget</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"RESTARGET"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>indirection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outMultiAssignRef</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>MultiAssignRef</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"MULTIASSIGNREF"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>source</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>colno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>ncolumns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outSortBy</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>SortBy</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"SORTBY"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>sortby_dir</name></expr></argument>, <argument><expr><name>SortByDir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>sortby_nulls</name></expr></argument>, <argument><expr><name>SortByNulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>useOp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>COMPILING_BINARY_FUNCS</name></cpp:ifndef>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outWindowDef</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>WindowDef</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"WINDOWDEF"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>refname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>partitionClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>orderClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>frameOptions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>startOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>endOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outRangeSubselect</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>RangeSubselect</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"RANGESUBSELECT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>lateral</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>subquery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>alias</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outRangeFunction</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>RangeFunction</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"RANGEFUNCTION"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>lateral</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>ordinality</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>is_rowsfrom</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>functions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>alias</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>coldeflist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>COMPILING_BINARY_FUNCS</name></cpp:ifndef>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outRangeTableSample</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>RangeTableSample</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"RANGETABLESAMPLE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>method</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>repeatable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outRangeTableFunc</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>RangeTableFunc</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"RANGETABLEFUNC"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>lateral</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>docexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>rowexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>namespaces</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>columns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>alias</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outRangeTableFuncCol</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>RangeTableFuncCol</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"RANGETABLEFUNCCOL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>colname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>typeName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>for_ordinality</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>is_not_null</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>colexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>coldefexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* COMPILING_BINARY_FUNCS */</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outConstraint</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Constraint</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"CONSTRAINT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>contype</name></expr></argument>, <argument><expr><name>ConstrType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>conname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>			<comment type="block">/* name, or NULL if unnamed */</comment>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>deferrable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>initdeferred</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>is_no_inherit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>raw_expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>cooked_expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_CHAR_FIELD</name><argument_list>(<argument><expr><name>generated_when</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>keys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>including</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>exclusions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>indexname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>indexspace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>reset_default_tblspc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>access_method</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>where_clause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>pktable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>fk_attrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>pk_attrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_CHAR_FIELD</name><argument_list>(<argument><expr><name>fk_matchtype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_CHAR_FIELD</name><argument_list>(<argument><expr><name>fk_upd_action</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_CHAR_FIELD</name><argument_list>(<argument><expr><name>fk_del_action</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>old_conpfeqop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>old_pktable_oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>skip_validation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>initially_valid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>COMPILING_BINARY_FUNCS</name></cpp:ifndef>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outForeignKeyCacheInfo</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ForeignKeyCacheInfo</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"FOREIGNKEYCACHEINFO"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>conoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>conrelid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>confrelid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>nkeys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_ATTRNUMBER_ARRAY</name><argument_list>(<argument><expr><name>conkey</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>nkeys</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_ATTRNUMBER_ARRAY</name><argument_list>(<argument><expr><name>confkey</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>nkeys</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_ARRAY</name><argument_list>(<argument><expr><name>conpfeqop</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>nkeys</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* COMPILING_BINARY_FUNCS */</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outPartitionElem</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>PartitionElem</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"PARTITIONELEM"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>collation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>opclass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outPartitionSpec</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>PartitionSpec</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"PARTITIONSPEC"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>strategy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>partParams</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outPartitionBoundSpec</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>PartitionBoundSpec</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"PARTITIONBOUNDSPEC"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_CHAR_FIELD</name><argument_list>(<argument><expr><name>strategy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>is_default</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>modulus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>remainder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>listdatums</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>lowerdatums</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>upperdatums</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outPartitionRangeDatum</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>PartitionRangeDatum</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"PARTITIONRANGEDATUM"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>kind</name></expr></argument>, <argument><expr><name>PartitionRangeDatumKind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outPartitionCmd</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>PartitionCmd</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"PARTITIONCMD"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>bound</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outGpAlterPartitionId</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>GpAlterPartitionId</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"GPALTERPARTITIONID"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>idtype</name></expr></argument>, <argument><expr><name>GpAlterPartitionIdType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>partiddef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outGpDropPartitionCmd</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>GpDropPartitionCmd</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"GPDROPPARTITIONCMD"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>partid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>behavior</name></expr></argument>, <argument><expr><name>DropBehavior</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>missing_ok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outGpAlterPartitionCmd</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>GpAlterPartitionCmd</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"GPALTERPARTITIONCMD"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>partid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outCreateSchemaStmt</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CreateSchemaStmt</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"CREATESCHEMASTMT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>schemaname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>authrole</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>istemp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outCreatePLangStmt</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CreatePLangStmt</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"CREATEPLANGSTMT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>replace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>plname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>plhandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>plinline</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>plvalidator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>pltrusted</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outVacuumStmt</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VacuumStmt</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"VACUUMSTMT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>rels</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>is_vacuumcmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outVacuumRelation</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VacuumRelation</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"VACUUMRELATION"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>va_cols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outCdbProcess</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CdbProcess</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"CDBPROCESS"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>listenerAddr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>listenerPort</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>pid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>contentid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>dbid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outSliceTable</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>SliceTable</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"SLICETABLE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>localSlice</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>numSlices</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>node</name><operator>-&gt;</operator><name>numSlices</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name><name>slices</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sliceIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name><name>slices</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>rootIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name><name>slices</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>parentIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name><name>slices</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>planNumSegments</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name><name>slices</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>children</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* List of int index */</comment>
		<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name><name>slices</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>gangType</name></expr></argument>, <argument><expr><name>GangType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name><name>slices</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>segments</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* List of int */</comment>
		<expr_stmt><expr><call><name>WRITE_DUMMY_FIELD</name><argument_list>(<argument><expr><name><name>slices</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>primaryGang</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name><name>slices</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>primaryProcesses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* List of (CDBProcess *) */</comment>
		<expr_stmt><expr><call><name>WRITE_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name><name>slices</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>processesMap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>hasMotions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>instrument_options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>ic_instance_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outCursorPosInfo</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CursorPosInfo</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"CURSORPOSINFO"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>cursor_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>gp_segment_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_UINT_FIELD</name><argument_list>(<argument><expr><name><name>ctid</name><operator>.</operator><name>ip_blkid</name><operator>.</operator><name>bi_hi</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_UINT_FIELD</name><argument_list>(<argument><expr><name><name>ctid</name><operator>.</operator><name>ip_blkid</name><operator>.</operator><name>bi_lo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_UINT_FIELD</name><argument_list>(<argument><expr><name><name>ctid</name><operator>.</operator><name>ip_posid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>table_oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outCreateTrigStmt</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CreateTrigStmt</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"CREATETRIGSTMT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>trigname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>funcname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>timing</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>events</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>columns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>whenClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>isconstraint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>transitionRels</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>deferrable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>initdeferred</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>constrrel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outCreateTableSpaceStmt</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CreateTableSpaceStmt</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"CREATETABLESPACESTMT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>tablespacename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>owner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outDropTableSpaceStmt</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>DropTableSpaceStmt</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"DROPTABLESPACESTMT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>tablespacename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>missing_ok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>COMPILING_BINARY_FUNCS</name></cpp:ifndef>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outCreateQueueStmt</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CreateQueueStmt</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"CREATEQUEUESTMT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>queue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* List of DefElem nodes */</comment>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* COMPILING_BINARY_FUNCS */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>COMPILING_BINARY_FUNCS</name></cpp:ifndef>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outAlterQueueStmt</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>AlterQueueStmt</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"ALTERQUEUESTMT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>queue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* List of DefElem nodes */</comment>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* COMPILING_BINARY_FUNCS */</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outDropQueueStmt</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>DropQueueStmt</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"DROPQUEUESTMT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>queue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>COMPILING_BINARY_FUNCS</name></cpp:ifndef>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outCreateResourceGroupStmt</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CreateResourceGroupStmt</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"CREATERESOURCEGROUPSTMT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* List of DefElem nodes */</comment>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* COMPILING_BINARY_FUNCS */</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outDropResourceGroupStmt</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>DropResourceGroupStmt</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"DROPRESOURCEGROUPSTMT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>COMPILING_BINARY_FUNCS</name></cpp:ifndef>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outAlterResourceGroupStmt</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>AlterResourceGroupStmt</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"ALTERRESOURCEGROUPSTMT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* List of DefElem nodes */</comment>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* COMPILING_BINARY_FUNCS */</comment>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outCommentStmt</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CommentStmt</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"COMMENTSTMT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>objtype</name></expr></argument>, <argument><expr><name>ObjectType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>object</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>comment</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outTableValueExpr</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>TableValueExpr</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"TABLEVALUEEXPR"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>subquery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outAlterTypeStmt</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>AlterTypeStmt</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"ALTERTYPESTMT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>typeName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outAlterExtensionStmt</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>AlterExtensionStmt</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"ALTEREXTENSIONSTMT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>extname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>update_ext_state</name></expr></argument>, <argument><expr><name>UpdateExtensionState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outAlterExtensionContentsStmt</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>AlterExtensionContentsStmt</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"ALTEREXTENSIONCONTENTSSTMT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>extname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>action</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>objtype</name></expr></argument>, <argument><expr><name>ObjectType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>object</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outAlterTSConfigurationStmt</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>AlterTSConfigurationStmt</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"ALTERTSCONFIGURATIONSTMT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>cfgname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>tokentype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>dicts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>override</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>replace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>missing_ok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outAlterTSDictionaryStmt</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>AlterTSDictionaryStmt</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"ALTERTSDICTIONARYSTMT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>dictname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outCreatePublicationStmt</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CreatePublicationStmt</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"CREATEPUBLICATIONSTMT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>pubname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>tables</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>for_all_tables</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outAlterPublicationStmt</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>AlterPublicationStmt</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"ALTERPUBLICATIONSTMT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>pubname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>tables</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>for_all_tables</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>tableAction</name></expr></argument>, <argument><expr><name>DefElemAction</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outCreateSubscriptionStmt</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CreateSubscriptionStmt</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"CREATESUBSCRIPTIONSTMT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>subname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>conninfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>publication</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outDropSubscriptionStmt</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>DropSubscriptionStmt</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"DROPSUBSCRIPTIONSTMT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>subname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>missing_ok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>behavior</name></expr></argument>, <argument><expr><name>DropBehavior</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outAlterSubscriptionStmt</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>AlterSubscriptionStmt</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"ALTERSUBSCRIPTIONSTMT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>kind</name></expr></argument>, <argument><expr><name>AlterSubscriptionType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>subname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>conninfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>publication</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>COMPILING_BINARY_FUNCS</name></cpp:ifndef>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outGpPartitionDefinition</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>GpPartitionDefinition</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"GPPARTITIONDEFINITION"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>partDefElems</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>encClauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>isTemplate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outGpPartDefElem</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>GpPartDefElem</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"GPPARTDEFELEM"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>partName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>boundSpec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>subSpec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>isDefault</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>accessMethod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>tablespacename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>colencs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outGpPartitionRangeItem</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>GpPartitionRangeItem</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"GPPARTITIONRANGEITEM"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>edge</name></expr></argument>, <argument><expr><name>GpPartitionEdgeBounding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outGpPartitionRangeSpec</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>GpPartitionRangeSpec</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"GPPARTITIONRANGESPEC"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>partStart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>partEnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>partEvery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outGpPartitionListSpec</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>GpPartitionListSpec</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"GPPARTITIONLISTSPEC"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>partValues</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outTupleDescNode</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>TupleDescNode</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>tuple</name><operator>-&gt;</operator><name>tdtypeid</name></name> <operator>==</operator> <name>RECORDOID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"TUPLEDESCNODE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>natts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name><name>tuple</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>node</name><operator>-&gt;</operator><name>tuple</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>tuple</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>ATTRIBUTE_FIXED_PART_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>tuple</name><operator>-&gt;</operator><name>constr</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name><name>tuple</name><operator>-&gt;</operator><name>tdtypeid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name><name>tuple</name><operator>-&gt;</operator><name>tdtypmod</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name><name>tuple</name><operator>-&gt;</operator><name>tdrefcount</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* COMPILING_BINARY_FUNCS */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>COMPILING_BINARY_FUNCS</name></cpp:ifndef>
<comment type="block">/*
 * outNode -
 *	  converts a Node into ascii string and append it to 'str'
 */</comment>
<function><type><name>void</name></type>
<name>outNode</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>obj</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Guard against stack overflow due to overly complex expressions */</comment>
	<expr_stmt><expr><call><name>check_stack_depth</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>obj</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"&lt;&gt;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>List</name></expr></argument>)</argument_list></call> <operator>||</operator><call><name>IsA</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>IntList</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>OidList</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>_outList</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>Integer</name></expr></argument>)</argument_list></call> <operator>||</operator>
			 <call><name>IsA</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>Float</name></expr></argument>)</argument_list></call> <operator>||</operator>
			 <call><name>IsA</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>String</name></expr></argument>)</argument_list></call> <operator>||</operator>
			 <call><name>IsA</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>BitString</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* nodeRead does not want to see { } around these! */</comment>
		<expr_stmt><expr><call><name>_outValue</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="char">'{'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>T_PlannedStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outPlannedStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_QueryDispatchDesc</name></expr>:</case>
				<expr_stmt><expr><call><name>_outQueryDispatchDesc</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_SerializedParams</name></expr>:</case>
				<expr_stmt><expr><call><name>_outSerializedParams</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_OidAssignment</name></expr>:</case>
				<expr_stmt><expr><call><name>_outOidAssignment</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_Plan</name></expr>:</case>
				<expr_stmt><expr><call><name>_outPlan</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_Result</name></expr>:</case>
				<expr_stmt><expr><call><name>_outResult</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_ProjectSet</name></expr>:</case>
				<expr_stmt><expr><call><name>_outProjectSet</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_ModifyTable</name></expr>:</case>
				<expr_stmt><expr><call><name>_outModifyTable</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_Append</name></expr>:</case>
				<expr_stmt><expr><call><name>_outAppend</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_MergeAppend</name></expr>:</case>
				<expr_stmt><expr><call><name>_outMergeAppend</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_Sequence</name></expr>:</case>
				<expr_stmt><expr><call><name>_outSequence</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_RecursiveUnion</name></expr>:</case>
				<expr_stmt><expr><call><name>_outRecursiveUnion</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_BitmapAnd</name></expr>:</case>
				<expr_stmt><expr><call><name>_outBitmapAnd</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_BitmapOr</name></expr>:</case>
				<expr_stmt><expr><call><name>_outBitmapOr</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_Gather</name></expr>:</case>
				<expr_stmt><expr><call><name>_outGather</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_GatherMerge</name></expr>:</case>
				<expr_stmt><expr><call><name>_outGatherMerge</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_Scan</name></expr>:</case>
				<expr_stmt><expr><call><name>_outScan</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_SeqScan</name></expr>:</case>
				<expr_stmt><expr><call><name>_outSeqScan</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_DynamicSeqScan</name></expr>:</case>
				<expr_stmt><expr><call><name>_outDynamicSeqScan</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_ExternalScanInfo</name></expr>:</case>
				<expr_stmt><expr><call><name>_outExternalScanInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_SampleScan</name></expr>:</case>
				<expr_stmt><expr><call><name>_outSampleScan</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_IndexScan</name></expr>:</case>
				<expr_stmt><expr><call><name>_outIndexScan</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_DynamicIndexScan</name></expr>:</case>
				<expr_stmt><expr><call><name>_outDynamicIndexScan</name><argument_list>(<argument><expr><name>str</name></expr></argument>,<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_IndexOnlyScan</name></expr>:</case>
				<expr_stmt><expr><call><name>_outIndexOnlyScan</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_BitmapIndexScan</name></expr>:</case>
				<expr_stmt><expr><call><name>_outBitmapIndexScan</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_DynamicBitmapIndexScan</name></expr>:</case>
				<expr_stmt><expr><call><name>_outDynamicBitmapIndexScan</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_BitmapHeapScan</name></expr>:</case>
				<expr_stmt><expr><call><name>_outBitmapHeapScan</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_DynamicBitmapHeapScan</name></expr>:</case>
				<expr_stmt><expr><call><name>_outDynamicBitmapHeapScan</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_TidScan</name></expr>:</case>
				<expr_stmt><expr><call><name>_outTidScan</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_SubqueryScan</name></expr>:</case>
				<expr_stmt><expr><call><name>_outSubqueryScan</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_FunctionScan</name></expr>:</case>
				<expr_stmt><expr><call><name>_outFunctionScan</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_TableFuncScan</name></expr>:</case>
				<expr_stmt><expr><call><name>_outTableFuncScan</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_ValuesScan</name></expr>:</case>
				<expr_stmt><expr><call><name>_outValuesScan</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_CteScan</name></expr>:</case>
				<expr_stmt><expr><call><name>_outCteScan</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_NamedTuplestoreScan</name></expr>:</case>
				<expr_stmt><expr><call><name>_outNamedTuplestoreScan</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_WorkTableScan</name></expr>:</case>
				<expr_stmt><expr><call><name>_outWorkTableScan</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_ForeignScan</name></expr>:</case>
				<expr_stmt><expr><call><name>_outForeignScan</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_CustomScan</name></expr>:</case>
				<expr_stmt><expr><call><name>_outCustomScan</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_Join</name></expr>:</case>
				<expr_stmt><expr><call><name>_outJoin</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_NestLoop</name></expr>:</case>
				<expr_stmt><expr><call><name>_outNestLoop</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_MergeJoin</name></expr>:</case>
				<expr_stmt><expr><call><name>_outMergeJoin</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_HashJoin</name></expr>:</case>
				<expr_stmt><expr><call><name>_outHashJoin</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_Agg</name></expr>:</case>
				<expr_stmt><expr><call><name>_outAgg</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_TupleSplit</name></expr>:</case>
				<expr_stmt><expr><call><name>_outTupleSplit</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
		    <case>case <expr><name>T_DQAExpr</name></expr>:</case>
                <expr_stmt><expr><call><name>_outDQAExpr</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
			<case>case <expr><name>T_WindowAgg</name></expr>:</case>
				<expr_stmt><expr><call><name>_outWindowAgg</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_TableFunctionScan</name></expr>:</case>
				<expr_stmt><expr><call><name>_outTableFunctionScan</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_Material</name></expr>:</case>
				<expr_stmt><expr><call><name>_outMaterial</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_ShareInputScan</name></expr>:</case>
				<expr_stmt><expr><call><name>_outShareInputScan</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_Sort</name></expr>:</case>
				<expr_stmt><expr><call><name>_outSort</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_Unique</name></expr>:</case>
				<expr_stmt><expr><call><name>_outUnique</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_Hash</name></expr>:</case>
				<expr_stmt><expr><call><name>_outHash</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_SetOp</name></expr>:</case>
				<expr_stmt><expr><call><name>_outSetOp</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_LockRows</name></expr>:</case>
				<expr_stmt><expr><call><name>_outLockRows</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_Limit</name></expr>:</case>
				<expr_stmt><expr><call><name>_outLimit</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_NestLoopParam</name></expr>:</case>
				<expr_stmt><expr><call><name>_outNestLoopParam</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_PlanRowMark</name></expr>:</case>
				<expr_stmt><expr><call><name>_outPlanRowMark</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_PartitionPruneInfo</name></expr>:</case>
				<expr_stmt><expr><call><name>_outPartitionPruneInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_PartitionedRelPruneInfo</name></expr>:</case>
				<expr_stmt><expr><call><name>_outPartitionedRelPruneInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_PartitionPruneStepOp</name></expr>:</case>
				<expr_stmt><expr><call><name>_outPartitionPruneStepOp</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_PartitionPruneStepCombine</name></expr>:</case>
				<expr_stmt><expr><call><name>_outPartitionPruneStepCombine</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_PlanInvalItem</name></expr>:</case>
				<expr_stmt><expr><call><name>_outPlanInvalItem</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_Motion</name></expr>:</case>
				<expr_stmt><expr><call><name>_outMotion</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_SplitUpdate</name></expr>:</case>
				<expr_stmt><expr><call><name>_outSplitUpdate</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_AssertOp</name></expr>:</case>
				<expr_stmt><expr><call><name>_outAssertOp</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_PartitionSelector</name></expr>:</case>
				<expr_stmt><expr><call><name>_outPartitionSelector</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_Alias</name></expr>:</case>
				<expr_stmt><expr><call><name>_outAlias</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_RangeVar</name></expr>:</case>
				<expr_stmt><expr><call><name>_outRangeVar</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_TableFunc</name></expr>:</case>
				<expr_stmt><expr><call><name>_outTableFunc</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_IntoClause</name></expr>:</case>
				<expr_stmt><expr><call><name>_outIntoClause</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_CopyIntoClause</name></expr>:</case>
				<expr_stmt><expr><call><name>_outCopyIntoClause</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_RefreshClause</name></expr>:</case>
				<expr_stmt><expr><call><name>_outRefreshClause</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_Var</name></expr>:</case>
				<expr_stmt><expr><call><name>_outVar</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_Const</name></expr>:</case>
				<expr_stmt><expr><call><name>_outConst</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_Param</name></expr>:</case>
				<expr_stmt><expr><call><name>_outParam</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_Aggref</name></expr>:</case>
				<expr_stmt><expr><call><name>_outAggref</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_GroupingFunc</name></expr>:</case>
				<expr_stmt><expr><call><name>_outGroupingFunc</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_GroupId</name></expr>:</case>
				<expr_stmt><expr><call><name>_outGroupId</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_GroupingSetId</name></expr>:</case>
				<expr_stmt><expr><call><name>_outGroupingSetId</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_WindowFunc</name></expr>:</case>
				<expr_stmt><expr><call><name>_outWindowFunc</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_SubscriptingRef</name></expr>:</case>
				<expr_stmt><expr><call><name>_outSubscriptingRef</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_FuncExpr</name></expr>:</case>
				<expr_stmt><expr><call><name>_outFuncExpr</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_NamedArgExpr</name></expr>:</case>
				<expr_stmt><expr><call><name>_outNamedArgExpr</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_OpExpr</name></expr>:</case>
				<expr_stmt><expr><call><name>_outOpExpr</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_DistinctExpr</name></expr>:</case>
				<expr_stmt><expr><call><name>_outDistinctExpr</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_NullIfExpr</name></expr>:</case>
				<expr_stmt><expr><call><name>_outNullIfExpr</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_ScalarArrayOpExpr</name></expr>:</case>
				<expr_stmt><expr><call><name>_outScalarArrayOpExpr</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_BoolExpr</name></expr>:</case>
				<expr_stmt><expr><call><name>_outBoolExpr</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_SubLink</name></expr>:</case>
				<expr_stmt><expr><call><name>_outSubLink</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_SubPlan</name></expr>:</case>
				<expr_stmt><expr><call><name>_outSubPlan</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_AlternativeSubPlan</name></expr>:</case>
				<expr_stmt><expr><call><name>_outAlternativeSubPlan</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_FieldSelect</name></expr>:</case>
				<expr_stmt><expr><call><name>_outFieldSelect</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_FieldStore</name></expr>:</case>
				<expr_stmt><expr><call><name>_outFieldStore</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_RelabelType</name></expr>:</case>
				<expr_stmt><expr><call><name>_outRelabelType</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_CoerceViaIO</name></expr>:</case>
				<expr_stmt><expr><call><name>_outCoerceViaIO</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_ArrayCoerceExpr</name></expr>:</case>
				<expr_stmt><expr><call><name>_outArrayCoerceExpr</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_ConvertRowtypeExpr</name></expr>:</case>
				<expr_stmt><expr><call><name>_outConvertRowtypeExpr</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_CollateExpr</name></expr>:</case>
				<expr_stmt><expr><call><name>_outCollateExpr</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_CaseExpr</name></expr>:</case>
				<expr_stmt><expr><call><name>_outCaseExpr</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_CaseWhen</name></expr>:</case>
				<expr_stmt><expr><call><name>_outCaseWhen</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_CaseTestExpr</name></expr>:</case>
				<expr_stmt><expr><call><name>_outCaseTestExpr</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_ArrayExpr</name></expr>:</case>
				<expr_stmt><expr><call><name>_outArrayExpr</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_RowExpr</name></expr>:</case>
				<expr_stmt><expr><call><name>_outRowExpr</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_RowCompareExpr</name></expr>:</case>
				<expr_stmt><expr><call><name>_outRowCompareExpr</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_CoalesceExpr</name></expr>:</case>
				<expr_stmt><expr><call><name>_outCoalesceExpr</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_MinMaxExpr</name></expr>:</case>
				<expr_stmt><expr><call><name>_outMinMaxExpr</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_SQLValueFunction</name></expr>:</case>
				<expr_stmt><expr><call><name>_outSQLValueFunction</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_XmlExpr</name></expr>:</case>
				<expr_stmt><expr><call><name>_outXmlExpr</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_NullTest</name></expr>:</case>
				<expr_stmt><expr><call><name>_outNullTest</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_BooleanTest</name></expr>:</case>
				<expr_stmt><expr><call><name>_outBooleanTest</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_CoerceToDomain</name></expr>:</case>
				<expr_stmt><expr><call><name>_outCoerceToDomain</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_CoerceToDomainValue</name></expr>:</case>
				<expr_stmt><expr><call><name>_outCoerceToDomainValue</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_SetToDefault</name></expr>:</case>
				<expr_stmt><expr><call><name>_outSetToDefault</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_CurrentOfExpr</name></expr>:</case>
				<expr_stmt><expr><call><name>_outCurrentOfExpr</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_NextValueExpr</name></expr>:</case>
				<expr_stmt><expr><call><name>_outNextValueExpr</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_InferenceElem</name></expr>:</case>
				<expr_stmt><expr><call><name>_outInferenceElem</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_TargetEntry</name></expr>:</case>
				<expr_stmt><expr><call><name>_outTargetEntry</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_RangeTblRef</name></expr>:</case>
				<expr_stmt><expr><call><name>_outRangeTblRef</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_JoinExpr</name></expr>:</case>
				<expr_stmt><expr><call><name>_outJoinExpr</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_FromExpr</name></expr>:</case>
				<expr_stmt><expr><call><name>_outFromExpr</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_Flow</name></expr>:</case>
				<expr_stmt><expr><call><name>_outFlow</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_OnConflictExpr</name></expr>:</case>
				<expr_stmt><expr><call><name>_outOnConflictExpr</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_Path</name></expr>:</case>
				<expr_stmt><expr><call><name>_outPath</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_IndexPath</name></expr>:</case>
				<expr_stmt><expr><call><name>_outIndexPath</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_BitmapHeapPath</name></expr>:</case>
				<expr_stmt><expr><call><name>_outBitmapHeapPath</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_BitmapAndPath</name></expr>:</case>
				<expr_stmt><expr><call><name>_outBitmapAndPath</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_BitmapOrPath</name></expr>:</case>
				<expr_stmt><expr><call><name>_outBitmapOrPath</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_TidPath</name></expr>:</case>
				<expr_stmt><expr><call><name>_outTidPath</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_SubqueryScanPath</name></expr>:</case>
				<expr_stmt><expr><call><name>_outSubqueryScanPath</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_TableFunctionScanPath</name></expr>:</case>
				<expr_stmt><expr><call><name>_outTableFunctionScanPath</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_ForeignPath</name></expr>:</case>
				<expr_stmt><expr><call><name>_outForeignPath</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_CustomPath</name></expr>:</case>
				<expr_stmt><expr><call><name>_outCustomPath</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_AppendPath</name></expr>:</case>
				<expr_stmt><expr><call><name>_outAppendPath</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_MergeAppendPath</name></expr>:</case>
				<expr_stmt><expr><call><name>_outMergeAppendPath</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_AppendOnlyPath</name></expr>:</case>
				<expr_stmt><expr><call><name>_outAppendOnlyPath</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_AOCSPath</name></expr>:</case>
				<expr_stmt><expr><call><name>_outAOCSPath</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_GroupResultPath</name></expr>:</case>
				<expr_stmt><expr><call><name>_outGroupResultPath</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_MaterialPath</name></expr>:</case>
				<expr_stmt><expr><call><name>_outMaterialPath</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_UniquePath</name></expr>:</case>
				<expr_stmt><expr><call><name>_outUniquePath</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_GatherPath</name></expr>:</case>
				<expr_stmt><expr><call><name>_outGatherPath</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_ProjectionPath</name></expr>:</case>
				<expr_stmt><expr><call><name>_outProjectionPath</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_ProjectSetPath</name></expr>:</case>
				<expr_stmt><expr><call><name>_outProjectSetPath</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_SortPath</name></expr>:</case>
				<expr_stmt><expr><call><name>_outSortPath</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_GroupPath</name></expr>:</case>
				<expr_stmt><expr><call><name>_outGroupPath</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_UpperUniquePath</name></expr>:</case>
				<expr_stmt><expr><call><name>_outUpperUniquePath</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_AggPath</name></expr>:</case>
				<expr_stmt><expr><call><name>_outAggPath</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_GroupingSetsPath</name></expr>:</case>
				<expr_stmt><expr><call><name>_outGroupingSetsPath</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_MinMaxAggPath</name></expr>:</case>
				<expr_stmt><expr><call><name>_outMinMaxAggPath</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_WindowAggPath</name></expr>:</case>
				<expr_stmt><expr><call><name>_outWindowAggPath</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_SetOpPath</name></expr>:</case>
				<expr_stmt><expr><call><name>_outSetOpPath</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_RecursiveUnionPath</name></expr>:</case>
				<expr_stmt><expr><call><name>_outRecursiveUnionPath</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_LockRowsPath</name></expr>:</case>
				<expr_stmt><expr><call><name>_outLockRowsPath</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_ModifyTablePath</name></expr>:</case>
				<expr_stmt><expr><call><name>_outModifyTablePath</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_LimitPath</name></expr>:</case>
				<expr_stmt><expr><call><name>_outLimitPath</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_GatherMergePath</name></expr>:</case>
				<expr_stmt><expr><call><name>_outGatherMergePath</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_NestPath</name></expr>:</case>
				<expr_stmt><expr><call><name>_outNestPath</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_MergePath</name></expr>:</case>
				<expr_stmt><expr><call><name>_outMergePath</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_HashPath</name></expr>:</case>
				<expr_stmt><expr><call><name>_outHashPath</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
            <case>case <expr><name>T_CdbMotionPath</name></expr>:</case>
                <expr_stmt><expr><call><name>_outCdbMotionPath</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
			<case>case <expr><name>T_PlannerGlobal</name></expr>:</case>
				<expr_stmt><expr><call><name>_outPlannerGlobal</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_PlannerInfo</name></expr>:</case>
				<expr_stmt><expr><call><name>_outPlannerInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_RelOptInfo</name></expr>:</case>
				<expr_stmt><expr><call><name>_outRelOptInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_IndexOptInfo</name></expr>:</case>
				<expr_stmt><expr><call><name>_outIndexOptInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_ForeignKeyOptInfo</name></expr>:</case>
				<expr_stmt><expr><call><name>_outForeignKeyOptInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_EquivalenceClass</name></expr>:</case>
				<expr_stmt><expr><call><name>_outEquivalenceClass</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_EquivalenceMember</name></expr>:</case>
				<expr_stmt><expr><call><name>_outEquivalenceMember</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_PathKey</name></expr>:</case>
				<expr_stmt><expr><call><name>_outPathKey</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_DistributionKey</name></expr>:</case>
				<expr_stmt><expr><call><name>_outDistributionKey</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_PathTarget</name></expr>:</case>
				<expr_stmt><expr><call><name>_outPathTarget</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_ParamPathInfo</name></expr>:</case>
				<expr_stmt><expr><call><name>_outParamPathInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_RestrictInfo</name></expr>:</case>
				<expr_stmt><expr><call><name>_outRestrictInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_IndexClause</name></expr>:</case>
				<expr_stmt><expr><call><name>_outIndexClause</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_PlaceHolderVar</name></expr>:</case>
				<expr_stmt><expr><call><name>_outPlaceHolderVar</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_SpecialJoinInfo</name></expr>:</case>
				<expr_stmt><expr><call><name>_outSpecialJoinInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_AppendRelInfo</name></expr>:</case>
				<expr_stmt><expr><call><name>_outAppendRelInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_PlaceHolderInfo</name></expr>:</case>
				<expr_stmt><expr><call><name>_outPlaceHolderInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_MinMaxAggInfo</name></expr>:</case>
				<expr_stmt><expr><call><name>_outMinMaxAggInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_PlannerParamItem</name></expr>:</case>
				<expr_stmt><expr><call><name>_outPlannerParamItem</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_RollupData</name></expr>:</case>
				<expr_stmt><expr><call><name>_outRollupData</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_GroupingSetData</name></expr>:</case>
				<expr_stmt><expr><call><name>_outGroupingSetData</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_StatisticExtInfo</name></expr>:</case>
				<expr_stmt><expr><call><name>_outStatisticExtInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_GrantStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outGrantStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_ObjectWithArgs</name></expr>:</case>
				<expr_stmt><expr><call><name>_outObjectWithArgs</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_GrantRoleStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outGrantRoleStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_LockStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outLockStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_ExtensibleNode</name></expr>:</case>
				<expr_stmt><expr><call><name>_outExtensibleNode</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_CreateStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outCreateStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_CreateForeignTableStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outCreateForeignTableStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_DistributionKeyElem</name></expr>:</case>
				<expr_stmt><expr><call><name>_outDistributionKeyElem</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_ColumnReferenceStorageDirective</name></expr>:</case>
				<expr_stmt><expr><call><name>_outColumnReferenceStorageDirective</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_SegfileMapNode</name></expr>:</case>
				<expr_stmt><expr><call><name>_outSegfileMapNode</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_ExtTableTypeDesc</name></expr>:</case>
				<expr_stmt><expr><call><name>_outExtTableTypeDesc</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_CreateExternalStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outCreateExternalStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_DistributedBy</name></expr>:</case>
				<expr_stmt><expr><call><name>_outDistributedBy</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_ImportForeignSchemaStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outImportForeignSchemaStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_IndexStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outIndexStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_ReindexStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outReindexStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_ConstraintsSetStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outConstraintsSetStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_CreateFunctionStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outCreateFunctionStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_FunctionParameter</name></expr>:</case>
				<expr_stmt><expr><call><name>_outFunctionParameter</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_AlterFunctionStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outAlterFunctionStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_DefineStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outDefineStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>,<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_CompositeTypeStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outCompositeTypeStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>,<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_CreateEnumStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outCreateEnumStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>,<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_CreateRangeStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outCreateRangeStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>,<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_CreateCastStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outCreateCastStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>,<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_CreateOpClassStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outCreateOpClassStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>,<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_CreateOpClassItem</name></expr>:</case>
				<expr_stmt><expr><call><name>_outCreateOpClassItem</name><argument_list>(<argument><expr><name>str</name></expr></argument>,<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_CreateOpFamilyStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outCreateOpFamilyStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>,<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_AlterOpFamilyStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outAlterOpFamilyStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>,<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_CreateConversionStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outCreateConversionStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>,<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_ViewStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outViewStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_RuleStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outRuleStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_DropStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outDropStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_DropOwnedStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outDropOwnedStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_ReassignOwnedStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outReassignOwnedStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_TruncateStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outTruncateStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_ReplicaIdentityStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outReplicaIdentityStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_AlterTableStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outAlterTableStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_AlterTableCmd</name></expr>:</case>
				<expr_stmt><expr><call><name>_outAlterTableCmd</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_AlteredTableInfo</name></expr>:</case>
				<expr_stmt><expr><call><name>_outAlteredTableInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_NewConstraint</name></expr>:</case>
				<expr_stmt><expr><call><name>_outNewConstraint</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_NewColumnValue</name></expr>:</case>
				<expr_stmt><expr><call><name>_outNewColumnValue</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_CreateRoleStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outCreateRoleStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_DropRoleStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outDropRoleStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_AlterRoleStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outAlterRoleStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_AlterRoleSetStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outAlterRoleSetStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_AlterSystemStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outAlterSystemStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_AlterObjectSchemaStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outAlterObjectSchemaStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_AlterOwnerStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outAlterOwnerStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_RenameStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outRenameStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_CreateSeqStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outCreateSeqStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_AlterSeqStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outAlterSeqStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_ClusterStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outClusterStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_CreatedbStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outCreatedbStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_DropdbStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outDropdbStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_CreateDomainStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outCreateDomainStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_AlterDomainStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outAlterDomainStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_TransactionStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outTransactionStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_CreateStatsStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outCreateStatsStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_NotifyStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outNotifyStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_DeclareCursorStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outDeclareCursorStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_SingleRowErrorDesc</name></expr>:</case>
				<expr_stmt><expr><call><name>_outSingleRowErrorDesc</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_CopyStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outCopyStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_SelectStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outSelectStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_InsertStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outInsertStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_DeleteStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outDeleteStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_UpdateStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outUpdateStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_Null</name></expr>:</case>
				<expr_stmt><expr><call><name>_outNull</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_ColumnDef</name></expr>:</case>
				<expr_stmt><expr><call><name>_outColumnDef</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_TypeName</name></expr>:</case>
				<expr_stmt><expr><call><name>_outTypeName</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_TypeCast</name></expr>:</case>
				<expr_stmt><expr><call><name>_outTypeCast</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_CollateClause</name></expr>:</case>
				<expr_stmt><expr><call><name>_outCollateClause</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_IndexElem</name></expr>:</case>
				<expr_stmt><expr><call><name>_outIndexElem</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_Query</name></expr>:</case>
				<expr_stmt><expr><call><name>_outQuery</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_WithCheckOption</name></expr>:</case>
				<expr_stmt><expr><call><name>_outWithCheckOption</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_SortGroupClause</name></expr>:</case>
				<expr_stmt><expr><call><name>_outSortGroupClause</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_GroupingSet</name></expr>:</case>
				<expr_stmt><expr><call><name>_outGroupingSet</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_WindowClause</name></expr>:</case>
				<expr_stmt><expr><call><name>_outWindowClause</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_RowMarkClause</name></expr>:</case>
				<expr_stmt><expr><call><name>_outRowMarkClause</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_WithClause</name></expr>:</case>
				<expr_stmt><expr><call><name>_outWithClause</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_CommonTableExpr</name></expr>:</case>
				<expr_stmt><expr><call><name>_outCommonTableExpr</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_SetOperationStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outSetOperationStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_RangeTblEntry</name></expr>:</case>
				<expr_stmt><expr><call><name>_outRangeTblEntry</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_RangeTblFunction</name></expr>:</case>
				<expr_stmt><expr><call><name>_outRangeTblFunction</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_TableSampleClause</name></expr>:</case>
				<expr_stmt><expr><call><name>_outTableSampleClause</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_A_Expr</name></expr>:</case>
				<expr_stmt><expr><call><name>_outAExpr</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_ColumnRef</name></expr>:</case>
				<expr_stmt><expr><call><name>_outColumnRef</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_ParamRef</name></expr>:</case>
				<expr_stmt><expr><call><name>_outParamRef</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_RawStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outRawStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_A_Const</name></expr>:</case>
				<expr_stmt><expr><call><name>_outAConst</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_A_Star</name></expr>:</case>
				<expr_stmt><expr><call><name>_outA_Star</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_A_Indices</name></expr>:</case>
				<expr_stmt><expr><call><name>_outA_Indices</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_A_Indirection</name></expr>:</case>
				<expr_stmt><expr><call><name>_outA_Indirection</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_A_ArrayExpr</name></expr>:</case>
				<expr_stmt><expr><call><name>_outA_ArrayExpr</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_ResTarget</name></expr>:</case>
				<expr_stmt><expr><call><name>_outResTarget</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_MultiAssignRef</name></expr>:</case>
				<expr_stmt><expr><call><name>_outMultiAssignRef</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_SortBy</name></expr>:</case>
				<expr_stmt><expr><call><name>_outSortBy</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_WindowDef</name></expr>:</case>
				<expr_stmt><expr><call><name>_outWindowDef</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_RangeSubselect</name></expr>:</case>
				<expr_stmt><expr><call><name>_outRangeSubselect</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<break>break;</break>
			<case>case <expr><name>T_RangeFunction</name></expr>:</case>
				<expr_stmt><expr><call><name>_outRangeFunction</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_RangeTableSample</name></expr>:</case>
				<expr_stmt><expr><call><name>_outRangeTableSample</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_RangeTableFunc</name></expr>:</case>
				<expr_stmt><expr><call><name>_outRangeTableFunc</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_RangeTableFuncCol</name></expr>:</case>
				<expr_stmt><expr><call><name>_outRangeTableFuncCol</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_Constraint</name></expr>:</case>
				<expr_stmt><expr><call><name>_outConstraint</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_FuncCall</name></expr>:</case>
				<expr_stmt><expr><call><name>_outFuncCall</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_DefElem</name></expr>:</case>
				<expr_stmt><expr><call><name>_outDefElem</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_TableLikeClause</name></expr>:</case>
				<expr_stmt><expr><call><name>_outTableLikeClause</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_LockingClause</name></expr>:</case>
				<expr_stmt><expr><call><name>_outLockingClause</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_XmlSerialize</name></expr>:</case>
				<expr_stmt><expr><call><name>_outXmlSerialize</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_ForeignKeyCacheInfo</name></expr>:</case>
				<expr_stmt><expr><call><name>_outForeignKeyCacheInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_TriggerTransition</name></expr>:</case>
				<expr_stmt><expr><call><name>_outTriggerTransition</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_PartitionElem</name></expr>:</case>
				<expr_stmt><expr><call><name>_outPartitionElem</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_PartitionSpec</name></expr>:</case>
				<expr_stmt><expr><call><name>_outPartitionSpec</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_PartitionBoundSpec</name></expr>:</case>
				<expr_stmt><expr><call><name>_outPartitionBoundSpec</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_PartitionRangeDatum</name></expr>:</case>
				<expr_stmt><expr><call><name>_outPartitionRangeDatum</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_PartitionCmd</name></expr>:</case>
				<expr_stmt><expr><call><name>_outPartitionCmd</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_GpAlterPartitionId</name></expr>:</case>
				<expr_stmt><expr><call><name>_outGpAlterPartitionId</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_GpAlterPartitionCmd</name></expr>:</case>
				<expr_stmt><expr><call><name>_outGpAlterPartitionCmd</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_GpDropPartitionCmd</name></expr>:</case>
				<expr_stmt><expr><call><name>_outGpDropPartitionCmd</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_CreateSchemaStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outCreateSchemaStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_CreatePLangStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outCreatePLangStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_VacuumStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outVacuumStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_VacuumRelation</name></expr>:</case>
				<expr_stmt><expr><call><name>_outVacuumRelation</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_CdbProcess</name></expr>:</case>
				<expr_stmt><expr><call><name>_outCdbProcess</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_SliceTable</name></expr>:</case>
				<expr_stmt><expr><call><name>_outSliceTable</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_CursorPosInfo</name></expr>:</case>
				<expr_stmt><expr><call><name>_outCursorPosInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_VariableSetStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outVariableSetStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_DMLActionExpr</name></expr>:</case>
				<expr_stmt><expr><call><name>_outDMLActionExpr</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_CreateTrigStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outCreateTrigStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_CreateTableSpaceStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outCreateTableSpaceStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_DropTableSpaceStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outDropTableSpaceStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_CreateQueueStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outCreateQueueStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_AlterQueueStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outAlterQueueStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_DropQueueStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outDropQueueStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_CreateResourceGroupStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outCreateResourceGroupStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_DropResourceGroupStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outDropResourceGroupStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_AlterResourceGroupStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outAlterResourceGroupStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_CommentStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outCommentStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_TableValueExpr</name></expr>:</case>
				<expr_stmt><expr><call><name>_outTableValueExpr</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
			<case>case <expr><name>T_DenyLoginInterval</name></expr>:</case>
				<expr_stmt><expr><call><name>_outDenyLoginInterval</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_DenyLoginPoint</name></expr>:</case>
				<expr_stmt><expr><call><name>_outDenyLoginPoint</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_AlterTypeStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outAlterTypeStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_AlterExtensionStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outAlterExtensionStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_AlterExtensionContentsStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outAlterExtensionContentsStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_TupleDescNode</name></expr>:</case>
				<expr_stmt><expr><call><name>_outTupleDescNode</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_AlterTSConfigurationStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outAlterTSConfigurationStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_AlterTSDictionaryStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outAlterTSDictionaryStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_CreatePublicationStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outCreatePublicationStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_AlterPublicationStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outAlterPublicationStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_CreateSubscriptionStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outCreateSubscriptionStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_DropSubscriptionStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outDropSubscriptionStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_AlterSubscriptionStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outAlterSubscriptionStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_CreatePolicyStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outCreatePolicyStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_AlterPolicyStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outAlterPolicyStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_CreateTransformStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outCreateTransformStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_GpPartitionDefinition</name></expr>:</case>
				<expr_stmt><expr><call><name>_outGpPartitionDefinition</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_GpPartDefElem</name></expr>:</case>
				<expr_stmt><expr><call><name>_outGpPartDefElem</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_GpPartitionRangeItem</name></expr>:</case>
				<expr_stmt><expr><call><name>_outGpPartitionRangeItem</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_GpPartitionRangeSpec</name></expr>:</case>
				<expr_stmt><expr><call><name>_outGpPartitionRangeSpec</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_GpPartitionListSpec</name></expr>:</case>
				<expr_stmt><expr><call><name>_outGpPartitionListSpec</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<default>default:</default>

				<comment type="block">/*
				 * This should be an ERROR, but it's too useful to be able to
				 * dump structures that outNode only understands part of.
				 */</comment>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"could not dump unrecognized node type: %d"</literal></expr></argument>,
					 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>nodeTag</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
		</block_content>}</block></switch>
		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="char">'}'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * nodeToString -
 *	   returns the ascii representation of the Node as a palloc'd string
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>nodeToString</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>obj</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>str</name></decl>;</decl_stmt>

	<comment type="block">/* see stringinfo.h for an explanation of this maneuver */</comment>
	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>outNode</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name><name>str</name><operator>.</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * bmsToString -
 *	   returns the ascii representation of the Bitmapset as a palloc'd string
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>bmsToString</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Bitmapset</name> <modifier>*</modifier></type><name>bms</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>str</name></decl>;</decl_stmt>

	<comment type="block">/* see stringinfo.h for an explanation of this maneuver */</comment>
	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>outBitmapset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><name>bms</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name><name>str</name><operator>.</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* COMPILING_BINARY_FUNCS */</comment>
</unit>
