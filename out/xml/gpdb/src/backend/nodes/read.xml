<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/backend/nodes/read.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * read.c
 *	  routines to convert a string (legal ascii representation of node) back
 *	  to nodes
 *
 * Portions Copyright (c) 2006-2008, Greenplum inc
 * Portions Copyright (c) 2012-Present VMware, Inc. or its affiliates.
 * Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/nodes/read.c
 *
 * HISTORY
 *	  AUTHOR			DATE			MAJOR EVENT
 *	  Andrew Yu			Nov 2, 1994		file creation
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/string.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/pg_list.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/readfuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/value.h"</cpp:file></cpp:include>


<comment type="block">/* Static state for pg_strtok */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pg_strtok_ptr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pg_strtok_begin</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>                    <comment type="block">/*CDB*/</comment>

<comment type="block">/* State flag that determines how readfuncs.c should treat location fields */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WRITE_READ_PARSE_PLAN_TREES</name></cpp:ifdef>
<decl_stmt><decl><type><name>bool</name></type>		<name>restore_location_fields</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>nodeReadSkipThru</name><parameter_list>(<parameter><decl><type><name>char</name></type> <name>closingDelimiter</name></decl></parameter>)</parameter_list>;</function_decl>    <comment type="block">/*CDB*/</comment>

<comment type="block">/*
 * Helper functions for saving current states and pg_strtok() another string
 *
 * External functions like ExtensibleNodeMethods-&gt;nodeRead() uses the
 * pg_strtok_ptr information via pg_strtok() but the context could be binary
 * (readfast.c), set_strtok_states() to pg_strtok() the string.
 */</comment>
<function><type><name>void</name></type>
<name>save_strtok_states</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type> <name>save_ptr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type> <name>save_begin</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><operator>*</operator><name>save_ptr</name> <operator>=</operator> <name>pg_strtok_ptr</name></expr>;</expr_stmt>		<comment type="block">/* point pg_strtok at the string to read */</comment>
	<expr_stmt><expr><operator>*</operator><name>save_begin</name> <operator>=</operator> <name>pg_strtok_begin</name></expr>;</expr_stmt>	<comment type="block">/* CDB: save starting position for debug */</comment>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>set_strtok_states</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>begin</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name>pg_strtok_ptr</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>		<comment type="block">/* point pg_strtok at the string to read */</comment>
	<expr_stmt><expr><name>pg_strtok_begin</name> <operator>=</operator> <name>begin</name></expr>;</expr_stmt>	<comment type="block">/* CDB: save starting position for debug */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * stringToNode -
 *	  builds a Node tree from its string representation (assumed valid)
 *
 * restore_loc_fields instructs readfuncs.c whether to restore location
 * fields rather than set them to -1.  This is currently only supported
 * in builds with the WRITE_READ_PARSE_PLAN_TREES debugging flag set.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type>
<name>stringToNodeInternal</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>restore_loc_fields</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>void</name>	   <modifier>*</modifier></type><name>retval</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>save_strtok</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>save_begin</name> <init>= <expr><name>pg_strtok_begin</name></expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WRITE_READ_PARSE_PLAN_TREES</name></cpp:ifdef>
	<decl_stmt><decl><type><name>bool</name></type>		<name>save_restore_location_fields</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/*
	 * We save and restore the pre-existing state of pg_strtok. This makes the
	 * world safe for re-entrant invocation of stringToNode, without incurring
	 * a lot of notational overhead by having to pass the next-character
	 * pointer around through all the readfuncs.c code.
	 */</comment>
	<expr_stmt><expr><name>save_strtok</name> <operator>=</operator> <name>pg_strtok_ptr</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>pg_strtok_ptr</name> <operator>=</operator> <name>str</name></expr>;</expr_stmt>		<comment type="block">/* point pg_strtok at the string to read */</comment>
    <expr_stmt><expr><name>pg_strtok_begin</name> <operator>=</operator> <name>str</name></expr>;</expr_stmt>      <comment type="block">/* CDB: save starting position for debug */</comment>

	<comment type="block">/*
	 * If enabled, likewise save/restore the location field handling flag.
	 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WRITE_READ_PARSE_PLAN_TREES</name></cpp:ifdef>
	<expr_stmt><expr><name>save_restore_location_fields</name> <operator>=</operator> <name>restore_location_fields</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>restore_location_fields</name> <operator>=</operator> <name>restore_loc_fields</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>nodeRead</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* do the reading */</comment>

	<expr_stmt><expr><name>pg_strtok_ptr</name> <operator>=</operator> <name>save_strtok</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>pg_strtok_begin</name> <operator>=</operator> <name>save_begin</name></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WRITE_READ_PARSE_PLAN_TREES</name></cpp:ifdef>
	<expr_stmt><expr><name>restore_location_fields</name> <operator>=</operator> <name>save_restore_location_fields</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<return>return <expr><name>retval</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Externally visible entry points
 */</comment>
<function><type><name>void</name> <modifier>*</modifier></type>
<name>stringToNode</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>stringToNodeInternal</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WRITE_READ_PARSE_PLAN_TREES</name></cpp:ifdef>

<function><type><name>void</name> <modifier>*</modifier></type>
<name>stringToNodeWithLocations</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>stringToNodeInternal</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block" format="doxygen">/*****************************************************************************
 *
 * the lisp token parser
 *
 *****************************************************************************/</comment>

<comment type="block">/*
 * pg_strtok --- retrieve next "token" from a string.
 *
 * Works kinda like strtok, except it never modifies the source string.
 * (Instead of storing nulls into the string, the length of the token
 * is returned to the caller.)
 * Also, the rules about what is a token are hard-wired rather than being
 * configured by passing a set of terminating characters.
 *
 * The string is assumed to have been initialized already by stringToNode.
 *
 * The rules for tokens are:
 *	* Whitespace (space, tab, newline) always separates tokens.
 *	* The characters '(', ')', '{', '}' form individual tokens even
 *	  without any whitespace around them.
 *	* Otherwise, a token is all the characters up to the next whitespace
 *	  or occurrence of one of the four special characters.
 *	* A backslash '\' can be used to quote whitespace or one of the four
 *	  special characters, so that it is treated as a plain token character.
 *	  Backslashes themselves must also be backslashed for consistency.
 *	  Any other character can be, but need not be, backslashed as well.
 *	* If the resulting token is '&lt;&gt;' (with no backslash), it is returned
 *	  as a non-NULL pointer to the token but with length == 0.  Note that
 *	  there is no other way to get a zero-length token.
 *
 * Returns a pointer to the start of the next token, and the length of the
 * token (including any embedded backslashes!) in *length.  If there are
 * no more tokens, NULL and 0 are returned.
 *
 * NOTE: this routine doesn't remove backslashes; the caller must do so
 * if necessary (see "debackslash").
 *
 * NOTE: prior to release 7.0, this routine also had a special case to treat
 * a token starting with '"' as extending to the next '"'.  This code was
 * broken, however, since it would fail to cope with a string containing an
 * embedded '"'.  I have therefore removed this special case, and instead
 * introduced rules for using backslashes to quote characters.  Higher-level
 * code should add backslashes to a string constant to ensure it is treated
 * as a single token.
 */</comment>
<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>pg_strtok</name><parameter_list>(<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>length</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>local_str</name></decl>;</decl_stmt>		<comment type="block">/* working pointer to string */</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ret_str</name></decl>;</decl_stmt>		<comment type="block">/* start of token to return */</comment>

	<expr_stmt><expr><name>local_str</name> <operator>=</operator> <name>pg_strtok_ptr</name></expr>;</expr_stmt>

	<while>while <condition>(<expr><operator>*</operator><name>local_str</name> <operator>==</operator> <literal type="char">' '</literal> <operator>||</operator> <operator>*</operator><name>local_str</name> <operator>==</operator> <literal type="char">'\n'</literal> <operator>||</operator> <operator>*</operator><name>local_str</name> <operator>==</operator> <literal type="char">'\t'</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>local_str</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>

	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>local_str</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>length</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>pg_strtok_ptr</name> <operator>=</operator> <name>local_str</name></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>			<comment type="block">/* no more tokens */</comment>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Now pointing at start of next token.
	 */</comment>
	<expr_stmt><expr><name>ret_str</name> <operator>=</operator> <name>local_str</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>local_str</name> <operator>==</operator> <literal type="char">'('</literal> <operator>||</operator> <operator>*</operator><name>local_str</name> <operator>==</operator> <literal type="char">')'</literal> <operator>||</operator>
		<operator>*</operator><name>local_str</name> <operator>==</operator> <literal type="char">'{'</literal> <operator>||</operator> <operator>*</operator><name>local_str</name> <operator>==</operator> <literal type="char">'}'</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* special 1-character token */</comment>
		<expr_stmt><expr><name>local_str</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Normal token, possibly containing backslashes */</comment>
		<while>while <condition>(<expr><operator>*</operator><name>local_str</name> <operator>!=</operator> <literal type="char">'\0'</literal> <operator>&amp;&amp;</operator>
			   <operator>*</operator><name>local_str</name> <operator>!=</operator> <literal type="char">' '</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>local_str</name> <operator>!=</operator> <literal type="char">'\n'</literal> <operator>&amp;&amp;</operator>
			   <operator>*</operator><name>local_str</name> <operator>!=</operator> <literal type="char">'\t'</literal> <operator>&amp;&amp;</operator>
			   <operator>*</operator><name>local_str</name> <operator>!=</operator> <literal type="char">'('</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>local_str</name> <operator>!=</operator> <literal type="char">')'</literal> <operator>&amp;&amp;</operator>
			   <operator>*</operator><name>local_str</name> <operator>!=</operator> <literal type="char">'{'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>local_str</name> <operator>!=</operator> <literal type="char">'}'</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>*</operator><name>local_str</name> <operator>==</operator> <literal type="char">'\\'</literal> <operator>&amp;&amp;</operator> <name><name>local_str</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>local_str</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>local_str</name><operator>++</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></while>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><operator>*</operator><name>length</name> <operator>=</operator> <name>local_str</name> <operator>-</operator> <name>ret_str</name></expr>;</expr_stmt>

	<comment type="block">/* Recognize special case for "empty" token */</comment>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>length</name> <operator>==</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <name><name>ret_str</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'&lt;'</literal> <operator>&amp;&amp;</operator> <name><name>ret_str</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'&gt;'</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>length</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>pg_strtok_ptr</name> <operator>=</operator> <name>local_str</name></expr>;</expr_stmt>

	<return>return <expr><name>ret_str</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * debackslash -
 *	  create a palloc'd string holding the given token.
 *	  any protective backslashes in the token are removed.
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>debackslash</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>token</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>length</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>result</name> <init>= <expr><call><name>palloc</name><argument_list>(<argument><expr><name>length</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>ptr</name> <init>= <expr><name>result</name></expr></init></decl>;</decl_stmt>

	<while>while <condition>(<expr><name>length</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>token</name> <operator>==</operator> <literal type="char">'\\'</literal> <operator>&amp;&amp;</operator> <name>length</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>token</name><operator>++</operator></expr><operator>,</operator> <expr><name>length</name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><operator>*</operator><name>ptr</name><operator>++</operator> <operator>=</operator> <operator>*</operator><name>token</name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>length</name><operator>--</operator></expr>;</expr_stmt>
	</block_content>}</block></while>
	<expr_stmt><expr><operator>*</operator><name>ptr</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RIGHT_PAREN</name></cpp:macro> <cpp:value>(1000000 + 1)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LEFT_PAREN</name></cpp:macro>	<cpp:value>(1000000 + 2)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LEFT_BRACE</name></cpp:macro>	<cpp:value>(1000000 + 3)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OTHER_TOKEN</name></cpp:macro> <cpp:value>(1000000 + 4)</cpp:value></cpp:define>

<comment type="block">/*
 * nodeTokenType -
 *	  returns the type of the node token contained in token.
 *	  It returns one of the following valid NodeTags:
 *		T_Integer, T_Float, T_String, T_BitString
 *	  and some of its own:
 *		RIGHT_PAREN, LEFT_PAREN, LEFT_BRACE, OTHER_TOKEN
 *
 *	  Assumption: the ascii representation is legal
 */</comment>
<function><type><specifier>static</specifier> <name>NodeTag</name></type>
<name>nodeTokenType</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>token</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>length</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>NodeTag</name></type>		<name>retval</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>numptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numlen</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Check if the token is a number
	 */</comment>
	<expr_stmt><expr><name>numptr</name> <operator>=</operator> <name>token</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>numlen</name> <operator>=</operator> <name>length</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>numptr</name> <operator>==</operator> <literal type="char">'+'</literal> <operator>||</operator> <operator>*</operator><name>numptr</name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>numptr</name><operator>++</operator></expr><operator>,</operator> <expr><name>numlen</name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>numlen</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>isdigit</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>numptr</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>||</operator>
		<operator>(</operator><name>numlen</name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>numptr</name> <operator>==</operator> <literal type="char">'.'</literal> <operator>&amp;&amp;</operator> <call><name>isdigit</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <name><name>numptr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Yes.  Figure out whether it is integral or float; this requires
		 * both a syntax check and a range check. strtoint() can do both for
		 * us. We know the token will end at a character that strtoint will
		 * stop at, so we do not need to modify the string.
		 */</comment>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>endptr</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>strtoint</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>endptr</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>endptr</name> <operator>!=</operator> <name>token</name> <operator>+</operator> <name>length</name> <operator>||</operator> <name>errno</name> <operator>==</operator> <name>ERANGE</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>T_Float</name></expr>;</return></block_content></block></if></if_stmt>
		<return>return <expr><name>T_Integer</name></expr>;</return>
	</block_content>}</block></if>

	<comment type="block">/*
	 * these three cases do not need length checks, since pg_strtok() will
	 * always treat them as single-byte tokens
	 */</comment>
	<if type="elseif">else if <condition>(<expr><operator>*</operator><name>token</name> <operator>==</operator> <literal type="char">'('</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>retval</name> <operator>=</operator> <name>LEFT_PAREN</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><operator>*</operator><name>token</name> <operator>==</operator> <literal type="char">')'</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>retval</name> <operator>=</operator> <name>RIGHT_PAREN</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><operator>*</operator><name>token</name> <operator>==</operator> <literal type="char">'{'</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>retval</name> <operator>=</operator> <name>LEFT_BRACE</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><operator>*</operator><name>token</name> <operator>==</operator> <literal type="char">'"'</literal> <operator>&amp;&amp;</operator> <name>length</name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>token</name><index>[<expr><name>length</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'"'</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>retval</name> <operator>=</operator> <name>T_String</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><operator>*</operator><name>token</name> <operator>==</operator> <literal type="char">'b'</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>retval</name> <operator>=</operator> <name>T_BitString</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>retval</name> <operator>=</operator> <name>OTHER_TOKEN</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<return>return <expr><name>retval</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * nodeRead -
 *	  Slightly higher-level reader.
 *
 * This routine applies some semantic knowledge on top of the purely
 * lexical tokenizer pg_strtok().   It can read
 *	* Value token nodes (integers, floats, or strings);
 *	* General nodes (via parseNodeString() from readfuncs.c);
 *	* Lists of the above;
 *	* Lists of integers or OIDs.
 * The return value is declared void *, not Node *, to avoid having to
 * cast it explicitly in callers that assign to fields of different types.
 *
 * External callers should always pass NULL/0 for the arguments.  Internally
 * a non-NULL token may be passed when the upper recursion level has already
 * scanned the first token of a node's representation.
 *
 * We assume pg_strtok is already initialized with a string to read (hence
 * this should only be invoked from within a stringToNode operation).
 */</comment>
<function><type><name>void</name> <modifier>*</modifier></type>
<name>nodeRead</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>token</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>tok_len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NodeTag</name></type>		<name>type</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>token</name> <operator>==</operator> <name>NULL</name></expr>)</condition>			<comment type="block">/* need to read a token? */</comment>
	<block>{<block_content>
		<expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tok_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>token</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>		<comment type="block">/* end of input */</comment>
			<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>nodeTokenType</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><name>tok_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><operator>(</operator><name>int</name><operator>)</operator> <name>type</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>LEFT_BRACE</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>parseNodeString</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tok_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/*
             * CDB: Check for extra fields left over following the ones that
             * were consumed by the node reader function.  If this tree was
             * read from the catalog, it might have been stored by a future
             * release which may have added fields that we don't know about.
             */</comment>
            <while>while <condition>(<expr><name>token</name> <operator>&amp;&amp;</operator>
                   <name><name>token</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">':'</literal></expr>)</condition>
            <block>{<block_content>
                <comment type="block">/*
                 * Check for special :prereq tag that a future release may have
                 * inserted to tell us that the node's semantics are not
                 * downward compatible.  The node reader function should have
                 * consumed any such tags for features that it supports.  If a
                 * :prereq is left to be seen here, that means its feature isn't
                 * implemented in this release and we must reject the statement.
                 * The tag should be followed by a concise feature name or
                 * release id that can be shown to the user in an error message.
                 */</comment>
                <if_stmt><if>if <condition>(<expr><name>tok_len</name> <operator>==</operator> <literal type="number">7</literal> <operator>&amp;&amp;</operator>
                    <call><name>memcmp</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><literal type="string">":prereq"</literal></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
                <block>{<block_content>
        			<expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tok_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>debackslash</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><name>tok_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
                                    <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"This operation requires a feature "</literal>
                                           <literal type="string">"called \"%.*s\" which is not "</literal>
                                           <literal type="string">"supported in this version of %s."</literal></expr></argument>, 
                                           <argument><expr><name>tok_len</name></expr></argument>, <argument><expr><name>token</name></expr></argument>, <argument><expr><name>PACKAGE_NAME</name></expr></argument>)</argument_list></call>
                            <operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if></if_stmt>

                <comment type="block">/*
                 * Other extra fields can safely be ignored.  They are assumed
                 * downward compatible unless a :prereq tag tells us otherwise.
                 */</comment>
                <expr_stmt><expr><call><name>nodeReadSkip</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"nodeRead: unknown option '%.*s' ignored"</literal></expr></argument>,
                                        <argument><expr><name>tok_len</name></expr></argument>, <argument><expr><name>token</name></expr></argument>)</argument_list></call><operator>,</operator>
                                 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Skipped '%.*s' at offset %d in %s"</literal></expr></argument>,
                                           <argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>pg_strtok_ptr</name> <operator>-</operator> <name>token</name><operator>)</operator></expr></argument>, <argument><expr><name>token</name></expr></argument>,
                                           <argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>token</name> <operator>-</operator> <name>pg_strtok_begin</name><operator>)</operator></expr></argument>,
                                           <argument><expr><name>pg_strtok_begin</name></expr></argument>)</argument_list></call>
                        <operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tok_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></while>

			<if_stmt><if>if <condition>(<expr><name>token</name> <operator>==</operator> <name>NULL</name></expr> )</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"did not find '}' at end of input node"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>token</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'}'</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"did not find '}' at end of input node, instead found %s"</literal></expr></argument>,<argument><expr><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>LEFT_PAREN</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>l</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

				<comment type="block">/*----------
				 * Could be an integer list:	(i int int ...)
				 * or an OID list:				(o int int ...)
				 * or a list of nodes/values:	(node node ...)
				 *----------
				 */</comment>
				<expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tok_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>token</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unterminated List structure"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name>tok_len</name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>token</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'i'</literal></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* List of integers */</comment>
					<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
					<block>{<block_content>
						<decl_stmt><decl><type><name>int</name></type>			<name>val</name></decl>;</decl_stmt>
						<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>endptr</name></decl>;</decl_stmt>

						<expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tok_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><name>token</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unterminated List structure"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
						<if_stmt><if>if <condition>(<expr><name><name>token</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">')'</literal></expr>)</condition><block type="pseudo"><block_content>
							<break>break;</break></block_content></block></if></if_stmt>
						<expr_stmt><expr><name>val</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <call><name>strtol</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>endptr</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><name>endptr</name> <operator>!=</operator> <name>token</name> <operator>+</operator> <name>tok_len</name></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized integer: \"%.*s\""</literal></expr></argument>,
								 <argument><expr><name>tok_len</name></expr></argument>, <argument><expr><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
						<expr_stmt><expr><name>l</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></for>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><name>tok_len</name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>token</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'o'</literal></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* List of OIDs */</comment>
					<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
					<block>{<block_content>
						<decl_stmt><decl><type><name>Oid</name></type>			<name>val</name></decl>;</decl_stmt>
						<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>endptr</name></decl>;</decl_stmt>

						<expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tok_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><name>token</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unterminated List structure"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
						<if_stmt><if>if <condition>(<expr><name><name>token</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">')'</literal></expr>)</condition><block type="pseudo"><block_content>
							<break>break;</break></block_content></block></if></if_stmt>
						<expr_stmt><expr><name>val</name> <operator>=</operator> <operator>(</operator><name>Oid</name><operator>)</operator> <call><name>strtoul</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>endptr</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><name>endptr</name> <operator>!=</operator> <name>token</name> <operator>+</operator> <name>tok_len</name></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized OID: \"%.*s\""</literal></expr></argument>,
								 <argument><expr><name>tok_len</name></expr></argument>, <argument><expr><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
						<expr_stmt><expr><name>l</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></for>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<comment type="block">/* List of other node types */</comment>
					<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
					<block>{<block_content>
						<comment type="block">/* We have already scanned next token... */</comment>
						<if_stmt><if>if <condition>(<expr><name><name>token</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">')'</literal></expr>)</condition><block type="pseudo"><block_content>
							<break>break;</break></block_content></block></if></if_stmt>
						<expr_stmt><expr><name>l</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><call><name>nodeRead</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><name>tok_len</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tok_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><name>token</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unterminated List structure"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					</block_content>}</block></for>
				</block_content>}</block></else></if_stmt>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>l</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block>
		<case>case <expr><name>RIGHT_PAREN</name></expr>:</case>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected right parenthesis"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>		<comment type="block">/* keep compiler happy */</comment>
			<break>break;</break>
		<case>case <expr><name>OTHER_TOKEN</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name>tok_len</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* must be "&lt;&gt;" --- represents a null pointer */</comment>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized token: \"%.*s\""</literal></expr></argument>, <argument><expr><name>tok_len</name></expr></argument>, <argument><expr><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>	<comment type="block">/* keep compiler happy */</comment>
			</block_content>}</block></else></if_stmt>
			<break>break;</break>
		<case>case <expr><name>T_Integer</name></expr>:</case>

			<comment type="block">/*
			 * we know that the token terminates on a char atoi will stop at
			 */</comment>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeInteger</name><argument_list>(<argument><expr><call><name>atoi</name><argument_list>(<argument><expr><name>token</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_Float</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>fval</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>tok_len</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>fval</name></expr></argument>, <argument><expr><name>token</name></expr></argument>, <argument><expr><name>tok_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>fval</name><index>[<expr><name>tok_len</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeFloat</name><argument_list>(<argument><expr><name>fval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_String</name></expr>:</case>
			<comment type="block">/* need to remove leading and trailing quotes, and backslashes */</comment>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeString</name><argument_list>(<argument><expr><call><name>debackslash</name><argument_list>(<argument><expr><name>token</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>tok_len</name> <operator>-</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_BitString</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>val</name> <init>= <expr><call><name>palloc</name><argument_list>(<argument><expr><name>tok_len</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<comment type="block">/* skip leading 'b' */</comment>
				<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name>token</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>tok_len</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>val</name><index>[<expr><name>tok_len</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeBitString</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized node type: %d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>		<comment type="block">/* keep compiler happy */</comment>
			<break>break;</break>
	</block_content>}</block></switch>

	<return>return <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>result</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * nodeReadSkip
 *    Skips next item (a token, list or subtree).
 */</comment>
<function><type><name>void</name></type>
<name>nodeReadSkip</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>     <name>tok_len</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>token</name> <init>= <expr><call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tok_len</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>token</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"did not find expected token"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>                 <comment type="block">/* not reached */</comment>
    </block_content>}</block></if></if_stmt>

    <switch>switch <condition>(<expr><operator>*</operator><name>token</name></expr>)</condition>
    <block>{<block_content>
        <case>case <expr><literal type="char">'{'</literal></expr>:</case>
            <expr_stmt><expr><call><name>nodeReadSkipThru</name><argument_list>(<argument><expr><literal type="char">'}'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><literal type="char">'('</literal></expr>:</case>
            <expr_stmt><expr><call><name>nodeReadSkipThru</name><argument_list>(<argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        <case>case <expr><literal type="char">'}'</literal></expr>:</case>
        <case>case <expr><literal type="char">')'</literal></expr>:</case>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"did not find expected token, instead found %s"</literal></expr></argument>, <argument><expr><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>             <comment type="block">/* not reached */</comment>

        <default>default:</default>
            <break>break;</break>
    </block_content>}</block></switch>
</block_content>}</block></function>                               <comment type="block">/* nodeReadSkip */</comment>


<comment type="block">/*
 * nodeReadSkipThru
 *    Skips one or more tokens, lists or subtrees up to and including
 *    the specified matching delimiter.
 */</comment>
<function><type><name>void</name></type>
<name>nodeReadSkipThru</name><parameter_list>(<parameter><decl><type><name>char</name></type> <name>closingDelimiter</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type>     <name>tok_len</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name>   <modifier>*</modifier></type><name>token</name> <init>= <expr><call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tok_len</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><name>token</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"did not find '%c' as expected"</literal></expr></argument>, <argument><expr><name>closingDelimiter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>             <comment type="block">/* not reached */</comment>
        </block_content>}</block></if></if_stmt>

        <switch>switch <condition>(<expr><operator>*</operator><name>token</name></expr>)</condition>
        <block>{<block_content>
            <case>case <expr><literal type="char">'{'</literal></expr>:</case>
                <expr_stmt><expr><call><name>nodeReadSkipThru</name><argument_list>(<argument><expr><literal type="char">'}'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>

            <case>case <expr><literal type="char">'('</literal></expr>:</case>
                <expr_stmt><expr><call><name>nodeReadSkipThru</name><argument_list>(<argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>

            <case>case <expr><literal type="char">'}'</literal></expr>:</case>
            <case>case <expr><literal type="char">')'</literal></expr>:</case>
                <if_stmt><if>if <condition>(<expr><operator>*</operator><name>token</name> <operator>!=</operator> <name>closingDelimiter</name></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"did not find '%c' as expected, instead found %s"</literal></expr></argument>,
                         <argument><expr><name>closingDelimiter</name></expr></argument>, <argument><expr><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <return>return;</return>         <comment type="block">/* not reached */</comment>

            <default>default:</default>
                <break>break;</break>
        </block_content>}</block></switch>
    </block_content>}</block></for>
</block_content>}</block></function>                               <comment type="block">/* nodeReadSkipThru */</comment>


<comment type="block">/*
 * pg_strtok_peek_fldname
 *    Peeks at the token that will be returned by the next call to
 *    pg_strtok and returns true if it is, case-sensitively,
 *          :fldname
 */</comment>
<function><type><name>bool</name></type>
<name>pg_strtok_peek_fldname</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fldname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name>   <modifier>*</modifier></type><name>bp</name> <init>= <expr><name>pg_strtok_ptr</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name>   <modifier>*</modifier></type><name>cp</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>bp</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* trim leading whitespace */</comment>
    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>bp</name> <operator>&lt;=</operator> <literal type="char">' '</literal></expr>)</condition>
    <block>{<block_content>
        <while>while <condition>(<expr><operator>*</operator><name>bp</name> <operator>==</operator> <literal type="char">' '</literal> <operator>||</operator> <operator>*</operator><name>bp</name> <operator>==</operator> <literal type="char">'\n'</literal> <operator>||</operator> <operator>*</operator><name>bp</name> <operator>==</operator> <literal type="char">'\t'</literal></expr>)</condition><block type="pseudo"><block_content>
		    <expr_stmt><expr><name>bp</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
        <expr_stmt><expr><name>pg_strtok_ptr</name> <operator>=</operator> <name>bp</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>bp</name> <operator>!=</operator> <literal type="char">':'</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>cp</name> <operator>=</operator> <name>bp</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <while>while <condition>(<expr><operator>*</operator><name>fldname</name> <operator>!=</operator> <literal type="char">'\0'</literal> <operator>&amp;&amp;</operator>
           <operator>*</operator><name>fldname</name> <operator>==</operator> <operator>*</operator><name>cp</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>cp</name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name>fldname</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></while>

    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>fldname</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>cp</name> <operator>==</operator> <literal type="char">' '</literal> <operator>||</operator>
        <operator>*</operator><name>cp</name> <operator>==</operator> <literal type="char">'\n'</literal> <operator>||</operator>
        <operator>*</operator><name>cp</name> <operator>==</operator> <literal type="char">'\t'</literal> <operator>||</operator>
        <operator>*</operator><name>cp</name> <operator>==</operator> <literal type="char">'('</literal> <operator>||</operator>
        <operator>*</operator><name>cp</name> <operator>==</operator> <literal type="char">')'</literal> <operator>||</operator>
        <operator>*</operator><name>cp</name> <operator>==</operator> <literal type="char">'{'</literal> <operator>||</operator>
        <operator>*</operator><name>cp</name> <operator>==</operator> <literal type="char">'}'</literal> <operator>||</operator>
        <operator>*</operator><name>cp</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

    <return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>                                   <comment type="block">/* pg_strtok_peek_fldname */</comment>
</unit>
