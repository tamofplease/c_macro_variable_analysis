<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/backend/nodes/readfuncs.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * readfuncs.c
 *	  Reader functions for Postgres tree nodes.
 *
 * Portions Copyright (c) 2005-2010, Greenplum inc
 * Portions Copyright (c) 2012-Present VMware, Inc. or its affiliates.
 * Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/nodes/readfuncs.c
 *
 * NOTES
 *	  Path nodes do not have any readfuncs support, because we never
 *	  have occasion to read them in.  (There was once code here that
 *	  claimed to read them, but it was broken as well as unused.)  We
 *	  never read executor state trees, either.
 *
 *    But due to the use of this routine in older version of CDB/MPP/GPDB,
 *    there are routines that do read those types of nodes (unlike PostgreSQL)
 *    Those routines never actually get called.
 *
 *    We could go back and remove them, but they don't hurt anything.
 *
 *    The purpose of these routines is to read serialized trees that were stored
 *    in the catalog, and reconstruct the trees.
 *
 *	  Parse location fields are written out by outfuncs.c, but only for
 *	  debugging use.  When reading a location field, we normally discard
 *	  the stored value and set the location field to -1 (ie, "unknown").
 *	  This is because nodes coming from a stored rule should not be thought
 *	  to have a known location in the current query's text.
 *	  However, if restore_location_fields is true, we do restore location
 *	  fields from the string.  This is currently intended only for use by the
 *	  WRITE_READ_PARSE_PLAN_TREES test code, which doesn't want to cause
 *	  any change in the node contents.
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;math.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"fmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/extensible.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/parsenodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/plannodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/readfuncs.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbgang.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/altertablenodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>

<comment type="block">/*
 * readfuncs.c is compiled normally into readfuncs.o, but it's also
 * #included from readfast.c. When #included, readfuncs.c defines
 * COMPILING_BINARY_FUNCS, and provides replacements READ_* macros. See
 * comments at top of readfast.c.
 */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>COMPILING_BINARY_FUNCS</name></cpp:ifndef>

<comment type="block">/*
 * Macros to simplify reading of different kinds of fields.  Use these
 * wherever possible to reduce the chance for silly typos.  Note that these
 * hard-wire conventions about the names of the local variables in a Read
 * routine.
 */</comment>

<comment type="block">/* Macros for declaring appropriate local variables */</comment>

<comment type="block">/* A few guys need only local_node */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>READ_LOCALS_NO_FIELDS</name><parameter_list>(<parameter><type><name>nodeTypeName</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>nodeTypeName *local_node = makeNode(nodeTypeName)</cpp:value></cpp:define>

<comment type="block">/* And a few guys need only the pg_strtok support fields */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>READ_TEMP_LOCALS</name><parameter_list>()</parameter_list></cpp:macro>	\
	<cpp:value>const char *token;		\
	int			length</cpp:value></cpp:define>

<comment type="block">/* ... but most need both */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>READ_LOCALS</name><parameter_list>(<parameter><type><name>nodeTypeName</name></type></parameter>)</parameter_list></cpp:macro>			\
	<cpp:value>READ_LOCALS_NO_FIELDS(nodeTypeName);	\
	READ_TEMP_LOCALS()</cpp:value></cpp:define>

<comment type="block">/* Read a simple scalar field (written as ":fldname value") */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>READ_SCALAR_FIELD</name><parameter_list>(<parameter><type><name>fldname</name></type></parameter>, <parameter><type><name>conversion</name></type></parameter>)</parameter_list></cpp:macro> \
    <cpp:value>do { \
	    token = pg_strtok(&amp;length);		<comment type="block">/* skip :fldname */</comment> \
	    token = pg_strtok(&amp;length);		<comment type="block">/* get field value */</comment> \
	    local_node-&gt;fldname = (conversion); \
    } while (0)</cpp:value></cpp:define>

<comment type="block">/* Read an integer field (anything written as ":fldname %d") */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>READ_INT_FIELD</name><parameter_list>(<parameter><type><name>fldname</name></type></parameter>)</parameter_list></cpp:macro>     <cpp:value>READ_SCALAR_FIELD(fldname, atoi(token))</cpp:value></cpp:define>

<comment type="block">/* Read an unsigned integer field (anything written as ":fldname %u") */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>READ_UINT_FIELD</name><parameter_list>(<parameter><type><name>fldname</name></type></parameter>)</parameter_list></cpp:macro>    <cpp:value>READ_SCALAR_FIELD(fldname, atoui(token))</cpp:value></cpp:define>

<comment type="block">/* Read an uint64 field (anything written as ":fldname %ll") */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>READ_UINT64_FIELD</name><parameter_list>(<parameter><type><name>fldname</name></type></parameter>)</parameter_list></cpp:macro>  <cpp:value>READ_SCALAR_FIELD(fldname, atoll(token))</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>READ_UINT64_FIELD</name><parameter_list>(<parameter><type><name>fldname</name></type></parameter>)</parameter_list></cpp:macro>  <cpp:value>READ_SCALAR_FIELD(fldname, _atoi64(token))</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Read a long integer field (anything written as ":fldname %ld") */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>READ_LONG_FIELD</name><parameter_list>(<parameter><type><name>fldname</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>token = pg_strtok(&amp;length);		<comment type="block">/* skip :fldname */</comment> \
	token = pg_strtok(&amp;length);		<comment type="block">/* get field value */</comment> \
	local_node-&gt;fldname = atol(token)</cpp:value></cpp:define>

<comment type="block">/* Read an OID field (don't hard-wire assumption that OID is same as uint) */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>READ_OID_FIELD</name><parameter_list>(<parameter><type><name>fldname</name></type></parameter>)</parameter_list></cpp:macro>     <cpp:value>READ_SCALAR_FIELD(fldname, atooid(token))</cpp:value></cpp:define>

<comment type="block">/*
 * extended_char
 *    In GPDB some structures have char fields with non-printing characters
 *    in them.  '\0' is problematic in particular because it ends debugging
 *    displays of nodes.  It is a bad practice, but hard to stem.  This
 *    function used in readfuncs.c READ_CHAR_FIELD is the inverse of the
 *    character output format in outfuncs.c WRITE_CHAR_FIELD.  A length
 *    one token is translated as before.  A longer token is taken as the
 *    decimal code of the desired character.  (The only zero length token,
 *    &lt;&gt;, should not appear in a character field.)
 */</comment>
<function><type><specifier>inline</specifier> <specifier>static</specifier> <name>char</name></type> <name>extended_char</name><parameter_list>(<parameter><decl><type><name>char</name><modifier>*</modifier></type> <name>token</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>length</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type> <name>c</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>( <expr><name>length</name> <operator>==</operator> <literal type="number">1</literal></expr> )</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>*</operator><name>token</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>debackslash</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>( <expr><call><name>strlen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr> )</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>c</name> <operator>=</operator> <name><name>s</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>c</name> <operator>=</operator> <operator>(</operator><name>char</name><operator>)</operator><call><name>strtoul</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>c</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Read a char field (ie, one ascii character) */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>READ_CHAR_FIELD</name><parameter_list>(<parameter><type><name>fldname</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>token = pg_strtok(&amp;length);		<comment type="block">/* skip :fldname */</comment> \
	token = pg_strtok(&amp;length);		<comment type="block">/* get field value */</comment> \
	<comment type="block">/* avoid overhead of calling debackslash() for one char */</comment> \
	local_node-&gt;fldname = (length == 0) ? '\0' : (token[0] == '\\' ? token[1] : token[0])</cpp:value></cpp:define>

<comment type="block">/* Read an enumerated-type field that was written as an integer code */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>READ_ENUM_FIELD</name><parameter_list>(<parameter><type><name>fldname</name></type></parameter>, <parameter><type><name>enumtype</name></type></parameter>)</parameter_list></cpp:macro>  <cpp:value>READ_SCALAR_FIELD(fldname, (enumtype)atoi(token))</cpp:value></cpp:define>

<comment type="block">/* Read a float field */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>READ_FLOAT_FIELD</name><parameter_list>(<parameter><type><name>fldname</name></type></parameter>)</parameter_list></cpp:macro>   <cpp:value>READ_SCALAR_FIELD(fldname, atof(token))</cpp:value></cpp:define>

<comment type="block">/* Read a boolean field */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>READ_BOOL_FIELD</name><parameter_list>(<parameter><type><name>fldname</name></type></parameter>)</parameter_list></cpp:macro>    <cpp:value>READ_SCALAR_FIELD(fldname, strtobool(token))</cpp:value></cpp:define>

<comment type="block">/* Read a character-string field */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>READ_STRING_FIELD</name><parameter_list>(<parameter><type><name>fldname</name></type></parameter>)</parameter_list></cpp:macro>  <cpp:value>READ_SCALAR_FIELD(fldname, nullable_string(token, length))</cpp:value></cpp:define>

<comment type="block">/* Read a parse location field (and possibly throw away the value) */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WRITE_READ_PARSE_PLAN_TREES</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>READ_LOCATION_FIELD</name><parameter_list>(<parameter><type><name>fldname</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>token = pg_strtok(&amp;length);		<comment type="block">/* skip :fldname */</comment> \
	token = pg_strtok(&amp;length);		<comment type="block">/* get field value */</comment> \
	local_node-&gt;fldname = restore_location_fields ? atoi(token) : -1</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>READ_LOCATION_FIELD</name><parameter_list>(<parameter><type><name>fldname</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>token = pg_strtok(&amp;length);		<comment type="block">/* skip :fldname */</comment> \
	token = pg_strtok(&amp;length);		<comment type="block">/* get field value */</comment> \
	(void) token;				<comment type="block">/* in case not used elsewhere */</comment> \
	local_node-&gt;fldname = -1</cpp:value></cpp:define>	<comment type="block">/* set field to "unknown" */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Read a Node field */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>READ_NODE_FIELD</name><parameter_list>(<parameter><type><name>fldname</name></type></parameter>)</parameter_list></cpp:macro> \
    <cpp:value>do { \
	    token = pg_strtok(&amp;length);		<comment type="block">/* skip :fldname */</comment> \
		(void) token;				<comment type="block">/* in case not used elsewhere */</comment> \
	    local_node-&gt;fldname = nodeRead(NULL, 0); \
    } while (0)</cpp:value></cpp:define>

<comment type="block">/* Read a bytea field */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>READ_BYTEA_FIELD</name><parameter_list>(<parameter><type><name>fldname</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>local_node-&gt;fldname = (bytea *) DatumGetPointer(readDatum(false))</cpp:value></cpp:define>

<comment type="block">/* Set field to a given value, ignoring the value read from the input */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>READ_DUMMY_FIELD</name><parameter_list>(<parameter><type><name>fldname</name></type></parameter>,<parameter><type><name>fldvalue</name></type></parameter>)</parameter_list></cpp:macro>  <cpp:value>READ_SCALAR_FIELD(fldname, fldvalue)</cpp:value></cpp:define>

<comment type="block">/* Read a bitmapset field */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>READ_BITMAPSET_FIELD</name><parameter_list>(<parameter><type><name>fldname</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>token = pg_strtok(&amp;length);		<comment type="block">/* skip :fldname */</comment> \
	(void) token;				<comment type="block">/* in case not used elsewhere */</comment> \
	local_node-&gt;fldname = _readBitmapset()</cpp:value></cpp:define>

<comment type="block">/* Read an attribute number array */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>READ_ATTRNUMBER_ARRAY</name><parameter_list>(<parameter><type><name>fldname</name></type></parameter>, <parameter><type><name>len</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>token = pg_strtok(&amp;length);		<comment type="block">/* skip :fldname */</comment> \
	local_node-&gt;fldname = readAttrNumberCols(len);</cpp:value></cpp:define>

<comment type="block">/* Read an oid array */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>READ_OID_ARRAY</name><parameter_list>(<parameter><type><name>fldname</name></type></parameter>, <parameter><type><name>len</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>token = pg_strtok(&amp;length);		<comment type="block">/* skip :fldname */</comment> \
	local_node-&gt;fldname = readOidCols(len);</cpp:value></cpp:define>

<comment type="block">/* Read an int array */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>READ_INT_ARRAY</name><parameter_list>(<parameter><type><name>fldname</name></type></parameter>, <parameter><type><name>len</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>token = pg_strtok(&amp;length);		<comment type="block">/* skip :fldname */</comment> \
	local_node-&gt;fldname = readIntCols(len);</cpp:value></cpp:define>

<comment type="block">/* Read a bool array */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>READ_BOOL_ARRAY</name><parameter_list>(<parameter><type><name>fldname</name></type></parameter>, <parameter><type><name>len</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>token = pg_strtok(&amp;length);		<comment type="block">/* skip :fldname */</comment> \
	local_node-&gt;fldname = readBoolCols(len);</cpp:value></cpp:define>

<comment type="block">/* Routine exit */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>READ_DONE</name><parameter_list>()</parameter_list></cpp:macro> \
	<cpp:value>return local_node</cpp:value></cpp:define>

<comment type="block">/*
 * NOTE: use atoi() to read values written with %d, or atoui() to read
 * values written with %u in outfuncs.c.  An exception is OID values,
 * for which use atooid().  (As of 7.1, outfuncs.c writes OIDs as %u,
 * but this will probably change in the future.)
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>atoui</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro>  <cpp:value>((unsigned int) strtoul((x), NULL, 10))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>strtobool</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro>  <cpp:value>((*(x) == 't') ? true : false)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>nullable_string</name><parameter_list>(<parameter><type><name>token</name></type></parameter>,<parameter><type><name>length</name></type></parameter>)</parameter_list></cpp:macro>  \
	<cpp:value>((length) == 0 ? NULL : debackslash(token, length))</cpp:value></cpp:define>

<comment type="block">/* The following READ_..._VALUE macros mimic the corresponding READ_..._FIELD
 * macros above, but produce the value read (with appropriate type) instead of
 * assigning it to a field of local_node.  They are expressions, not statements.
 *
 * Note that the fldname parameter is not used, but retained is for symmetry.
 * These macros exist only to simplify supporting old node formats.
 */</comment>

<comment type="block">/* Return the value of a simple scalar field (written as ":fldname value") */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>READ_SCALAR_VALUE</name><parameter_list>(<parameter><type><name>fldname</name></type></parameter>, <parameter><type><name>conversion</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>( \
		token = pg_strtok(&amp;length),		<comment type="block">/* skip :fldname */</comment> \
		token = pg_strtok(&amp;length),		<comment type="block">/* get field value */</comment> \
		(conversion) \
	)</cpp:value></cpp:define>

<comment type="block">/* Return the value of  an enumerated-type field that was written as an integer code */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>READ_ENUM_VALUE</name><parameter_list>(<parameter><type><name>fldname</name></type></parameter>, <parameter><type><name>enumtype</name></type></parameter>)</parameter_list></cpp:macro>  <cpp:value>READ_SCALAR_VALUE(fldname, (enumtype)atoi(token))</cpp:value></cpp:define>

<comment type="block">/* Return the value of  a character-string field */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>READ_STRING_VALUE</name><parameter_list>(<parameter><type><name>fldname</name></type></parameter>)</parameter_list></cpp:macro>  <cpp:value>READ_SCALAR_VALUE(fldname, nullable_string(token, length))</cpp:value></cpp:define>

<comment type="block">/* Return the value of  a Node field */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>READ_NODE_VALUE</name><parameter_list>(<parameter><type><name>fldname</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>( \
		token = pg_strtok(&amp;length),		<comment type="block">/* skip :fldname */</comment> \
		nodeRead(NULL, 0) \
	)</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* COMPILING_BINARY_FUNCS */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>COMPILING_BINARY_FUNCS</name></cpp:ifndef>
<comment type="block">/*
 * _readBitmapset
 */</comment>
<function><type><specifier>static</specifier> <name>Bitmapset</name> <modifier>*</modifier></type>
<name>_readBitmapset</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>READ_TEMP_LOCALS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>token</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"incomplete Bitmapset structure"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>length</name> <operator>!=</operator> <literal type="number">1</literal> <operator>||</operator> <name><name>token</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'('</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized token: \"%.*s\""</literal></expr></argument>, <argument><expr><name>length</name></expr></argument>, <argument><expr><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>token</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"incomplete Bitmapset structure"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>length</name> <operator>!=</operator> <literal type="number">1</literal> <operator>||</operator> <name><name>token</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'b'</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized token: \"%.*s\""</literal></expr></argument>, <argument><expr><name>length</name></expr></argument>, <argument><expr><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>val</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>endptr</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>token</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unterminated Bitmapset structure"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>length</name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>token</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">')'</literal></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>val</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <call><name>strtol</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>endptr</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>endptr</name> <operator>!=</operator> <name>token</name> <operator>+</operator> <name>length</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized integer: \"%.*s\""</literal></expr></argument>, <argument><expr><name>length</name></expr></argument>, <argument><expr><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * for use by extensions which define extensible nodes
 */</comment>
<function><type><name>Bitmapset</name> <modifier>*</modifier></type>
<name>readBitmapset</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>_readBitmapset</name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * _readQuery
 */</comment>
<function><type><specifier>static</specifier> <name>Query</name> <modifier>*</modifier></type>
<name>_readQuery</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name>commandType</name></expr></argument>, <argument><expr><name>CmdType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name>querySource</name></expr></argument>, <argument><expr><name>QuerySource</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>local_node</name><operator>-&gt;</operator><name>queryId</name></name> <operator>=</operator> <call><name>UINT64CONST</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* not saved in output format */</comment>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>canSetTag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>utilityStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>resultRelation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>hasAggs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>hasWindowFuncs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>hasTargetSRFs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>hasSubLinks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>hasDynamicFunctions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>hasFuncsWithExecRestrictions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>hasDistinctOn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>hasRecursive</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>hasModifyingCTE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>hasForUpdate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>hasRowSecurity</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>canOptSelectLockingClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>cteList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>rtable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>jointree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>targetList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name>override</name></expr></argument>, <argument><expr><name>OverridingKind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>onConflict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>returningList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>groupClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>groupingSets</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>havingQual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>windowClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>distinctClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>sortClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>scatterClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>isTableValueSelect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>limitOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>limitCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>rowMarks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>setOperations</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>constraintDeps</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>withCheckOptions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>local_node</name><operator>-&gt;</operator><name>intoPolicy</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>parentStmtType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_LOCATION_FIELD</name><argument_list>(<argument><expr><name>stmt_location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_LOCATION_FIELD</name><argument_list>(<argument><expr><name>stmt_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* COMPILING_BINARY_FUNCS */</comment>

<comment type="block">/*
 * _readNotifyStmt
 */</comment>
<function><type><specifier>static</specifier> <name>NotifyStmt</name> <modifier>*</modifier></type>
<name>_readNotifyStmt</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>NotifyStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_STRING_FIELD</name><argument_list>(<argument><expr><name>conditionname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_STRING_FIELD</name><argument_list>(<argument><expr><name>payload</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readDeclareCursorStmt
 */</comment>
<function><type><specifier>static</specifier> <name>DeclareCursorStmt</name> <modifier>*</modifier></type>
<name>_readDeclareCursorStmt</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>DeclareCursorStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_STRING_FIELD</name><argument_list>(<argument><expr><name>portalname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readSingleRowErrorDesc
 */</comment>
<function><type><specifier>static</specifier> <name>SingleRowErrorDesc</name> <modifier>*</modifier></type>
<name>_readSingleRowErrorDesc</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>SingleRowErrorDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>rejectlimit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>is_limit_in_rows</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_CHAR_FIELD</name><argument_list>(<argument><expr><name>log_error_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readWithCheckOption
 */</comment>
<function><type><specifier>static</specifier> <name>WithCheckOption</name> <modifier>*</modifier></type>
<name>_readWithCheckOption</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>WithCheckOption</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name>kind</name></expr></argument>, <argument><expr><name>WCOKind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_STRING_FIELD</name><argument_list>(<argument><expr><name>relname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_STRING_FIELD</name><argument_list>(<argument><expr><name>polname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>qual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>cascaded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readSortGroupClause
 */</comment>
<function><type><specifier>static</specifier> <name>SortGroupClause</name> <modifier>*</modifier></type>
<name>_readSortGroupClause</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>SortGroupClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_UINT_FIELD</name><argument_list>(<argument><expr><name>tleSortGroupRef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>eqop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>sortop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>nulls_first</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>hashable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readGroupingSet
 */</comment>
<function><type><specifier>static</specifier> <name>GroupingSet</name> <modifier>*</modifier></type>
<name>_readGroupingSet</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>GroupingSet</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name>kind</name></expr></argument>, <argument><expr><name>GroupingSetKind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>content</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readWindowClause
 */</comment>
<function><type><specifier>static</specifier> <name>WindowClause</name> <modifier>*</modifier></type>
<name>_readWindowClause</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>WindowClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_STRING_FIELD</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_STRING_FIELD</name><argument_list>(<argument><expr><name>refname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>partitionClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>orderClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>frameOptions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>startOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>endOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>startInRangeFunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>endInRangeFunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>inRangeColl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>inRangeAsc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>inRangeNullsFirst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_UINT_FIELD</name><argument_list>(<argument><expr><name>winref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>copiedOrder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readRowMarkClause
 */</comment>
<function><type><specifier>static</specifier> <name>RowMarkClause</name> <modifier>*</modifier></type>
<name>_readRowMarkClause</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>RowMarkClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_UINT_FIELD</name><argument_list>(<argument><expr><name>rti</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name>strength</name></expr></argument>, <argument><expr><name>LockClauseStrength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name>waitPolicy</name></expr></argument>, <argument><expr><name>LockWaitPolicy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>pushedDown</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readCommonTableExpr
 */</comment>
<function><type><specifier>static</specifier> <name>CommonTableExpr</name> <modifier>*</modifier></type>
<name>_readCommonTableExpr</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>CommonTableExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_STRING_FIELD</name><argument_list>(<argument><expr><name>ctename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>aliascolnames</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name>ctematerialized</name></expr></argument>, <argument><expr><name>CTEMaterialize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>ctequery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>cterecursive</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>cterefcount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>ctecolnames</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>ctecoltypes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>ctecoltypmods</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>ctecolcollations</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>WithClause</name> <modifier>*</modifier></type>
<name>_readWithClause</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>WithClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>ctes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>recursive</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readSetOperationStmt
 */</comment>
<function><type><specifier>static</specifier> <name>SetOperationStmt</name> <modifier>*</modifier></type>
<name>_readSetOperationStmt</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>SetOperationStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>SetOperation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>all</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>larg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>rarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>colTypes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>colTypmods</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>colCollations</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>groupClauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 *	Stuff from primnodes.h.
 */</comment>

<function><type><specifier>static</specifier> <name>Alias</name> <modifier>*</modifier></type>
<name>_readAlias</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>Alias</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_STRING_FIELD</name><argument_list>(<argument><expr><name>aliasname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>colnames</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>RangeVar</name> <modifier>*</modifier></type>
<name>_readRangeVar</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>RangeVar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>local_node</name><operator>-&gt;</operator><name>catalogname</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt> <comment type="block">/* not currently saved in output format */</comment>

	<expr_stmt><expr><call><name>READ_STRING_FIELD</name><argument_list>(<argument><expr><name>catalogname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_STRING_FIELD</name><argument_list>(<argument><expr><name>schemaname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_STRING_FIELD</name><argument_list>(<argument><expr><name>relname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>inh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_CHAR_FIELD</name><argument_list>(<argument><expr><name>relpersistence</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>alias</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readTableFunc
 */</comment>
<function><type><specifier>static</specifier> <name>TableFunc</name> <modifier>*</modifier></type>
<name>_readTableFunc</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>TableFunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>ns_uris</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>ns_names</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>docexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>rowexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>colnames</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>coltypes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>coltypmods</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>colcollations</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>colexprs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>coldefexprs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name>notnulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>ordinalitycol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>IntoClause</name> <modifier>*</modifier></type>
<name>_readIntoClause</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>IntoClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>colNames</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_STRING_FIELD</name><argument_list>(<argument><expr><name>accessMethod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name>onCommit</name></expr></argument>, <argument><expr><name>OnCommitAction</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_STRING_FIELD</name><argument_list>(<argument><expr><name>tableSpaceName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>viewQuery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>skipData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>distributedBy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>CopyIntoClause</name> <modifier>*</modifier></type>
<name>_readCopyIntoClause</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>CopyIntoClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>attlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>is_program</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_STRING_FIELD</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>RefreshClause</name> <modifier>*</modifier></type>
<name>_readRefreshClause</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>RefreshClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>concurrent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>skipData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readVar
 */</comment>
<function><type><specifier>static</specifier> <name>Var</name> <modifier>*</modifier></type>
<name>_readVar</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_UINT_FIELD</name><argument_list>(<argument><expr><name>varno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>varattno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>vartype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>vartypmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>varcollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_UINT_FIELD</name><argument_list>(<argument><expr><name>varlevelsup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_UINT_FIELD</name><argument_list>(<argument><expr><name>varnoold</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>varoattno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>COMPILING_BINARY_FUNCS</name></cpp:ifndef>
<comment type="block">/*
 * _readConst
 */</comment>
<function><type><specifier>static</specifier> <name>Const</name> <modifier>*</modifier></type>
<name>_readConst</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>consttype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>consttypmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>constcollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>constlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>constbyval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>constisnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* skip :constvalue */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>local_node</name><operator>-&gt;</operator><name>constisnull</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if> <comment type="block">/* skip "&lt;&gt;" */</comment>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>local_node</name><operator>-&gt;</operator><name>constvalue</name></name> <operator>=</operator> <call><name>readDatum</name><argument_list>(<argument><expr><name><name>local_node</name><operator>-&gt;</operator><name>constbyval</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* COMPILING_BINARY_FUNCS */</comment>

<comment type="block">/*
 * _readConstraint
 */</comment>
<function><type><specifier>static</specifier> <name>Constraint</name> <modifier>*</modifier></type>
<name>_readConstraint</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>Constraint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name>contype</name></expr></argument>, <argument><expr><name>ConstrType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_STRING_FIELD</name><argument_list>(<argument><expr><name>conname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>			<comment type="block">/* name, or NULL if unnamed */</comment>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>deferrable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>initdeferred</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>is_no_inherit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>raw_expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_STRING_FIELD</name><argument_list>(<argument><expr><name>cooked_expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_CHAR_FIELD</name><argument_list>(<argument><expr><name>generated_when</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>keys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>including</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>exclusions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_STRING_FIELD</name><argument_list>(<argument><expr><name>indexname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_STRING_FIELD</name><argument_list>(<argument><expr><name>indexspace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>reset_default_tblspc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_STRING_FIELD</name><argument_list>(<argument><expr><name>access_method</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>where_clause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>pktable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>fk_attrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>pk_attrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_CHAR_FIELD</name><argument_list>(<argument><expr><name>fk_matchtype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_CHAR_FIELD</name><argument_list>(<argument><expr><name>fk_upd_action</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_CHAR_FIELD</name><argument_list>(<argument><expr><name>fk_del_action</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>old_conpfeqop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>old_pktable_oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>skip_validation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>initially_valid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>IndexStmt</name> <modifier>*</modifier></type>
<name>_readIndexStmt</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>IndexStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_STRING_FIELD</name><argument_list>(<argument><expr><name>idxname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>relationOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_STRING_FIELD</name><argument_list>(<argument><expr><name>accessMethod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_STRING_FIELD</name><argument_list>(<argument><expr><name>tableSpace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>indexParams</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>indexIncludingParams</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>whereClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>excludeOpNames</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_STRING_FIELD</name><argument_list>(<argument><expr><name>idxcomment</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>indexOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>oldNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>unique</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>primary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>isconstraint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>deferrable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>initdeferred</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>transformed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>concurrent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>if_not_exists</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>reset_default_tblspc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>IndexElem</name> <modifier>*</modifier></type>
<name>_readIndexElem</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>IndexElem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_STRING_FIELD</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_STRING_FIELD</name><argument_list>(<argument><expr><name>indexcolname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>collation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>opclass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name>ordering</name></expr></argument>, <argument><expr><name>SortByDir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name>nulls_ordering</name></expr></argument>, <argument><expr><name>SortByNulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ReindexStmt</name> <modifier>*</modifier></type>
<name>_readReindexStmt</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>ReindexStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name>kind</name></expr></argument>,<argument><expr><name>ReindexObjectType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_STRING_FIELD</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ViewStmt</name> <modifier>*</modifier></type>
<name>_readViewStmt</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>ViewStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>view</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>aliases</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>replace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>RuleStmt</name> <modifier>*</modifier></type>
<name>_readRuleStmt</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>RuleStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_STRING_FIELD</name><argument_list>(<argument><expr><name>rulename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>whereClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name>event</name></expr></argument>,<argument><expr><name>CmdType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>instead</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>actions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>replace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>DropStmt</name> <modifier>*</modifier></type>
<name>_readDropStmt</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>DropStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>objects</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name>removeType</name></expr></argument>,<argument><expr><name>ObjectType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name>behavior</name></expr></argument>,<argument><expr><name>DropBehavior</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>missing_ok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>concurrent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Force 'missing_ok' in QEs */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>COMPILING_BINARY_FUNCS</name></cpp:ifdef>
	<expr_stmt><expr><name><name>local_node</name><operator>-&gt;</operator><name>missing_ok</name></name><operator>=</operator><name>true</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* COMPILING_BINARY_FUNCS */</comment>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>TruncateStmt</name> <modifier>*</modifier></type>
<name>_readTruncateStmt</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>TruncateStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>relations</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name>behavior</name></expr></argument>,<argument><expr><name>DropBehavior</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ReplicaIdentityStmt</name> <modifier>*</modifier></type>
<name>_readReplicaIdentityStmt</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>ReplicaIdentityStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_CHAR_FIELD</name><argument_list>(<argument><expr><name>identity_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_STRING_FIELD</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>AlterDatabaseStmt</name> <modifier>*</modifier></type>
<name>_readAlterDatabaseStmt</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>AlterDatabaseStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_STRING_FIELD</name><argument_list>(<argument><expr><name>dbname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>AlterTableStmt</name> <modifier>*</modifier></type>
<name>_readAlterTableStmt</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>AlterTableStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>cmds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name>relkind</name></expr></argument>, <argument><expr><name>ObjectType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>wqueue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>AlterTableCmd</name> <modifier>*</modifier></type>
<name>_readAlterTableCmd</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>AlterTableCmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name>subtype</name></expr></argument>, <argument><expr><name>AlterTableType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_STRING_FIELD</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>newowner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>def</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>transform</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name>behavior</name></expr></argument>, <argument><expr><name>DropBehavior</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>missing_ok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>backendId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>policy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>unwrapStringList</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>list</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>list</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Value</name>	   <modifier>*</modifier></type><name>val</name> <init>= <expr><operator>(</operator><name>Value</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call> <operator>=</operator> <call><name>strVal</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>AlteredTableInfo</name> <modifier>*</modifier></type>
<name>_readAlteredTableInfo</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>AlteredTableInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_CHAR_FIELD</name><argument_list>(<argument><expr><name>relkind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* oldDesc is omitted */</comment>

	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>AT_NUM_PASSES</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name><name>subcmds</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>constraints</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>newvals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>verify_new_notnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>rewrite</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>newAccessMethod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>dist_opfamily_changed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>new_opclass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>newTableSpace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>chgPersistence</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_CHAR_FIELD</name><argument_list>(<argument><expr><name>newrelpersistence</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>partition_constraint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>validate_default</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>changedConstraintOids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>changedConstraintDefs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* The QD sends changedConstraintDefs wrapped in Values. Unwrap them. */</comment>
	<expr_stmt><expr><call><name>unwrapStringList</name><argument_list>(<argument><expr><name><name>local_node</name><operator>-&gt;</operator><name>changedConstraintDefs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>changedIndexOids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>changedIndexDefs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>unwrapStringList</name><argument_list>(<argument><expr><name><name>local_node</name><operator>-&gt;</operator><name>changedIndexDefs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>NewConstraint</name> <modifier>*</modifier></type>
<name>_readNewConstraint</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>NewConstraint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_STRING_FIELD</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name>contype</name></expr></argument>, <argument><expr><name>ConstrType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>refrelid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>refindid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>conid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>qual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* can't serialize qualstate */</comment>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>NewColumnValue</name> <modifier>*</modifier></type>
<name>_readNewColumnValue</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>NewColumnValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* can't serialize exprstate */</comment>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>is_generated</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>CreateRoleStmt</name> <modifier>*</modifier></type>
<name>_readCreateRoleStmt</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>CreateRoleStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name>stmt_type</name></expr></argument>, <argument><expr><name>RoleStmtType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_STRING_FIELD</name><argument_list>(<argument><expr><name>role</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>DenyLoginInterval</name> <modifier>*</modifier></type>
<name>_readDenyLoginInterval</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>DenyLoginInterval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>DenyLoginPoint</name> <modifier>*</modifier></type>
<name>_readDenyLoginPoint</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>DenyLoginPoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>day</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>DropRoleStmt</name> <modifier>*</modifier></type>
<name>_readDropRoleStmt</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>DropRoleStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>roles</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>missing_ok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>AlterRoleStmt</name> <modifier>*</modifier></type>
<name>_readAlterRoleStmt</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>AlterRoleStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>role</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>action</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>AlterRoleSetStmt</name> <modifier>*</modifier></type>
<name>_readAlterRoleSetStmt</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>AlterRoleSetStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>role</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>setstmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>AlterSystemStmt</name> <modifier>*</modifier></type>
<name>_readAlterSystemStmt</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>AlterSystemStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>setstmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>AlterObjectSchemaStmt</name> <modifier>*</modifier></type>
<name>_readAlterObjectSchemaStmt</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>AlterObjectSchemaStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>object</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_STRING_FIELD</name><argument_list>(<argument><expr><name>newschema</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>missing_ok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name>objectType</name></expr></argument>,<argument><expr><name>ObjectType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>AlterOwnerStmt</name> <modifier>*</modifier></type>
<name>_readAlterOwnerStmt</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>AlterOwnerStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name>objectType</name></expr></argument>,<argument><expr><name>ObjectType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>object</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>newowner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>RenameStmt</name> <modifier>*</modifier></type>
<name>_readRenameStmt</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>RenameStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name>renameType</name></expr></argument>, <argument><expr><name>ObjectType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name>relationType</name></expr></argument>, <argument><expr><name>ObjectType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>objid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>object</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_STRING_FIELD</name><argument_list>(<argument><expr><name>subname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_STRING_FIELD</name><argument_list>(<argument><expr><name>newname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name>behavior</name></expr></argument>,<argument><expr><name>DropBehavior</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>missing_ok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * _readFuncCall
 *
 * This parsenode is transformed during parse_analyze.
 * It not stored in views = no upgrade implication for changes
 */</comment>
<function><type><specifier>static</specifier> <name>FuncCall</name> <modifier>*</modifier></type>
<name>_readFuncCall</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>FuncCall</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>funcname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>agg_order</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>agg_filter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>agg_within_group</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>agg_star</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>agg_distinct</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>func_variadic</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>over</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>COMPILING_BINARY_FUNCS</name></cpp:ifndef>
<function><type><specifier>static</specifier> <name>A_Const</name> <modifier>*</modifier></type>
<name>_readAConst</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>A_Const</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* skip " :val " */</comment>
	<expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>length</name> <operator>!=</operator> <literal type="number">4</literal> <operator>||</operator> <name><name>token</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">':'</literal> <operator>||</operator> <name><name>token</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'v'</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,<argument><expr><literal type="string">"Unable to understand A_CONST node \"%.30s\""</literal></expr></argument>, <argument><expr><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>debackslash</name><argument_list>(<argument><expr><name>token</name></expr></argument>,<argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>local_node</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>T_String</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>token</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'"'</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>local_node</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>val</name><operator>.</operator><name>str</name></name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>length</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name><name>local_node</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>val</name><operator>.</operator><name>str</name></name></expr></argument> , <argument><expr><name>token</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>token</name></expr></argument>)</argument_list></call><operator>-</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>local_node</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>val</name><operator>.</operator><name>str</name><index>[<expr><call><name>strlen</name><argument_list>(<argument><expr><name>token</name></expr></argument>)</argument_list></call><operator>-</operator><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>length</name> <operator>&gt;</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>token</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'b'</literal><operator>||</operator> <name><name>token</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'B'</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>token</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\''</literal> <operator>||</operator> <name><name>token</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'"'</literal><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>local_node</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>T_BitString</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>local_node</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>val</name><operator>.</operator><name>str</name></name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>length</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name><name>local_node</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>val</name><operator>.</operator><name>str</name></name></expr></argument> , <argument><expr><name>token</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>local_node</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>val</name><operator>.</operator><name>str</name><index>[<expr><name>length</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type> <name>isInt</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>isFloat</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>token</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="char">' '</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>token</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="char">'-'</literal> <operator>||</operator> <name><name>token</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="char">'+'</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<for>for <control>(<init>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>length</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
	 	   <if_stmt><if>if <condition>(<expr><name><name>token</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&lt;</operator> <literal type="char">'0'</literal> <operator>||</operator> <name><name>token</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;</operator> <literal type="char">'9'</literal></expr>)</condition>
	 	   <block>{<block_content>
	 	   	 <expr_stmt><expr><name>isInt</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	 	   	 <if_stmt><if>if <condition>(<expr><name><name>token</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <literal type="char">'.'</literal> <operator>&amp;&amp;</operator> <name><name>token</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <literal type="char">'e'</literal> <operator>&amp;&amp;</operator> <name><name>token</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <literal type="char">'E'</literal> <operator>&amp;&amp;</operator> <name><name>token</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <literal type="char">'+'</literal> <operator>&amp;&amp;</operator> <name><name>token</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <literal type="char">'-'</literal></expr>)</condition><block type="pseudo"><block_content>
	 	   	 	<expr_stmt><expr><name>isFloat</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	 	   </block_content>}</block></if></if_stmt></block_content></block></for>
	 	<if_stmt><if>if <condition>(<expr><name>isInt</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>local_node</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>T_Integer</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>local_node</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>val</name><operator>.</operator><name>ival</name></name> <operator>=</operator> <call><name>atol</name><argument_list>(<argument><expr><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>isFloat</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>local_node</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>T_Float</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>local_node</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>val</name><operator>.</operator><name>str</name></name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>length</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name><name>local_node</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>val</name><operator>.</operator><name>str</name></name></expr></argument> , <argument><expr><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,<argument><expr><literal type="string">"Deserialization problem:  A_Const not string, bitstring, float, or int"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>local_node</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>val</name><operator>.</operator><name>str</name></name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>length</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name><name>local_node</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>val</name><operator>.</operator><name>str</name></name></expr></argument> , <argument><expr><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></else></if_stmt>

    <comment type="block">/* CDB: 'location' field is not serialized */</comment>
    <expr_stmt><expr><name><name>local_node</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* COMPILING_BINARY_FUNCS */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>COMPILING_BINARY_FUNCS</name></cpp:ifndef>
<function><type><specifier>static</specifier> <name>A_Expr</name> <modifier>*</modifier></type>
<name>_readAExpr</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>A_Expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>token</name></expr></argument>,<argument><expr><literal type="string">"OPER"</literal></expr></argument>,<argument><expr><name>length</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>local_node</name><operator>-&gt;</operator><name>kind</name></name> <operator>=</operator> <name>AEXPR_OP</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>token</name></expr></argument>,<argument><expr><literal type="string">"ANY"</literal></expr></argument>,<argument><expr><name>length</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>local_node</name><operator>-&gt;</operator><name>kind</name></name> <operator>=</operator> <name>AEXPR_OP_ANY</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>token</name></expr></argument>,<argument><expr><literal type="string">"ALL"</literal></expr></argument>,<argument><expr><name>length</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>local_node</name><operator>-&gt;</operator><name>kind</name></name> <operator>=</operator> <name>AEXPR_OP_ALL</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>token</name></expr></argument>,<argument><expr><literal type="string">"DISTINCT"</literal></expr></argument>,<argument><expr><name>length</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>local_node</name><operator>-&gt;</operator><name>kind</name></name> <operator>=</operator> <name>AEXPR_DISTINCT</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>token</name></expr></argument>,<argument><expr><literal type="string">"NULLIF"</literal></expr></argument>,<argument><expr><name>length</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>local_node</name><operator>-&gt;</operator><name>kind</name></name> <operator>=</operator> <name>AEXPR_NULLIF</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>token</name></expr></argument>,<argument><expr><literal type="string">"OF"</literal></expr></argument>,<argument><expr><name>length</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>local_node</name><operator>-&gt;</operator><name>kind</name></name> <operator>=</operator> <name>AEXPR_OF</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>token</name></expr></argument>,<argument><expr><literal type="string">"IN"</literal></expr></argument>,<argument><expr><name>length</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>local_node</name><operator>-&gt;</operator><name>kind</name></name> <operator>=</operator> <name>AEXPR_IN</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>token</name></expr></argument>,<argument><expr><literal type="string">"LIKE"</literal></expr></argument>,<argument><expr><name>length</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>local_node</name><operator>-&gt;</operator><name>kind</name></name> <operator>=</operator> <name>AEXPR_LIKE</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>token</name></expr></argument>,<argument><expr><literal type="string">"ILIKE"</literal></expr></argument>,<argument><expr><name>length</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>local_node</name><operator>-&gt;</operator><name>kind</name></name> <operator>=</operator> <name>AEXPR_ILIKE</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>token</name></expr></argument>,<argument><expr><literal type="string">"SIMILAR"</literal></expr></argument>,<argument><expr><name>length</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>local_node</name><operator>-&gt;</operator><name>kind</name></name> <operator>=</operator> <name>AEXPR_SIMILAR</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>token</name></expr></argument>,<argument><expr><literal type="string">"BETWEEN"</literal></expr></argument>,<argument><expr><name>length</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>local_node</name><operator>-&gt;</operator><name>kind</name></name> <operator>=</operator> <name>AEXPR_BETWEEN</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>token</name></expr></argument>,<argument><expr><literal type="string">"NOT_BETWEEN"</literal></expr></argument>,<argument><expr><name>length</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>local_node</name><operator>-&gt;</operator><name>kind</name></name> <operator>=</operator> <name>AEXPR_NOT_BETWEEN</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>token</name></expr></argument>,<argument><expr><literal type="string">"BETWEEN_SYM"</literal></expr></argument>,<argument><expr><name>length</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>local_node</name><operator>-&gt;</operator><name>kind</name></name> <operator>=</operator> <name>AEXPR_BETWEEN_SYM</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>token</name></expr></argument>,<argument><expr><literal type="string">"NOT_BETWEEN_SYM"</literal></expr></argument>,<argument><expr><name>length</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>local_node</name><operator>-&gt;</operator><name>kind</name></name> <operator>=</operator> <name>AEXPR_NOT_BETWEEN_SYM</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>token</name></expr></argument>,<argument><expr><literal type="string">"PAREN"</literal></expr></argument>,<argument><expr><name>length</name></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>local_node</name><operator>-&gt;</operator><name>kind</name></name> <operator>=</operator> <name>AEXPR_PAREN</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,<argument><expr><literal type="string">"Unable to understand A_Expr node %.30s"</literal></expr></argument>,<argument><expr><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>lexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>rexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* COMPILING_BINARY_FUNCS */</comment>

<comment type="block">/*
 * _readParam
 */</comment>
<function><type><specifier>static</specifier> <name>Param</name> <modifier>*</modifier></type>
<name>_readParam</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>Param</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name>paramkind</name></expr></argument>, <argument><expr><name>ParamKind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>paramid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>paramtype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>paramtypmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>paramcollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readAggref
 */</comment>
<function><type><specifier>static</specifier> <name>Aggref</name> <modifier>*</modifier></type>
<name>_readAggref</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>Aggref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>aggfnoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>aggtype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>aggcollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>inputcollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>aggtranstype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>aggargtypes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>aggdirectargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>aggorder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>aggdistinct</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>aggfilter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>aggstar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>aggvariadic</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_CHAR_FIELD</name><argument_list>(<argument><expr><name>aggkind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_UINT_FIELD</name><argument_list>(<argument><expr><name>agglevelsup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name>aggsplit</name></expr></argument>, <argument><expr><name>AggSplit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>agg_expr_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readGroupingFunc
 */</comment>
<function><type><specifier>static</specifier> <name>GroupingFunc</name> <modifier>*</modifier></type>
<name>_readGroupingFunc</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>GroupingFunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>refs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>cols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_UINT_FIELD</name><argument_list>(<argument><expr><name>agglevelsup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readGroupId
 */</comment>
<function><type><specifier>static</specifier> <name>GroupId</name> <modifier>*</modifier></type>
<name>_readGroupId</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>GroupId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>agglevelsup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readGroupingSetId
 */</comment>
<function><type><specifier>static</specifier> <name>GroupingSetId</name> <modifier>*</modifier></type>
<name>_readGroupingSetId</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>GroupingSetId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readWindowFunc
 */</comment>
<function><type><specifier>static</specifier> <name>WindowFunc</name> <modifier>*</modifier></type>
<name>_readWindowFunc</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>WindowFunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>winfnoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>wintype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>wincollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>inputcollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>aggfilter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_UINT_FIELD</name><argument_list>(<argument><expr><name>winref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>winstar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>winagg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>windistinct</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readSubscriptingRef
 */</comment>
<function><type><specifier>static</specifier> <name>SubscriptingRef</name> <modifier>*</modifier></type>
<name>_readSubscriptingRef</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>SubscriptingRef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>refcontainertype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>refelemtype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>reftypmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>refcollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>refupperindexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>reflowerindexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>refexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>refassgnexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readFuncExpr
 */</comment>
<function><type><specifier>static</specifier> <name>FuncExpr</name> <modifier>*</modifier></type>
<name>_readFuncExpr</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>FuncExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>funcid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>funcresulttype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>funcretset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>funcvariadic</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name>funcformat</name></expr></argument>, <argument><expr><name>CoercionForm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>funccollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>inputcollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>is_tablefunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* GPDB */</comment>
	<expr_stmt><expr><call><name>READ_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readNamedArgExpr
 */</comment>
<function><type><specifier>static</specifier> <name>NamedArgExpr</name> <modifier>*</modifier></type>
<name>_readNamedArgExpr</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>NamedArgExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_STRING_FIELD</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>argnumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>COMPILING_BINARY_FUNCS</name></cpp:ifndef>
<comment type="block">/*
 * _readOpExpr
 */</comment>
<function><type><specifier>static</specifier> <name>OpExpr</name> <modifier>*</modifier></type>
<name>_readOpExpr</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>OpExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>opno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>opfuncid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>opresulttype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>opretset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>opcollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>inputcollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* COMPILING_BINARY_FUNCS */</comment>

<comment type="block">/*
 * _readDistinctExpr
 */</comment>
<function><type><specifier>static</specifier> <name>DistinctExpr</name> <modifier>*</modifier></type>
<name>_readDistinctExpr</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>DistinctExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>opno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>opfuncid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>opresulttype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>opretset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>opcollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>inputcollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readNullIfExpr
 */</comment>
<function><type><specifier>static</specifier> <name>NullIfExpr</name> <modifier>*</modifier></type>
<name>_readNullIfExpr</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>NullIfExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>opno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>opfuncid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>opresulttype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>opretset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>opcollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>inputcollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readScalarArrayOpExpr
 */</comment>
<function><type><specifier>static</specifier> <name>ScalarArrayOpExpr</name> <modifier>*</modifier></type>
<name>_readScalarArrayOpExpr</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>ScalarArrayOpExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>opno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>opfuncid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>useOr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>inputcollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>COMPILING_BINARY_FUNCS</name></cpp:ifndef>
<comment type="block">/*
 * _readBoolExpr
 */</comment>
<function><type><specifier>static</specifier> <name>BoolExpr</name> <modifier>*</modifier></type>
<name>_readBoolExpr</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>BoolExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* do-it-yourself enum representation */</comment>
	<expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* skip :boolop */</comment>
	<expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* get field value */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><literal type="string">"and"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>local_node</name><operator>-&gt;</operator><name>boolop</name></name> <operator>=</operator> <name>AND_EXPR</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><literal type="string">"or"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>local_node</name><operator>-&gt;</operator><name>boolop</name></name> <operator>=</operator> <name>OR_EXPR</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><literal type="string">"not"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>local_node</name><operator>-&gt;</operator><name>boolop</name></name> <operator>=</operator> <name>NOT_EXPR</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized boolop \"%.*s\""</literal></expr></argument>, <argument><expr><name>length</name></expr></argument>, <argument><expr><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* COMPILING_BINARY_FUNCS */</comment>

<comment type="block">/*
 * _readSubLink
 */</comment>
<function><type><specifier>static</specifier> <name>SubLink</name> <modifier>*</modifier></type>
<name>_readSubLink</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>SubLink</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name>subLinkType</name></expr></argument>, <argument><expr><name>SubLinkType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>subLinkId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>testexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>operName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>subselect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readFieldSelect
 */</comment>
<function><type><specifier>static</specifier> <name>FieldSelect</name> <modifier>*</modifier></type>
<name>_readFieldSelect</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>FieldSelect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>fieldnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>resulttype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>resulttypmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>resultcollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readFieldStore
 */</comment>
<function><type><specifier>static</specifier> <name>FieldStore</name> <modifier>*</modifier></type>
<name>_readFieldStore</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>FieldStore</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>newvals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>fieldnums</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>resulttype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readRelabelType
 */</comment>
<function><type><specifier>static</specifier> <name>RelabelType</name> <modifier>*</modifier></type>
<name>_readRelabelType</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>RelabelType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>resulttype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>resulttypmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>resultcollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name>relabelformat</name></expr></argument>, <argument><expr><name>CoercionForm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readCoerceViaIO
 */</comment>
<function><type><specifier>static</specifier> <name>CoerceViaIO</name> <modifier>*</modifier></type>
<name>_readCoerceViaIO</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>CoerceViaIO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>resulttype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>resultcollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name>coerceformat</name></expr></argument>, <argument><expr><name>CoercionForm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readArrayCoerceExpr
 */</comment>
<function><type><specifier>static</specifier> <name>ArrayCoerceExpr</name> <modifier>*</modifier></type>
<name>_readArrayCoerceExpr</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>ArrayCoerceExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>elemexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>resulttype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>resulttypmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>resultcollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name>coerceformat</name></expr></argument>, <argument><expr><name>CoercionForm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readConvertRowtypeExpr
 */</comment>
<function><type><specifier>static</specifier> <name>ConvertRowtypeExpr</name> <modifier>*</modifier></type>
<name>_readConvertRowtypeExpr</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>ConvertRowtypeExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>resulttype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name>convertformat</name></expr></argument>, <argument><expr><name>CoercionForm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readCollateExpr
 */</comment>
<function><type><specifier>static</specifier> <name>CollateExpr</name> <modifier>*</modifier></type>
<name>_readCollateExpr</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>CollateExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>collOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readCaseExpr
 */</comment>
<function><type><specifier>static</specifier> <name>CaseExpr</name> <modifier>*</modifier></type>
<name>_readCaseExpr</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>CaseExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>casetype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>casecollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>defresult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readCaseWhen
 */</comment>
<function><type><specifier>static</specifier> <name>CaseWhen</name> <modifier>*</modifier></type>
<name>_readCaseWhen</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>CaseWhen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readCaseTestExpr
 */</comment>
<function><type><specifier>static</specifier> <name>CaseTestExpr</name> <modifier>*</modifier></type>
<name>_readCaseTestExpr</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>CaseTestExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>typeId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>typeMod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>collation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readArrayExpr
 */</comment>
<function><type><specifier>static</specifier> <name>ArrayExpr</name> <modifier>*</modifier></type>
<name>_readArrayExpr</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>ArrayExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>array_typeid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>array_collid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>element_typeid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>elements</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>multidims</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readA_ArrayExpr
 */</comment>
<function><type><specifier>static</specifier> <name>A_ArrayExpr</name> <modifier>*</modifier></type>
<name>_readA_ArrayExpr</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>A_ArrayExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>elements</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readRowExpr
 */</comment>
<function><type><specifier>static</specifier> <name>RowExpr</name> <modifier>*</modifier></type>
<name>_readRowExpr</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>RowExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>row_typeid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name>row_format</name></expr></argument>, <argument><expr><name>CoercionForm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>colnames</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readRowCompareExpr
 */</comment>
<function><type><specifier>static</specifier> <name>RowCompareExpr</name> <modifier>*</modifier></type>
<name>_readRowCompareExpr</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>RowCompareExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name>rctype</name></expr></argument>, <argument><expr><name>RowCompareType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>opnos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>opfamilies</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>inputcollids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>largs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>rargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readCoalesceExpr
 */</comment>
<function><type><specifier>static</specifier> <name>CoalesceExpr</name> <modifier>*</modifier></type>
<name>_readCoalesceExpr</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>CoalesceExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>coalescetype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>coalescecollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readMinMaxExpr
 */</comment>
<function><type><specifier>static</specifier> <name>MinMaxExpr</name> <modifier>*</modifier></type>
<name>_readMinMaxExpr</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>MinMaxExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>minmaxtype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>minmaxcollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>inputcollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>MinMaxOp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readSQLValueFunction
 */</comment>
<function><type><specifier>static</specifier> <name>SQLValueFunction</name> <modifier>*</modifier></type>
<name>_readSQLValueFunction</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>SQLValueFunction</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>SQLValueFunctionOp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>typmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readXmlExpr
 */</comment>
<function><type><specifier>static</specifier> <name>XmlExpr</name> <modifier>*</modifier></type>
<name>_readXmlExpr</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>XmlExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>XmlExprOp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_STRING_FIELD</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>named_args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>arg_names</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name>xmloption</name></expr></argument>, <argument><expr><name>XmlOptionType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>typmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readNullTest
 */</comment>
<function><type><specifier>static</specifier> <name>NullTest</name> <modifier>*</modifier></type>
<name>_readNullTest</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>NullTest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name>nulltesttype</name></expr></argument>, <argument><expr><name>NullTestType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>argisrow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readBooleanTest
 */</comment>
<function><type><specifier>static</specifier> <name>BooleanTest</name> <modifier>*</modifier></type>
<name>_readBooleanTest</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>BooleanTest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name>booltesttype</name></expr></argument>, <argument><expr><name>BoolTestType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readCoerceToDomain
 */</comment>
<function><type><specifier>static</specifier> <name>CoerceToDomain</name> <modifier>*</modifier></type>
<name>_readCoerceToDomain</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>CoerceToDomain</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>resulttype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>resulttypmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>resultcollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name>coercionformat</name></expr></argument>, <argument><expr><name>CoercionForm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readCoerceToDomainValue
 */</comment>
<function><type><specifier>static</specifier> <name>CoerceToDomainValue</name> <modifier>*</modifier></type>
<name>_readCoerceToDomainValue</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>CoerceToDomainValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>typeId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>typeMod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>collation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readSetToDefault
 */</comment>
<function><type><specifier>static</specifier> <name>SetToDefault</name> <modifier>*</modifier></type>
<name>_readSetToDefault</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>SetToDefault</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>typeId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>typeMod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>collation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readCurrentOfExpr
 */</comment>
<function><type><specifier>static</specifier> <name>CurrentOfExpr</name> <modifier>*</modifier></type>
<name>_readCurrentOfExpr</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>CurrentOfExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_UINT_FIELD</name><argument_list>(<argument><expr><name>cvarno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_STRING_FIELD</name><argument_list>(<argument><expr><name>cursor_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>cursor_param</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>target_relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readNextValueExpr
 */</comment>
<function><type><specifier>static</specifier> <name>NextValueExpr</name> <modifier>*</modifier></type>
<name>_readNextValueExpr</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>NextValueExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>seqid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>typeId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readInferenceElem
 */</comment>
<function><type><specifier>static</specifier> <name>InferenceElem</name> <modifier>*</modifier></type>
<name>_readInferenceElem</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>InferenceElem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>infercollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>inferopclass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readTargetEntry
 */</comment>
<function><type><specifier>static</specifier> <name>TargetEntry</name> <modifier>*</modifier></type>
<name>_readTargetEntry</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>TargetEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>resno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_STRING_FIELD</name><argument_list>(<argument><expr><name>resname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_UINT_FIELD</name><argument_list>(<argument><expr><name>ressortgroupref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>resorigtbl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>resorigcol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>resjunk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readRangeTblRef
 */</comment>
<function><type><specifier>static</specifier> <name>RangeTblRef</name> <modifier>*</modifier></type>
<name>_readRangeTblRef</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>RangeTblRef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>rtindex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readJoinExpr
 */</comment>
<function><type><specifier>static</specifier> <name>JoinExpr</name> <modifier>*</modifier></type>
<name>_readJoinExpr</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>JoinExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name>jointype</name></expr></argument>, <argument><expr><name>JoinType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>isNatural</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>larg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>rarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>usingClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>quals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>alias</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>rtindex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readFromExpr
 */</comment>
<function><type><specifier>static</specifier> <name>FromExpr</name> <modifier>*</modifier></type>
<name>_readFromExpr</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>FromExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>fromlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>quals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readOnConflictExpr
 */</comment>
<function><type><specifier>static</specifier> <name>OnConflictExpr</name> <modifier>*</modifier></type>
<name>_readOnConflictExpr</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>OnConflictExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name>action</name></expr></argument>, <argument><expr><name>OnConflictAction</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>arbiterElems</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>arbiterWhere</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>constraint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>onConflictSet</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>onConflictWhere</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>exclRelIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>exclRelTlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *	Stuff from parsenodes.h.
 */</comment>

<function><type><specifier>static</specifier> <name>ColumnDef</name> <modifier>*</modifier></type>
<name>_readColumnDef</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>ColumnDef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_STRING_FIELD</name><argument_list>(<argument><expr><name>colname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>typeName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>inhcount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>is_local</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>is_not_null</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>is_from_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>storage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>raw_default</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>cooked_default</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>hasCookedMissingVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>missingIsNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>local_node</name><operator>-&gt;</operator><name>hasCookedMissingVal</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>local_node</name><operator>-&gt;</operator><name>missingIsNull</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>local_node</name><operator>-&gt;</operator><name>missingVal</name></name> <operator>=</operator> <call><name>readDatum</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>READ_CHAR_FIELD</name><argument_list>(<argument><expr><name>identity</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>identitySequence</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_CHAR_FIELD</name><argument_list>(<argument><expr><name>generated</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>collClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>collOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>constraints</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>fdwoptions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>DistributionKeyElem</name> <modifier>*</modifier></type>
<name>_readDistributionKeyElem</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>DistributionKeyElem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_STRING_FIELD</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>opclass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ColumnRef</name> <modifier>*</modifier></type>
<name>_readColumnRef</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>ColumnRef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>fields</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>TypeName</name> <modifier>*</modifier></type>
<name>_readTypeName</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>TypeName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>names</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>typeOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>setof</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>pct_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>typmods</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>typemod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>arrayBounds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>SortBy</name> <modifier>*</modifier></type>
<name>_readSortBy</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>SortBy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name>sortby_dir</name></expr></argument>, <argument><expr><name>SortByDir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name>sortby_nulls</name></expr></argument>, <argument><expr><name>SortByNulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>useOp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>TypeCast</name> <modifier>*</modifier></type>
<name>_readTypeCast</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>TypeCast</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>typeName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readRangeTblEntry
 */</comment>
<function><type><specifier>static</specifier> <name>RangeTblEntry</name> <modifier>*</modifier></type>
<name>_readRangeTblEntry</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>RangeTblEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* put alias + eref first to make dump more legible */</comment>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>alias</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>eref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name>rtekind</name></expr></argument>, <argument><expr><name>RTEKind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><name><name>local_node</name><operator>-&gt;</operator><name>rtekind</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>RTE_RELATION</name></expr>:</case>
			<expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>READ_CHAR_FIELD</name><argument_list>(<argument><expr><name>relkind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>rellockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>tablesample</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>RTE_SUBQUERY</name></expr>:</case>
			<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>subquery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>security_barrier</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>RTE_JOIN</name></expr>:</case>
			<expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name>jointype</name></expr></argument>, <argument><expr><name>JoinType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>joinaliasvars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>RTE_FUNCTION</name></expr>:</case>
			<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>functions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>funcordinality</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>RTE_TABLEFUNCTION</name></expr>:</case>
			<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>subquery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>functions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>funcordinality</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>RTE_TABLEFUNC</name></expr>:</case>
			<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>tablefunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* The RTE must have a copy of the column type info, if any */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>local_node</name><operator>-&gt;</operator><name>tablefunc</name></name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>TableFunc</name>  <modifier>*</modifier></type><name>tf</name> <init>= <expr><name><name>local_node</name><operator>-&gt;</operator><name>tablefunc</name></name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name><name>local_node</name><operator>-&gt;</operator><name>coltypes</name></name> <operator>=</operator> <name><name>tf</name><operator>-&gt;</operator><name>coltypes</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>local_node</name><operator>-&gt;</operator><name>coltypmods</name></name> <operator>=</operator> <name><name>tf</name><operator>-&gt;</operator><name>coltypmods</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>local_node</name><operator>-&gt;</operator><name>colcollations</name></name> <operator>=</operator> <name><name>tf</name><operator>-&gt;</operator><name>colcollations</name></name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>RTE_VALUES</name></expr>:</case>
			<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>values_lists</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>coltypes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>coltypmods</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>colcollations</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>RTE_CTE</name></expr>:</case>
			<expr_stmt><expr><call><name>READ_STRING_FIELD</name><argument_list>(<argument><expr><name>ctename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>READ_UINT_FIELD</name><argument_list>(<argument><expr><name>ctelevelsup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>self_reference</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>coltypes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>coltypmods</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>colcollations</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>RTE_NAMEDTUPLESTORE</name></expr>:</case>
			<expr_stmt><expr><call><name>READ_STRING_FIELD</name><argument_list>(<argument><expr><name>enrname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>READ_FLOAT_FIELD</name><argument_list>(<argument><expr><name>enrtuples</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>coltypes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>coltypmods</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>colcollations</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>RTE_RESULT</name></expr>:</case>
			<comment type="block">/* no extra fields */</comment>
			<break>break;</break>
        <case>case <expr><name>RTE_VOID</name></expr>:</case>                                                  <comment type="block">/*CDB*/</comment>
            <break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized RTE kind: %d"</literal></expr></argument>,
				 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>local_node</name><operator>-&gt;</operator><name>rtekind</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>lateral</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>inh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>inFromCl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_UINT_FIELD</name><argument_list>(<argument><expr><name>requiredPerms</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>checkAsUser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name>selectedCols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name>insertedCols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name>updatedCols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name>extraUpdatedCols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>securityQuals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>forceDistRandom</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readRangeTblFunction
 */</comment>
<function><type><specifier>static</specifier> <name>RangeTblFunction</name> <modifier>*</modifier></type>
<name>_readRangeTblFunction</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>RangeTblFunction</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>funcexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>funccolcount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>funccolnames</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>funccoltypes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>funccoltypmods</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>funccolcollations</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* funcuserdata is only serialized in binary out/read functions */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>COMPILING_BINARY_FUNCS</name></cpp:ifdef>
	<expr_stmt><expr><call><name>READ_BYTEA_FIELD</name><argument_list>(<argument><expr><name>funcuserdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><call><name>READ_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name>funcparams</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Greenplum Database additions for serialization support
 * These are currently not used (see outfastc ad readfast.c)
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/plannodes.h"</cpp:file></cpp:include>

<comment type="block">/*
 * _readTableSampleClause
 */</comment>
<function><type><specifier>static</specifier> <name>TableSampleClause</name> <modifier>*</modifier></type>
<name>_readTableSampleClause</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>TableSampleClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>tsmhandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>repeatable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readDefElem
 */</comment>
<function><type><specifier>static</specifier> <name>DefElem</name> <modifier>*</modifier></type>
<name>_readDefElem</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>DefElem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_STRING_FIELD</name><argument_list>(<argument><expr><name>defnamespace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_STRING_FIELD</name><argument_list>(<argument><expr><name>defname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name>defaction</name></expr></argument>, <argument><expr><name>DefElemAction</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *	Stuff from plannodes.h.
 */</comment>

<comment type="block">/*
 * _readPlannedStmt
 */</comment>
<function><type><specifier>static</specifier> <name>PlannedStmt</name> <modifier>*</modifier></type>
<name>_readPlannedStmt</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>PlannedStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name>commandType</name></expr></argument>, <argument><expr><name>CmdType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name>planGen</name></expr></argument>, <argument><expr><name>PlanGenerator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_UINT64_FIELD</name><argument_list>(<argument><expr><name>queryId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>hasReturning</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>hasModifyingCTE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>canSetTag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>transientPlan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>oneoffPlan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>simplyUpdatableRel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>dependsOnRole</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>parallelModeNeeded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>jitFlags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>planTree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>rtable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>resultRelations</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>rootResultRelations</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>subplans</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name>rewindPlanIDs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>rowMarks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>relationOids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* invalItems not serialized in binary mode */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>COMPILING_BINARY_FUNCS</name></cpp:ifndef>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>invalItems</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* COMPILING_BINARY_FUNCS */</comment>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>paramExecTypes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>utilityStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_LOCATION_FIELD</name><argument_list>(<argument><expr><name>stmt_location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_LOCATION_FIELD</name><argument_list>(<argument><expr><name>stmt_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_INT_ARRAY</name><argument_list>(<argument><expr><name>subplan_sliceIds</name></expr></argument>, <argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>local_node</name><operator>-&gt;</operator><name>subplans</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>numSlices</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>local_node</name><operator>-&gt;</operator><name>slices</name></name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>local_node</name><operator>-&gt;</operator><name>numSlices</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PlanSlice</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>local_node</name><operator>-&gt;</operator><name>numSlices</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name><name>slices</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sliceIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name><name>slices</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>parentIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name><name>slices</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>gangType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name><name>slices</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>numsegments</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name><name>slices</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>segindex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name><name>slices</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>directDispatch</name><operator>.</operator><name>isDirectDispatch</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name><name>slices</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>directDispatch</name><operator>.</operator><name>contentIds</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>READ_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name>rewindPlanIDs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>intoPolicy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_UINT64_FIELD</name><argument_list>(<argument><expr><name>query_mem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>total_memory_coordinator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>nsegments_coordinator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>intoClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>copyIntoClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>refreshClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>metricsQueryType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ReadCommonPlan
 *	Assign the basic stuff of all nodes that inherit from Plan
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ReadCommonPlan</name><parameter_list>(<parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>local_node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_TEMP_LOCALS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_FLOAT_FIELD</name><argument_list>(<argument><expr><name>startup_cost</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_FLOAT_FIELD</name><argument_list>(<argument><expr><name>total_cost</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_FLOAT_FIELD</name><argument_list>(<argument><expr><name>plan_rows</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>plan_width</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>parallel_aware</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>parallel_safe</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>plan_node_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>targetlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>qual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>lefttree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>righttree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>initPlan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name>extParam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name>allParam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>COMPILING_BINARY_FUNCS</name></cpp:ifndef>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>flow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* COMPILING_BINARY_FUNCS */</comment>

	<expr_stmt><expr><call><name>READ_UINT64_FIELD</name><argument_list>(<argument><expr><name>operatorMemKB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readPlan
 */</comment>
<function><type><specifier>static</specifier> <name>Plan</name> <modifier>*</modifier></type>
<name>_readPlan</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS_NO_FIELDS</name><argument_list>(<argument><expr><name>Plan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReadCommonPlan</name><argument_list>(<argument><expr><name>local_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readResult
 */</comment>
<function><type><specifier>static</specifier> <name>Result</name> <modifier>*</modifier></type>
<name>_readResult</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>Result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReadCommonPlan</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>local_node</name><operator>-&gt;</operator><name>plan</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>resconstantqual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>numHashFilterCols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_ATTRNUMBER_ARRAY</name><argument_list>(<argument><expr><name>hashFilterColIdx</name></expr></argument>, <argument><expr><name><name>local_node</name><operator>-&gt;</operator><name>numHashFilterCols</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_OID_ARRAY</name><argument_list>(<argument><expr><name>hashFilterFuncs</name></expr></argument>, <argument><expr><name><name>local_node</name><operator>-&gt;</operator><name>numHashFilterCols</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readProjectSet
 */</comment>
<function><type><specifier>static</specifier> <name>ProjectSet</name> <modifier>*</modifier></type>
<name>_readProjectSet</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS_NO_FIELDS</name><argument_list>(<argument><expr><name>ProjectSet</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReadCommonPlan</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>local_node</name><operator>-&gt;</operator><name>plan</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readModifyTable
 */</comment>
<function><type><specifier>static</specifier> <name>ModifyTable</name> <modifier>*</modifier></type>
<name>_readModifyTable</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>ModifyTable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReadCommonPlan</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>local_node</name><operator>-&gt;</operator><name>plan</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name>operation</name></expr></argument>, <argument><expr><name>CmdType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>canSetTag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_UINT_FIELD</name><argument_list>(<argument><expr><name>nominalRelation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_UINT_FIELD</name><argument_list>(<argument><expr><name>rootRelation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>partColsUpdated</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>resultRelations</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>resultRelIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>rootResultRelIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>plans</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>withCheckOptionLists</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>returningLists</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>fdwPrivLists</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name>fdwDirectModifyPlans</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>rowMarks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>epqParam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name>onConflictAction</name></expr></argument>, <argument><expr><name>OnConflictAction</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>arbiterIndexes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>onConflictSet</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>onConflictWhere</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_UINT_FIELD</name><argument_list>(<argument><expr><name>exclRelRTI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>exclRelTlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>isSplitUpdates</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>forceTupleRouting</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readAppend
 */</comment>
<function><type><specifier>static</specifier> <name>Append</name> <modifier>*</modifier></type>
<name>_readAppend</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>Append</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReadCommonPlan</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>local_node</name><operator>-&gt;</operator><name>plan</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>appendplans</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>first_partial_plan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>part_prune_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>join_prune_paramids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readMergeAppend
 */</comment>
<function><type><specifier>static</specifier> <name>MergeAppend</name> <modifier>*</modifier></type>
<name>_readMergeAppend</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>MergeAppend</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReadCommonPlan</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>local_node</name><operator>-&gt;</operator><name>plan</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>mergeplans</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>numCols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_ATTRNUMBER_ARRAY</name><argument_list>(<argument><expr><name>sortColIdx</name></expr></argument>, <argument><expr><name><name>local_node</name><operator>-&gt;</operator><name>numCols</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_OID_ARRAY</name><argument_list>(<argument><expr><name>sortOperators</name></expr></argument>, <argument><expr><name><name>local_node</name><operator>-&gt;</operator><name>numCols</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_OID_ARRAY</name><argument_list>(<argument><expr><name>collations</name></expr></argument>, <argument><expr><name><name>local_node</name><operator>-&gt;</operator><name>numCols</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_ARRAY</name><argument_list>(<argument><expr><name>nullsFirst</name></expr></argument>, <argument><expr><name><name>local_node</name><operator>-&gt;</operator><name>numCols</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>part_prune_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>join_prune_paramids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readRecursiveUnion
 */</comment>
<function><type><specifier>static</specifier> <name>RecursiveUnion</name> <modifier>*</modifier></type>
<name>_readRecursiveUnion</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>RecursiveUnion</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReadCommonPlan</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>local_node</name><operator>-&gt;</operator><name>plan</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>wtParam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>numCols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_ATTRNUMBER_ARRAY</name><argument_list>(<argument><expr><name>dupColIdx</name></expr></argument>, <argument><expr><name><name>local_node</name><operator>-&gt;</operator><name>numCols</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_OID_ARRAY</name><argument_list>(<argument><expr><name>dupOperators</name></expr></argument>, <argument><expr><name><name>local_node</name><operator>-&gt;</operator><name>numCols</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_OID_ARRAY</name><argument_list>(<argument><expr><name>dupCollations</name></expr></argument>, <argument><expr><name><name>local_node</name><operator>-&gt;</operator><name>numCols</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_LONG_FIELD</name><argument_list>(<argument><expr><name>numGroups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readBitmapAnd
 */</comment>
<function><type><specifier>static</specifier> <name>BitmapAnd</name> <modifier>*</modifier></type>
<name>_readBitmapAnd</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>BitmapAnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReadCommonPlan</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>local_node</name><operator>-&gt;</operator><name>plan</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>bitmapplans</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readBitmapOr
 */</comment>
<function><type><specifier>static</specifier> <name>BitmapOr</name> <modifier>*</modifier></type>
<name>_readBitmapOr</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>BitmapOr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReadCommonPlan</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>local_node</name><operator>-&gt;</operator><name>plan</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>isshared</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>bitmapplans</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ReadCommonScan
 *	Assign the basic stuff of all nodes that inherit from Scan
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ReadCommonScan</name><parameter_list>(<parameter><decl><type><name>Scan</name> <modifier>*</modifier></type><name>local_node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_TEMP_LOCALS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReadCommonPlan</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>local_node</name><operator>-&gt;</operator><name>plan</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_UINT_FIELD</name><argument_list>(<argument><expr><name>scanrelid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readScan
 */</comment>
<function><type><specifier>static</specifier> <name>Scan</name> <modifier>*</modifier></type>
<name>_readScan</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS_NO_FIELDS</name><argument_list>(<argument><expr><name>Scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReadCommonScan</name><argument_list>(<argument><expr><name>local_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readSeqScan
 */</comment>
<function><type><specifier>static</specifier> <name>SeqScan</name> <modifier>*</modifier></type>
<name>_readSeqScan</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS_NO_FIELDS</name><argument_list>(<argument><expr><name>SeqScan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReadCommonScan</name><argument_list>(<argument><expr><name>local_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readSampleScan
 */</comment>
<function><type><specifier>static</specifier> <name>SampleScan</name> <modifier>*</modifier></type>
<name>_readSampleScan</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>SampleScan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReadCommonScan</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>local_node</name><operator>-&gt;</operator><name>scan</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>tablesample</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readIndexScan
 */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>readIndexScanFields</name><parameter_list>(<parameter><decl><type><name>IndexScan</name> <modifier>*</modifier></type><name>local_node</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>IndexScan</name> <modifier>*</modifier></type>
<name>_readIndexScan</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS_NO_FIELDS</name><argument_list>(<argument><expr><name>IndexScan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>readIndexScanFields</name><argument_list>(<argument><expr><name>local_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>DynamicIndexScan</name> <modifier>*</modifier></type>
<name>_readDynamicIndexScan</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>DynamicIndexScan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* DynamicIndexScan has some content from IndexScan. */</comment>
	<expr_stmt><expr><call><name>readIndexScanFields</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>local_node</name><operator>-&gt;</operator><name>indexscan</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>partOids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>part_prune_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>join_prune_paramids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>readIndexScanFields</name><parameter_list>(<parameter><decl><type><name>IndexScan</name> <modifier>*</modifier></type><name>local_node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_TEMP_LOCALS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReadCommonScan</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>local_node</name><operator>-&gt;</operator><name>scan</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>indexid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>indexqual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>indexqualorig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>indexorderby</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>indexorderbyorig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>indexorderbyops</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name>indexorderdir</name></expr></argument>, <argument><expr><name>ScanDirection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readIndexOnlyScan
 */</comment>
<function><type><specifier>static</specifier> <name>IndexOnlyScan</name> <modifier>*</modifier></type>
<name>_readIndexOnlyScan</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>IndexOnlyScan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReadCommonScan</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>local_node</name><operator>-&gt;</operator><name>scan</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>indexid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>indexqual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>indexorderby</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>indextlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name>indexorderdir</name></expr></argument>, <argument><expr><name>ScanDirection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>readBitmapIndexScanFields</name><parameter_list>(<parameter><decl><type><name>BitmapIndexScan</name> <modifier>*</modifier></type><name>local_node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_TEMP_LOCALS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReadCommonScan</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>local_node</name><operator>-&gt;</operator><name>scan</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>indexid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>isshared</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>indexqual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>indexqualorig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readBitmapIndexScan
 */</comment>
<function><type><specifier>static</specifier> <name>BitmapIndexScan</name> <modifier>*</modifier></type>
<name>_readBitmapIndexScan</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS_NO_FIELDS</name><argument_list>(<argument><expr><name>BitmapIndexScan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>readBitmapIndexScanFields</name><argument_list>(<argument><expr><name>local_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>DynamicBitmapIndexScan</name> <modifier>*</modifier></type>
<name>_readDynamicBitmapIndexScan</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS_NO_FIELDS</name><argument_list>(<argument><expr><name>DynamicBitmapIndexScan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* DynamicBitmapIndexScan has some content from BitmapIndexScan. */</comment>
	<expr_stmt><expr><call><name>readBitmapIndexScanFields</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>local_node</name><operator>-&gt;</operator><name>biscan</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>readBitmapHeapScanFields</name><parameter_list>(<parameter><decl><type><name>BitmapHeapScan</name> <modifier>*</modifier></type><name>local_node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_TEMP_LOCALS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReadCommonScan</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>local_node</name><operator>-&gt;</operator><name>scan</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>bitmapqualorig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readBitmapHeapScan
 */</comment>
<function><type><specifier>static</specifier> <name>BitmapHeapScan</name> <modifier>*</modifier></type>
<name>_readBitmapHeapScan</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS_NO_FIELDS</name><argument_list>(<argument><expr><name>BitmapHeapScan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>readBitmapHeapScanFields</name><argument_list>(<argument><expr><name>local_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>DynamicBitmapHeapScan</name> <modifier>*</modifier></type>
<name>_readDynamicBitmapHeapScan</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>DynamicBitmapHeapScan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* DynamicBitmapHeapScan has some content from BitmapHeapScan. */</comment>
	<expr_stmt><expr><call><name>readBitmapHeapScanFields</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>local_node</name><operator>-&gt;</operator><name>bitmapheapscan</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>partOids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>part_prune_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>join_prune_paramids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readTidScan
 */</comment>
<function><type><specifier>static</specifier> <name>TidScan</name> <modifier>*</modifier></type>
<name>_readTidScan</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>TidScan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReadCommonScan</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>local_node</name><operator>-&gt;</operator><name>scan</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>tidquals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readSubqueryScan
 */</comment>
<function><type><specifier>static</specifier> <name>SubqueryScan</name> <modifier>*</modifier></type>
<name>_readSubqueryScan</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>SubqueryScan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReadCommonScan</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>local_node</name><operator>-&gt;</operator><name>scan</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>subplan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readTableFunctionScan
 */</comment>
<function><type><specifier>static</specifier> <name>TableFunctionScan</name> <modifier>*</modifier></type>
<name>_readTableFunctionScan</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>TableFunctionScan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReadCommonScan</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>local_node</name><operator>-&gt;</operator><name>scan</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>function</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readFunctionScan
 */</comment>
<function><type><specifier>static</specifier> <name>FunctionScan</name> <modifier>*</modifier></type>
<name>_readFunctionScan</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>FunctionScan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReadCommonScan</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>local_node</name><operator>-&gt;</operator><name>scan</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>functions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>funcordinality</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>param</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>resultInTupleStore</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>initplanId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readValuesScan
 */</comment>
<function><type><specifier>static</specifier> <name>ValuesScan</name> <modifier>*</modifier></type>
<name>_readValuesScan</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>ValuesScan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReadCommonScan</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>local_node</name><operator>-&gt;</operator><name>scan</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>values_lists</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readTableFuncScan
 */</comment>
<function><type><specifier>static</specifier> <name>TableFuncScan</name> <modifier>*</modifier></type>
<name>_readTableFuncScan</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>TableFuncScan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReadCommonScan</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>local_node</name><operator>-&gt;</operator><name>scan</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>tablefunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readCteScan
 */</comment>
<function><type><specifier>static</specifier> <name>CteScan</name> <modifier>*</modifier></type>
<name>_readCteScan</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>CteScan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReadCommonScan</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>local_node</name><operator>-&gt;</operator><name>scan</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>ctePlanId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>cteParam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readNamedTuplestoreScan
 */</comment>
<function><type><specifier>static</specifier> <name>NamedTuplestoreScan</name> <modifier>*</modifier></type>
<name>_readNamedTuplestoreScan</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>NamedTuplestoreScan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReadCommonScan</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>local_node</name><operator>-&gt;</operator><name>scan</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_STRING_FIELD</name><argument_list>(<argument><expr><name>enrname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readWorkTableScan
 */</comment>
<function><type><specifier>static</specifier> <name>WorkTableScan</name> <modifier>*</modifier></type>
<name>_readWorkTableScan</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>WorkTableScan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReadCommonScan</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>local_node</name><operator>-&gt;</operator><name>scan</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>wtParam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readForeignScan
 */</comment>
<function><type><specifier>static</specifier> <name>ForeignScan</name> <modifier>*</modifier></type>
<name>_readForeignScan</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>ForeignScan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReadCommonScan</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>local_node</name><operator>-&gt;</operator><name>scan</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name>operation</name></expr></argument>, <argument><expr><name>CmdType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>fs_server</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>fdw_exprs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>fdw_private</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>fdw_scan_tlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>fdw_recheck_quals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name>fs_relids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>fsSystemCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>COMPILING_BINARY_FUNCS</name></cpp:ifndef>
<comment type="block">/*
 * _readCustomScan
 */</comment>
<function><type><specifier>static</specifier> <name>CustomScan</name> <modifier>*</modifier></type>
<name>_readCustomScan</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>CustomScan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>custom_name</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>CustomScanMethods</name> <modifier>*</modifier></type><name>methods</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ReadCommonScan</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>local_node</name><operator>-&gt;</operator><name>scan</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_UINT_FIELD</name><argument_list>(<argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>custom_plans</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>custom_exprs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>custom_private</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>custom_scan_tlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name>custom_relids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Lookup CustomScanMethods by CustomName */</comment>
	<expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* skip methods: */</comment>
	<expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* CustomName */</comment>
	<expr_stmt><expr><name>custom_name</name> <operator>=</operator> <call><name>nullable_string</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>methods</name> <operator>=</operator> <call><name>GetCustomScanMethods</name><argument_list>(<argument><expr><name>custom_name</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>local_node</name><operator>-&gt;</operator><name>methods</name></name> <operator>=</operator> <name>methods</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* COMPILING_BINARY_FUNCS */</comment>

<comment type="block">/*
 * ReadCommonJoin
 *	Assign the basic stuff of all nodes that inherit from Join
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ReadCommonJoin</name><parameter_list>(<parameter><decl><type><name>Join</name> <modifier>*</modifier></type><name>local_node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_TEMP_LOCALS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReadCommonPlan</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>local_node</name><operator>-&gt;</operator><name>plan</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>prefetch_inner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>prefetch_joinqual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>prefetch_qual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name>jointype</name></expr></argument>, <argument><expr><name>JoinType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>inner_unique</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>joinqual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readJoin
 */</comment>
<function><type><specifier>static</specifier> <name>Join</name> <modifier>*</modifier></type>
<name>_readJoin</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS_NO_FIELDS</name><argument_list>(<argument><expr><name>Join</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReadCommonJoin</name><argument_list>(<argument><expr><name>local_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readNestLoop
 */</comment>
<function><type><specifier>static</specifier> <name>NestLoop</name> <modifier>*</modifier></type>
<name>_readNestLoop</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>NestLoop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReadCommonJoin</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>local_node</name><operator>-&gt;</operator><name>join</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>nestParams</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>shared_outer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>singleton_outer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/*CDB-OLAP*/</comment>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readMergeJoin
 */</comment>
<function><type><specifier>static</specifier> <name>MergeJoin</name> <modifier>*</modifier></type>
<name>_readMergeJoin</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>numCols</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>MergeJoin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReadCommonJoin</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>local_node</name><operator>-&gt;</operator><name>join</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>skip_mark_restore</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>mergeclauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>numCols</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>local_node</name><operator>-&gt;</operator><name>mergeclauses</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_OID_ARRAY</name><argument_list>(<argument><expr><name>mergeFamilies</name></expr></argument>, <argument><expr><name>numCols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_OID_ARRAY</name><argument_list>(<argument><expr><name>mergeCollations</name></expr></argument>, <argument><expr><name>numCols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_INT_ARRAY</name><argument_list>(<argument><expr><name>mergeStrategies</name></expr></argument>, <argument><expr><name>numCols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_ARRAY</name><argument_list>(<argument><expr><name>mergeNullsFirst</name></expr></argument>, <argument><expr><name>numCols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>unique_outer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readHashJoin
 */</comment>
<function><type><specifier>static</specifier> <name>HashJoin</name> <modifier>*</modifier></type>
<name>_readHashJoin</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>HashJoin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReadCommonJoin</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>local_node</name><operator>-&gt;</operator><name>join</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>hashclauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>hashqualclauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readMaterial
 */</comment>
<function><type><specifier>static</specifier> <name>Material</name> <modifier>*</modifier></type>
<name>_readMaterial</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>Material</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReadCommonPlan</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>local_node</name><operator>-&gt;</operator><name>plan</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>cdb_strict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>cdb_shield_child_from_rescans</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readSort
 */</comment>
<function><type><specifier>static</specifier> <name>Sort</name> <modifier>*</modifier></type>
<name>_readSort</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>Sort</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReadCommonPlan</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>local_node</name><operator>-&gt;</operator><name>plan</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>numCols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_ATTRNUMBER_ARRAY</name><argument_list>(<argument><expr><name>sortColIdx</name></expr></argument>, <argument><expr><name><name>local_node</name><operator>-&gt;</operator><name>numCols</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_OID_ARRAY</name><argument_list>(<argument><expr><name>sortOperators</name></expr></argument>, <argument><expr><name><name>local_node</name><operator>-&gt;</operator><name>numCols</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_OID_ARRAY</name><argument_list>(<argument><expr><name>collations</name></expr></argument>, <argument><expr><name><name>local_node</name><operator>-&gt;</operator><name>numCols</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_ARRAY</name><argument_list>(<argument><expr><name>nullsFirst</name></expr></argument>, <argument><expr><name><name>local_node</name><operator>-&gt;</operator><name>numCols</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readAgg
 */</comment>
<function><type><specifier>static</specifier> <name>Agg</name> <modifier>*</modifier></type>
<name>_readAgg</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>Agg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReadCommonPlan</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>local_node</name><operator>-&gt;</operator><name>plan</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name>aggstrategy</name></expr></argument>, <argument><expr><name>AggStrategy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name>aggsplit</name></expr></argument>, <argument><expr><name>AggSplit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>numCols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_ATTRNUMBER_ARRAY</name><argument_list>(<argument><expr><name>grpColIdx</name></expr></argument>, <argument><expr><name><name>local_node</name><operator>-&gt;</operator><name>numCols</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_OID_ARRAY</name><argument_list>(<argument><expr><name>grpOperators</name></expr></argument>, <argument><expr><name><name>local_node</name><operator>-&gt;</operator><name>numCols</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_OID_ARRAY</name><argument_list>(<argument><expr><name>grpCollations</name></expr></argument>, <argument><expr><name><name>local_node</name><operator>-&gt;</operator><name>numCols</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_LONG_FIELD</name><argument_list>(<argument><expr><name>numGroups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name>aggParams</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>groupingSets</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>chain</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>streaming</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_UINT_FIELD</name><argument_list>(<argument><expr><name>agg_expr_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>TupleSplit</name> <modifier>*</modifier></type>
<name>_readTupleSplit</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>TupleSplit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReadCommonPlan</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>local_node</name><operator>-&gt;</operator><name>plan</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>numCols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_ATTRNUMBER_ARRAY</name><argument_list>(<argument><expr><name>grpColIdx</name></expr></argument>, <argument><expr><name><name>local_node</name><operator>-&gt;</operator><name>numCols</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>dqa_expr_lst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>DQAExpr</name><modifier>*</modifier></type>
<name>_readDQAExpr</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>DQAExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>agg_expr_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name>agg_args_id_bms</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>agg_filter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readWindowAgg
 */</comment>
<function><type><specifier>static</specifier> <name>WindowAgg</name> <modifier>*</modifier></type>
<name>_readWindowAgg</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>WindowAgg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReadCommonPlan</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>local_node</name><operator>-&gt;</operator><name>plan</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_UINT_FIELD</name><argument_list>(<argument><expr><name>winref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>partNumCols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_ATTRNUMBER_ARRAY</name><argument_list>(<argument><expr><name>partColIdx</name></expr></argument>, <argument><expr><name><name>local_node</name><operator>-&gt;</operator><name>partNumCols</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_OID_ARRAY</name><argument_list>(<argument><expr><name>partOperators</name></expr></argument>, <argument><expr><name><name>local_node</name><operator>-&gt;</operator><name>partNumCols</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_OID_ARRAY</name><argument_list>(<argument><expr><name>partCollations</name></expr></argument>, <argument><expr><name><name>local_node</name><operator>-&gt;</operator><name>partNumCols</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>ordNumCols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_ATTRNUMBER_ARRAY</name><argument_list>(<argument><expr><name>ordColIdx</name></expr></argument>, <argument><expr><name><name>local_node</name><operator>-&gt;</operator><name>ordNumCols</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_OID_ARRAY</name><argument_list>(<argument><expr><name>ordOperators</name></expr></argument>, <argument><expr><name><name>local_node</name><operator>-&gt;</operator><name>ordNumCols</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_OID_ARRAY</name><argument_list>(<argument><expr><name>ordCollations</name></expr></argument>, <argument><expr><name><name>local_node</name><operator>-&gt;</operator><name>ordNumCols</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>firstOrderCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>firstOrderCmpOperator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>firstOrderNullsFirst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>frameOptions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>startOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>endOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>startInRangeFunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>endInRangeFunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>inRangeColl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>inRangeAsc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>inRangeNullsFirst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readUnique
 */</comment>
<function><type><specifier>static</specifier> <name>Unique</name> <modifier>*</modifier></type>
<name>_readUnique</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>Unique</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReadCommonPlan</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>local_node</name><operator>-&gt;</operator><name>plan</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>numCols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_ATTRNUMBER_ARRAY</name><argument_list>(<argument><expr><name>uniqColIdx</name></expr></argument>, <argument><expr><name><name>local_node</name><operator>-&gt;</operator><name>numCols</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_OID_ARRAY</name><argument_list>(<argument><expr><name>uniqOperators</name></expr></argument>, <argument><expr><name><name>local_node</name><operator>-&gt;</operator><name>numCols</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_OID_ARRAY</name><argument_list>(<argument><expr><name>uniqCollations</name></expr></argument>, <argument><expr><name><name>local_node</name><operator>-&gt;</operator><name>numCols</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readGather
 */</comment>
<function><type><specifier>static</specifier> <name>Gather</name> <modifier>*</modifier></type>
<name>_readGather</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>Gather</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReadCommonPlan</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>local_node</name><operator>-&gt;</operator><name>plan</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>num_workers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>rescan_param</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>single_copy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>invisible</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name>initParam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readGatherMerge
 */</comment>
<function><type><specifier>static</specifier> <name>GatherMerge</name> <modifier>*</modifier></type>
<name>_readGatherMerge</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>GatherMerge</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReadCommonPlan</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>local_node</name><operator>-&gt;</operator><name>plan</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>num_workers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>rescan_param</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>numCols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_ATTRNUMBER_ARRAY</name><argument_list>(<argument><expr><name>sortColIdx</name></expr></argument>, <argument><expr><name><name>local_node</name><operator>-&gt;</operator><name>numCols</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_OID_ARRAY</name><argument_list>(<argument><expr><name>sortOperators</name></expr></argument>, <argument><expr><name><name>local_node</name><operator>-&gt;</operator><name>numCols</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_OID_ARRAY</name><argument_list>(<argument><expr><name>collations</name></expr></argument>, <argument><expr><name><name>local_node</name><operator>-&gt;</operator><name>numCols</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_ARRAY</name><argument_list>(<argument><expr><name>nullsFirst</name></expr></argument>, <argument><expr><name><name>local_node</name><operator>-&gt;</operator><name>numCols</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name>initParam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readHash
 */</comment>
<function><type><specifier>static</specifier> <name>Hash</name> <modifier>*</modifier></type>
<name>_readHash</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>Hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReadCommonPlan</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>local_node</name><operator>-&gt;</operator><name>plan</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>rescannable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>           <comment type="block">/*CDB*/</comment>
	<expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>skewTable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>skewColumn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>skewInherit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_FLOAT_FIELD</name><argument_list>(<argument><expr><name>rows_total</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readSetOp
 */</comment>
<function><type><specifier>static</specifier> <name>SetOp</name> <modifier>*</modifier></type>
<name>_readSetOp</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>SetOp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReadCommonPlan</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>local_node</name><operator>-&gt;</operator><name>plan</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>SetOpCmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name>strategy</name></expr></argument>, <argument><expr><name>SetOpStrategy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>numCols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_ATTRNUMBER_ARRAY</name><argument_list>(<argument><expr><name>dupColIdx</name></expr></argument>, <argument><expr><name><name>local_node</name><operator>-&gt;</operator><name>numCols</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_OID_ARRAY</name><argument_list>(<argument><expr><name>dupOperators</name></expr></argument>, <argument><expr><name><name>local_node</name><operator>-&gt;</operator><name>numCols</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_OID_ARRAY</name><argument_list>(<argument><expr><name>dupCollations</name></expr></argument>, <argument><expr><name><name>local_node</name><operator>-&gt;</operator><name>numCols</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>flagColIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>firstFlag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_LONG_FIELD</name><argument_list>(<argument><expr><name>numGroups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readLockRows
 */</comment>
<function><type><specifier>static</specifier> <name>LockRows</name> <modifier>*</modifier></type>
<name>_readLockRows</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>LockRows</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReadCommonPlan</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>local_node</name><operator>-&gt;</operator><name>plan</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>rowMarks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>epqParam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readLimit
 */</comment>
<function><type><specifier>static</specifier> <name>Limit</name> <modifier>*</modifier></type>
<name>_readLimit</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>Limit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReadCommonPlan</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>local_node</name><operator>-&gt;</operator><name>plan</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>limitOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>limitCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readNestLoopParam
 */</comment>
<function><type><specifier>static</specifier> <name>NestLoopParam</name> <modifier>*</modifier></type>
<name>_readNestLoopParam</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>NestLoopParam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>paramno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>paramval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readPlanRowMark
 */</comment>
<function><type><specifier>static</specifier> <name>PlanRowMark</name> <modifier>*</modifier></type>
<name>_readPlanRowMark</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>PlanRowMark</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_UINT_FIELD</name><argument_list>(<argument><expr><name>rti</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_UINT_FIELD</name><argument_list>(<argument><expr><name>prti</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_UINT_FIELD</name><argument_list>(<argument><expr><name>rowmarkId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name>markType</name></expr></argument>, <argument><expr><name>RowMarkType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>allMarkTypes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name>strength</name></expr></argument>, <argument><expr><name>LockClauseStrength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name>waitPolicy</name></expr></argument>, <argument><expr><name>LockWaitPolicy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>isParent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>canOptSelectLockingClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>PartitionPruneInfo</name> <modifier>*</modifier></type>
<name>_readPartitionPruneInfo</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>PartitionPruneInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>prune_infos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name>other_subplans</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>PartitionedRelPruneInfo</name> <modifier>*</modifier></type>
<name>_readPartitionedRelPruneInfo</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>PartitionedRelPruneInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_UINT_FIELD</name><argument_list>(<argument><expr><name>rtindex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name>present_parts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>nparts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_INT_ARRAY</name><argument_list>(<argument><expr><name>subplan_map</name></expr></argument>, <argument><expr><name><name>local_node</name><operator>-&gt;</operator><name>nparts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_INT_ARRAY</name><argument_list>(<argument><expr><name>subpart_map</name></expr></argument>, <argument><expr><name><name>local_node</name><operator>-&gt;</operator><name>nparts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_OID_ARRAY</name><argument_list>(<argument><expr><name>relid_map</name></expr></argument>, <argument><expr><name><name>local_node</name><operator>-&gt;</operator><name>nparts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>initial_pruning_steps</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>exec_pruning_steps</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name>execparamids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>PartitionPruneStepOp</name> <modifier>*</modifier></type>
<name>_readPartitionPruneStepOp</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>PartitionPruneStepOp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name><name>step</name><operator>.</operator><name>step_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>opstrategy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>exprs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>cmpfns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name>nullkeys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>PartitionPruneStepCombine</name> <modifier>*</modifier></type>
<name>_readPartitionPruneStepCombine</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>PartitionPruneStepCombine</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name><name>step</name><operator>.</operator><name>step_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name>combineOp</name></expr></argument>, <argument><expr><name>PartitionPruneCombineOp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>source_stepids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readPlanInvalItem
 */</comment>
<function><type><specifier>static</specifier> <name>PlanInvalItem</name> <modifier>*</modifier></type>
<name>_readPlanInvalItem</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>PlanInvalItem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>cacheId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_UINT_FIELD</name><argument_list>(<argument><expr><name>hashValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readSubPlan
 */</comment>
<function><type><specifier>static</specifier> <name>SubPlan</name> <modifier>*</modifier></type>
<name>_readSubPlan</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>SubPlan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name>subLinkType</name></expr></argument>, <argument><expr><name>SubLinkType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>testexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>paramIds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>plan_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_STRING_FIELD</name><argument_list>(<argument><expr><name>plan_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>firstColType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>firstColTypmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>firstColCollation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>useHashTable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>unknownEqFalse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>parallel_safe</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>is_initplan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/*CDB*/</comment>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>is_multirow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/*CDB*/</comment>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>setParam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>parParam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>extParam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_FLOAT_FIELD</name><argument_list>(<argument><expr><name>startup_cost</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_FLOAT_FIELD</name><argument_list>(<argument><expr><name>per_call_cost</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readAlternativeSubPlan
 */</comment>
<function><type><specifier>static</specifier> <name>AlternativeSubPlan</name> <modifier>*</modifier></type>
<name>_readAlternativeSubPlan</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>AlternativeSubPlan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>subplans</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>RestrictInfo</name> <modifier>*</modifier></type>
<name>_readRestrictInfo</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>RestrictInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* NB: this isn't a complete set of fields */</comment>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>clause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>is_pushed_down</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>outerjoin_delayed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>can_join</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>pseudoconstant</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>contain_outer_query_references</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name>clause_relids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name>required_relids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name>outer_relids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name>nullable_relids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name>left_relids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name>right_relids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>orclause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_FLOAT_FIELD</name><argument_list>(<argument><expr><name>norm_selec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_FLOAT_FIELD</name><argument_list>(<argument><expr><name>outer_selec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>mergeopfamilies</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>left_em</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>right_em</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>outer_is_left</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>hashjoinoperator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>COMPILING_BINARY_FUNCS</name></cpp:ifndef>
<comment type="block">/*
 * _readExtensibleNode
 */</comment>
<function><type><specifier>static</specifier> <name>ExtensibleNode</name> <modifier>*</modifier></type>
<name>_readExtensibleNode</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>ExtensibleNodeMethods</name> <modifier>*</modifier></type><name>methods</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExtensibleNode</name> <modifier>*</modifier></type><name>local_node</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>extnodename</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>READ_TEMP_LOCALS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* skip :extnodename */</comment>
	<expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* get extnodename */</comment>

	<expr_stmt><expr><name>extnodename</name> <operator>=</operator> <call><name>nullable_string</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>extnodename</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"extnodename has to be supplied"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>methods</name> <operator>=</operator> <call><name>GetExtensibleNodeMethods</name><argument_list>(<argument><expr><name>extnodename</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>local_node</name> <operator>=</operator> <operator>(</operator><name>ExtensibleNode</name> <operator>*</operator><operator>)</operator> <call><name>newNode</name><argument_list>(<argument><expr><name><name>methods</name><operator>-&gt;</operator><name>node_size</name></name></expr></argument>,
											<argument><expr><name>T_ExtensibleNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>local_node</name><operator>-&gt;</operator><name>extnodename</name></name> <operator>=</operator> <name>extnodename</name></expr>;</expr_stmt>

	<comment type="block">/* deserialize the private fields */</comment>
	<expr_stmt><expr><call><name><name>methods</name><operator>-&gt;</operator><name>nodeRead</name></name><argument_list>(<argument><expr><name>local_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* COMPILING_BINARY_FUNCS */</comment>

<function><type><specifier>static</specifier> <name>SegfileMapNode</name> <modifier>*</modifier></type>
<name>_readSegfileMapNode</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>SegfileMapNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>segno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ExtTableTypeDesc</name> <modifier>*</modifier></type>
<name>_readExtTableTypeDesc</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>ExtTableTypeDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name>exttabletype</name></expr></argument>, <argument><expr><name>ExtTableType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>location_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>on_clause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_STRING_FIELD</name><argument_list>(<argument><expr><name>command_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>CreateExternalStmt</name> <modifier>*</modifier></type>
<name>_readCreateExternalStmt</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>CreateExternalStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>tableElts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>exttypedesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_STRING_FIELD</name><argument_list>(<argument><expr><name>format</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>formatOpts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>isweb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>iswritable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>sreh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>extOptions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>distributedBy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>CreateSchemaStmt</name> <modifier>*</modifier></type>
<name>_readCreateSchemaStmt</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>CreateSchemaStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_STRING_FIELD</name><argument_list>(<argument><expr><name>schemaname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>authrole</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>local_node</name><operator>-&gt;</operator><name>schemaElts</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>istemp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>CreatePLangStmt</name> <modifier>*</modifier></type>
<name>_readCreatePLangStmt</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>CreatePLangStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>replace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_STRING_FIELD</name><argument_list>(<argument><expr><name>plname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>plhandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>plinline</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>plvalidator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>pltrusted</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>CreateSeqStmt</name> <modifier>*</modifier></type>
<name>_readCreateSeqStmt</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>CreateSeqStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>sequence</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>ownerId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>for_identity</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>if_not_exists</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>AlterSeqStmt</name> <modifier>*</modifier></type>
<name>_readAlterSeqStmt</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>AlterSeqStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>sequence</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>for_identity</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>missing_ok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ClusterStmt</name> <modifier>*</modifier></type>
<name>_readClusterStmt</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>ClusterStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_STRING_FIELD</name><argument_list>(<argument><expr><name>indexname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>CreatedbStmt</name> <modifier>*</modifier></type>
<name>_readCreatedbStmt</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>CreatedbStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_STRING_FIELD</name><argument_list>(<argument><expr><name>dbname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>DropdbStmt</name> <modifier>*</modifier></type>
<name>_readDropdbStmt</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>DropdbStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_STRING_FIELD</name><argument_list>(<argument><expr><name>dbname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>missing_ok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>CreateDomainStmt</name> <modifier>*</modifier></type>
<name>_readCreateDomainStmt</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>CreateDomainStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>domainname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>typeName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>collClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>constraints</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>COMPILING_BINARY_FUNCS</name></cpp:ifndef>
<function><type><specifier>static</specifier> <name>AlterDomainStmt</name> <modifier>*</modifier></type>
<name>_readAlterDomainStmt</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>AlterDomainStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_CHAR_FIELD</name><argument_list>(<argument><expr><name>subtype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>typeName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_STRING_FIELD</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>def</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name>behavior</name></expr></argument>, <argument><expr><name>DropBehavior</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>missing_ok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* COMPILING_BINARY_FUNCS */</comment>

<function><type><specifier>static</specifier> <name>CreateFunctionStmt</name> <modifier>*</modifier></type>
<name>_readCreateFunctionStmt</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>CreateFunctionStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>is_procedure</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>replace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>funcname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>parameters</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>returnType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>FunctionParameter</name> <modifier>*</modifier></type>
<name>_readFunctionParameter</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>FunctionParameter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_STRING_FIELD</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>argType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name>mode</name></expr></argument>, <argument><expr><name>FunctionParameterMode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>defexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>AlterFunctionStmt</name> <modifier>*</modifier></type>
<name>_readAlterFunctionStmt</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>AlterFunctionStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name>objtype</name></expr></argument>,<argument><expr><name>ObjectType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>actions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>DefineStmt</name> <modifier>*</modifier></type>
<name>_readDefineStmt</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>DefineStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name>kind</name></expr></argument>, <argument><expr><name>ObjectType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>oldstyle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>defnames</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>definition</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>if_not_exists</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>replace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>trusted</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>   <comment type="block">/* CDB */</comment>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>CompositeTypeStmt</name> <modifier>*</modifier></type>
<name>_readCompositeTypeStmt</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>CompositeTypeStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>typevar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>coldeflist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>CreateEnumStmt</name> <modifier>*</modifier></type>
<name>_readCreateEnumStmt</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>CreateEnumStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>typeName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>vals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>CreateCastStmt</name> <modifier>*</modifier></type>
<name>_readCreateCastStmt</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>CreateCastStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>sourcetype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>targettype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>CoercionContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>inout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>CreateOpClassStmt</name> <modifier>*</modifier></type>
<name>_readCreateOpClassStmt</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>CreateOpClassStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>opclassname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>opfamilyname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_STRING_FIELD</name><argument_list>(<argument><expr><name>amname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>datatype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>items</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>isDefault</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>CreateOpClassItem</name> <modifier>*</modifier></type>
<name>_readCreateOpClassItem</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>CreateOpClassItem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>itemtype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>number</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>order_family</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>class_args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>storedtype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>CreateOpFamilyStmt</name> <modifier>*</modifier></type>
<name>_readCreateOpFamilyStmt</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>CreateOpFamilyStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>opfamilyname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_STRING_FIELD</name><argument_list>(<argument><expr><name>amname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>AlterOpFamilyStmt</name> <modifier>*</modifier></type>
<name>_readAlterOpFamilyStmt</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>AlterOpFamilyStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>opfamilyname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_STRING_FIELD</name><argument_list>(<argument><expr><name>amname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>isDrop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>items</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>CreateConversionStmt</name> <modifier>*</modifier></type>
<name>_readCreateConversionStmt</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>CreateConversionStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>conversion_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_STRING_FIELD</name><argument_list>(<argument><expr><name>for_encoding_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_STRING_FIELD</name><argument_list>(<argument><expr><name>to_encoding_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>func_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>def</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>GrantStmt</name> <modifier>*</modifier></type>
<name>_readGrantStmt</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>GrantStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>is_grant</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name>targtype</name></expr></argument>,<argument><expr><name>GrantTargetType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name>objtype</name></expr></argument>,<argument><expr><name>ObjectType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>objects</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>privileges</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>grantees</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>grant_option</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name>behavior</name></expr></argument>, <argument><expr><name>DropBehavior</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ObjectWithArgs</name> <modifier>*</modifier></type>
<name>_readObjectWithArgs</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>ObjectWithArgs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>objname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>objargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>args_unspecified</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>COMPILING_BINARY_FUNCS</name></cpp:ifndef>
<function><type><specifier>static</specifier> <name>GrantRoleStmt</name> <modifier>*</modifier></type>
<name>_readGrantRoleStmt</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>GrantRoleStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>granted_roles</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>grantee_roles</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>is_grant</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>admin_opt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>grantor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name>behavior</name></expr></argument>, <argument><expr><name>DropBehavior</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* COMPILING_BINARY_FUNCS */</comment>

<function><type><specifier>static</specifier> <name>LockStmt</name> <modifier>*</modifier></type>
<name>_readLockStmt</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>LockStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>relations</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>nowait</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ConstraintsSetStmt</name> <modifier>*</modifier></type>
<name>_readConstraintsSetStmt</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>ConstraintsSetStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>constraints</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>deferred</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readVacuumStmt
 */</comment>
<function><type><specifier>static</specifier> <name>VacuumStmt</name> <modifier>*</modifier></type>
<name>_readVacuumStmt</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>VacuumStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>rels</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>is_vacuumcmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VacuumRelation</name> <modifier>*</modifier></type>
<name>_readVacuumRelation</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>VacuumRelation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>va_cols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>CreatePublicationStmt</name> <modifier>*</modifier></type>
<name>_readCreatePublicationStmt</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>CreatePublicationStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_STRING_FIELD</name><argument_list>(<argument><expr><name>pubname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>tables</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>for_all_tables</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>AlterPublicationStmt</name> <modifier>*</modifier></type>
<name>_readAlterPublicationStmt</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>AlterPublicationStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_STRING_FIELD</name><argument_list>(<argument><expr><name>pubname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>tables</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>for_all_tables</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name>tableAction</name></expr></argument>, <argument><expr><name>DefElemAction</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>CreateSubscriptionStmt</name> <modifier>*</modifier></type>
<name>_readCreateSubscriptionStmt</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>CreateSubscriptionStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_STRING_FIELD</name><argument_list>(<argument><expr><name>subname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_STRING_FIELD</name><argument_list>(<argument><expr><name>conninfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>publication</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * conninfo can be an empty string, but the serialization
	 * doesn't distinguish an empty string from NULL. The
	 * code that executes the command in't prepared for a NULL.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>local_node</name><operator>-&gt;</operator><name>conninfo</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>local_node</name><operator>-&gt;</operator><name>conninfo</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>DropSubscriptionStmt</name> <modifier>*</modifier></type>
<name>_readDropSubscriptionStmt</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>DropSubscriptionStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_STRING_FIELD</name><argument_list>(<argument><expr><name>subname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>missing_ok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name>behavior</name></expr></argument>, <argument><expr><name>DropBehavior</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>AlterSubscriptionStmt</name> <modifier>*</modifier></type>
<name>_readAlterSubscriptionStmt</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>AlterSubscriptionStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name>kind</name></expr></argument>, <argument><expr><name>AlterSubscriptionType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_STRING_FIELD</name><argument_list>(<argument><expr><name>subname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_STRING_FIELD</name><argument_list>(<argument><expr><name>conninfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>publication</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>CreatePolicyStmt</name> <modifier>*</modifier></type>
<name>_readCreatePolicyStmt</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>CreatePolicyStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_STRING_FIELD</name><argument_list>(<argument><expr><name>policy_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_STRING_FIELD</name><argument_list>(<argument><expr><name>cmd_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>permissive</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>roles</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>qual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>with_check</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>AlterPolicyStmt</name> <modifier>*</modifier></type>
<name>_readAlterPolicyStmt</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>AlterPolicyStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_STRING_FIELD</name><argument_list>(<argument><expr><name>policy_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>roles</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>qual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>with_check</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>CreateTransformStmt</name> <modifier>*</modifier></type>
<name>_readCreateTransformStmt</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>CreateTransformStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>replace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>type_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_STRING_FIELD</name><argument_list>(<argument><expr><name>lang</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>fromsql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>tosql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>CdbProcess</name> <modifier>*</modifier></type>
<name>_readCdbProcess</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>CdbProcess</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_STRING_FIELD</name><argument_list>(<argument><expr><name>listenerAddr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>listenerPort</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>pid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>contentid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>dbid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>SliceTable</name> <modifier>*</modifier></type>
<name>_readSliceTable</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>SliceTable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>localSlice</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>numSlices</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>local_node</name><operator>-&gt;</operator><name>slices</name></name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name><name>local_node</name><operator>-&gt;</operator><name>numSlices</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ExecSlice</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>local_node</name><operator>-&gt;</operator><name>numSlices</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name><name>slices</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sliceIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name><name>slices</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>rootIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name><name>slices</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>parentIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name><name>slices</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>planNumSegments</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name><name>slices</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>children</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* List of int index */</comment>
		<expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name><name>slices</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>gangType</name></expr></argument>, <argument><expr><name>GangType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name><name>slices</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>segments</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* List of int index */</comment>
		<expr_stmt><expr><call><name>READ_DUMMY_FIELD</name><argument_list>(<argument><expr><name><name>slices</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>primaryGang</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name><name>slices</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>primaryProcesses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* List of (CDBProcess *) */</comment>
		<expr_stmt><expr><call><name>READ_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name><name>slices</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>processesMap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>hasMotions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>instrument_options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>ic_instance_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>CursorPosInfo</name> <modifier>*</modifier></type>
<name>_readCursorPosInfo</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>CursorPosInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_STRING_FIELD</name><argument_list>(<argument><expr><name>cursor_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>gp_segment_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_UINT_FIELD</name><argument_list>(<argument><expr><name><name>ctid</name><operator>.</operator><name>ip_blkid</name><operator>.</operator><name>bi_hi</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_UINT_FIELD</name><argument_list>(<argument><expr><name><name>ctid</name><operator>.</operator><name>ip_blkid</name><operator>.</operator><name>bi_lo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_UINT_FIELD</name><argument_list>(<argument><expr><name><name>ctid</name><operator>.</operator><name>ip_posid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_OID_FIELD</name><argument_list>(<argument><expr><name>table_oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>VariableSetStmt</name> <modifier>*</modifier></type>
<name>_readVariableSetStmt</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>VariableSetStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_STRING_FIELD</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name>kind</name></expr></argument>, <argument><expr><name>VariableSetKind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>is_local</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>TableValueExpr</name> <modifier>*</modifier></type>
<name>_readTableValueExpr</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>TableValueExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>subquery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>AlterTypeStmt</name> <modifier>*</modifier></type>
<name>_readAlterTypeStmt</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>AlterTypeStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>typeName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>PartitionElem</name> <modifier>*</modifier></type>
<name>_readPartitionElem</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>PartitionElem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_STRING_FIELD</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>collation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>opclass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>PartitionSpec</name> <modifier>*</modifier></type>
<name>_readPartitionSpec</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>PartitionSpec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_STRING_FIELD</name><argument_list>(<argument><expr><name>strategy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>partParams</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readPartitionBoundSpec
 */</comment>
<function><type><specifier>static</specifier> <name>PartitionBoundSpec</name> <modifier>*</modifier></type>
<name>_readPartitionBoundSpec</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>PartitionBoundSpec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_CHAR_FIELD</name><argument_list>(<argument><expr><name>strategy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>is_default</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>modulus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_INT_FIELD</name><argument_list>(<argument><expr><name>remainder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>listdatums</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>lowerdatums</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>upperdatums</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _readPartitionRangeDatum
 */</comment>
<function><type><specifier>static</specifier> <name>PartitionRangeDatum</name> <modifier>*</modifier></type>
<name>_readPartitionRangeDatum</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>PartitionRangeDatum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name>kind</name></expr></argument>, <argument><expr><name>PartitionRangeDatumKind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>PartitionCmd</name> <modifier>*</modifier></type>
<name>_readPartitionCmd</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>PartitionCmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>bound</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>COMPILING_BINARY_FUNCS</name></cpp:ifndef>
<function><type><specifier>static</specifier> <name>GpPartitionDefinition</name> <modifier>*</modifier></type>
<name>_readGpPartitionDefinition</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>GpPartitionDefinition</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>partDefElems</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>encClauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>isTemplate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>GpPartDefElem</name> <modifier>*</modifier></type>
<name>_readGpPartDefElem</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>GpPartDefElem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_STRING_FIELD</name><argument_list>(<argument><expr><name>partName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>boundSpec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>subSpec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>isDefault</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_STRING_FIELD</name><argument_list>(<argument><expr><name>accessMethod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_STRING_FIELD</name><argument_list>(<argument><expr><name>tablespacename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>colencs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>GpPartitionRangeItem</name> <modifier>*</modifier></type>
<name>_readGpPartitionRangeItem</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>GpPartitionRangeItem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_ENUM_FIELD</name><argument_list>(<argument><expr><name>edge</name></expr></argument>, <argument><expr><name>GpPartitionEdgeBounding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>GpPartitionRangeSpec</name> <modifier>*</modifier></type>
<name>_readGpPartitionRangeSpec</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>GpPartitionRangeSpec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>partStart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>partEnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>partEvery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>GpPartitionListSpec</name> <modifier>*</modifier></type>
<name>_readGpPartitionListSpec</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>GpPartitionListSpec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>partValues</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ColumnReferenceStorageDirective</name> <modifier>*</modifier></type>
<name>_readColumnReferenceStorageDirective</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>READ_LOCALS</name><argument_list>(<argument><expr><name>ColumnReferenceStorageDirective</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_STRING_FIELD</name><argument_list>(<argument><expr><name>column</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_BOOL_FIELD</name><argument_list>(<argument><expr><name>deflt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>READ_NODE_FIELD</name><argument_list>(<argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>READ_DONE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * parseNodeString
 *
 * Given a character string representing a node tree, parseNodeString creates
 * the internal node structure.
 *
 * The string to be read must already have been loaded into pg_strtok().
 */</comment>
<function><type><name>Node</name> <modifier>*</modifier></type>
<name>parseNodeString</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>void</name>	   <modifier>*</modifier></type><name>return_value</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>READ_TEMP_LOCALS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Guard against stack overflow due to overly complex expressions */</comment>
	<expr_stmt><expr><call><name>check_stack_depth</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MATCH</name><parameter_list>(<parameter><type><name>tokname</name></type></parameter>, <parameter><type><name>namelen</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>(length == namelen &amp;&amp; memcmp(token, tokname, namelen) == 0)</cpp:value></cpp:define>

	<comment type="block">/*
	 * Same as MATCH, but we make our life a bit easier by relying on the
	 * compiler to be smart, and evaluate the strlen("&lt;constant&gt;") at
	 * compilation time for us.
	 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MATCHX</name><parameter_list>(<parameter><type><name>tokname</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>(length == strlen(tokname) &amp;&amp; strncmp(token, tokname, strlen(tokname)) == 0)</cpp:value></cpp:define>

	<if_stmt><if>if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"QUERY"</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readQuery</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"WITHCHECKOPTION"</literal></expr></argument>, <argument><expr><literal type="number">15</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readWithCheckOption</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"SORTGROUPCLAUSE"</literal></expr></argument>, <argument><expr><literal type="number">15</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readSortGroupClause</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"GROUPINGSET"</literal></expr></argument>, <argument><expr><literal type="number">11</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readGroupingSet</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"WINDOWCLAUSE"</literal></expr></argument>, <argument><expr><literal type="number">12</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readWindowClause</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"ROWMARKCLAUSE"</literal></expr></argument>, <argument><expr><literal type="number">13</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readRowMarkClause</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"COMMONTABLEEXPR"</literal></expr></argument>, <argument><expr><literal type="number">15</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readCommonTableExpr</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"SETOPERATIONSTMT"</literal></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readSetOperationStmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"ALIAS"</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readAlias</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"RANGEVAR"</literal></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readRangeVar</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"INTOCLAUSE"</literal></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readIntoClause</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"COPYINTOCLAUSE"</literal></expr></argument>, <argument><expr><literal type="number">14</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readCopyIntoClause</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"REFRESHCLAUSE"</literal></expr></argument>, <argument><expr><literal type="number">13</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readRefreshClause</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"TABLEFUNC"</literal></expr></argument>, <argument><expr><literal type="number">9</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readTableFunc</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"VAR"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readVar</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"CONST"</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readConst</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"PARAM"</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readParam</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"AGGREF"</literal></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readAggref</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"GROUPINGFUNC"</literal></expr></argument>, <argument><expr><literal type="number">12</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readGroupingFunc</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"GROUPID"</literal></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readGroupId</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"GROUPINGSETID"</literal></expr></argument>, <argument><expr><literal type="number">13</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readGroupingSetId</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"WINDOWFUNC"</literal></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readWindowFunc</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"SUBSCRIPTINGREF"</literal></expr></argument>, <argument><expr><literal type="number">15</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readSubscriptingRef</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"FUNCEXPR"</literal></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readFuncExpr</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"NAMEDARGEXPR"</literal></expr></argument>, <argument><expr><literal type="number">12</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readNamedArgExpr</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"OPEXPR"</literal></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readOpExpr</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"DISTINCTEXPR"</literal></expr></argument>, <argument><expr><literal type="number">12</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readDistinctExpr</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"NULLIFEXPR"</literal></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readNullIfExpr</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"SCALARARRAYOPEXPR"</literal></expr></argument>, <argument><expr><literal type="number">17</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readScalarArrayOpExpr</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"BOOLEXPR"</literal></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readBoolExpr</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"SUBLINK"</literal></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readSubLink</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"FIELDSELECT"</literal></expr></argument>, <argument><expr><literal type="number">11</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readFieldSelect</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"FIELDSTORE"</literal></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readFieldStore</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"RELABELTYPE"</literal></expr></argument>, <argument><expr><literal type="number">11</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readRelabelType</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"COERCEVIAIO"</literal></expr></argument>, <argument><expr><literal type="number">11</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readCoerceViaIO</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"ARRAYCOERCEEXPR"</literal></expr></argument>, <argument><expr><literal type="number">15</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readArrayCoerceExpr</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"CONVERTROWTYPEEXPR"</literal></expr></argument>, <argument><expr><literal type="number">18</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readConvertRowtypeExpr</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"COLLATE"</literal></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readCollateExpr</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"CASE"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readCaseExpr</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"WHEN"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readCaseWhen</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"CASETESTEXPR"</literal></expr></argument>, <argument><expr><literal type="number">12</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readCaseTestExpr</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"ARRAY"</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readArrayExpr</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"ROW"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readRowExpr</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"ROWCOMPARE"</literal></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readRowCompareExpr</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"COALESCE"</literal></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readCoalesceExpr</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"MINMAX"</literal></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readMinMaxExpr</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"SQLVALUEFUNCTION"</literal></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readSQLValueFunction</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"XMLEXPR"</literal></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readXmlExpr</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"NULLTEST"</literal></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readNullTest</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"BOOLEANTEST"</literal></expr></argument>, <argument><expr><literal type="number">11</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readBooleanTest</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"COERCETODOMAIN"</literal></expr></argument>, <argument><expr><literal type="number">14</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readCoerceToDomain</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"COERCETODOMAINVALUE"</literal></expr></argument>, <argument><expr><literal type="number">19</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readCoerceToDomainValue</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"SETTODEFAULT"</literal></expr></argument>, <argument><expr><literal type="number">12</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readSetToDefault</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"CURRENTOFEXPR"</literal></expr></argument>, <argument><expr><literal type="number">13</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readCurrentOfExpr</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"NEXTVALUEEXPR"</literal></expr></argument>, <argument><expr><literal type="number">13</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readNextValueExpr</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"INFERENCEELEM"</literal></expr></argument>, <argument><expr><literal type="number">13</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readInferenceElem</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"TARGETENTRY"</literal></expr></argument>, <argument><expr><literal type="number">11</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readTargetEntry</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"RANGETBLREF"</literal></expr></argument>, <argument><expr><literal type="number">11</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readRangeTblRef</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"JOINEXPR"</literal></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readJoinExpr</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"FROMEXPR"</literal></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readFromExpr</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"ONCONFLICTEXPR"</literal></expr></argument>, <argument><expr><literal type="number">14</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readOnConflictExpr</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"RTE"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readRangeTblEntry</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"RANGETBLFUNCTION"</literal></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readRangeTblFunction</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"TABLESAMPLECLAUSE"</literal></expr></argument>, <argument><expr><literal type="number">17</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readTableSampleClause</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"NOTIFY"</literal></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readNotifyStmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"DEFELEM"</literal></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readDefElem</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"DECLARECURSOR"</literal></expr></argument>, <argument><expr><literal type="number">13</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readDeclareCursorStmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"PLANNEDSTMT"</literal></expr></argument>, <argument><expr><literal type="number">11</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readPlannedStmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"PLAN"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readPlan</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"RESULT"</literal></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readResult</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"PROJECTSET"</literal></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readProjectSet</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"MODIFYTABLE"</literal></expr></argument>, <argument><expr><literal type="number">11</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readModifyTable</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"APPEND"</literal></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readAppend</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"MERGEAPPEND"</literal></expr></argument>, <argument><expr><literal type="number">11</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readMergeAppend</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"RECURSIVEUNION"</literal></expr></argument>, <argument><expr><literal type="number">14</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readRecursiveUnion</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"BITMAPAND"</literal></expr></argument>, <argument><expr><literal type="number">9</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readBitmapAnd</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"BITMAPOR"</literal></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readBitmapOr</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"SCAN"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readScan</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"SEQSCAN"</literal></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readSeqScan</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"SAMPLESCAN"</literal></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readSampleScan</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"INDEXSCAN"</literal></expr></argument>, <argument><expr><literal type="number">9</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readIndexScan</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"DYNAMICINDEXSCAN"</literal></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readDynamicIndexScan</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"INDEXONLYSCAN"</literal></expr></argument>, <argument><expr><literal type="number">13</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readIndexOnlyScan</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"BITMAPINDEXSCAN"</literal></expr></argument>, <argument><expr><literal type="number">15</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readBitmapIndexScan</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"DYNAMICBITMAPINDEXSCAN"</literal></expr></argument>, <argument><expr><literal type="number">23</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readDynamicBitmapIndexScan</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"BITMAPHEAPSCAN"</literal></expr></argument>, <argument><expr><literal type="number">14</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readBitmapHeapScan</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"DYNAMICBITMAPHEAPSCAN"</literal></expr></argument>, <argument><expr><literal type="number">21</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readDynamicBitmapHeapScan</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"TIDSCAN"</literal></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readTidScan</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"SUBQUERYSCAN"</literal></expr></argument>, <argument><expr><literal type="number">12</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readSubqueryScan</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"TABLEFUNCTIONSCAN"</literal></expr></argument>, <argument><expr><literal type="number">17</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readTableFunctionScan</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"FUNCTIONSCAN"</literal></expr></argument>, <argument><expr><literal type="number">12</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readFunctionScan</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"VALUESSCAN"</literal></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readValuesScan</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"TABLEFUNCSCAN"</literal></expr></argument>, <argument><expr><literal type="number">13</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readTableFuncScan</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"CTESCAN"</literal></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readCteScan</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"NAMEDTUPLESTORESCAN"</literal></expr></argument>, <argument><expr><literal type="number">19</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readNamedTuplestoreScan</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"WORKTABLESCAN"</literal></expr></argument>, <argument><expr><literal type="number">13</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readWorkTableScan</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"FOREIGNSCAN"</literal></expr></argument>, <argument><expr><literal type="number">11</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readForeignScan</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"CUSTOMSCAN"</literal></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readCustomScan</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"JOIN"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readJoin</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"NESTLOOP"</literal></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readNestLoop</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"MERGEJOIN"</literal></expr></argument>, <argument><expr><literal type="number">9</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readMergeJoin</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"HASHJOIN"</literal></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readHashJoin</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"MATERIAL"</literal></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readMaterial</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"SORT"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readSort</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"AGG"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readAgg</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"TupleSplit"</literal></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readTupleSplit</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"DQAExpr"</literal></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readDQAExpr</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"WINDOWAGG"</literal></expr></argument>, <argument><expr><literal type="number">9</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readWindowAgg</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"UNIQUE"</literal></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readUnique</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"GATHER"</literal></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readGather</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"GATHERMERGE"</literal></expr></argument>, <argument><expr><literal type="number">11</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readGatherMerge</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"HASH"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readHash</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"SETOP"</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readSetOp</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"LOCKROWS"</literal></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readLockRows</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"LIMIT"</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readLimit</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"NESTLOOPPARAM"</literal></expr></argument>, <argument><expr><literal type="number">13</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readNestLoopParam</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"PLANROWMARK"</literal></expr></argument>, <argument><expr><literal type="number">11</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readPlanRowMark</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"PARTITIONPRUNEINFO"</literal></expr></argument>, <argument><expr><literal type="number">18</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readPartitionPruneInfo</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"PARTITIONEDRELPRUNEINFO"</literal></expr></argument>, <argument><expr><literal type="number">23</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readPartitionedRelPruneInfo</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"PARTITIONPRUNESTEPOP"</literal></expr></argument>, <argument><expr><literal type="number">20</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readPartitionPruneStepOp</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"PARTITIONPRUNESTEPCOMBINE"</literal></expr></argument>, <argument><expr><literal type="number">25</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readPartitionPruneStepCombine</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"PLANINVALITEM"</literal></expr></argument>, <argument><expr><literal type="number">13</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readPlanInvalItem</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"SUBPLAN"</literal></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readSubPlan</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"ALTERNATIVESUBPLAN"</literal></expr></argument>, <argument><expr><literal type="number">18</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readAlternativeSubPlan</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"RESTRICTINFO"</literal></expr></argument>, <argument><expr><literal type="number">12</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readRestrictInfo</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"EXTENSIBLENODE"</literal></expr></argument>, <argument><expr><literal type="number">14</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readExtensibleNode</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"PARTITIONSPEC"</literal></expr></argument>, <argument><expr><literal type="number">13</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readPartitionSpec</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"PARTITIONELEM"</literal></expr></argument>, <argument><expr><literal type="number">13</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readPartitionElem</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"PARTITIONBOUNDSPEC"</literal></expr></argument>, <argument><expr><literal type="number">18</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readPartitionBoundSpec</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><call><name>MATCH</name><argument_list>(<argument><expr><literal type="string">"PARTITIONRANGEDATUM"</literal></expr></argument>, <argument><expr><literal type="number">19</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readPartitionRangeDatum</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCHX</name><argument_list>(<argument><expr><literal type="string">"PARTITIONCMD"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readPartitionCmd</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>

	<comment type="block">/* GPDB additions */</comment>
	<if type="elseif">else if <condition>(<expr><call><name>MATCHX</name><argument_list>(<argument><expr><literal type="string">"A_ARRAYEXPR"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readA_ArrayExpr</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCHX</name><argument_list>(<argument><expr><literal type="string">"A_CONST"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readAConst</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCHX</name><argument_list>(<argument><expr><literal type="string">"AEXPR"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readAExpr</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCHX</name><argument_list>(<argument><expr><literal type="string">"ALTERDOMAINSTMT"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readAlterDomainStmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCHX</name><argument_list>(<argument><expr><literal type="string">"ALTERFUNCTIONSTMT"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readAlterFunctionStmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCHX</name><argument_list>(<argument><expr><literal type="string">"ALTEROBJECTSCHEMASTMT"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readAlterObjectSchemaStmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCHX</name><argument_list>(<argument><expr><literal type="string">"ALTEROWNERSTMT"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readAlterOwnerStmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCHX</name><argument_list>(<argument><expr><literal type="string">"ALTEROPFAMILYSTMT"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readAlterOpFamilyStmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCHX</name><argument_list>(<argument><expr><literal type="string">"ALTERPOLICYSTMT"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readAlterPolicyStmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCHX</name><argument_list>(<argument><expr><literal type="string">"ALTERROLESETSTMT"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readAlterRoleSetStmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCHX</name><argument_list>(<argument><expr><literal type="string">"ALTERSYSTEMSTMT"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readAlterSystemStmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCHX</name><argument_list>(<argument><expr><literal type="string">"ALTERROLESTMT"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readAlterRoleStmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCHX</name><argument_list>(<argument><expr><literal type="string">"ALTERSEQSTMT"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readAlterSeqStmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCHX</name><argument_list>(<argument><expr><literal type="string">"ALTERTABLECMD"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readAlterTableCmd</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCHX</name><argument_list>(<argument><expr><literal type="string">"ALTEREDTABLEINFO"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readAlteredTableInfo</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCHX</name><argument_list>(<argument><expr><literal type="string">"NEWCONSTRAINT"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readNewConstraint</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCHX</name><argument_list>(<argument><expr><literal type="string">"NEWCOLUMNVALUE"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readNewColumnValue</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCHX</name><argument_list>(<argument><expr><literal type="string">"ALTERDATABASESTMT"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readAlterDatabaseStmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCHX</name><argument_list>(<argument><expr><literal type="string">"ALTERTABLESTMT"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readAlterTableStmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCHX</name><argument_list>(<argument><expr><literal type="string">"ALTERTYPESTMT"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readAlterTypeStmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCHX</name><argument_list>(<argument><expr><literal type="string">"CDBPROCESS"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readCdbProcess</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCHX</name><argument_list>(<argument><expr><literal type="string">"CLUSTERSTMT"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readClusterStmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCHX</name><argument_list>(<argument><expr><literal type="string">"COLUMNDEF"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readColumnDef</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCHX</name><argument_list>(<argument><expr><literal type="string">"COLUMNREF"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readColumnRef</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCHX</name><argument_list>(<argument><expr><literal type="string">"COMMONTABLEEXPR"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readCommonTableExpr</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCHX</name><argument_list>(<argument><expr><literal type="string">"COMPTYPESTMT"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readCompositeTypeStmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCHX</name><argument_list>(<argument><expr><literal type="string">"CONSTRAINT"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readConstraint</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCHX</name><argument_list>(<argument><expr><literal type="string">"CONSTRAINTSSETSTMT"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readConstraintsSetStmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCHX</name><argument_list>(<argument><expr><literal type="string">"CREATECAST"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readCreateCastStmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCHX</name><argument_list>(<argument><expr><literal type="string">"CREATECONVERSION"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readCreateConversionStmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCHX</name><argument_list>(<argument><expr><literal type="string">"CREATEDBSTMT"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readCreatedbStmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCHX</name><argument_list>(<argument><expr><literal type="string">"CREATEDOMAINSTMT"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readCreateDomainStmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCHX</name><argument_list>(<argument><expr><literal type="string">"CREATEENUMSTMT"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readCreateEnumStmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCHX</name><argument_list>(<argument><expr><literal type="string">"CREATEEXTERNALSTMT"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readCreateExternalStmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCHX</name><argument_list>(<argument><expr><literal type="string">"CREATEFUNCSTMT"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readCreateFunctionStmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCHX</name><argument_list>(<argument><expr><literal type="string">"CREATEOPCLASS"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readCreateOpClassStmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCHX</name><argument_list>(<argument><expr><literal type="string">"CREATEOPCLASSITEM"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readCreateOpClassItem</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCHX</name><argument_list>(<argument><expr><literal type="string">"CREATEOPFAMILYSTMT"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readCreateOpFamilyStmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCHX</name><argument_list>(<argument><expr><literal type="string">"CREATEPLANGSTMT"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readCreatePLangStmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCHX</name><argument_list>(<argument><expr><literal type="string">"CREATEPUBLICATIONSTMT"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readCreatePublicationStmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCHX</name><argument_list>(<argument><expr><literal type="string">"ALTERPUBLICATIONSTMT"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readAlterPublicationStmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCHX</name><argument_list>(<argument><expr><literal type="string">"CREATESUBSCRIPTIONSTMT"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readCreateSubscriptionStmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCHX</name><argument_list>(<argument><expr><literal type="string">"DROPSUBSCRIPTIONSTMT"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readDropSubscriptionStmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCHX</name><argument_list>(<argument><expr><literal type="string">"ALTERSUBSCRIPTIONSTMT"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readAlterSubscriptionStmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCHX</name><argument_list>(<argument><expr><literal type="string">"CREATEPOLICYSTMT"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readCreatePolicyStmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCHX</name><argument_list>(<argument><expr><literal type="string">"CREATEROLESTMT"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readCreateRoleStmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCHX</name><argument_list>(<argument><expr><literal type="string">"CREATESCHEMASTMT"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readCreateSchemaStmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCHX</name><argument_list>(<argument><expr><literal type="string">"CREATESEQSTMT"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readCreateSeqStmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCHX</name><argument_list>(<argument><expr><literal type="string">"CREATETRANSFORMSTMT"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readCreateTransformStmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCHX</name><argument_list>(<argument><expr><literal type="string">"CURSORPOSINFO"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readCursorPosInfo</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCHX</name><argument_list>(<argument><expr><literal type="string">"DEFELEM"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readDefElem</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCHX</name><argument_list>(<argument><expr><literal type="string">"DEFINESTMT"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readDefineStmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCHX</name><argument_list>(<argument><expr><literal type="string">"DENYLOGININTERVAL"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readDenyLoginInterval</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCHX</name><argument_list>(<argument><expr><literal type="string">"DENYLOGINPOINT"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readDenyLoginPoint</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCHX</name><argument_list>(<argument><expr><literal type="string">"DROPDBSTMT"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readDropdbStmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCHX</name><argument_list>(<argument><expr><literal type="string">"DROPROLESTMT"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readDropRoleStmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCHX</name><argument_list>(<argument><expr><literal type="string">"DROPSTMT"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readDropStmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCHX</name><argument_list>(<argument><expr><literal type="string">"DISTRIBUTIONKEYELEM"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readDistributionKeyElem</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCHX</name><argument_list>(<argument><expr><literal type="string">"EXTTABLETYPEDESC"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readExtTableTypeDesc</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCHX</name><argument_list>(<argument><expr><literal type="string">"FUNCCALL"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readFuncCall</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCHX</name><argument_list>(<argument><expr><literal type="string">"FUNCTIONPARAMETER"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readFunctionParameter</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCHX</name><argument_list>(<argument><expr><literal type="string">"OBJECTWITHARGS"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readObjectWithArgs</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCHX</name><argument_list>(<argument><expr><literal type="string">"GRANTROLESTMT"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readGrantRoleStmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCHX</name><argument_list>(<argument><expr><literal type="string">"GRANTSTMT"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readGrantStmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCHX</name><argument_list>(<argument><expr><literal type="string">"INDEXELEM"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readIndexElem</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCHX</name><argument_list>(<argument><expr><literal type="string">"INDEXSTMT"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readIndexStmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCHX</name><argument_list>(<argument><expr><literal type="string">"LOCKSTMT"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readLockStmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCHX</name><argument_list>(<argument><expr><literal type="string">"REINDEXSTMT"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readReindexStmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCHX</name><argument_list>(<argument><expr><literal type="string">"RENAMESTMT"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readRenameStmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCHX</name><argument_list>(<argument><expr><literal type="string">"REPLICAIDENTITYSTMT"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readReplicaIdentityStmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCHX</name><argument_list>(<argument><expr><literal type="string">"RULESTMT"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readRuleStmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCHX</name><argument_list>(<argument><expr><literal type="string">"SEGFILEMAPNODE"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readSegfileMapNode</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCHX</name><argument_list>(<argument><expr><literal type="string">"SINGLEROWERRORDESC"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readSingleRowErrorDesc</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCHX</name><argument_list>(<argument><expr><literal type="string">"SLICETABLE"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readSliceTable</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCHX</name><argument_list>(<argument><expr><literal type="string">"SORTBY"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readSortBy</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCHX</name><argument_list>(<argument><expr><literal type="string">"TABLEVALUEEXPR"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readTableValueExpr</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCHX</name><argument_list>(<argument><expr><literal type="string">"TRUNCATESTMT"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readTruncateStmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCHX</name><argument_list>(<argument><expr><literal type="string">"TYPECAST"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readTypeCast</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCHX</name><argument_list>(<argument><expr><literal type="string">"TYPENAME"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readTypeName</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCHX</name><argument_list>(<argument><expr><literal type="string">"VACUUMSTMT"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readVacuumStmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCHX</name><argument_list>(<argument><expr><literal type="string">"VACUUMRELATION"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readVacuumRelation</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCHX</name><argument_list>(<argument><expr><literal type="string">"VARIABLESETSTMT"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readVariableSetStmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCHX</name><argument_list>(<argument><expr><literal type="string">"VIEWSTMT"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readViewStmt</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCHX</name><argument_list>(<argument><expr><literal type="string">"WITHCLAUSE"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readWithClause</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCHX</name><argument_list>(<argument><expr><literal type="string">"GPPARTITIONDEFINITION"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readGpPartitionDefinition</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCHX</name><argument_list>(<argument><expr><literal type="string">"GPPARTDEFELEM"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readGpPartDefElem</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCHX</name><argument_list>(<argument><expr><literal type="string">"GPPARTITIONRANGEITEM"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readGpPartitionRangeItem</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCHX</name><argument_list>(<argument><expr><literal type="string">"GPPARTITIONRANGESPEC"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readGpPartitionRangeSpec</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCHX</name><argument_list>(<argument><expr><literal type="string">"GPPARTITIONLISTSPEC"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readGpPartitionListSpec</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>MATCHX</name><argument_list>(<argument><expr><literal type="string">"COLUMNREFERENCESTORAGEDIRECTIVE"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <call><name>_readColumnReferenceStorageDirective</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"This operation involves an internal data item "</literal>
						<literal type="string">"of a type called \"%.*s\" which is not "</literal>
						<literal type="string">"supported in this version of %s."</literal></expr></argument>,
						<argument><expr><name>length</name></expr></argument>, <argument><expr><name>token</name></expr></argument>, <argument><expr><name>PACKAGE_NAME</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>return_value</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>	<comment type="block">/* keep compiler quiet */</comment>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>return_value</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * readDatum
 *
 * Given a string representation of a constant, recreate the appropriate
 * Datum.  The string representation embeds length info, but not byValue,
 * so we must be told that.
 */</comment>
<function><type><name>Datum</name></type>
<name>readDatum</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>typbyval</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Size</name></type>		<name>length</name></decl>,
				<decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>tokenLength</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>token</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * read the actual length of the value
	 */</comment>
	<expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tokenLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>length</name> <operator>=</operator> <call><name>atoui</name><argument_list>(<argument><expr><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tokenLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* read the '[' */</comment>
	<if_stmt><if>if <condition>(<expr><name>token</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>token</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'['</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"expected \"[\" to start datum, but got \"%s\"; length = %zu"</literal></expr></argument>,
			 <argument><expr><ternary><condition><expr><name>token</name></expr> ?</condition><then> <expr><name>token</name></expr> </then><else>: <expr><literal type="string">"[NULL]"</literal></expr></else></ternary></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>typbyval</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>length</name> <operator>&gt;</operator> <operator>(</operator><name>Size</name><operator>)</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"byval datum but length = %zu"</literal></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>res</name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>s</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>&amp;</operator><name>res</name><operator>)</operator></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <operator>(</operator><name>Size</name><operator>)</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tokenLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>)</operator> <call><name>atoi</name><argument_list>(<argument><expr><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>length</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>res</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>s</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>length</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tokenLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>)</operator> <call><name>atoi</name><argument_list>(<argument><expr><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tokenLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* read the ']' */</comment>
	<if_stmt><if>if <condition>(<expr><name>token</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>token</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">']'</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"expected \"]\" to end datum, but got \"%s\"; length = %zu"</literal></expr></argument>,
			 <argument><expr><ternary><condition><expr><name>token</name></expr> ?</condition><then> <expr><name>token</name></expr> </then><else>: <expr><literal type="string">"[NULL]"</literal></expr></else></ternary></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * readAttrNumberCols
 */</comment>
<function><type><name>AttrNumber</name> <modifier>*</modifier></type>
<name>readAttrNumberCols</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>numCols</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>tokenLength</name></decl>,
				<decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>token</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>attr_vals</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>numCols</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>attr_vals</name> <operator>=</operator> <operator>(</operator><name>AttrNumber</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>numCols</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>AttrNumber</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numCols</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tokenLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>attr_vals</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>attr_vals</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * readOidCols
 */</comment>
<function><type><name>Oid</name> <modifier>*</modifier></type>
<name>readOidCols</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>numCols</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>tokenLength</name></decl>,
				<decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>token</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name>		   <modifier>*</modifier></type><name>oid_vals</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>numCols</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>oid_vals</name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>numCols</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numCols</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tokenLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>oid_vals</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>atooid</name><argument_list>(<argument><expr><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>oid_vals</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * readIntCols
 */</comment>
<function><type><name>int</name> <modifier>*</modifier></type>
<name>readIntCols</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>numCols</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>tokenLength</name></decl>,
				<decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>token</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name>		   <modifier>*</modifier></type><name>int_vals</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>numCols</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>int_vals</name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>numCols</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numCols</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tokenLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>int_vals</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>int_vals</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * readBoolCols
 */</comment>
<function><type><name>bool</name> <modifier>*</modifier></type>
<name>readBoolCols</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>numCols</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>tokenLength</name></decl>,
				<decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>token</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>bool_vals</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>numCols</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>bool_vals</name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>numCols</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numCols</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tokenLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>bool_vals</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>strtobool</name><argument_list>(<argument><expr><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>bool_vals</name></expr>;</return>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* COMPILING_BINARY_FUNCS */</comment>
</unit>
