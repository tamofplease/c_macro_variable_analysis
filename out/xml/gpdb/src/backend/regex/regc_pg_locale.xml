<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/backend/regex/regc_pg_locale.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * regc_pg_locale.c
 *	  ctype functions adapted to work on pg_wchar (a/k/a chr),
 *	  and functions to cache the results of wholesale ctype probing.
 *
 * This file is #included by regcomp.c; it's not meant to compile standalone.
 *
 * Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 * IDENTIFICATION
 *	  src/backend/regex/regc_pg_locale.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_collation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/pg_locale.h"</cpp:file></cpp:include>

<comment type="block">/*
 * To provide as much functionality as possible on a variety of platforms,
 * without going so far as to implement everything from scratch, we use
 * several implementation strategies depending on the situation:
 *
 * 1. In C/POSIX collations, we use hard-wired code.  We can't depend on
 * the &lt;ctype.h&gt; functions since those will obey LC_CTYPE.  Note that these
 * collations don't give a fig about multibyte characters.
 *
 * 2. In the "default" collation (which is supposed to obey LC_CTYPE):
 *
 * 2a. When working in UTF8 encoding, we use the &lt;wctype.h&gt; functions.
 * This assumes that every platform uses Unicode codepoints directly
 * as the wchar_t representation of Unicode.  On some platforms
 * wchar_t is only 16 bits wide, so we have to punt for codepoints &gt; 0xFFFF.
 *
 * 2b. In all other encodings, we use the &lt;ctype.h&gt; functions for pg_wchar
 * values up to 255, and punt for values above that.  This is 100% correct
 * only in single-byte encodings such as LATINn.  However, non-Unicode
 * multibyte encodings are mostly Far Eastern character sets for which the
 * properties being tested here aren't very relevant for higher code values
 * anyway.  The difficulty with using the &lt;wctype.h&gt; functions with
 * non-Unicode multibyte encodings is that we can have no certainty that
 * the platform's wchar_t representation matches what we do in pg_wchar
 * conversions.
 *
 * 3. Other collations are only supported on platforms that HAVE_LOCALE_T.
 * Here, we use the locale_t-extended forms of the &lt;wctype.h&gt; and &lt;ctype.h&gt;
 * functions, under exactly the same cases as #2.
 *
 * There is one notable difference between cases 2 and 3: in the "default"
 * collation we force ASCII letters to follow ASCII upcase/downcase rules,
 * while in a non-default collation we just let the library functions do what
 * they will.  The case where this matters is treatment of I/i in Turkish,
 * and the behavior is meant to match the upper()/lower() SQL functions.
 *
 * We store the active collation setting in static variables.  In principle
 * it could be passed down to here via the regex library's "struct vars" data
 * structure; but that would require somewhat invasive changes in the regex
 * library, and right now there's no real benefit to be gained from that.
 *
 * NB: the coding here assumes pg_wchar is an unsigned type.
 */</comment>

<typedef>typedef <type><enum>enum
<block>{
	<decl><name>PG_REGEX_LOCALE_C</name></decl>,			<comment type="block">/* C locale (encoding independent) */</comment>
	<decl><name>PG_REGEX_LOCALE_WIDE</name></decl>,		<comment type="block">/* Use &lt;wctype.h&gt; functions */</comment>
	<decl><name>PG_REGEX_LOCALE_1BYTE</name></decl>,		<comment type="block">/* Use &lt;ctype.h&gt; functions */</comment>
	<decl><name>PG_REGEX_LOCALE_WIDE_L</name></decl>,		<comment type="block">/* Use locale_t &lt;wctype.h&gt; functions */</comment>
	<decl><name>PG_REGEX_LOCALE_1BYTE_L</name></decl>,	<comment type="block">/* Use locale_t &lt;ctype.h&gt; functions */</comment>
	<decl><name>PG_REGEX_LOCALE_ICU</name></decl>			<comment type="block">/* Use ICU uchar.h functions */</comment>
}</block></enum></type> <name>PG_Locale_Strategy</name>;</typedef>

<decl_stmt><decl><type><specifier>static</specifier> <name>PG_Locale_Strategy</name></type> <name>pg_regex_strategy</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>pg_locale_t</name></type> <name>pg_regex_locale</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>Oid</name></type>	<name>pg_regex_collation</name></decl>;</decl_stmt>

<comment type="block">/*
 * Hard-wired character properties for C locale
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PG_ISDIGIT</name></cpp:macro>	<cpp:value>0x01</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PG_ISALPHA</name></cpp:macro>	<cpp:value>0x02</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PG_ISALNUM</name></cpp:macro>	<cpp:value>(PG_ISDIGIT | PG_ISALPHA)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PG_ISUPPER</name></cpp:macro>	<cpp:value>0x04</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PG_ISLOWER</name></cpp:macro>	<cpp:value>0x08</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PG_ISGRAPH</name></cpp:macro>	<cpp:value>0x10</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PG_ISPRINT</name></cpp:macro>	<cpp:value>0x20</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PG_ISPUNCT</name></cpp:macro>	<cpp:value>0x40</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PG_ISSPACE</name></cpp:macro>	<cpp:value>0x80</cpp:value></cpp:define>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>unsigned</name> <name>char</name></type> <name><name>pg_char_properties</name><index>[<expr><literal type="number">128</literal></expr>]</index></name> <init>= <expr><block>{
	 <comment type="block">/* NUL */</comment> <expr><literal type="number">0</literal></expr>,
	 <comment type="block">/* ^A */</comment> <expr><literal type="number">0</literal></expr>,
	 <comment type="block">/* ^B */</comment> <expr><literal type="number">0</literal></expr>,
	 <comment type="block">/* ^C */</comment> <expr><literal type="number">0</literal></expr>,
	 <comment type="block">/* ^D */</comment> <expr><literal type="number">0</literal></expr>,
	 <comment type="block">/* ^E */</comment> <expr><literal type="number">0</literal></expr>,
	 <comment type="block">/* ^F */</comment> <expr><literal type="number">0</literal></expr>,
	 <comment type="block">/* ^G */</comment> <expr><literal type="number">0</literal></expr>,
	 <comment type="block">/* ^H */</comment> <expr><literal type="number">0</literal></expr>,
	 <comment type="block">/* ^I */</comment> <expr><name>PG_ISSPACE</name></expr>,
	 <comment type="block">/* ^J */</comment> <expr><name>PG_ISSPACE</name></expr>,
	 <comment type="block">/* ^K */</comment> <expr><name>PG_ISSPACE</name></expr>,
	 <comment type="block">/* ^L */</comment> <expr><name>PG_ISSPACE</name></expr>,
	 <comment type="block">/* ^M */</comment> <expr><name>PG_ISSPACE</name></expr>,
	 <comment type="block">/* ^N */</comment> <expr><literal type="number">0</literal></expr>,
	 <comment type="block">/* ^O */</comment> <expr><literal type="number">0</literal></expr>,
	 <comment type="block">/* ^P */</comment> <expr><literal type="number">0</literal></expr>,
	 <comment type="block">/* ^Q */</comment> <expr><literal type="number">0</literal></expr>,
	 <comment type="block">/* ^R */</comment> <expr><literal type="number">0</literal></expr>,
	 <comment type="block">/* ^S */</comment> <expr><literal type="number">0</literal></expr>,
	 <comment type="block">/* ^T */</comment> <expr><literal type="number">0</literal></expr>,
	 <comment type="block">/* ^U */</comment> <expr><literal type="number">0</literal></expr>,
	 <comment type="block">/* ^V */</comment> <expr><literal type="number">0</literal></expr>,
	 <comment type="block">/* ^W */</comment> <expr><literal type="number">0</literal></expr>,
	 <comment type="block">/* ^X */</comment> <expr><literal type="number">0</literal></expr>,
	 <comment type="block">/* ^Y */</comment> <expr><literal type="number">0</literal></expr>,
	 <comment type="block">/* ^Z */</comment> <expr><literal type="number">0</literal></expr>,
	 <comment type="block">/* ^[ */</comment> <expr><literal type="number">0</literal></expr>,
	 <comment type="block">/* ^\ */</comment> <expr><literal type="number">0</literal></expr>,
	 <comment type="block">/* ^] */</comment> <expr><literal type="number">0</literal></expr>,
	 <comment type="block">/* ^^ */</comment> <expr><literal type="number">0</literal></expr>,
	 <comment type="block">/* ^_ */</comment> <expr><literal type="number">0</literal></expr>,
	 <comment type="block">/* */</comment> <expr><name>PG_ISPRINT</name> <operator>|</operator> <name>PG_ISSPACE</name></expr>,
	 <comment type="block">/* !  */</comment> <expr><name>PG_ISGRAPH</name> <operator>|</operator> <name>PG_ISPRINT</name> <operator>|</operator> <name>PG_ISPUNCT</name></expr>,
	 <comment type="block">/* "  */</comment> <expr><name>PG_ISGRAPH</name> <operator>|</operator> <name>PG_ISPRINT</name> <operator>|</operator> <name>PG_ISPUNCT</name></expr>,
	 <comment type="block">/* #  */</comment> <expr><name>PG_ISGRAPH</name> <operator>|</operator> <name>PG_ISPRINT</name> <operator>|</operator> <name>PG_ISPUNCT</name></expr>,
	 <comment type="block">/* $  */</comment> <expr><name>PG_ISGRAPH</name> <operator>|</operator> <name>PG_ISPRINT</name> <operator>|</operator> <name>PG_ISPUNCT</name></expr>,
	 <comment type="block">/* %  */</comment> <expr><name>PG_ISGRAPH</name> <operator>|</operator> <name>PG_ISPRINT</name> <operator>|</operator> <name>PG_ISPUNCT</name></expr>,
	 <comment type="block">/* &amp;  */</comment> <expr><name>PG_ISGRAPH</name> <operator>|</operator> <name>PG_ISPRINT</name> <operator>|</operator> <name>PG_ISPUNCT</name></expr>,
	 <comment type="block">/* '  */</comment> <expr><name>PG_ISGRAPH</name> <operator>|</operator> <name>PG_ISPRINT</name> <operator>|</operator> <name>PG_ISPUNCT</name></expr>,
	 <comment type="block">/* (  */</comment> <expr><name>PG_ISGRAPH</name> <operator>|</operator> <name>PG_ISPRINT</name> <operator>|</operator> <name>PG_ISPUNCT</name></expr>,
	 <comment type="block">/* )  */</comment> <expr><name>PG_ISGRAPH</name> <operator>|</operator> <name>PG_ISPRINT</name> <operator>|</operator> <name>PG_ISPUNCT</name></expr>,
	 <comment type="block">/* *  */</comment> <expr><name>PG_ISGRAPH</name> <operator>|</operator> <name>PG_ISPRINT</name> <operator>|</operator> <name>PG_ISPUNCT</name></expr>,
	 <comment type="block">/* +  */</comment> <expr><name>PG_ISGRAPH</name> <operator>|</operator> <name>PG_ISPRINT</name> <operator>|</operator> <name>PG_ISPUNCT</name></expr>,
	 <comment type="block">/* ,  */</comment> <expr><name>PG_ISGRAPH</name> <operator>|</operator> <name>PG_ISPRINT</name> <operator>|</operator> <name>PG_ISPUNCT</name></expr>,
	 <comment type="block">/* -  */</comment> <expr><name>PG_ISGRAPH</name> <operator>|</operator> <name>PG_ISPRINT</name> <operator>|</operator> <name>PG_ISPUNCT</name></expr>,
	 <comment type="block">/* .  */</comment> <expr><name>PG_ISGRAPH</name> <operator>|</operator> <name>PG_ISPRINT</name> <operator>|</operator> <name>PG_ISPUNCT</name></expr>,
	 <comment type="block">/* /  */</comment> <expr><name>PG_ISGRAPH</name> <operator>|</operator> <name>PG_ISPRINT</name> <operator>|</operator> <name>PG_ISPUNCT</name></expr>,
	 <comment type="block">/* 0  */</comment> <expr><name>PG_ISDIGIT</name> <operator>|</operator> <name>PG_ISGRAPH</name> <operator>|</operator> <name>PG_ISPRINT</name></expr>,
	 <comment type="block">/* 1  */</comment> <expr><name>PG_ISDIGIT</name> <operator>|</operator> <name>PG_ISGRAPH</name> <operator>|</operator> <name>PG_ISPRINT</name></expr>,
	 <comment type="block">/* 2  */</comment> <expr><name>PG_ISDIGIT</name> <operator>|</operator> <name>PG_ISGRAPH</name> <operator>|</operator> <name>PG_ISPRINT</name></expr>,
	 <comment type="block">/* 3  */</comment> <expr><name>PG_ISDIGIT</name> <operator>|</operator> <name>PG_ISGRAPH</name> <operator>|</operator> <name>PG_ISPRINT</name></expr>,
	 <comment type="block">/* 4  */</comment> <expr><name>PG_ISDIGIT</name> <operator>|</operator> <name>PG_ISGRAPH</name> <operator>|</operator> <name>PG_ISPRINT</name></expr>,
	 <comment type="block">/* 5  */</comment> <expr><name>PG_ISDIGIT</name> <operator>|</operator> <name>PG_ISGRAPH</name> <operator>|</operator> <name>PG_ISPRINT</name></expr>,
	 <comment type="block">/* 6  */</comment> <expr><name>PG_ISDIGIT</name> <operator>|</operator> <name>PG_ISGRAPH</name> <operator>|</operator> <name>PG_ISPRINT</name></expr>,
	 <comment type="block">/* 7  */</comment> <expr><name>PG_ISDIGIT</name> <operator>|</operator> <name>PG_ISGRAPH</name> <operator>|</operator> <name>PG_ISPRINT</name></expr>,
	 <comment type="block">/* 8  */</comment> <expr><name>PG_ISDIGIT</name> <operator>|</operator> <name>PG_ISGRAPH</name> <operator>|</operator> <name>PG_ISPRINT</name></expr>,
	 <comment type="block">/* 9  */</comment> <expr><name>PG_ISDIGIT</name> <operator>|</operator> <name>PG_ISGRAPH</name> <operator>|</operator> <name>PG_ISPRINT</name></expr>,
	 <comment type="block">/* :  */</comment> <expr><name>PG_ISGRAPH</name> <operator>|</operator> <name>PG_ISPRINT</name> <operator>|</operator> <name>PG_ISPUNCT</name></expr>,
	 <comment type="block">/* ;  */</comment> <expr><name>PG_ISGRAPH</name> <operator>|</operator> <name>PG_ISPRINT</name> <operator>|</operator> <name>PG_ISPUNCT</name></expr>,
	 <comment type="block">/* &lt;  */</comment> <expr><name>PG_ISGRAPH</name> <operator>|</operator> <name>PG_ISPRINT</name> <operator>|</operator> <name>PG_ISPUNCT</name></expr>,
	 <comment type="block">/* =  */</comment> <expr><name>PG_ISGRAPH</name> <operator>|</operator> <name>PG_ISPRINT</name> <operator>|</operator> <name>PG_ISPUNCT</name></expr>,
	 <comment type="block">/* &gt;  */</comment> <expr><name>PG_ISGRAPH</name> <operator>|</operator> <name>PG_ISPRINT</name> <operator>|</operator> <name>PG_ISPUNCT</name></expr>,
	 <comment type="block">/* ?  */</comment> <expr><name>PG_ISGRAPH</name> <operator>|</operator> <name>PG_ISPRINT</name> <operator>|</operator> <name>PG_ISPUNCT</name></expr>,
	 <comment type="block">/* @  */</comment> <expr><name>PG_ISGRAPH</name> <operator>|</operator> <name>PG_ISPRINT</name> <operator>|</operator> <name>PG_ISPUNCT</name></expr>,
	 <comment type="block">/* A  */</comment> <expr><name>PG_ISALPHA</name> <operator>|</operator> <name>PG_ISUPPER</name> <operator>|</operator> <name>PG_ISGRAPH</name> <operator>|</operator> <name>PG_ISPRINT</name></expr>,
	 <comment type="block">/* B  */</comment> <expr><name>PG_ISALPHA</name> <operator>|</operator> <name>PG_ISUPPER</name> <operator>|</operator> <name>PG_ISGRAPH</name> <operator>|</operator> <name>PG_ISPRINT</name></expr>,
	 <comment type="block">/* C  */</comment> <expr><name>PG_ISALPHA</name> <operator>|</operator> <name>PG_ISUPPER</name> <operator>|</operator> <name>PG_ISGRAPH</name> <operator>|</operator> <name>PG_ISPRINT</name></expr>,
	 <comment type="block">/* D  */</comment> <expr><name>PG_ISALPHA</name> <operator>|</operator> <name>PG_ISUPPER</name> <operator>|</operator> <name>PG_ISGRAPH</name> <operator>|</operator> <name>PG_ISPRINT</name></expr>,
	 <comment type="block">/* E  */</comment> <expr><name>PG_ISALPHA</name> <operator>|</operator> <name>PG_ISUPPER</name> <operator>|</operator> <name>PG_ISGRAPH</name> <operator>|</operator> <name>PG_ISPRINT</name></expr>,
	 <comment type="block">/* F  */</comment> <expr><name>PG_ISALPHA</name> <operator>|</operator> <name>PG_ISUPPER</name> <operator>|</operator> <name>PG_ISGRAPH</name> <operator>|</operator> <name>PG_ISPRINT</name></expr>,
	 <comment type="block">/* G  */</comment> <expr><name>PG_ISALPHA</name> <operator>|</operator> <name>PG_ISUPPER</name> <operator>|</operator> <name>PG_ISGRAPH</name> <operator>|</operator> <name>PG_ISPRINT</name></expr>,
	 <comment type="block">/* H  */</comment> <expr><name>PG_ISALPHA</name> <operator>|</operator> <name>PG_ISUPPER</name> <operator>|</operator> <name>PG_ISGRAPH</name> <operator>|</operator> <name>PG_ISPRINT</name></expr>,
	 <comment type="block">/* I  */</comment> <expr><name>PG_ISALPHA</name> <operator>|</operator> <name>PG_ISUPPER</name> <operator>|</operator> <name>PG_ISGRAPH</name> <operator>|</operator> <name>PG_ISPRINT</name></expr>,
	 <comment type="block">/* J  */</comment> <expr><name>PG_ISALPHA</name> <operator>|</operator> <name>PG_ISUPPER</name> <operator>|</operator> <name>PG_ISGRAPH</name> <operator>|</operator> <name>PG_ISPRINT</name></expr>,
	 <comment type="block">/* K  */</comment> <expr><name>PG_ISALPHA</name> <operator>|</operator> <name>PG_ISUPPER</name> <operator>|</operator> <name>PG_ISGRAPH</name> <operator>|</operator> <name>PG_ISPRINT</name></expr>,
	 <comment type="block">/* L  */</comment> <expr><name>PG_ISALPHA</name> <operator>|</operator> <name>PG_ISUPPER</name> <operator>|</operator> <name>PG_ISGRAPH</name> <operator>|</operator> <name>PG_ISPRINT</name></expr>,
	 <comment type="block">/* M  */</comment> <expr><name>PG_ISALPHA</name> <operator>|</operator> <name>PG_ISUPPER</name> <operator>|</operator> <name>PG_ISGRAPH</name> <operator>|</operator> <name>PG_ISPRINT</name></expr>,
	 <comment type="block">/* N  */</comment> <expr><name>PG_ISALPHA</name> <operator>|</operator> <name>PG_ISUPPER</name> <operator>|</operator> <name>PG_ISGRAPH</name> <operator>|</operator> <name>PG_ISPRINT</name></expr>,
	 <comment type="block">/* O  */</comment> <expr><name>PG_ISALPHA</name> <operator>|</operator> <name>PG_ISUPPER</name> <operator>|</operator> <name>PG_ISGRAPH</name> <operator>|</operator> <name>PG_ISPRINT</name></expr>,
	 <comment type="block">/* P  */</comment> <expr><name>PG_ISALPHA</name> <operator>|</operator> <name>PG_ISUPPER</name> <operator>|</operator> <name>PG_ISGRAPH</name> <operator>|</operator> <name>PG_ISPRINT</name></expr>,
	 <comment type="block">/* Q  */</comment> <expr><name>PG_ISALPHA</name> <operator>|</operator> <name>PG_ISUPPER</name> <operator>|</operator> <name>PG_ISGRAPH</name> <operator>|</operator> <name>PG_ISPRINT</name></expr>,
	 <comment type="block">/* R  */</comment> <expr><name>PG_ISALPHA</name> <operator>|</operator> <name>PG_ISUPPER</name> <operator>|</operator> <name>PG_ISGRAPH</name> <operator>|</operator> <name>PG_ISPRINT</name></expr>,
	 <comment type="block">/* S  */</comment> <expr><name>PG_ISALPHA</name> <operator>|</operator> <name>PG_ISUPPER</name> <operator>|</operator> <name>PG_ISGRAPH</name> <operator>|</operator> <name>PG_ISPRINT</name></expr>,
	 <comment type="block">/* T  */</comment> <expr><name>PG_ISALPHA</name> <operator>|</operator> <name>PG_ISUPPER</name> <operator>|</operator> <name>PG_ISGRAPH</name> <operator>|</operator> <name>PG_ISPRINT</name></expr>,
	 <comment type="block">/* U  */</comment> <expr><name>PG_ISALPHA</name> <operator>|</operator> <name>PG_ISUPPER</name> <operator>|</operator> <name>PG_ISGRAPH</name> <operator>|</operator> <name>PG_ISPRINT</name></expr>,
	 <comment type="block">/* V  */</comment> <expr><name>PG_ISALPHA</name> <operator>|</operator> <name>PG_ISUPPER</name> <operator>|</operator> <name>PG_ISGRAPH</name> <operator>|</operator> <name>PG_ISPRINT</name></expr>,
	 <comment type="block">/* W  */</comment> <expr><name>PG_ISALPHA</name> <operator>|</operator> <name>PG_ISUPPER</name> <operator>|</operator> <name>PG_ISGRAPH</name> <operator>|</operator> <name>PG_ISPRINT</name></expr>,
	 <comment type="block">/* X  */</comment> <expr><name>PG_ISALPHA</name> <operator>|</operator> <name>PG_ISUPPER</name> <operator>|</operator> <name>PG_ISGRAPH</name> <operator>|</operator> <name>PG_ISPRINT</name></expr>,
	 <comment type="block">/* Y  */</comment> <expr><name>PG_ISALPHA</name> <operator>|</operator> <name>PG_ISUPPER</name> <operator>|</operator> <name>PG_ISGRAPH</name> <operator>|</operator> <name>PG_ISPRINT</name></expr>,
	 <comment type="block">/* Z  */</comment> <expr><name>PG_ISALPHA</name> <operator>|</operator> <name>PG_ISUPPER</name> <operator>|</operator> <name>PG_ISGRAPH</name> <operator>|</operator> <name>PG_ISPRINT</name></expr>,
	 <comment type="block">/* [  */</comment> <expr><name>PG_ISGRAPH</name> <operator>|</operator> <name>PG_ISPRINT</name> <operator>|</operator> <name>PG_ISPUNCT</name></expr>,
	 <comment type="block">/* \  */</comment> <expr><name>PG_ISGRAPH</name> <operator>|</operator> <name>PG_ISPRINT</name> <operator>|</operator> <name>PG_ISPUNCT</name></expr>,
	 <comment type="block">/* ]  */</comment> <expr><name>PG_ISGRAPH</name> <operator>|</operator> <name>PG_ISPRINT</name> <operator>|</operator> <name>PG_ISPUNCT</name></expr>,
	 <comment type="block">/* ^  */</comment> <expr><name>PG_ISGRAPH</name> <operator>|</operator> <name>PG_ISPRINT</name> <operator>|</operator> <name>PG_ISPUNCT</name></expr>,
	 <comment type="block">/* _  */</comment> <expr><name>PG_ISGRAPH</name> <operator>|</operator> <name>PG_ISPRINT</name> <operator>|</operator> <name>PG_ISPUNCT</name></expr>,
	 <comment type="block">/* `  */</comment> <expr><name>PG_ISGRAPH</name> <operator>|</operator> <name>PG_ISPRINT</name> <operator>|</operator> <name>PG_ISPUNCT</name></expr>,
	 <comment type="block">/* a  */</comment> <expr><name>PG_ISALPHA</name> <operator>|</operator> <name>PG_ISLOWER</name> <operator>|</operator> <name>PG_ISGRAPH</name> <operator>|</operator> <name>PG_ISPRINT</name></expr>,
	 <comment type="block">/* b  */</comment> <expr><name>PG_ISALPHA</name> <operator>|</operator> <name>PG_ISLOWER</name> <operator>|</operator> <name>PG_ISGRAPH</name> <operator>|</operator> <name>PG_ISPRINT</name></expr>,
	 <comment type="block">/* c  */</comment> <expr><name>PG_ISALPHA</name> <operator>|</operator> <name>PG_ISLOWER</name> <operator>|</operator> <name>PG_ISGRAPH</name> <operator>|</operator> <name>PG_ISPRINT</name></expr>,
	 <comment type="block">/* d  */</comment> <expr><name>PG_ISALPHA</name> <operator>|</operator> <name>PG_ISLOWER</name> <operator>|</operator> <name>PG_ISGRAPH</name> <operator>|</operator> <name>PG_ISPRINT</name></expr>,
	 <comment type="block">/* e  */</comment> <expr><name>PG_ISALPHA</name> <operator>|</operator> <name>PG_ISLOWER</name> <operator>|</operator> <name>PG_ISGRAPH</name> <operator>|</operator> <name>PG_ISPRINT</name></expr>,
	 <comment type="block">/* f  */</comment> <expr><name>PG_ISALPHA</name> <operator>|</operator> <name>PG_ISLOWER</name> <operator>|</operator> <name>PG_ISGRAPH</name> <operator>|</operator> <name>PG_ISPRINT</name></expr>,
	 <comment type="block">/* g  */</comment> <expr><name>PG_ISALPHA</name> <operator>|</operator> <name>PG_ISLOWER</name> <operator>|</operator> <name>PG_ISGRAPH</name> <operator>|</operator> <name>PG_ISPRINT</name></expr>,
	 <comment type="block">/* h  */</comment> <expr><name>PG_ISALPHA</name> <operator>|</operator> <name>PG_ISLOWER</name> <operator>|</operator> <name>PG_ISGRAPH</name> <operator>|</operator> <name>PG_ISPRINT</name></expr>,
	 <comment type="block">/* i  */</comment> <expr><name>PG_ISALPHA</name> <operator>|</operator> <name>PG_ISLOWER</name> <operator>|</operator> <name>PG_ISGRAPH</name> <operator>|</operator> <name>PG_ISPRINT</name></expr>,
	 <comment type="block">/* j  */</comment> <expr><name>PG_ISALPHA</name> <operator>|</operator> <name>PG_ISLOWER</name> <operator>|</operator> <name>PG_ISGRAPH</name> <operator>|</operator> <name>PG_ISPRINT</name></expr>,
	 <comment type="block">/* k  */</comment> <expr><name>PG_ISALPHA</name> <operator>|</operator> <name>PG_ISLOWER</name> <operator>|</operator> <name>PG_ISGRAPH</name> <operator>|</operator> <name>PG_ISPRINT</name></expr>,
	 <comment type="block">/* l  */</comment> <expr><name>PG_ISALPHA</name> <operator>|</operator> <name>PG_ISLOWER</name> <operator>|</operator> <name>PG_ISGRAPH</name> <operator>|</operator> <name>PG_ISPRINT</name></expr>,
	 <comment type="block">/* m  */</comment> <expr><name>PG_ISALPHA</name> <operator>|</operator> <name>PG_ISLOWER</name> <operator>|</operator> <name>PG_ISGRAPH</name> <operator>|</operator> <name>PG_ISPRINT</name></expr>,
	 <comment type="block">/* n  */</comment> <expr><name>PG_ISALPHA</name> <operator>|</operator> <name>PG_ISLOWER</name> <operator>|</operator> <name>PG_ISGRAPH</name> <operator>|</operator> <name>PG_ISPRINT</name></expr>,
	 <comment type="block">/* o  */</comment> <expr><name>PG_ISALPHA</name> <operator>|</operator> <name>PG_ISLOWER</name> <operator>|</operator> <name>PG_ISGRAPH</name> <operator>|</operator> <name>PG_ISPRINT</name></expr>,
	 <comment type="block">/* p  */</comment> <expr><name>PG_ISALPHA</name> <operator>|</operator> <name>PG_ISLOWER</name> <operator>|</operator> <name>PG_ISGRAPH</name> <operator>|</operator> <name>PG_ISPRINT</name></expr>,
	 <comment type="block">/* q  */</comment> <expr><name>PG_ISALPHA</name> <operator>|</operator> <name>PG_ISLOWER</name> <operator>|</operator> <name>PG_ISGRAPH</name> <operator>|</operator> <name>PG_ISPRINT</name></expr>,
	 <comment type="block">/* r  */</comment> <expr><name>PG_ISALPHA</name> <operator>|</operator> <name>PG_ISLOWER</name> <operator>|</operator> <name>PG_ISGRAPH</name> <operator>|</operator> <name>PG_ISPRINT</name></expr>,
	 <comment type="block">/* s  */</comment> <expr><name>PG_ISALPHA</name> <operator>|</operator> <name>PG_ISLOWER</name> <operator>|</operator> <name>PG_ISGRAPH</name> <operator>|</operator> <name>PG_ISPRINT</name></expr>,
	 <comment type="block">/* t  */</comment> <expr><name>PG_ISALPHA</name> <operator>|</operator> <name>PG_ISLOWER</name> <operator>|</operator> <name>PG_ISGRAPH</name> <operator>|</operator> <name>PG_ISPRINT</name></expr>,
	 <comment type="block">/* u  */</comment> <expr><name>PG_ISALPHA</name> <operator>|</operator> <name>PG_ISLOWER</name> <operator>|</operator> <name>PG_ISGRAPH</name> <operator>|</operator> <name>PG_ISPRINT</name></expr>,
	 <comment type="block">/* v  */</comment> <expr><name>PG_ISALPHA</name> <operator>|</operator> <name>PG_ISLOWER</name> <operator>|</operator> <name>PG_ISGRAPH</name> <operator>|</operator> <name>PG_ISPRINT</name></expr>,
	 <comment type="block">/* w  */</comment> <expr><name>PG_ISALPHA</name> <operator>|</operator> <name>PG_ISLOWER</name> <operator>|</operator> <name>PG_ISGRAPH</name> <operator>|</operator> <name>PG_ISPRINT</name></expr>,
	 <comment type="block">/* x  */</comment> <expr><name>PG_ISALPHA</name> <operator>|</operator> <name>PG_ISLOWER</name> <operator>|</operator> <name>PG_ISGRAPH</name> <operator>|</operator> <name>PG_ISPRINT</name></expr>,
	 <comment type="block">/* y  */</comment> <expr><name>PG_ISALPHA</name> <operator>|</operator> <name>PG_ISLOWER</name> <operator>|</operator> <name>PG_ISGRAPH</name> <operator>|</operator> <name>PG_ISPRINT</name></expr>,
	 <comment type="block">/* z  */</comment> <expr><name>PG_ISALPHA</name> <operator>|</operator> <name>PG_ISLOWER</name> <operator>|</operator> <name>PG_ISGRAPH</name> <operator>|</operator> <name>PG_ISPRINT</name></expr>,
	 <comment type="block">/* {  */</comment> <expr><name>PG_ISGRAPH</name> <operator>|</operator> <name>PG_ISPRINT</name> <operator>|</operator> <name>PG_ISPUNCT</name></expr>,
	 <comment type="block">/* |  */</comment> <expr><name>PG_ISGRAPH</name> <operator>|</operator> <name>PG_ISPRINT</name> <operator>|</operator> <name>PG_ISPUNCT</name></expr>,
	 <comment type="block">/* }  */</comment> <expr><name>PG_ISGRAPH</name> <operator>|</operator> <name>PG_ISPRINT</name> <operator>|</operator> <name>PG_ISPUNCT</name></expr>,
	 <comment type="block">/* ~  */</comment> <expr><name>PG_ISGRAPH</name> <operator>|</operator> <name>PG_ISPRINT</name> <operator>|</operator> <name>PG_ISPUNCT</name></expr>,
	 <comment type="block">/* DEL */</comment> <expr><literal type="number">0</literal></expr>
}</block></expr></init></decl>;</decl_stmt>


<comment type="block">/*
 * pg_set_regex_collation: set collation for these functions to obey
 *
 * This is called when beginning compilation or execution of a regexp.
 * Since there's no need for reentrancy of regexp operations, it's okay
 * to store the results in static variables.
 */</comment>
<function><type><name>void</name></type>
<name>pg_set_regex_collation</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>collation</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>lc_ctype_is_c</name><argument_list>(<argument><expr><name>collation</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* C/POSIX collations use this path regardless of database encoding */</comment>
		<expr_stmt><expr><name>pg_regex_strategy</name> <operator>=</operator> <name>PG_REGEX_LOCALE_C</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>pg_regex_locale</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>pg_regex_collation</name> <operator>=</operator> <name>C_COLLATION_OID</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>collation</name> <operator>==</operator> <name>DEFAULT_COLLATION_OID</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>pg_regex_locale</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>collation</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * NB: pg_newlocale_from_collation will fail if not HAVE_LOCALE_T;
			 * the case of pg_regex_locale != 0 but not HAVE_LOCALE_T does not
			 * have to be considered below.
			 */</comment>
			<expr_stmt><expr><name>pg_regex_locale</name> <operator>=</operator> <call><name>pg_newlocale_from_collation</name><argument_list>(<argument><expr><name>collation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * This typically means that the parser could not resolve a
			 * conflict of implicit collations, so report it that way.
			 */</comment>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INDETERMINATE_COLLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not determine which collation to use for regular expression"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Use the COLLATE clause to set the collation explicitly."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>pg_regex_locale</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>pg_regex_locale</name><operator>-&gt;</operator><name>deterministic</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"nondeterministic collations are not supported for regular expressions"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ICU</name></cpp:ifdef>
		<if_stmt><if>if <condition>(<expr><name>pg_regex_locale</name> <operator>&amp;&amp;</operator> <name><name>pg_regex_locale</name><operator>-&gt;</operator><name>provider</name></name> <operator>==</operator> <name>COLLPROVIDER_ICU</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>pg_regex_strategy</name> <operator>=</operator> <name>PG_REGEX_LOCALE_ICU</name></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		if <condition>(<expr><call><name>GetDatabaseEncoding</name><argument_list>()</argument_list></call> <operator>==</operator> <name>PG_UTF8</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>pg_regex_locale</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>pg_regex_strategy</name> <operator>=</operator> <name>PG_REGEX_LOCALE_WIDE_L</name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>pg_regex_strategy</name> <operator>=</operator> <name>PG_REGEX_LOCALE_WIDE</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>pg_regex_locale</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>pg_regex_strategy</name> <operator>=</operator> <name>PG_REGEX_LOCALE_1BYTE_L</name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>pg_regex_strategy</name> <operator>=</operator> <name>PG_REGEX_LOCALE_1BYTE</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name>pg_regex_collation</name> <operator>=</operator> <name>collation</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>pg_wc_isdigit</name><parameter_list>(<parameter><decl><type><name>pg_wchar</name></type> <name>c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name>pg_regex_strategy</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>PG_REGEX_LOCALE_C</name></expr>:</case>
			<return>return <expr><operator>(</operator><name>c</name> <operator>&lt;=</operator> <operator>(</operator><name>pg_wchar</name><operator>)</operator> <literal type="number">127</literal> <operator>&amp;&amp;</operator>
					<operator>(</operator><name><name>pg_char_properties</name><index>[<expr><name>c</name></expr>]</index></name> <operator>&amp;</operator> <name>PG_ISDIGIT</name><operator>)</operator><operator>)</operator></expr>;</return>
		<case>case <expr><name>PG_REGEX_LOCALE_WIDE</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><sizeof>sizeof<argument_list>(<argument><expr><name>wchar_t</name></expr></argument>)</argument_list></sizeof> <operator>&gt;=</operator> <literal type="number">4</literal> <operator>||</operator> <name>c</name> <operator>&lt;=</operator> <operator>(</operator><name>pg_wchar</name><operator>)</operator> <literal type="number">0xFFFF</literal></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><call><name>iswdigit</name><argument_list>(<argument><expr><operator>(</operator><name>wint_t</name><operator>)</operator> <name>c</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
			<comment type="block">/* FALL THRU */</comment>
		<case>case <expr><name>PG_REGEX_LOCALE_1BYTE</name></expr>:</case>
			<return>return <expr><operator>(</operator><name>c</name> <operator>&lt;=</operator> <operator>(</operator><name>pg_wchar</name><operator>)</operator> <name>UCHAR_MAX</name> <operator>&amp;&amp;</operator>
					<call><name>isdigit</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <name>c</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
		<case>case <expr><name>PG_REGEX_LOCALE_WIDE_L</name></expr>:</case>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_LOCALE_T</name></cpp:ifdef>
			<if_stmt><if>if <condition>(<expr><sizeof>sizeof<argument_list>(<argument><expr><name>wchar_t</name></expr></argument>)</argument_list></sizeof> <operator>&gt;=</operator> <literal type="number">4</literal> <operator>||</operator> <name>c</name> <operator>&lt;=</operator> <operator>(</operator><name>pg_wchar</name><operator>)</operator> <literal type="number">0xFFFF</literal></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><call><name>iswdigit_l</name><argument_list>(<argument><expr><operator>(</operator><name>wint_t</name><operator>)</operator> <name>c</name></expr></argument>, <argument><expr><name><name>pg_regex_locale</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>lt</name></name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<comment type="block">/* FALL THRU */</comment>
		<case>case <expr><name>PG_REGEX_LOCALE_1BYTE_L</name></expr>:</case>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_LOCALE_T</name></cpp:ifdef>
			<return>return <expr><operator>(</operator><name>c</name> <operator>&lt;=</operator> <operator>(</operator><name>pg_wchar</name><operator>)</operator> <name>UCHAR_MAX</name> <operator>&amp;&amp;</operator>
					<call><name>isdigit_l</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <name>c</name></expr></argument>, <argument><expr><name><name>pg_regex_locale</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>lt</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<break>break;</break>
		<case>case <expr><name>PG_REGEX_LOCALE_ICU</name></expr>:</case>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ICU</name></cpp:ifdef>
			<return>return <expr><call><name>u_isdigit</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<break>break;</break>
	</block_content>}</block></switch>
	<return>return <expr><literal type="number">0</literal></expr>;</return>					<comment type="block">/* can't get here, but keep compiler quiet */</comment>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>pg_wc_isalpha</name><parameter_list>(<parameter><decl><type><name>pg_wchar</name></type> <name>c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name>pg_regex_strategy</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>PG_REGEX_LOCALE_C</name></expr>:</case>
			<return>return <expr><operator>(</operator><name>c</name> <operator>&lt;=</operator> <operator>(</operator><name>pg_wchar</name><operator>)</operator> <literal type="number">127</literal> <operator>&amp;&amp;</operator>
					<operator>(</operator><name><name>pg_char_properties</name><index>[<expr><name>c</name></expr>]</index></name> <operator>&amp;</operator> <name>PG_ISALPHA</name><operator>)</operator><operator>)</operator></expr>;</return>
		<case>case <expr><name>PG_REGEX_LOCALE_WIDE</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><sizeof>sizeof<argument_list>(<argument><expr><name>wchar_t</name></expr></argument>)</argument_list></sizeof> <operator>&gt;=</operator> <literal type="number">4</literal> <operator>||</operator> <name>c</name> <operator>&lt;=</operator> <operator>(</operator><name>pg_wchar</name><operator>)</operator> <literal type="number">0xFFFF</literal></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><call><name>iswalpha</name><argument_list>(<argument><expr><operator>(</operator><name>wint_t</name><operator>)</operator> <name>c</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
			<comment type="block">/* FALL THRU */</comment>
		<case>case <expr><name>PG_REGEX_LOCALE_1BYTE</name></expr>:</case>
			<return>return <expr><operator>(</operator><name>c</name> <operator>&lt;=</operator> <operator>(</operator><name>pg_wchar</name><operator>)</operator> <name>UCHAR_MAX</name> <operator>&amp;&amp;</operator>
					<call><name>isalpha</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <name>c</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
		<case>case <expr><name>PG_REGEX_LOCALE_WIDE_L</name></expr>:</case>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_LOCALE_T</name></cpp:ifdef>
			<if_stmt><if>if <condition>(<expr><sizeof>sizeof<argument_list>(<argument><expr><name>wchar_t</name></expr></argument>)</argument_list></sizeof> <operator>&gt;=</operator> <literal type="number">4</literal> <operator>||</operator> <name>c</name> <operator>&lt;=</operator> <operator>(</operator><name>pg_wchar</name><operator>)</operator> <literal type="number">0xFFFF</literal></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><call><name>iswalpha_l</name><argument_list>(<argument><expr><operator>(</operator><name>wint_t</name><operator>)</operator> <name>c</name></expr></argument>, <argument><expr><name><name>pg_regex_locale</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>lt</name></name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<comment type="block">/* FALL THRU */</comment>
		<case>case <expr><name>PG_REGEX_LOCALE_1BYTE_L</name></expr>:</case>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_LOCALE_T</name></cpp:ifdef>
			<return>return <expr><operator>(</operator><name>c</name> <operator>&lt;=</operator> <operator>(</operator><name>pg_wchar</name><operator>)</operator> <name>UCHAR_MAX</name> <operator>&amp;&amp;</operator>
					<call><name>isalpha_l</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <name>c</name></expr></argument>, <argument><expr><name><name>pg_regex_locale</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>lt</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<break>break;</break>
		<case>case <expr><name>PG_REGEX_LOCALE_ICU</name></expr>:</case>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ICU</name></cpp:ifdef>
			<return>return <expr><call><name>u_isalpha</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<break>break;</break>
	</block_content>}</block></switch>
	<return>return <expr><literal type="number">0</literal></expr>;</return>					<comment type="block">/* can't get here, but keep compiler quiet */</comment>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>pg_wc_isalnum</name><parameter_list>(<parameter><decl><type><name>pg_wchar</name></type> <name>c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name>pg_regex_strategy</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>PG_REGEX_LOCALE_C</name></expr>:</case>
			<return>return <expr><operator>(</operator><name>c</name> <operator>&lt;=</operator> <operator>(</operator><name>pg_wchar</name><operator>)</operator> <literal type="number">127</literal> <operator>&amp;&amp;</operator>
					<operator>(</operator><name><name>pg_char_properties</name><index>[<expr><name>c</name></expr>]</index></name> <operator>&amp;</operator> <name>PG_ISALNUM</name><operator>)</operator><operator>)</operator></expr>;</return>
		<case>case <expr><name>PG_REGEX_LOCALE_WIDE</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><sizeof>sizeof<argument_list>(<argument><expr><name>wchar_t</name></expr></argument>)</argument_list></sizeof> <operator>&gt;=</operator> <literal type="number">4</literal> <operator>||</operator> <name>c</name> <operator>&lt;=</operator> <operator>(</operator><name>pg_wchar</name><operator>)</operator> <literal type="number">0xFFFF</literal></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><call><name>iswalnum</name><argument_list>(<argument><expr><operator>(</operator><name>wint_t</name><operator>)</operator> <name>c</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
			<comment type="block">/* FALL THRU */</comment>
		<case>case <expr><name>PG_REGEX_LOCALE_1BYTE</name></expr>:</case>
			<return>return <expr><operator>(</operator><name>c</name> <operator>&lt;=</operator> <operator>(</operator><name>pg_wchar</name><operator>)</operator> <name>UCHAR_MAX</name> <operator>&amp;&amp;</operator>
					<call><name>isalnum</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <name>c</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
		<case>case <expr><name>PG_REGEX_LOCALE_WIDE_L</name></expr>:</case>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_LOCALE_T</name></cpp:ifdef>
			<if_stmt><if>if <condition>(<expr><sizeof>sizeof<argument_list>(<argument><expr><name>wchar_t</name></expr></argument>)</argument_list></sizeof> <operator>&gt;=</operator> <literal type="number">4</literal> <operator>||</operator> <name>c</name> <operator>&lt;=</operator> <operator>(</operator><name>pg_wchar</name><operator>)</operator> <literal type="number">0xFFFF</literal></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><call><name>iswalnum_l</name><argument_list>(<argument><expr><operator>(</operator><name>wint_t</name><operator>)</operator> <name>c</name></expr></argument>, <argument><expr><name><name>pg_regex_locale</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>lt</name></name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<comment type="block">/* FALL THRU */</comment>
		<case>case <expr><name>PG_REGEX_LOCALE_1BYTE_L</name></expr>:</case>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_LOCALE_T</name></cpp:ifdef>
			<return>return <expr><operator>(</operator><name>c</name> <operator>&lt;=</operator> <operator>(</operator><name>pg_wchar</name><operator>)</operator> <name>UCHAR_MAX</name> <operator>&amp;&amp;</operator>
					<call><name>isalnum_l</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <name>c</name></expr></argument>, <argument><expr><name><name>pg_regex_locale</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>lt</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<break>break;</break>
		<case>case <expr><name>PG_REGEX_LOCALE_ICU</name></expr>:</case>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ICU</name></cpp:ifdef>
			<return>return <expr><call><name>u_isalnum</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<break>break;</break>
	</block_content>}</block></switch>
	<return>return <expr><literal type="number">0</literal></expr>;</return>					<comment type="block">/* can't get here, but keep compiler quiet */</comment>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>pg_wc_isupper</name><parameter_list>(<parameter><decl><type><name>pg_wchar</name></type> <name>c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name>pg_regex_strategy</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>PG_REGEX_LOCALE_C</name></expr>:</case>
			<return>return <expr><operator>(</operator><name>c</name> <operator>&lt;=</operator> <operator>(</operator><name>pg_wchar</name><operator>)</operator> <literal type="number">127</literal> <operator>&amp;&amp;</operator>
					<operator>(</operator><name><name>pg_char_properties</name><index>[<expr><name>c</name></expr>]</index></name> <operator>&amp;</operator> <name>PG_ISUPPER</name><operator>)</operator><operator>)</operator></expr>;</return>
		<case>case <expr><name>PG_REGEX_LOCALE_WIDE</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><sizeof>sizeof<argument_list>(<argument><expr><name>wchar_t</name></expr></argument>)</argument_list></sizeof> <operator>&gt;=</operator> <literal type="number">4</literal> <operator>||</operator> <name>c</name> <operator>&lt;=</operator> <operator>(</operator><name>pg_wchar</name><operator>)</operator> <literal type="number">0xFFFF</literal></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><call><name>iswupper</name><argument_list>(<argument><expr><operator>(</operator><name>wint_t</name><operator>)</operator> <name>c</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
			<comment type="block">/* FALL THRU */</comment>
		<case>case <expr><name>PG_REGEX_LOCALE_1BYTE</name></expr>:</case>
			<return>return <expr><operator>(</operator><name>c</name> <operator>&lt;=</operator> <operator>(</operator><name>pg_wchar</name><operator>)</operator> <name>UCHAR_MAX</name> <operator>&amp;&amp;</operator>
					<call><name>isupper</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <name>c</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
		<case>case <expr><name>PG_REGEX_LOCALE_WIDE_L</name></expr>:</case>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_LOCALE_T</name></cpp:ifdef>
			<if_stmt><if>if <condition>(<expr><sizeof>sizeof<argument_list>(<argument><expr><name>wchar_t</name></expr></argument>)</argument_list></sizeof> <operator>&gt;=</operator> <literal type="number">4</literal> <operator>||</operator> <name>c</name> <operator>&lt;=</operator> <operator>(</operator><name>pg_wchar</name><operator>)</operator> <literal type="number">0xFFFF</literal></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><call><name>iswupper_l</name><argument_list>(<argument><expr><operator>(</operator><name>wint_t</name><operator>)</operator> <name>c</name></expr></argument>, <argument><expr><name><name>pg_regex_locale</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>lt</name></name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<comment type="block">/* FALL THRU */</comment>
		<case>case <expr><name>PG_REGEX_LOCALE_1BYTE_L</name></expr>:</case>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_LOCALE_T</name></cpp:ifdef>
			<return>return <expr><operator>(</operator><name>c</name> <operator>&lt;=</operator> <operator>(</operator><name>pg_wchar</name><operator>)</operator> <name>UCHAR_MAX</name> <operator>&amp;&amp;</operator>
					<call><name>isupper_l</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <name>c</name></expr></argument>, <argument><expr><name><name>pg_regex_locale</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>lt</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<break>break;</break>
		<case>case <expr><name>PG_REGEX_LOCALE_ICU</name></expr>:</case>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ICU</name></cpp:ifdef>
			<return>return <expr><call><name>u_isupper</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<break>break;</break>
	</block_content>}</block></switch>
	<return>return <expr><literal type="number">0</literal></expr>;</return>					<comment type="block">/* can't get here, but keep compiler quiet */</comment>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>pg_wc_islower</name><parameter_list>(<parameter><decl><type><name>pg_wchar</name></type> <name>c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name>pg_regex_strategy</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>PG_REGEX_LOCALE_C</name></expr>:</case>
			<return>return <expr><operator>(</operator><name>c</name> <operator>&lt;=</operator> <operator>(</operator><name>pg_wchar</name><operator>)</operator> <literal type="number">127</literal> <operator>&amp;&amp;</operator>
					<operator>(</operator><name><name>pg_char_properties</name><index>[<expr><name>c</name></expr>]</index></name> <operator>&amp;</operator> <name>PG_ISLOWER</name><operator>)</operator><operator>)</operator></expr>;</return>
		<case>case <expr><name>PG_REGEX_LOCALE_WIDE</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><sizeof>sizeof<argument_list>(<argument><expr><name>wchar_t</name></expr></argument>)</argument_list></sizeof> <operator>&gt;=</operator> <literal type="number">4</literal> <operator>||</operator> <name>c</name> <operator>&lt;=</operator> <operator>(</operator><name>pg_wchar</name><operator>)</operator> <literal type="number">0xFFFF</literal></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><call><name>iswlower</name><argument_list>(<argument><expr><operator>(</operator><name>wint_t</name><operator>)</operator> <name>c</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
			<comment type="block">/* FALL THRU */</comment>
		<case>case <expr><name>PG_REGEX_LOCALE_1BYTE</name></expr>:</case>
			<return>return <expr><operator>(</operator><name>c</name> <operator>&lt;=</operator> <operator>(</operator><name>pg_wchar</name><operator>)</operator> <name>UCHAR_MAX</name> <operator>&amp;&amp;</operator>
					<call><name>islower</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <name>c</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
		<case>case <expr><name>PG_REGEX_LOCALE_WIDE_L</name></expr>:</case>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_LOCALE_T</name></cpp:ifdef>
			<if_stmt><if>if <condition>(<expr><sizeof>sizeof<argument_list>(<argument><expr><name>wchar_t</name></expr></argument>)</argument_list></sizeof> <operator>&gt;=</operator> <literal type="number">4</literal> <operator>||</operator> <name>c</name> <operator>&lt;=</operator> <operator>(</operator><name>pg_wchar</name><operator>)</operator> <literal type="number">0xFFFF</literal></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><call><name>iswlower_l</name><argument_list>(<argument><expr><operator>(</operator><name>wint_t</name><operator>)</operator> <name>c</name></expr></argument>, <argument><expr><name><name>pg_regex_locale</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>lt</name></name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<comment type="block">/* FALL THRU */</comment>
		<case>case <expr><name>PG_REGEX_LOCALE_1BYTE_L</name></expr>:</case>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_LOCALE_T</name></cpp:ifdef>
			<return>return <expr><operator>(</operator><name>c</name> <operator>&lt;=</operator> <operator>(</operator><name>pg_wchar</name><operator>)</operator> <name>UCHAR_MAX</name> <operator>&amp;&amp;</operator>
					<call><name>islower_l</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <name>c</name></expr></argument>, <argument><expr><name><name>pg_regex_locale</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>lt</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<break>break;</break>
		<case>case <expr><name>PG_REGEX_LOCALE_ICU</name></expr>:</case>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ICU</name></cpp:ifdef>
			<return>return <expr><call><name>u_islower</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<break>break;</break>
	</block_content>}</block></switch>
	<return>return <expr><literal type="number">0</literal></expr>;</return>					<comment type="block">/* can't get here, but keep compiler quiet */</comment>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>pg_wc_isgraph</name><parameter_list>(<parameter><decl><type><name>pg_wchar</name></type> <name>c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name>pg_regex_strategy</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>PG_REGEX_LOCALE_C</name></expr>:</case>
			<return>return <expr><operator>(</operator><name>c</name> <operator>&lt;=</operator> <operator>(</operator><name>pg_wchar</name><operator>)</operator> <literal type="number">127</literal> <operator>&amp;&amp;</operator>
					<operator>(</operator><name><name>pg_char_properties</name><index>[<expr><name>c</name></expr>]</index></name> <operator>&amp;</operator> <name>PG_ISGRAPH</name><operator>)</operator><operator>)</operator></expr>;</return>
		<case>case <expr><name>PG_REGEX_LOCALE_WIDE</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><sizeof>sizeof<argument_list>(<argument><expr><name>wchar_t</name></expr></argument>)</argument_list></sizeof> <operator>&gt;=</operator> <literal type="number">4</literal> <operator>||</operator> <name>c</name> <operator>&lt;=</operator> <operator>(</operator><name>pg_wchar</name><operator>)</operator> <literal type="number">0xFFFF</literal></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><call><name>iswgraph</name><argument_list>(<argument><expr><operator>(</operator><name>wint_t</name><operator>)</operator> <name>c</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
			<comment type="block">/* FALL THRU */</comment>
		<case>case <expr><name>PG_REGEX_LOCALE_1BYTE</name></expr>:</case>
			<return>return <expr><operator>(</operator><name>c</name> <operator>&lt;=</operator> <operator>(</operator><name>pg_wchar</name><operator>)</operator> <name>UCHAR_MAX</name> <operator>&amp;&amp;</operator>
					<call><name>isgraph</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <name>c</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
		<case>case <expr><name>PG_REGEX_LOCALE_WIDE_L</name></expr>:</case>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_LOCALE_T</name></cpp:ifdef>
			<if_stmt><if>if <condition>(<expr><sizeof>sizeof<argument_list>(<argument><expr><name>wchar_t</name></expr></argument>)</argument_list></sizeof> <operator>&gt;=</operator> <literal type="number">4</literal> <operator>||</operator> <name>c</name> <operator>&lt;=</operator> <operator>(</operator><name>pg_wchar</name><operator>)</operator> <literal type="number">0xFFFF</literal></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><call><name>iswgraph_l</name><argument_list>(<argument><expr><operator>(</operator><name>wint_t</name><operator>)</operator> <name>c</name></expr></argument>, <argument><expr><name><name>pg_regex_locale</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>lt</name></name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<comment type="block">/* FALL THRU */</comment>
		<case>case <expr><name>PG_REGEX_LOCALE_1BYTE_L</name></expr>:</case>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_LOCALE_T</name></cpp:ifdef>
			<return>return <expr><operator>(</operator><name>c</name> <operator>&lt;=</operator> <operator>(</operator><name>pg_wchar</name><operator>)</operator> <name>UCHAR_MAX</name> <operator>&amp;&amp;</operator>
					<call><name>isgraph_l</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <name>c</name></expr></argument>, <argument><expr><name><name>pg_regex_locale</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>lt</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<break>break;</break>
		<case>case <expr><name>PG_REGEX_LOCALE_ICU</name></expr>:</case>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ICU</name></cpp:ifdef>
			<return>return <expr><call><name>u_isgraph</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<break>break;</break>
	</block_content>}</block></switch>
	<return>return <expr><literal type="number">0</literal></expr>;</return>					<comment type="block">/* can't get here, but keep compiler quiet */</comment>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>pg_wc_isprint</name><parameter_list>(<parameter><decl><type><name>pg_wchar</name></type> <name>c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name>pg_regex_strategy</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>PG_REGEX_LOCALE_C</name></expr>:</case>
			<return>return <expr><operator>(</operator><name>c</name> <operator>&lt;=</operator> <operator>(</operator><name>pg_wchar</name><operator>)</operator> <literal type="number">127</literal> <operator>&amp;&amp;</operator>
					<operator>(</operator><name><name>pg_char_properties</name><index>[<expr><name>c</name></expr>]</index></name> <operator>&amp;</operator> <name>PG_ISPRINT</name><operator>)</operator><operator>)</operator></expr>;</return>
		<case>case <expr><name>PG_REGEX_LOCALE_WIDE</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><sizeof>sizeof<argument_list>(<argument><expr><name>wchar_t</name></expr></argument>)</argument_list></sizeof> <operator>&gt;=</operator> <literal type="number">4</literal> <operator>||</operator> <name>c</name> <operator>&lt;=</operator> <operator>(</operator><name>pg_wchar</name><operator>)</operator> <literal type="number">0xFFFF</literal></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><call><name>iswprint</name><argument_list>(<argument><expr><operator>(</operator><name>wint_t</name><operator>)</operator> <name>c</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
			<comment type="block">/* FALL THRU */</comment>
		<case>case <expr><name>PG_REGEX_LOCALE_1BYTE</name></expr>:</case>
			<return>return <expr><operator>(</operator><name>c</name> <operator>&lt;=</operator> <operator>(</operator><name>pg_wchar</name><operator>)</operator> <name>UCHAR_MAX</name> <operator>&amp;&amp;</operator>
					<call><name>isprint</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <name>c</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
		<case>case <expr><name>PG_REGEX_LOCALE_WIDE_L</name></expr>:</case>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_LOCALE_T</name></cpp:ifdef>
			<if_stmt><if>if <condition>(<expr><sizeof>sizeof<argument_list>(<argument><expr><name>wchar_t</name></expr></argument>)</argument_list></sizeof> <operator>&gt;=</operator> <literal type="number">4</literal> <operator>||</operator> <name>c</name> <operator>&lt;=</operator> <operator>(</operator><name>pg_wchar</name><operator>)</operator> <literal type="number">0xFFFF</literal></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><call><name>iswprint_l</name><argument_list>(<argument><expr><operator>(</operator><name>wint_t</name><operator>)</operator> <name>c</name></expr></argument>, <argument><expr><name><name>pg_regex_locale</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>lt</name></name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<comment type="block">/* FALL THRU */</comment>
		<case>case <expr><name>PG_REGEX_LOCALE_1BYTE_L</name></expr>:</case>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_LOCALE_T</name></cpp:ifdef>
			<return>return <expr><operator>(</operator><name>c</name> <operator>&lt;=</operator> <operator>(</operator><name>pg_wchar</name><operator>)</operator> <name>UCHAR_MAX</name> <operator>&amp;&amp;</operator>
					<call><name>isprint_l</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <name>c</name></expr></argument>, <argument><expr><name><name>pg_regex_locale</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>lt</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<break>break;</break>
		<case>case <expr><name>PG_REGEX_LOCALE_ICU</name></expr>:</case>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ICU</name></cpp:ifdef>
			<return>return <expr><call><name>u_isprint</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<break>break;</break>
	</block_content>}</block></switch>
	<return>return <expr><literal type="number">0</literal></expr>;</return>					<comment type="block">/* can't get here, but keep compiler quiet */</comment>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>pg_wc_ispunct</name><parameter_list>(<parameter><decl><type><name>pg_wchar</name></type> <name>c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name>pg_regex_strategy</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>PG_REGEX_LOCALE_C</name></expr>:</case>
			<return>return <expr><operator>(</operator><name>c</name> <operator>&lt;=</operator> <operator>(</operator><name>pg_wchar</name><operator>)</operator> <literal type="number">127</literal> <operator>&amp;&amp;</operator>
					<operator>(</operator><name><name>pg_char_properties</name><index>[<expr><name>c</name></expr>]</index></name> <operator>&amp;</operator> <name>PG_ISPUNCT</name><operator>)</operator><operator>)</operator></expr>;</return>
		<case>case <expr><name>PG_REGEX_LOCALE_WIDE</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><sizeof>sizeof<argument_list>(<argument><expr><name>wchar_t</name></expr></argument>)</argument_list></sizeof> <operator>&gt;=</operator> <literal type="number">4</literal> <operator>||</operator> <name>c</name> <operator>&lt;=</operator> <operator>(</operator><name>pg_wchar</name><operator>)</operator> <literal type="number">0xFFFF</literal></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><call><name>iswpunct</name><argument_list>(<argument><expr><operator>(</operator><name>wint_t</name><operator>)</operator> <name>c</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
			<comment type="block">/* FALL THRU */</comment>
		<case>case <expr><name>PG_REGEX_LOCALE_1BYTE</name></expr>:</case>
			<return>return <expr><operator>(</operator><name>c</name> <operator>&lt;=</operator> <operator>(</operator><name>pg_wchar</name><operator>)</operator> <name>UCHAR_MAX</name> <operator>&amp;&amp;</operator>
					<call><name>ispunct</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <name>c</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
		<case>case <expr><name>PG_REGEX_LOCALE_WIDE_L</name></expr>:</case>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_LOCALE_T</name></cpp:ifdef>
			<if_stmt><if>if <condition>(<expr><sizeof>sizeof<argument_list>(<argument><expr><name>wchar_t</name></expr></argument>)</argument_list></sizeof> <operator>&gt;=</operator> <literal type="number">4</literal> <operator>||</operator> <name>c</name> <operator>&lt;=</operator> <operator>(</operator><name>pg_wchar</name><operator>)</operator> <literal type="number">0xFFFF</literal></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><call><name>iswpunct_l</name><argument_list>(<argument><expr><operator>(</operator><name>wint_t</name><operator>)</operator> <name>c</name></expr></argument>, <argument><expr><name><name>pg_regex_locale</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>lt</name></name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<comment type="block">/* FALL THRU */</comment>
		<case>case <expr><name>PG_REGEX_LOCALE_1BYTE_L</name></expr>:</case>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_LOCALE_T</name></cpp:ifdef>
			<return>return <expr><operator>(</operator><name>c</name> <operator>&lt;=</operator> <operator>(</operator><name>pg_wchar</name><operator>)</operator> <name>UCHAR_MAX</name> <operator>&amp;&amp;</operator>
					<call><name>ispunct_l</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <name>c</name></expr></argument>, <argument><expr><name><name>pg_regex_locale</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>lt</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<break>break;</break>
		<case>case <expr><name>PG_REGEX_LOCALE_ICU</name></expr>:</case>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ICU</name></cpp:ifdef>
			<return>return <expr><call><name>u_ispunct</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<break>break;</break>
	</block_content>}</block></switch>
	<return>return <expr><literal type="number">0</literal></expr>;</return>					<comment type="block">/* can't get here, but keep compiler quiet */</comment>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>pg_wc_isspace</name><parameter_list>(<parameter><decl><type><name>pg_wchar</name></type> <name>c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name>pg_regex_strategy</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>PG_REGEX_LOCALE_C</name></expr>:</case>
			<return>return <expr><operator>(</operator><name>c</name> <operator>&lt;=</operator> <operator>(</operator><name>pg_wchar</name><operator>)</operator> <literal type="number">127</literal> <operator>&amp;&amp;</operator>
					<operator>(</operator><name><name>pg_char_properties</name><index>[<expr><name>c</name></expr>]</index></name> <operator>&amp;</operator> <name>PG_ISSPACE</name><operator>)</operator><operator>)</operator></expr>;</return>
		<case>case <expr><name>PG_REGEX_LOCALE_WIDE</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><sizeof>sizeof<argument_list>(<argument><expr><name>wchar_t</name></expr></argument>)</argument_list></sizeof> <operator>&gt;=</operator> <literal type="number">4</literal> <operator>||</operator> <name>c</name> <operator>&lt;=</operator> <operator>(</operator><name>pg_wchar</name><operator>)</operator> <literal type="number">0xFFFF</literal></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><call><name>iswspace</name><argument_list>(<argument><expr><operator>(</operator><name>wint_t</name><operator>)</operator> <name>c</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
			<comment type="block">/* FALL THRU */</comment>
		<case>case <expr><name>PG_REGEX_LOCALE_1BYTE</name></expr>:</case>
			<return>return <expr><operator>(</operator><name>c</name> <operator>&lt;=</operator> <operator>(</operator><name>pg_wchar</name><operator>)</operator> <name>UCHAR_MAX</name> <operator>&amp;&amp;</operator>
					<call><name>isspace</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <name>c</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
		<case>case <expr><name>PG_REGEX_LOCALE_WIDE_L</name></expr>:</case>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_LOCALE_T</name></cpp:ifdef>
			<if_stmt><if>if <condition>(<expr><sizeof>sizeof<argument_list>(<argument><expr><name>wchar_t</name></expr></argument>)</argument_list></sizeof> <operator>&gt;=</operator> <literal type="number">4</literal> <operator>||</operator> <name>c</name> <operator>&lt;=</operator> <operator>(</operator><name>pg_wchar</name><operator>)</operator> <literal type="number">0xFFFF</literal></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><call><name>iswspace_l</name><argument_list>(<argument><expr><operator>(</operator><name>wint_t</name><operator>)</operator> <name>c</name></expr></argument>, <argument><expr><name><name>pg_regex_locale</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>lt</name></name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<comment type="block">/* FALL THRU */</comment>
		<case>case <expr><name>PG_REGEX_LOCALE_1BYTE_L</name></expr>:</case>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_LOCALE_T</name></cpp:ifdef>
			<return>return <expr><operator>(</operator><name>c</name> <operator>&lt;=</operator> <operator>(</operator><name>pg_wchar</name><operator>)</operator> <name>UCHAR_MAX</name> <operator>&amp;&amp;</operator>
					<call><name>isspace_l</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <name>c</name></expr></argument>, <argument><expr><name><name>pg_regex_locale</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>lt</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<break>break;</break>
		<case>case <expr><name>PG_REGEX_LOCALE_ICU</name></expr>:</case>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ICU</name></cpp:ifdef>
			<return>return <expr><call><name>u_isspace</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<break>break;</break>
	</block_content>}</block></switch>
	<return>return <expr><literal type="number">0</literal></expr>;</return>					<comment type="block">/* can't get here, but keep compiler quiet */</comment>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>pg_wchar</name></type>
<name>pg_wc_toupper</name><parameter_list>(<parameter><decl><type><name>pg_wchar</name></type> <name>c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name>pg_regex_strategy</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>PG_REGEX_LOCALE_C</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name>c</name> <operator>&lt;=</operator> <operator>(</operator><name>pg_wchar</name><operator>)</operator> <literal type="number">127</literal></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><call><name>pg_ascii_toupper</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <name>c</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
			<return>return <expr><name>c</name></expr>;</return>
		<case>case <expr><name>PG_REGEX_LOCALE_WIDE</name></expr>:</case>
			<comment type="block">/* force C behavior for ASCII characters, per comments above */</comment>
			<if_stmt><if>if <condition>(<expr><name>c</name> <operator>&lt;=</operator> <operator>(</operator><name>pg_wchar</name><operator>)</operator> <literal type="number">127</literal></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><call><name>pg_ascii_toupper</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <name>c</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><sizeof>sizeof<argument_list>(<argument><expr><name>wchar_t</name></expr></argument>)</argument_list></sizeof> <operator>&gt;=</operator> <literal type="number">4</literal> <operator>||</operator> <name>c</name> <operator>&lt;=</operator> <operator>(</operator><name>pg_wchar</name><operator>)</operator> <literal type="number">0xFFFF</literal></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><call><name>towupper</name><argument_list>(<argument><expr><operator>(</operator><name>wint_t</name><operator>)</operator> <name>c</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
			<comment type="block">/* FALL THRU */</comment>
		<case>case <expr><name>PG_REGEX_LOCALE_1BYTE</name></expr>:</case>
			<comment type="block">/* force C behavior for ASCII characters, per comments above */</comment>
			<if_stmt><if>if <condition>(<expr><name>c</name> <operator>&lt;=</operator> <operator>(</operator><name>pg_wchar</name><operator>)</operator> <literal type="number">127</literal></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><call><name>pg_ascii_toupper</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <name>c</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>c</name> <operator>&lt;=</operator> <operator>(</operator><name>pg_wchar</name><operator>)</operator> <name>UCHAR_MAX</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><call><name>toupper</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <name>c</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
			<return>return <expr><name>c</name></expr>;</return>
		<case>case <expr><name>PG_REGEX_LOCALE_WIDE_L</name></expr>:</case>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_LOCALE_T</name></cpp:ifdef>
			<if_stmt><if>if <condition>(<expr><sizeof>sizeof<argument_list>(<argument><expr><name>wchar_t</name></expr></argument>)</argument_list></sizeof> <operator>&gt;=</operator> <literal type="number">4</literal> <operator>||</operator> <name>c</name> <operator>&lt;=</operator> <operator>(</operator><name>pg_wchar</name><operator>)</operator> <literal type="number">0xFFFF</literal></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><call><name>towupper_l</name><argument_list>(<argument><expr><operator>(</operator><name>wint_t</name><operator>)</operator> <name>c</name></expr></argument>, <argument><expr><name><name>pg_regex_locale</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>lt</name></name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<comment type="block">/* FALL THRU */</comment>
		<case>case <expr><name>PG_REGEX_LOCALE_1BYTE_L</name></expr>:</case>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_LOCALE_T</name></cpp:ifdef>
			<if_stmt><if>if <condition>(<expr><name>c</name> <operator>&lt;=</operator> <operator>(</operator><name>pg_wchar</name><operator>)</operator> <name>UCHAR_MAX</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><call><name>toupper_l</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <name>c</name></expr></argument>, <argument><expr><name><name>pg_regex_locale</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>lt</name></name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<return>return <expr><name>c</name></expr>;</return>
		<case>case <expr><name>PG_REGEX_LOCALE_ICU</name></expr>:</case>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ICU</name></cpp:ifdef>
			<return>return <expr><call><name>u_toupper</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<break>break;</break>
	</block_content>}</block></switch>
	<return>return <expr><literal type="number">0</literal></expr>;</return>					<comment type="block">/* can't get here, but keep compiler quiet */</comment>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>pg_wchar</name></type>
<name>pg_wc_tolower</name><parameter_list>(<parameter><decl><type><name>pg_wchar</name></type> <name>c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name>pg_regex_strategy</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>PG_REGEX_LOCALE_C</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name>c</name> <operator>&lt;=</operator> <operator>(</operator><name>pg_wchar</name><operator>)</operator> <literal type="number">127</literal></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><call><name>pg_ascii_tolower</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <name>c</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
			<return>return <expr><name>c</name></expr>;</return>
		<case>case <expr><name>PG_REGEX_LOCALE_WIDE</name></expr>:</case>
			<comment type="block">/* force C behavior for ASCII characters, per comments above */</comment>
			<if_stmt><if>if <condition>(<expr><name>c</name> <operator>&lt;=</operator> <operator>(</operator><name>pg_wchar</name><operator>)</operator> <literal type="number">127</literal></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><call><name>pg_ascii_tolower</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <name>c</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><sizeof>sizeof<argument_list>(<argument><expr><name>wchar_t</name></expr></argument>)</argument_list></sizeof> <operator>&gt;=</operator> <literal type="number">4</literal> <operator>||</operator> <name>c</name> <operator>&lt;=</operator> <operator>(</operator><name>pg_wchar</name><operator>)</operator> <literal type="number">0xFFFF</literal></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><call><name>towlower</name><argument_list>(<argument><expr><operator>(</operator><name>wint_t</name><operator>)</operator> <name>c</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
			<comment type="block">/* FALL THRU */</comment>
		<case>case <expr><name>PG_REGEX_LOCALE_1BYTE</name></expr>:</case>
			<comment type="block">/* force C behavior for ASCII characters, per comments above */</comment>
			<if_stmt><if>if <condition>(<expr><name>c</name> <operator>&lt;=</operator> <operator>(</operator><name>pg_wchar</name><operator>)</operator> <literal type="number">127</literal></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><call><name>pg_ascii_tolower</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <name>c</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>c</name> <operator>&lt;=</operator> <operator>(</operator><name>pg_wchar</name><operator>)</operator> <name>UCHAR_MAX</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><call><name>tolower</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <name>c</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
			<return>return <expr><name>c</name></expr>;</return>
		<case>case <expr><name>PG_REGEX_LOCALE_WIDE_L</name></expr>:</case>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_LOCALE_T</name></cpp:ifdef>
			<if_stmt><if>if <condition>(<expr><sizeof>sizeof<argument_list>(<argument><expr><name>wchar_t</name></expr></argument>)</argument_list></sizeof> <operator>&gt;=</operator> <literal type="number">4</literal> <operator>||</operator> <name>c</name> <operator>&lt;=</operator> <operator>(</operator><name>pg_wchar</name><operator>)</operator> <literal type="number">0xFFFF</literal></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><call><name>towlower_l</name><argument_list>(<argument><expr><operator>(</operator><name>wint_t</name><operator>)</operator> <name>c</name></expr></argument>, <argument><expr><name><name>pg_regex_locale</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>lt</name></name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<comment type="block">/* FALL THRU */</comment>
		<case>case <expr><name>PG_REGEX_LOCALE_1BYTE_L</name></expr>:</case>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_LOCALE_T</name></cpp:ifdef>
			<if_stmt><if>if <condition>(<expr><name>c</name> <operator>&lt;=</operator> <operator>(</operator><name>pg_wchar</name><operator>)</operator> <name>UCHAR_MAX</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><call><name>tolower_l</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <name>c</name></expr></argument>, <argument><expr><name><name>pg_regex_locale</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>lt</name></name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<return>return <expr><name>c</name></expr>;</return>
		<case>case <expr><name>PG_REGEX_LOCALE_ICU</name></expr>:</case>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ICU</name></cpp:ifdef>
			<return>return <expr><call><name>u_tolower</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<break>break;</break>
	</block_content>}</block></switch>
	<return>return <expr><literal type="number">0</literal></expr>;</return>					<comment type="block">/* can't get here, but keep compiler quiet */</comment>
</block_content>}</block></function>


<comment type="block">/*
 * These functions cache the results of probing libc's ctype behavior for
 * all character codes of interest in a given encoding/collation.  The
 * result is provided as a "struct cvec", but notice that the representation
 * is a touch different from a cvec created by regc_cvec.c: we allocate the
 * chrs[] and ranges[] arrays separately from the struct so that we can
 * realloc them larger at need.  This is okay since the cvecs made here
 * should never be freed by freecvec().
 *
 * We use malloc not palloc since we mustn't lose control on out-of-memory;
 * the main regex code expects us to return a failure indication instead.
 */</comment>

<typedef>typedef <function_decl><type><name>int</name></type> (<modifier>*</modifier><name>pg_wc_probefunc</name>) <parameter_list>(<parameter><decl><type><name>pg_wchar</name></type> <name>c</name></decl></parameter>)</parameter_list>;</function_decl></typedef>

<typedef>typedef <type><struct>struct <name>pg_ctype_cache</name>
<block>{
	<decl_stmt><decl><type><name>pg_wc_probefunc</name></type> <name>probefunc</name></decl>;</decl_stmt>	<comment type="block">/* pg_wc_isalpha or a sibling */</comment>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>collation</name></decl>;</decl_stmt>		<comment type="block">/* collation this entry is for */</comment>
	<decl_stmt><decl><type><name><name>struct</name> <name>cvec</name></name></type> <name>cv</name></decl>;</decl_stmt>				<comment type="block">/* cache entry contents */</comment>
	<decl_stmt><decl><type><name><name>struct</name> <name>pg_ctype_cache</name></name> <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>	<comment type="block">/* chain link */</comment>
}</block></struct></type> <name>pg_ctype_cache</name>;</typedef>

<decl_stmt><decl><type><specifier>static</specifier> <name>pg_ctype_cache</name> <modifier>*</modifier></type><name>pg_ctype_cache_list</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Add a chr or range to pcc-&gt;cv; return false if run out of memory
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>store_match</name><parameter_list>(<parameter><decl><type><name>pg_ctype_cache</name> <modifier>*</modifier></type><name>pcc</name></decl></parameter>, <parameter><decl><type><name>pg_wchar</name></type> <name>chr1</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nchrs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>chr</name>		   <modifier>*</modifier></type><name>newchrs</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>nchrs</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>pcc</name><operator>-&gt;</operator><name>cv</name><operator>.</operator><name>nranges</name></name> <operator>&gt;=</operator> <name><name>pcc</name><operator>-&gt;</operator><name>cv</name><operator>.</operator><name>rangespace</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>pcc</name><operator>-&gt;</operator><name>cv</name><operator>.</operator><name>rangespace</name></name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>newchrs</name> <operator>=</operator> <operator>(</operator><name>chr</name> <operator>*</operator><operator>)</operator> <call><name>realloc</name><argument_list>(<argument><expr><name><name>pcc</name><operator>-&gt;</operator><name>cv</name><operator>.</operator><name>ranges</name></name></expr></argument>,
									  <argument><expr><name><name>pcc</name><operator>-&gt;</operator><name>cv</name><operator>.</operator><name>rangespace</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>chr</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>newchrs</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
			<expr_stmt><expr><name><name>pcc</name><operator>-&gt;</operator><name>cv</name><operator>.</operator><name>ranges</name></name> <operator>=</operator> <name>newchrs</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name><name>pcc</name><operator>-&gt;</operator><name>cv</name><operator>.</operator><name>ranges</name><index>[<expr><name><name>pcc</name><operator>-&gt;</operator><name>cv</name><operator>.</operator><name>nranges</name></name> <operator>*</operator> <literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>chr1</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pcc</name><operator>-&gt;</operator><name>cv</name><operator>.</operator><name>ranges</name><index>[<expr><name><name>pcc</name><operator>-&gt;</operator><name>cv</name><operator>.</operator><name>nranges</name></name> <operator>*</operator> <literal type="number">2</literal> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>chr1</name> <operator>+</operator> <name>nchrs</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pcc</name><operator>-&gt;</operator><name>cv</name><operator>.</operator><name>nranges</name></name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>nchrs</name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>pcc</name><operator>-&gt;</operator><name>cv</name><operator>.</operator><name>nchrs</name></name> <operator>&gt;=</operator> <name><name>pcc</name><operator>-&gt;</operator><name>cv</name><operator>.</operator><name>chrspace</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>pcc</name><operator>-&gt;</operator><name>cv</name><operator>.</operator><name>chrspace</name></name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>newchrs</name> <operator>=</operator> <operator>(</operator><name>chr</name> <operator>*</operator><operator>)</operator> <call><name>realloc</name><argument_list>(<argument><expr><name><name>pcc</name><operator>-&gt;</operator><name>cv</name><operator>.</operator><name>chrs</name></name></expr></argument>,
									  <argument><expr><name><name>pcc</name><operator>-&gt;</operator><name>cv</name><operator>.</operator><name>chrspace</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>chr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>newchrs</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
			<expr_stmt><expr><name><name>pcc</name><operator>-&gt;</operator><name>cv</name><operator>.</operator><name>chrs</name></name> <operator>=</operator> <name>newchrs</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name><name>pcc</name><operator>-&gt;</operator><name>cv</name><operator>.</operator><name>chrs</name><index>[<expr><name><name>pcc</name><operator>-&gt;</operator><name>cv</name><operator>.</operator><name>nchrs</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>chr1</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Given a probe function (e.g., pg_wc_isalpha) get a struct cvec for all
 * chrs satisfying the probe function.  The active collation is the one
 * previously set by pg_set_regex_collation.  Return NULL if out of memory.
 *
 * Note that the result must not be freed or modified by caller.
 */</comment>
<function><type><specifier>static</specifier> <name><name>struct</name> <name>cvec</name></name> <modifier>*</modifier></type>
<name>pg_ctype_get_cache</name><parameter_list>(<parameter><decl><type><name>pg_wc_probefunc</name></type> <name>probefunc</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>cclasscode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>pg_ctype_cache</name> <modifier>*</modifier></type><name>pcc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pg_wchar</name></type>	<name>max_chr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pg_wchar</name></type>	<name>cur_chr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nmatches</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>chr</name>		   <modifier>*</modifier></type><name>newchrs</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Do we already have the answer cached?
	 */</comment>
	<for>for <control>(<init><expr><name>pcc</name> <operator>=</operator> <name>pg_ctype_cache_list</name></expr>;</init> <condition><expr><name>pcc</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>pcc</name> <operator>=</operator> <name><name>pcc</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>pcc</name><operator>-&gt;</operator><name>probefunc</name></name> <operator>==</operator> <name>probefunc</name> <operator>&amp;&amp;</operator>
			<name><name>pcc</name><operator>-&gt;</operator><name>collation</name></name> <operator>==</operator> <name>pg_regex_collation</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><operator>&amp;</operator><name><name>pcc</name><operator>-&gt;</operator><name>cv</name></name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Nope, so initialize some workspace ...
	 */</comment>
	<expr_stmt><expr><name>pcc</name> <operator>=</operator> <operator>(</operator><name>pg_ctype_cache</name> <operator>*</operator><operator>)</operator> <call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>pg_ctype_cache</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>pcc</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>pcc</name><operator>-&gt;</operator><name>probefunc</name></name> <operator>=</operator> <name>probefunc</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pcc</name><operator>-&gt;</operator><name>collation</name></name> <operator>=</operator> <name>pg_regex_collation</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pcc</name><operator>-&gt;</operator><name>cv</name><operator>.</operator><name>nchrs</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pcc</name><operator>-&gt;</operator><name>cv</name><operator>.</operator><name>chrspace</name></name> <operator>=</operator> <literal type="number">128</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pcc</name><operator>-&gt;</operator><name>cv</name><operator>.</operator><name>chrs</name></name> <operator>=</operator> <operator>(</operator><name>chr</name> <operator>*</operator><operator>)</operator> <call><name>malloc</name><argument_list>(<argument><expr><name><name>pcc</name><operator>-&gt;</operator><name>cv</name><operator>.</operator><name>chrspace</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>chr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pcc</name><operator>-&gt;</operator><name>cv</name><operator>.</operator><name>nranges</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pcc</name><operator>-&gt;</operator><name>cv</name><operator>.</operator><name>rangespace</name></name> <operator>=</operator> <literal type="number">64</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pcc</name><operator>-&gt;</operator><name>cv</name><operator>.</operator><name>ranges</name></name> <operator>=</operator> <operator>(</operator><name>chr</name> <operator>*</operator><operator>)</operator> <call><name>malloc</name><argument_list>(<argument><expr><name><name>pcc</name><operator>-&gt;</operator><name>cv</name><operator>.</operator><name>rangespace</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>chr</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>pcc</name><operator>-&gt;</operator><name>cv</name><operator>.</operator><name>chrs</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>pcc</name><operator>-&gt;</operator><name>cv</name><operator>.</operator><name>ranges</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>out_of_memory</name>;</goto></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>pcc</name><operator>-&gt;</operator><name>cv</name><operator>.</operator><name>cclasscode</name></name> <operator>=</operator> <name>cclasscode</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Decide how many character codes we ought to look through.  In general
	 * we don't go past MAX_SIMPLE_CHR; chr codes above that are handled at
	 * runtime using the "high colormap" mechanism.  However, in C locale
	 * there's no need to go further than 127, and if we only have a 1-byte
	 * &lt;ctype.h&gt; API there's no need to go further than that can handle.
	 *
	 * If it's not MAX_SIMPLE_CHR that's constraining the search, mark the
	 * output cvec as not having any locale-dependent behavior, since there
	 * will be no need to do any run-time locale checks.  (The #if's here
	 * would always be true for production values of MAX_SIMPLE_CHR, but it's
	 * useful to allow it to be small for testing purposes.)
	 */</comment>
	<switch>switch <condition>(<expr><name>pg_regex_strategy</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>PG_REGEX_LOCALE_C</name></expr>:</case>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>MAX_SIMPLE_CHR</name> <operator>&gt;=</operator> <literal type="number">127</literal></expr></cpp:if>
			<expr_stmt><expr><name>max_chr</name> <operator>=</operator> <operator>(</operator><name>pg_wchar</name><operator>)</operator> <literal type="number">127</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>pcc</name><operator>-&gt;</operator><name>cv</name><operator>.</operator><name>cclasscode</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
			<expr_stmt><expr><name>max_chr</name> <operator>=</operator> <operator>(</operator><name>pg_wchar</name><operator>)</operator> <name>MAX_SIMPLE_CHR</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<break>break;</break>
		<case>case <expr><name>PG_REGEX_LOCALE_WIDE</name></expr>:</case>
		<case>case <expr><name>PG_REGEX_LOCALE_WIDE_L</name></expr>:</case>
			<expr_stmt><expr><name>max_chr</name> <operator>=</operator> <operator>(</operator><name>pg_wchar</name><operator>)</operator> <name>MAX_SIMPLE_CHR</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>PG_REGEX_LOCALE_1BYTE</name></expr>:</case>
		<case>case <expr><name>PG_REGEX_LOCALE_1BYTE_L</name></expr>:</case>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>MAX_SIMPLE_CHR</name> <operator>&gt;=</operator> <name>UCHAR_MAX</name></expr></cpp:if>
			<expr_stmt><expr><name>max_chr</name> <operator>=</operator> <operator>(</operator><name>pg_wchar</name><operator>)</operator> <name>UCHAR_MAX</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>pcc</name><operator>-&gt;</operator><name>cv</name><operator>.</operator><name>cclasscode</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
			<expr_stmt><expr><name>max_chr</name> <operator>=</operator> <operator>(</operator><name>pg_wchar</name><operator>)</operator> <name>MAX_SIMPLE_CHR</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<break>break;</break>
		<case>case <expr><name>PG_REGEX_LOCALE_ICU</name></expr>:</case>
			<expr_stmt><expr><name>max_chr</name> <operator>=</operator> <operator>(</operator><name>pg_wchar</name><operator>)</operator> <name>MAX_SIMPLE_CHR</name></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><name>max_chr</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>		<comment type="block">/* can't get here, but keep compiler quiet */</comment>
			<break>break;</break>
	</block_content>}</block></switch>

	<comment type="block">/*
	 * And scan 'em ...
	 */</comment>
	<expr_stmt><expr><name>nmatches</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>				<comment type="block">/* number of consecutive matches */</comment>

	<for>for <control>(<init><expr><name>cur_chr</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>cur_chr</name> <operator>&lt;=</operator> <name>max_chr</name></expr>;</condition> <incr><expr><name>cur_chr</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call>(<modifier>*</modifier><name>probefunc</name>) <argument_list>(<argument><expr><name>cur_chr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>nmatches</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name>nmatches</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>store_match</name><argument_list>(<argument><expr><name>pcc</name></expr></argument>, <argument><expr><name>cur_chr</name> <operator>-</operator> <name>nmatches</name></expr></argument>, <argument><expr><name>nmatches</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<goto>goto <name>out_of_memory</name>;</goto></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>nmatches</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><name>nmatches</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>store_match</name><argument_list>(<argument><expr><name>pcc</name></expr></argument>, <argument><expr><name>cur_chr</name> <operator>-</operator> <name>nmatches</name></expr></argument>, <argument><expr><name>nmatches</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>out_of_memory</name>;</goto></block_content></block></if></if_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * We might have allocated more memory than needed, if so free it
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>pcc</name><operator>-&gt;</operator><name>cv</name><operator>.</operator><name>nchrs</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>pcc</name><operator>-&gt;</operator><name>cv</name><operator>.</operator><name>chrs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pcc</name><operator>-&gt;</operator><name>cv</name><operator>.</operator><name>chrs</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pcc</name><operator>-&gt;</operator><name>cv</name><operator>.</operator><name>chrspace</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>pcc</name><operator>-&gt;</operator><name>cv</name><operator>.</operator><name>nchrs</name></name> <operator>&lt;</operator> <name><name>pcc</name><operator>-&gt;</operator><name>cv</name><operator>.</operator><name>chrspace</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>newchrs</name> <operator>=</operator> <operator>(</operator><name>chr</name> <operator>*</operator><operator>)</operator> <call><name>realloc</name><argument_list>(<argument><expr><name><name>pcc</name><operator>-&gt;</operator><name>cv</name><operator>.</operator><name>chrs</name></name></expr></argument>,
								  <argument><expr><name><name>pcc</name><operator>-&gt;</operator><name>cv</name><operator>.</operator><name>nchrs</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>chr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>newchrs</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>out_of_memory</name>;</goto></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>pcc</name><operator>-&gt;</operator><name>cv</name><operator>.</operator><name>chrs</name></name> <operator>=</operator> <name>newchrs</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pcc</name><operator>-&gt;</operator><name>cv</name><operator>.</operator><name>chrspace</name></name> <operator>=</operator> <name><name>pcc</name><operator>-&gt;</operator><name>cv</name><operator>.</operator><name>nchrs</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>pcc</name><operator>-&gt;</operator><name>cv</name><operator>.</operator><name>nranges</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>pcc</name><operator>-&gt;</operator><name>cv</name><operator>.</operator><name>ranges</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pcc</name><operator>-&gt;</operator><name>cv</name><operator>.</operator><name>ranges</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pcc</name><operator>-&gt;</operator><name>cv</name><operator>.</operator><name>rangespace</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>pcc</name><operator>-&gt;</operator><name>cv</name><operator>.</operator><name>nranges</name></name> <operator>&lt;</operator> <name><name>pcc</name><operator>-&gt;</operator><name>cv</name><operator>.</operator><name>rangespace</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>newchrs</name> <operator>=</operator> <operator>(</operator><name>chr</name> <operator>*</operator><operator>)</operator> <call><name>realloc</name><argument_list>(<argument><expr><name><name>pcc</name><operator>-&gt;</operator><name>cv</name><operator>.</operator><name>ranges</name></name></expr></argument>,
								  <argument><expr><name><name>pcc</name><operator>-&gt;</operator><name>cv</name><operator>.</operator><name>nranges</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>chr</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>newchrs</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>out_of_memory</name>;</goto></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>pcc</name><operator>-&gt;</operator><name>cv</name><operator>.</operator><name>ranges</name></name> <operator>=</operator> <name>newchrs</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pcc</name><operator>-&gt;</operator><name>cv</name><operator>.</operator><name>rangespace</name></name> <operator>=</operator> <name><name>pcc</name><operator>-&gt;</operator><name>cv</name><operator>.</operator><name>nranges</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Success, link it into cache chain
	 */</comment>
	<expr_stmt><expr><name><name>pcc</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>pg_ctype_cache_list</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>pg_ctype_cache_list</name> <operator>=</operator> <name>pcc</name></expr>;</expr_stmt>

	<return>return <expr><operator>&amp;</operator><name><name>pcc</name><operator>-&gt;</operator><name>cv</name></name></expr>;</return>

	<comment type="block">/*
	 * Failure, clean up
	 */</comment>
<label><name>out_of_memory</name>:</label>
	<if_stmt><if>if <condition>(<expr><name><name>pcc</name><operator>-&gt;</operator><name>cv</name><operator>.</operator><name>chrs</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>pcc</name><operator>-&gt;</operator><name>cv</name><operator>.</operator><name>chrs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>pcc</name><operator>-&gt;</operator><name>cv</name><operator>.</operator><name>ranges</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>pcc</name><operator>-&gt;</operator><name>cv</name><operator>.</operator><name>ranges</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>pcc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>
</unit>
