<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/backend/libpq/be-fsstubs.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * be-fsstubs.c
 *	  Builtin functions for open/close/read/write operations on large objects
 *
 * Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/libpq/be-fsstubs.c
 *
 * NOTES
 *	  This should be moved to a more appropriate place.  It is here
 *	  for lack of a better place.
 *
 *	  These functions store LargeObjectDesc structs in a private MemoryContext,
 *	  which means that large object descriptors hang around until we destroy
 *	  the context at transaction end.  It'd be possible to prolong the lifetime
 *	  of the context so that LO FDs are good across transactions (for example,
 *	  we could release the context only if we see that no FDs remain open).
 *	  But we'd need additional state in order to do the right thing at the
 *	  end of an aborted transaction.  FDs opened during an aborted xact would
 *	  still need to be closed, since they might not be pointing at valid
 *	  relations at all.  Locking semantics are also an interesting problem
 *	  if LOs stay open across transactions.  For now, we'll stick with the
 *	  existing documented semantics of LO FDs: they're only good within a
 *	  transaction.
 *
 *	  As of PostgreSQL 8.0, much of the angst expressed above is no longer
 *	  relevant, and in fact it'd be pretty easy to allow LO FDs to stay
 *	  open across transactions.  (Snapshot relevancy would still be an issue.)
 *	  However backwards compatibility suggests that we should stick to the
 *	  status quo.
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fcntl.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/stat.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq/be-fsstubs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq/libpq-fs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/fd.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/large_object.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/acl.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>

<comment type="block">/* define this to enable debug logging */</comment>
<comment type="block">/* #define FSDB 1 */</comment>
<comment type="block">/* chunk size for lo_import/lo_export transfers */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BUFSIZE</name></cpp:macro>			<cpp:value>8192</cpp:value></cpp:define>

<comment type="block">/*
 * LO "FD"s are indexes into the cookies array.
 *
 * A non-null entry is a pointer to a LargeObjectDesc allocated in the
 * LO private memory context "fscxt".  The cookies array itself is also
 * dynamically allocated in that context.  Its current allocated size is
 * cookies_size entries, of which any unused entries will be NULL.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>LargeObjectDesc</name> <modifier>*</modifier><modifier>*</modifier></type><name>cookies</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>cookies_size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>MemoryContext</name></type> <name>fscxt</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CreateFSContext</name><parameter_list>()</parameter_list></cpp:macro> \
	<cpp:value>do { \
		if (fscxt == NULL) \
			fscxt = AllocSetContextCreate(TopMemoryContext, \
										  "Filesystem", \
										  ALLOCSET_DEFAULT_SIZES); \
	} while (0)</cpp:value></cpp:define>


<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>newLOfd</name><parameter_list>(<parameter><decl><type><name>LargeObjectDesc</name> <modifier>*</modifier></type><name>lobjCookie</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>deleteLOfd</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Oid</name></type>	<name>lo_import_internal</name><parameter_list>(<parameter><decl><type><name>text</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>lobjOid</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block" format="doxygen">/*****************************************************************************
 *	File Interfaces for Large Objects
 *****************************************************************************/</comment>

<function><type><name>Datum</name></type>
<name>be_lo_open</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>lobjId</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>mode</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LargeObjectDesc</name> <modifier>*</modifier></type><name>lobjDesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>fd</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
		<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
		 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"large objects are not supported"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>FSDB</name></expr></cpp:if>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG4</name></expr></argument>, <argument><expr><literal type="string">"lo_open(%u,%d)"</literal></expr></argument>, <argument><expr><name>lobjId</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><call><name>CreateFSContext</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>lobjDesc</name> <operator>=</operator> <call><name>inv_open</name><argument_list>(<argument><expr><name>lobjId</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>, <argument><expr><name>fscxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>newLOfd</name><argument_list>(<argument><expr><name>lobjDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_INT32</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>be_lo_close</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int32</name></type>		<name>fd</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
		<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
		 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"large objects are not supported"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>fd</name> <operator>&gt;=</operator> <name>cookies_size</name> <operator>||</operator> <name><name>cookies</name><index>[<expr><name>fd</name></expr>]</index></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid large-object descriptor: %d"</literal></expr></argument>, <argument><expr><name>fd</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>FSDB</name></expr></cpp:if>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG4</name></expr></argument>, <argument><expr><literal type="string">"lo_close(%d)"</literal></expr></argument>, <argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><call><name>inv_close</name><argument_list>(<argument><expr><name><name>cookies</name><index>[<expr><name>fd</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>deleteLOfd</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_INT32</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block" format="doxygen">/*****************************************************************************
 *	Bare Read/Write operations --- these are not fmgr-callable!
 *
 *	We assume the large object supports byte oriented reads and seeks so
 *	that our work is easier.
 *
 *****************************************************************************/</comment>

<function><type><name>int</name></type>
<name>lo_read</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>status</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LargeObjectDesc</name> <modifier>*</modifier></type><name>lobj</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>fd</name> <operator>&gt;=</operator> <name>cookies_size</name> <operator>||</operator> <name><name>cookies</name><index>[<expr><name>fd</name></expr>]</index></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid large-object descriptor: %d"</literal></expr></argument>, <argument><expr><name>fd</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>lobj</name> <operator>=</operator> <name><name>cookies</name><index>[<expr><name>fd</name></expr>]</index></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Check state.  inv_read() would throw an error anyway, but we want the
	 * error to be about the FD's state not the underlying privilege; it might
	 * be that the privilege exists but user forgot to ask for read mode.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>lobj</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>IFS_RDLOCK</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"large object descriptor %d was not opened for reading"</literal></expr></argument>,
						<argument><expr><name>fd</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>inv_read</name><argument_list>(<argument><expr><name>lobj</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>status</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>lo_write</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>status</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LargeObjectDesc</name> <modifier>*</modifier></type><name>lobj</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>fd</name> <operator>&gt;=</operator> <name>cookies_size</name> <operator>||</operator> <name><name>cookies</name><index>[<expr><name>fd</name></expr>]</index></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid large-object descriptor: %d"</literal></expr></argument>, <argument><expr><name>fd</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>lobj</name> <operator>=</operator> <name><name>cookies</name><index>[<expr><name>fd</name></expr>]</index></name></expr>;</expr_stmt>

	<comment type="block">/* see comment in lo_read() */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>lobj</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>IFS_WRLOCK</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"large object descriptor %d was not opened for writing"</literal></expr></argument>,
						<argument><expr><name>fd</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>inv_write</name><argument_list>(<argument><expr><name>lobj</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>status</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>be_lo_lseek</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int32</name></type>		<name>fd</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>offset</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>whence</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type>		<name>status</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
		<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
		 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"large objects are not supported"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>fd</name> <operator>&gt;=</operator> <name>cookies_size</name> <operator>||</operator> <name><name>cookies</name><index>[<expr><name>fd</name></expr>]</index></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid large-object descriptor: %d"</literal></expr></argument>, <argument><expr><name>fd</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>inv_seek</name><argument_list>(<argument><expr><name><name>cookies</name><index>[<expr><name>fd</name></expr>]</index></name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>whence</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* guard against result overflow */</comment>
	<if_stmt><if>if <condition>(<expr><name>status</name> <operator>!=</operator> <operator>(</operator><name>int32</name><operator>)</operator> <name>status</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"lo_lseek result out of range for large-object descriptor %d"</literal></expr></argument>,
						<argument><expr><name>fd</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_INT32</name><argument_list>(<argument><expr><operator>(</operator><name>int32</name><operator>)</operator> <name>status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>be_lo_lseek64</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int32</name></type>		<name>fd</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type>		<name>offset</name> <init>= <expr><call><name>PG_GETARG_INT64</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>whence</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type>		<name>status</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>fd</name> <operator>&gt;=</operator> <name>cookies_size</name> <operator>||</operator> <name><name>cookies</name><index>[<expr><name>fd</name></expr>]</index></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid large-object descriptor: %d"</literal></expr></argument>, <argument><expr><name>fd</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>inv_seek</name><argument_list>(<argument><expr><name><name>cookies</name><index>[<expr><name>fd</name></expr>]</index></name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>whence</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_INT64</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>be_lo_creat</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>lobjId</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
		<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
		 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"large objects are not supported"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We don't actually need to store into fscxt, but create it anyway to
	 * ensure that AtEOXact_LargeObject knows there is state to clean up
	 */</comment>
	<expr_stmt><expr><call><name>CreateFSContext</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>lobjId</name> <operator>=</operator> <call><name>inv_create</name><argument_list>(<argument><expr><name>InvalidOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_OID</name><argument_list>(<argument><expr><name>lobjId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>be_lo_create</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>lobjId</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
		<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
		 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"large objects are not supported"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We don't actually need to store into fscxt, but create it anyway to
	 * ensure that AtEOXact_LargeObject knows there is state to clean up
	 */</comment>
	<expr_stmt><expr><call><name>CreateFSContext</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>lobjId</name> <operator>=</operator> <call><name>inv_create</name><argument_list>(<argument><expr><name>lobjId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_OID</name><argument_list>(<argument><expr><name>lobjId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>be_lo_tell</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int32</name></type>		<name>fd</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type>		<name>offset</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
		<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
		 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"large objects are not supported"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>fd</name> <operator>&gt;=</operator> <name>cookies_size</name> <operator>||</operator> <name><name>cookies</name><index>[<expr><name>fd</name></expr>]</index></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid large-object descriptor: %d"</literal></expr></argument>, <argument><expr><name>fd</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>offset</name> <operator>=</operator> <call><name>inv_tell</name><argument_list>(<argument><expr><name><name>cookies</name><index>[<expr><name>fd</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* guard against result overflow */</comment>
	<if_stmt><if>if <condition>(<expr><name>offset</name> <operator>!=</operator> <operator>(</operator><name>int32</name><operator>)</operator> <name>offset</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"lo_tell result out of range for large-object descriptor %d"</literal></expr></argument>,
						<argument><expr><name>fd</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_INT32</name><argument_list>(<argument><expr><operator>(</operator><name>int32</name><operator>)</operator> <name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>be_lo_tell64</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int32</name></type>		<name>fd</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type>		<name>offset</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>fd</name> <operator>&gt;=</operator> <name>cookies_size</name> <operator>||</operator> <name><name>cookies</name><index>[<expr><name>fd</name></expr>]</index></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid large-object descriptor: %d"</literal></expr></argument>, <argument><expr><name>fd</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>offset</name> <operator>=</operator> <call><name>inv_tell</name><argument_list>(<argument><expr><name><name>cookies</name><index>[<expr><name>fd</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_INT64</name><argument_list>(<argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>be_lo_unlink</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>lobjId</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
		<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
		 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"large objects are not supported"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Must be owner of the large object.  It would be cleaner to check this
	 * in inv_drop(), but we want to throw the error before not after closing
	 * relevant FDs.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>lo_compat_privileges</name> <operator>&amp;&amp;</operator>
		<operator>!</operator><call><name>pg_largeobject_ownercheck</name><argument_list>(<argument><expr><name>lobjId</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_PRIVILEGE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"must be owner of large object %u"</literal></expr></argument>, <argument><expr><name>lobjId</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If there are any open LO FDs referencing that ID, close 'em.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>fscxt</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>cookies_size</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>cookies</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>cookies</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>id</name> <operator>==</operator> <name>lobjId</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>inv_close</name><argument_list>(<argument><expr><name><name>cookies</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>deleteLOfd</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * inv_drop does not create a need for end-of-transaction cleanup and
	 * hence we don't need to have created fscxt.
	 */</comment>
	<expr_stmt><expr><call><name>PG_RETURN_INT32</name><argument_list>(<argument><expr><call><name>inv_drop</name><argument_list>(<argument><expr><name>lobjId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/*****************************************************************************
 *	Read/Write using bytea
 *****************************************************************************/</comment>

<function><type><name>Datum</name></type>
<name>be_loread</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int32</name></type>		<name>fd</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>len</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bytea</name>	   <modifier>*</modifier></type><name>retval</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>totalread</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
		<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
		 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"large objects are not supported"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>len</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>retval</name> <operator>=</operator> <operator>(</operator><name>bytea</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>VARHDRSZ</name> <operator>+</operator> <name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>totalread</name> <operator>=</operator> <call><name>lo_read</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><call><name>VARDATA</name><argument_list>(<argument><expr><name>retval</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><name>retval</name></expr></argument>, <argument><expr><name>totalread</name> <operator>+</operator> <name>VARHDRSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BYTEA_P</name><argument_list>(<argument><expr><name>retval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>be_lowrite</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int32</name></type>		<name>fd</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bytea</name>	   <modifier>*</modifier></type><name>wbuf</name> <init>= <expr><call><name>PG_GETARG_BYTEA_PP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>bytestowrite</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>totalwritten</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
		<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
		 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"large objects are not supported"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>bytestowrite</name> <operator>=</operator> <call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>wbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>totalwritten</name> <operator>=</operator> <call><name>lo_write</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>wbuf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>bytestowrite</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_INT32</name><argument_list>(<argument><expr><name>totalwritten</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/*****************************************************************************
 *	 Import/Export of Large Object
 *****************************************************************************/</comment>

<comment type="block">/*
 * lo_import -
 *	  imports a file as an (inversion) large object.
 */</comment>
<function><type><name>Datum</name></type>
<name>be_lo_import</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>filename</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
		<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
		 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"large objects are not supported"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_OID</name><argument_list>(<argument><expr><call><name>lo_import_internal</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * lo_import_with_oid -
 *	  imports a file as an (inversion) large object specifying oid.
 */</comment>
<function><type><name>Datum</name></type>
<name>be_lo_import_with_oid</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>filename</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>oid</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
		<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
		 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"large objects are not supported"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_OID</name><argument_list>(<argument><expr><call><name>lo_import_internal</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Oid</name></type>
<name>lo_import_internal</name><parameter_list>(<parameter><decl><type><name>text</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>lobjOid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>fd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nbytes</name></decl>,
				<decl><type ref="prev"/><name>tmp</name> <name>PG_USED_FOR_ASSERTS_ONLY</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>buf</name><index>[<expr><name>BUFSIZE</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>fnamebuf</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LargeObjectDesc</name> <modifier>*</modifier></type><name>lobj</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>oid</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>CreateFSContext</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * open the file to be read in
	 */</comment>
	<expr_stmt><expr><call><name>text_to_cstring_buffer</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><name>fnamebuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>fnamebuf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>OpenTransientFile</name><argument_list>(<argument><expr><name>fnamebuf</name></expr></argument>, <argument><expr><name>O_RDONLY</name> <operator>|</operator> <name>PG_BINARY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not open server file \"%s\": %m"</literal></expr></argument>,
						<argument><expr><name>fnamebuf</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * create an inversion object
	 */</comment>
	<expr_stmt><expr><name>oid</name> <operator>=</operator> <call><name>inv_create</name><argument_list>(<argument><expr><name>lobjOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * read in from the filesystem and write to the inversion object
	 */</comment>
	<expr_stmt><expr><name>lobj</name> <operator>=</operator> <call><name>inv_open</name><argument_list>(<argument><expr><name>oid</name></expr></argument>, <argument><expr><name>INV_WRITE</name></expr></argument>, <argument><expr><name>fscxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><operator>(</operator><name>nbytes</name> <operator>=</operator> <call><name>read</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>BUFSIZE</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>inv_write</name><argument_list>(<argument><expr><name>lobj</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>nbytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>tmp</name> <operator>==</operator> <name>nbytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<if_stmt><if>if <condition>(<expr><name>nbytes</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not read server file \"%s\": %m"</literal></expr></argument>,
						<argument><expr><name>fnamebuf</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>inv_close</name><argument_list>(<argument><expr><name>lobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>CloseTransientFile</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not close file \"%s\": %m"</literal></expr></argument>,
						<argument><expr><name>fnamebuf</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>oid</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * lo_export -
 *	  exports an (inversion) large object.
 */</comment>
<function><type><name>Datum</name></type>
<name>be_lo_export</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>lobjId</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>filename</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>fd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nbytes</name></decl>,
				<decl><type ref="prev"/><name>tmp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>buf</name><index>[<expr><name>BUFSIZE</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>fnamebuf</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LargeObjectDesc</name> <modifier>*</modifier></type><name>lobj</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>mode_t</name></type>		<name>oumask</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>CreateFSContext</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * open the inversion object (no need to test for failure)
	 */</comment>
	<expr_stmt><expr><name>lobj</name> <operator>=</operator> <call><name>inv_open</name><argument_list>(<argument><expr><name>lobjId</name></expr></argument>, <argument><expr><name>INV_READ</name></expr></argument>, <argument><expr><name>fscxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * open the file to be written to
	 *
	 * Note: we reduce backend's normal 077 umask to the slightly friendlier
	 * 022. This code used to drop it all the way to 0, but creating
	 * world-writable export files doesn't seem wise.
	 */</comment>
	<expr_stmt><expr><call><name>text_to_cstring_buffer</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><name>fnamebuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>fnamebuf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>oumask</name> <operator>=</operator> <call><name>umask</name><argument_list>(<argument><expr><name>S_IWGRP</name> <operator>|</operator> <name>S_IWOTH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>OpenTransientFilePerm</name><argument_list>(<argument><expr><name>fnamebuf</name></expr></argument>, <argument><expr><name>O_CREAT</name> <operator>|</operator> <name>O_WRONLY</name> <operator>|</operator> <name>O_TRUNC</name> <operator>|</operator> <name>PG_BINARY</name></expr></argument>,
								   <argument><expr><name>S_IRUSR</name> <operator>|</operator> <name>S_IWUSR</name> <operator>|</operator> <name>S_IRGRP</name> <operator>|</operator> <name>S_IROTH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<expr_stmt><expr><call><name>umask</name><argument_list>(<argument><expr><name>oumask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>umask</name><argument_list>(<argument><expr><name>oumask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not create server file \"%s\": %m"</literal></expr></argument>,
						<argument><expr><name>fnamebuf</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * read in from the inversion file and write to the filesystem
	 */</comment>
	<while>while <condition>(<expr><operator>(</operator><name>nbytes</name> <operator>=</operator> <call><name>inv_read</name><argument_list>(<argument><expr><name>lobj</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>BUFSIZE</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>write</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>nbytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>tmp</name> <operator>!=</operator> <name>nbytes</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not write server file \"%s\": %m"</literal></expr></argument>,
							<argument><expr><name>fnamebuf</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></while>

	<if_stmt><if>if <condition>(<expr><call><name>CloseTransientFile</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not close file \"%s\": %m"</literal></expr></argument>,
						<argument><expr><name>fnamebuf</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>inv_close</name><argument_list>(<argument><expr><name>lobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_INT32</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * lo_truncate -
 *	  truncate a large object to a specified length
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>lo_truncate_internal</name><parameter_list>(<parameter><decl><type><name>int32</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name>int64</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LargeObjectDesc</name> <modifier>*</modifier></type><name>lobj</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>fd</name> <operator>&gt;=</operator> <name>cookies_size</name> <operator>||</operator> <name><name>cookies</name><index>[<expr><name>fd</name></expr>]</index></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid large-object descriptor: %d"</literal></expr></argument>, <argument><expr><name>fd</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>lobj</name> <operator>=</operator> <name><name>cookies</name><index>[<expr><name>fd</name></expr>]</index></name></expr>;</expr_stmt>

	<comment type="block">/* see comment in lo_read() */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>lobj</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>IFS_WRLOCK</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"large object descriptor %d was not opened for writing"</literal></expr></argument>,
						<argument><expr><name>fd</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>inv_truncate</name><argument_list>(<argument><expr><name>lobj</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>be_lo_truncate</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int32</name></type>		<name>fd</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>len</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
		<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
		 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"large objects are not supported"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>lo_truncate_internal</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_INT32</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>be_lo_truncate64</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int32</name></type>		<name>fd</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type>		<name>len</name> <init>= <expr><call><name>PG_GETARG_INT64</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>lo_truncate_internal</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_INT32</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * AtEOXact_LargeObject -
 *		 prepares large objects for transaction commit
 */</comment>
<function><type><name>void</name></type>
<name>AtEOXact_LargeObject</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>isCommit</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>fscxt</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>					<comment type="block">/* no LO operations in this xact */</comment>

	<comment type="block">/*
	 * Close LO fds and clear cookies array so that LO fds are no longer good.
	 * On abort we skip the close step.
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>cookies_size</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>cookies</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>isCommit</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>inv_close</name><argument_list>(<argument><expr><name><name>cookies</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>deleteLOfd</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Needn't actually pfree since we're about to zap context */</comment>
	<expr_stmt><expr><name>cookies</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>cookies_size</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/* Release the LO memory context to prevent permanent memory leaks. */</comment>
	<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name>fscxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>fscxt</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/* Give inv_api.c a chance to clean up, too */</comment>
	<expr_stmt><expr><call><name>close_lo_relation</name><argument_list>(<argument><expr><name>isCommit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * AtEOSubXact_LargeObject
 *		Take care of large objects at subtransaction commit/abort
 *
 * Reassign LOs created/opened during a committing subtransaction
 * to the parent subtransaction.  On abort, just close them.
 */</comment>
<function><type><name>void</name></type>
<name>AtEOSubXact_LargeObject</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>isCommit</name></decl></parameter>, <parameter><decl><type><name>SubTransactionId</name></type> <name>mySubid</name></decl></parameter>,
						<parameter><decl><type><name>SubTransactionId</name></type> <name>parentSubid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>fscxt</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>			<comment type="block">/* no LO operations in this xact */</comment>
		<return>return;</return></block_content></block></if></if_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>cookies_size</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>LargeObjectDesc</name> <modifier>*</modifier></type><name>lo</name> <init>= <expr><name><name>cookies</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>lo</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>lo</name><operator>-&gt;</operator><name>subid</name></name> <operator>==</operator> <name>mySubid</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>isCommit</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>lo</name><operator>-&gt;</operator><name>subid</name></name> <operator>=</operator> <name>parentSubid</name></expr>;</expr_stmt></block_content></block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/*
				 * Make sure we do not call inv_close twice if it errors out
				 * for some reason.  Better a leak than a crash.
				 */</comment>
				<expr_stmt><expr><call><name>deleteLOfd</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>inv_close</name><argument_list>(<argument><expr><name>lo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block" format="doxygen">/*****************************************************************************
 *	Support routines for this file
 *****************************************************************************/</comment>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>newLOfd</name><parameter_list>(<parameter><decl><type><name>LargeObjectDesc</name> <modifier>*</modifier></type><name>lobjCookie</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
				<decl><type ref="prev"/><name>newsize</name></decl>;</decl_stmt>

	<comment type="block">/* Try to find a free slot */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>cookies_size</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>cookies</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>cookies</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>lobjCookie</name></expr>;</expr_stmt>
			<return>return <expr><name>i</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* No free slot, so make the array bigger */</comment>
	<if_stmt><if>if <condition>(<expr><name>cookies_size</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* First time through, arbitrarily make 64-element array */</comment>
		<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>newsize</name> <operator>=</operator> <literal type="number">64</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>cookies</name> <operator>=</operator> <operator>(</operator><name>LargeObjectDesc</name> <operator>*</operator><operator>*</operator><operator>)</operator>
			<call><name>MemoryContextAllocZero</name><argument_list>(<argument><expr><name>fscxt</name></expr></argument>, <argument><expr><name>newsize</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>LargeObjectDesc</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>cookies_size</name> <operator>=</operator> <name>newsize</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Double size of array */</comment>
		<expr_stmt><expr><name>i</name> <operator>=</operator> <name>cookies_size</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>newsize</name> <operator>=</operator> <name>cookies_size</name> <operator>*</operator> <literal type="number">2</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>cookies</name> <operator>=</operator> <operator>(</operator><name>LargeObjectDesc</name> <operator>*</operator><operator>*</operator><operator>)</operator>
			<call><name>repalloc</name><argument_list>(<argument><expr><name>cookies</name></expr></argument>, <argument><expr><name>newsize</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>LargeObjectDesc</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>cookies</name> <operator>+</operator> <name>cookies_size</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
			   <argument><expr><operator>(</operator><name>newsize</name> <operator>-</operator> <name>cookies_size</name><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>LargeObjectDesc</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>cookies_size</name> <operator>=</operator> <name>newsize</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>cookies</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cookies</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>lobjCookie</name></expr>;</expr_stmt>
	<return>return <expr><name>i</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>deleteLOfd</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>cookies</name><index>[<expr><name>fd</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/*****************************************************************************
 *	Wrappers oriented toward SQL callers
 *****************************************************************************/</comment>

<comment type="block">/*
 * Read [offset, offset+nbytes) within LO; when nbytes is -1, read to end.
 */</comment>
<function><type><specifier>static</specifier> <name>bytea</name> <modifier>*</modifier></type>
<name>lo_get_fragment_internal</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>loOid</name></decl></parameter>, <parameter><decl><type><name>int64</name></type> <name>offset</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>nbytes</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LargeObjectDesc</name> <modifier>*</modifier></type><name>loDesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type>		<name>loSize</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type>		<name>result_length</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name>			<name>total_read</name></type> <name>PG_USED_FOR_ASSERTS_ONLY</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bytea</name>	   <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * We don't actually need to store into fscxt, but create it anyway to
	 * ensure that AtEOXact_LargeObject knows there is state to clean up
	 */</comment>
	<expr_stmt><expr><call><name>CreateFSContext</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>loDesc</name> <operator>=</operator> <call><name>inv_open</name><argument_list>(<argument><expr><name>loOid</name></expr></argument>, <argument><expr><name>INV_READ</name></expr></argument>, <argument><expr><name>fscxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Compute number of bytes we'll actually read, accommodating nbytes == -1
	 * and reads beyond the end of the LO.
	 */</comment>
	<expr_stmt><expr><name>loSize</name> <operator>=</operator> <call><name>inv_seek</name><argument_list>(<argument><expr><name>loDesc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SEEK_END</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>loSize</name> <operator>&gt;</operator> <name>offset</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>nbytes</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>nbytes</name> <operator>&lt;=</operator> <name>loSize</name> <operator>-</operator> <name>offset</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>result_length</name> <operator>=</operator> <name>nbytes</name></expr>;</expr_stmt></block_content></block></if> <comment type="block">/* request is wholly inside LO */</comment>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>result_length</name> <operator>=</operator> <name>loSize</name> <operator>-</operator> <name>offset</name></expr>;</expr_stmt></block_content></block></else></if_stmt>	<comment type="block">/* adjust to end of LO */</comment>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>result_length</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>		<comment type="block">/* request is wholly outside LO */</comment>

	<comment type="block">/*
	 * A result_length calculated from loSize may not fit in a size_t.  Check
	 * that the size will satisfy this and subsequently-enforced size limits.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>result_length</name> <operator>&gt;</operator> <name>MaxAllocSize</name> <operator>-</operator> <name>VARHDRSZ</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROGRAM_LIMIT_EXCEEDED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"large object read request is too large"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>bytea</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>VARHDRSZ</name> <operator>+</operator> <name>result_length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>inv_seek</name><argument_list>(<argument><expr><name>loDesc</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>SEEK_SET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>total_read</name> <operator>=</operator> <call><name>inv_read</name><argument_list>(<argument><expr><name>loDesc</name></expr></argument>, <argument><expr><call><name>VARDATA</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>result_length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>total_read</name> <operator>==</operator> <name>result_length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>result_length</name> <operator>+</operator> <name>VARHDRSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>inv_close</name><argument_list>(<argument><expr><name>loDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Read entire LO
 */</comment>
<function><type><name>Datum</name></type>
<name>be_lo_get</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>loOid</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bytea</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lo_get_fragment_internal</name><argument_list>(<argument><expr><name>loOid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BYTEA_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Read range within LO
 */</comment>
<function><type><name>Datum</name></type>
<name>be_lo_get_fragment</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>loOid</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type>		<name>offset</name> <init>= <expr><call><name>PG_GETARG_INT64</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>nbytes</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bytea</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>nbytes</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"requested length cannot be negative"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lo_get_fragment_internal</name><argument_list>(<argument><expr><name>loOid</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>nbytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BYTEA_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Create LO with initial contents given by a bytea argument
 */</comment>
<function><type><name>Datum</name></type>
<name>be_lo_from_bytea</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>loOid</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bytea</name>	   <modifier>*</modifier></type><name>str</name> <init>= <expr><call><name>PG_GETARG_BYTEA_PP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LargeObjectDesc</name> <modifier>*</modifier></type><name>loDesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name>			<name>written</name></type> <name>PG_USED_FOR_ASSERTS_ONLY</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>CreateFSContext</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>loOid</name> <operator>=</operator> <call><name>inv_create</name><argument_list>(<argument><expr><name>loOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>loDesc</name> <operator>=</operator> <call><name>inv_open</name><argument_list>(<argument><expr><name>loOid</name></expr></argument>, <argument><expr><name>INV_WRITE</name></expr></argument>, <argument><expr><name>fscxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>written</name> <operator>=</operator> <call><name>inv_write</name><argument_list>(<argument><expr><name>loDesc</name></expr></argument>, <argument><expr><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>written</name> <operator>==</operator> <call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>inv_close</name><argument_list>(<argument><expr><name>loDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_OID</name><argument_list>(<argument><expr><name>loOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Update range within LO
 */</comment>
<function><type><name>Datum</name></type>
<name>be_lo_put</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>loOid</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type>		<name>offset</name> <init>= <expr><call><name>PG_GETARG_INT64</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bytea</name>	   <modifier>*</modifier></type><name>str</name> <init>= <expr><call><name>PG_GETARG_BYTEA_PP</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LargeObjectDesc</name> <modifier>*</modifier></type><name>loDesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name>			<name>written</name></type> <name>PG_USED_FOR_ASSERTS_ONLY</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>CreateFSContext</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>loDesc</name> <operator>=</operator> <call><name>inv_open</name><argument_list>(<argument><expr><name>loOid</name></expr></argument>, <argument><expr><name>INV_WRITE</name></expr></argument>, <argument><expr><name>fscxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Permission check */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>lo_compat_privileges</name> <operator>&amp;&amp;</operator>
		<call><name>pg_largeobject_aclcheck_snapshot</name><argument_list>(<argument><expr><name><name>loDesc</name><operator>-&gt;</operator><name>id</name></name></expr></argument>,
										 <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>,
										 <argument><expr><name>ACL_UPDATE</name></expr></argument>,
										 <argument><expr><name><name>loDesc</name><operator>-&gt;</operator><name>snapshot</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>ACLCHECK_OK</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_PRIVILEGE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"permission denied for large object %u"</literal></expr></argument>,
						<argument><expr><name><name>loDesc</name><operator>-&gt;</operator><name>id</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>inv_seek</name><argument_list>(<argument><expr><name>loDesc</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>SEEK_SET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>written</name> <operator>=</operator> <call><name>inv_write</name><argument_list>(<argument><expr><name>loDesc</name></expr></argument>, <argument><expr><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>written</name> <operator>==</operator> <call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>inv_close</name><argument_list>(<argument><expr><name>loDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
