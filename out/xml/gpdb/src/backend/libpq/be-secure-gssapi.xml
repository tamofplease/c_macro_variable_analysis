<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/backend/libpq/be-secure-gssapi.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * be-secure-gssapi.c
 *  GSSAPI encryption support
 *
 * Portions Copyright (c) 2018-2019, PostgreSQL Global Development Group
 *
 * IDENTIFICATION
 *  src/backend/libpq/be-secure-gssapi.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq/auth.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq/be-gssapi-common.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq/libpq.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq/pqformat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgstat.h"</cpp:file></cpp:include>


<comment type="block">/*
 * Handle the encryption/decryption of data using GSSAPI.
 *
 * In the encrypted data stream on the wire, we break up the data
 * into packets where each packet starts with a uint32-size length
 * word (in network byte order), then encrypted data of that length
 * immediately following.  Decryption yields the same data stream
 * that would appear when not using encryption.
 *
 * Encrypted data typically ends up being larger than the same data
 * unencrypted, so we use fixed-size buffers for handling the
 * encryption/decryption which are larger than PQComm's buffer will
 * typically be to minimize the times where we have to make multiple
 * packets (and therefore multiple recv/send calls for a single
 * read/write call to us).
 *
 * NOTE: The client and server have to agree on the max packet size,
 * because we have to pass an entire packet to GSSAPI at a time and we
 * don't want the other side to send arbitrarily huge packets as we
 * would have to allocate memory for them to then pass them to GSSAPI.
 *
 * Therefore, these two #define's are effectively part of the protocol
 * spec and can't ever be changed.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PQ_GSS_SEND_BUFFER_SIZE</name></cpp:macro> <cpp:value>16384</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PQ_GSS_RECV_BUFFER_SIZE</name></cpp:macro> <cpp:value>16384</cpp:value></cpp:define>

<comment type="block">/*
 * Since we manage at most one GSS-encrypted connection per backend,
 * we can just keep all this state in static variables.  The char *
 * variables point to buffers that are allocated once and re-used.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>PqGSSSendBuffer</name></decl>;</decl_stmt>	<comment type="block">/* Encrypted data waiting to be sent */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>PqGSSSendLength</name></decl>;</decl_stmt>	<comment type="block">/* End of data available in PqGSSSendBuffer */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>PqGSSSendNext</name></decl>;</decl_stmt>		<comment type="block">/* Next index to send a byte from
								 * PqGSSSendBuffer */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>PqGSSSendConsumed</name></decl>;</decl_stmt>	<comment type="block">/* Number of *unencrypted* bytes consumed for
								 * current contents of PqGSSSendBuffer */</comment>

<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>PqGSSRecvBuffer</name></decl>;</decl_stmt>	<comment type="block">/* Received, encrypted data */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>PqGSSRecvLength</name></decl>;</decl_stmt>	<comment type="block">/* End of data available in PqGSSRecvBuffer */</comment>

<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>PqGSSResultBuffer</name></decl>;</decl_stmt> <comment type="block">/* Decryption of data in gss_RecvBuffer */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>PqGSSResultLength</name></decl>;</decl_stmt>	<comment type="block">/* End of data available in PqGSSResultBuffer */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>PqGSSResultNext</name></decl>;</decl_stmt>	<comment type="block">/* Next index to read a byte from
								 * PqGSSResultBuffer */</comment>

<decl_stmt><decl><type><specifier>static</specifier> <name>uint32</name></type> <name>PqGSSMaxPktSize</name></decl>;</decl_stmt>	<comment type="block">/* Maximum size we can encrypt and fit the
								 * results into our output buffer */</comment>


<comment type="block">/*
 * Attempt to write len bytes of data from ptr to a GSSAPI-encrypted connection.
 *
 * The connection must be already set up for GSSAPI encryption (i.e., GSSAPI
 * transport negotiation is complete).
 *
 * On success, returns the number of data bytes consumed (possibly less than
 * len).  On failure, returns -1 with errno set appropriately.  (For fatal
 * errors, we may just elog and exit, if errno wouldn't be sufficient to
 * describe the error.)  For retryable errors, caller should call again
 * (passing the same data) once the socket is ready.
 */</comment>
<function><type><name>ssize_t</name></type>
<name>be_gssapi_write</name><parameter_list>(<parameter><decl><type><name>Port</name> <modifier>*</modifier></type><name>port</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OM_uint32</name></type>	<name>major</name></decl>,
				<decl><type ref="prev"/><name>minor</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>gss_buffer_desc</name></type> <name>input</name></decl>,
				<decl><type ref="prev"/><name>output</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type>		<name>bytes_sent</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type>		<name>bytes_to_encrypt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type>		<name>bytes_encrypted</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>gss_ctx_id_t</name></type> <name>gctx</name> <init>= <expr><name><name>port</name><operator>-&gt;</operator><name>gss</name><operator>-&gt;</operator><name>ctx</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * When we get a failure, we must not tell the caller we have successfully
	 * transmitted everything, else it won't retry.  Hence a "success"
	 * (positive) return value must only count source bytes corresponding to
	 * fully-transmitted encrypted packets.  The amount of source data
	 * corresponding to the current partly-transmitted packet is remembered in
	 * PqGSSSendConsumed.  On a retry, the caller *must* be sending that data
	 * again, so if it offers a len less than that, something is wrong.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <name>PqGSSSendConsumed</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"GSSAPI caller failed to retransmit all data needing to be retried"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Discount whatever source data we already encrypted. */</comment>
	<expr_stmt><expr><name>bytes_to_encrypt</name> <operator>=</operator> <name>len</name> <operator>-</operator> <name>PqGSSSendConsumed</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>bytes_encrypted</name> <operator>=</operator> <name>PqGSSSendConsumed</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Loop through encrypting data and sending it out until it's all done or
	 * secure_raw_write() complains (which would likely mean that the socket
	 * is non-blocking and the requested send() would block, or there was some
	 * kind of actual error).
	 */</comment>
	<while>while <condition>(<expr><name>bytes_to_encrypt</name> <operator>||</operator> <name>PqGSSSendLength</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>conf_state</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint32</name></type>		<name>netlen</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Check if we have data in the encrypted output buffer that needs to
		 * be sent (possibly left over from a previous call), and if so, try
		 * to send it.  If we aren't able to, return that fact back up to the
		 * caller.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>PqGSSSendLength</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ssize_t</name></type>		<name>ret</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ssize_t</name></type>		<name>amount</name> <init>= <expr><name>PqGSSSendLength</name> <operator>-</operator> <name>PqGSSSendNext</name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>secure_raw_write</name><argument_list>(<argument><expr><name>port</name></expr></argument>, <argument><expr><name>PqGSSSendBuffer</name> <operator>+</operator> <name>PqGSSSendNext</name></expr></argument>, <argument><expr><name>amount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * Report any previously-sent data; if there was none, reflect
				 * the secure_raw_write result up to our caller.  When there
				 * was some, we're effectively assuming that any interesting
				 * failure condition will recur on the next try.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>bytes_sent</name></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>bytes_sent</name></expr>;</return></block_content></block></if></if_stmt>
				<return>return <expr><name>ret</name></expr>;</return>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * Check if this was a partial write, and if so, move forward that
			 * far in our buffer and try again.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>!=</operator> <name>amount</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>PqGSSSendNext</name> <operator>+=</operator> <name>ret</name></expr>;</expr_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* We've successfully sent whatever data was in that packet. */</comment>
			<expr_stmt><expr><name>bytes_sent</name> <operator>+=</operator> <name>PqGSSSendConsumed</name></expr>;</expr_stmt>

			<comment type="block">/* All encrypted data was sent, our buffer is empty now. */</comment>
			<expr_stmt><expr><name>PqGSSSendLength</name> <operator>=</operator> <name>PqGSSSendNext</name> <operator>=</operator> <name>PqGSSSendConsumed</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Check if there are any bytes left to encrypt.  If not, we're done.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>bytes_to_encrypt</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Check how much we are being asked to send, if it's too much, then
		 * we will have to loop and possibly be called multiple times to get
		 * through all the data.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>bytes_to_encrypt</name> <operator>&gt;</operator> <name>PqGSSMaxPktSize</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>input</name><operator>.</operator><name>length</name></name> <operator>=</operator> <name>PqGSSMaxPktSize</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>input</name><operator>.</operator><name>length</name></name> <operator>=</operator> <name>bytes_to_encrypt</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><name><name>input</name><operator>.</operator><name>value</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>ptr</name> <operator>+</operator> <name>bytes_encrypted</name></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>output</name><operator>.</operator><name>value</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>output</name><operator>.</operator><name>length</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

		<comment type="block">/* Create the next encrypted packet */</comment>
		<expr_stmt><expr><name>major</name> <operator>=</operator> <call><name>gss_wrap</name><argument_list>(<argument><expr><operator>&amp;</operator><name>minor</name></expr></argument>, <argument><expr><name>gctx</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>GSS_C_QOP_DEFAULT</name></expr></argument>,
						 <argument><expr><operator>&amp;</operator><name>input</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>conf_state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>output</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>major</name> <operator>!=</operator> <name>GSS_S_COMPLETE</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pg_GSS_error_be</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"GSSAPI wrap error"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>major</name></expr></argument>, <argument><expr><name>minor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>conf_state</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"outgoing GSSAPI message would not use confidentiality"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>output</name><operator>.</operator><name>length</name></name> <operator>&gt;</operator> <name>PQ_GSS_SEND_BUFFER_SIZE</name> <operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"server tried to send oversize GSSAPI packet (%zu &gt; %zu)"</literal></expr></argument>,
							<argument><expr><operator>(</operator><name>size_t</name><operator>)</operator> <name><name>output</name><operator>.</operator><name>length</name></name></expr></argument>,
							<argument><expr><name>PQ_GSS_SEND_BUFFER_SIZE</name> <operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>bytes_encrypted</name> <operator>+=</operator> <name><name>input</name><operator>.</operator><name>length</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>bytes_to_encrypt</name> <operator>-=</operator> <name><name>input</name><operator>.</operator><name>length</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>PqGSSSendConsumed</name> <operator>+=</operator> <name><name>input</name><operator>.</operator><name>length</name></name></expr>;</expr_stmt>

		<comment type="block">/* 4 network-order bytes of length, then payload */</comment>
		<expr_stmt><expr><name>netlen</name> <operator>=</operator> <call><name>htonl</name><argument_list>(<argument><expr><name><name>output</name><operator>.</operator><name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>PqGSSSendBuffer</name> <operator>+</operator> <name>PqGSSSendLength</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>netlen</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>PqGSSSendLength</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>PqGSSSendBuffer</name> <operator>+</operator> <name>PqGSSSendLength</name></expr></argument>, <argument><expr><name><name>output</name><operator>.</operator><name>value</name></name></expr></argument>, <argument><expr><name><name>output</name><operator>.</operator><name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>PqGSSSendLength</name> <operator>+=</operator> <name><name>output</name><operator>.</operator><name>length</name></name></expr>;</expr_stmt>

		<comment type="block">/* Release buffer storage allocated by GSSAPI */</comment>
		<expr_stmt><expr><call><name>gss_release_buffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>minor</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>output</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<comment type="block">/* If we get here, our counters should all match up. */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>bytes_sent</name> <operator>==</operator> <name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>bytes_sent</name> <operator>==</operator> <name>bytes_encrypted</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>bytes_sent</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Read up to len bytes of data into ptr from a GSSAPI-encrypted connection.
 *
 * The connection must be already set up for GSSAPI encryption (i.e., GSSAPI
 * transport negotiation is complete).
 *
 * Returns the number of data bytes read, or on failure, returns -1
 * with errno set appropriately.  (For fatal errors, we may just elog and
 * exit, if errno wouldn't be sufficient to describe the error.)  For
 * retryable errors, caller should call again once the socket is ready.
 */</comment>
<function><type><name>ssize_t</name></type>
<name>be_gssapi_read</name><parameter_list>(<parameter><decl><type><name>Port</name> <modifier>*</modifier></type><name>port</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OM_uint32</name></type>	<name>major</name></decl>,
				<decl><type ref="prev"/><name>minor</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>gss_buffer_desc</name></type> <name>input</name></decl>,
				<decl><type ref="prev"/><name>output</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ssize_t</name></type>		<name>ret</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type>		<name>bytes_returned</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>gss_ctx_id_t</name></type> <name>gctx</name> <init>= <expr><name><name>port</name><operator>-&gt;</operator><name>gss</name><operator>-&gt;</operator><name>ctx</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * The plan here is to read one incoming encrypted packet into
	 * PqGSSRecvBuffer, decrypt it into PqGSSResultBuffer, and then dole out
	 * data from there to the caller.  When we exhaust the current input
	 * packet, read another.
	 */</comment>
	<while>while <condition>(<expr><name>bytes_returned</name> <operator>&lt;</operator> <name>len</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>conf_state</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Check if we have data in our buffer that we can return immediately */</comment>
		<if_stmt><if>if <condition>(<expr><name>PqGSSResultNext</name> <operator>&lt;</operator> <name>PqGSSResultLength</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>size_t</name></type>		<name>bytes_in_buffer</name> <init>= <expr><name>PqGSSResultLength</name> <operator>-</operator> <name>PqGSSResultNext</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>size_t</name></type>		<name>bytes_to_copy</name> <init>= <expr><call><name>Min</name><argument_list>(<argument><expr><name>bytes_in_buffer</name></expr></argument>, <argument><expr><name>len</name> <operator>-</operator> <name>bytes_returned</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * Copy the data from our result buffer into the caller's buffer,
			 * at the point where we last left off filling their buffer.
			 */</comment>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>ptr</name> <operator>+</operator> <name>bytes_returned</name></expr></argument>, <argument><expr><name>PqGSSResultBuffer</name> <operator>+</operator> <name>PqGSSResultNext</name></expr></argument>, <argument><expr><name>bytes_to_copy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>PqGSSResultNext</name> <operator>+=</operator> <name>bytes_to_copy</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>bytes_returned</name> <operator>+=</operator> <name>bytes_to_copy</name></expr>;</expr_stmt>

			<comment type="block">/*
			 * At this point, we've either filled the caller's buffer or
			 * emptied our result buffer.  Either way, return to caller.  In
			 * the second case, we could try to read another encrypted packet,
			 * but the odds are good that there isn't one available.  (If this
			 * isn't true, we chose too small a max packet size.)  In any
			 * case, there's no harm letting the caller process the data we've
			 * already returned.
			 */</comment>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Result buffer is empty, so reset buffer pointers */</comment>
		<expr_stmt><expr><name>PqGSSResultLength</name> <operator>=</operator> <name>PqGSSResultNext</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

		<comment type="block">/*
		 * Because we chose above to return immediately as soon as we emit
		 * some data, bytes_returned must be zero at this point.  Therefore
		 * the failure exits below can just return -1 without worrying about
		 * whether we already emitted some data.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>bytes_returned</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * At this point, our result buffer is empty with more bytes being
		 * requested to be read.  We are now ready to load the next packet and
		 * decrypt it (entirely) into our result buffer.
		 */</comment>

		<comment type="block">/* Collect the length if we haven't already */</comment>
		<if_stmt><if>if <condition>(<expr><name>PqGSSRecvLength</name> <operator>&lt;</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>secure_raw_read</name><argument_list>(<argument><expr><name>port</name></expr></argument>, <argument><expr><name>PqGSSRecvBuffer</name> <operator>+</operator> <name>PqGSSRecvLength</name></expr></argument>,
								  <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <name>PqGSSRecvLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* If ret &lt;= 0, secure_raw_read already set the correct errno */</comment>
			<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>PqGSSRecvLength</name> <operator>+=</operator> <name>ret</name></expr>;</expr_stmt>

			<comment type="block">/* If we still haven't got the length, return to the caller */</comment>
			<if_stmt><if>if <condition>(<expr><name>PqGSSRecvLength</name> <operator>&lt;</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>EWOULDBLOCK</name></expr>;</expr_stmt>
				<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Decode the packet length and check for overlength packet */</comment>
		<expr_stmt><expr><name><name>input</name><operator>.</operator><name>length</name></name> <operator>=</operator> <call><name>ntohl</name><argument_list>(<argument><expr><operator>*</operator><operator>(</operator><name>uint32</name> <operator>*</operator><operator>)</operator> <name>PqGSSRecvBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>input</name><operator>.</operator><name>length</name></name> <operator>&gt;</operator> <name>PQ_GSS_RECV_BUFFER_SIZE</name> <operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"oversize GSSAPI packet sent by the client (%zu &gt; %zu)"</literal></expr></argument>,
							<argument><expr><operator>(</operator><name>size_t</name><operator>)</operator> <name><name>input</name><operator>.</operator><name>length</name></name></expr></argument>,
							<argument><expr><name>PQ_GSS_RECV_BUFFER_SIZE</name> <operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Read as much of the packet as we are able to on this call into
		 * wherever we left off from the last time we were called.
		 */</comment>
		<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>secure_raw_read</name><argument_list>(<argument><expr><name>port</name></expr></argument>, <argument><expr><name>PqGSSRecvBuffer</name> <operator>+</operator> <name>PqGSSRecvLength</name></expr></argument>,
							  <argument><expr><name><name>input</name><operator>.</operator><name>length</name></name> <operator>-</operator> <operator>(</operator><name>PqGSSRecvLength</name> <operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* If ret &lt;= 0, secure_raw_read already set the correct errno */</comment>
		<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>PqGSSRecvLength</name> <operator>+=</operator> <name>ret</name></expr>;</expr_stmt>

		<comment type="block">/* If we don't yet have the whole packet, return to the caller */</comment>
		<if_stmt><if>if <condition>(<expr><name>PqGSSRecvLength</name> <operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof> <operator>&lt;</operator> <name><name>input</name><operator>.</operator><name>length</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>EWOULDBLOCK</name></expr>;</expr_stmt>
			<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * We now have the full packet and we can perform the decryption and
		 * refill our result buffer, then loop back up to pass data back to
		 * the caller.
		 */</comment>
		<expr_stmt><expr><name><name>output</name><operator>.</operator><name>value</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>output</name><operator>.</operator><name>length</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>input</name><operator>.</operator><name>value</name></name> <operator>=</operator> <name>PqGSSRecvBuffer</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

		<expr_stmt><expr><name>major</name> <operator>=</operator> <call><name>gss_unwrap</name><argument_list>(<argument><expr><operator>&amp;</operator><name>minor</name></expr></argument>, <argument><expr><name>gctx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>input</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>output</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>conf_state</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>major</name> <operator>!=</operator> <name>GSS_S_COMPLETE</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pg_GSS_error_be</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"GSSAPI unwrap error"</literal></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><name>major</name></expr></argument>, <argument><expr><name>minor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>conf_state</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"incoming GSSAPI message did not use confidentiality"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>PqGSSResultBuffer</name></expr></argument>, <argument><expr><name><name>output</name><operator>.</operator><name>value</name></name></expr></argument>, <argument><expr><name><name>output</name><operator>.</operator><name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>PqGSSResultLength</name> <operator>=</operator> <name><name>output</name><operator>.</operator><name>length</name></name></expr>;</expr_stmt>

		<comment type="block">/* Our receive buffer is now empty, reset it */</comment>
		<expr_stmt><expr><name>PqGSSRecvLength</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

		<comment type="block">/* Release buffer storage allocated by GSSAPI */</comment>
		<expr_stmt><expr><call><name>gss_release_buffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>minor</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>output</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<return>return <expr><name>bytes_returned</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Read the specified number of bytes off the wire, waiting using
 * WaitLatchOrSocket if we would block.
 *
 * Results are read into PqGSSRecvBuffer.
 *
 * Will always return either -1, to indicate a permanent error, or len.
 */</comment>
<function><type><specifier>static</specifier> <name>ssize_t</name></type>
<name>read_or_wait</name><parameter_list>(<parameter><decl><type><name>Port</name> <modifier>*</modifier></type><name>port</name></decl></parameter>, <parameter><decl><type><name>ssize_t</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ssize_t</name></type>		<name>ret</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Keep going until we either read in everything we were asked to, or we
	 * error out.
	 */</comment>
	<while>while <condition>(<expr><name>PqGSSRecvLength</name> <operator>&lt;</operator> <name>len</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>secure_raw_read</name><argument_list>(<argument><expr><name>port</name></expr></argument>, <argument><expr><name>PqGSSRecvBuffer</name> <operator>+</operator> <name>PqGSSRecvLength</name></expr></argument>, <argument><expr><name>len</name> <operator>-</operator> <name>PqGSSRecvLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If we got back an error and it wasn't just
		 * EWOULDBLOCK/EAGAIN/EINTR, then give up.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
			<operator>!</operator><operator>(</operator><name>errno</name> <operator>==</operator> <name>EWOULDBLOCK</name> <operator>||</operator> <name>errno</name> <operator>==</operator> <name>EAGAIN</name> <operator>||</operator> <name>errno</name> <operator>==</operator> <name>EINTR</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Ok, we got back either a positive value, zero, or a negative result
		 * indicating we should retry.
		 *
		 * If it was zero or negative, then we wait on the socket to be
		 * readable again.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>WaitLatchOrSocket</name><argument_list>(<argument><expr><name>MyLatch</name></expr></argument>,
							  <argument><expr><name>WL_SOCKET_READABLE</name> <operator>|</operator> <name>WL_EXIT_ON_PM_DEATH</name></expr></argument>,
							  <argument><expr><name><name>port</name><operator>-&gt;</operator><name>sock</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>WAIT_EVENT_GSS_OPEN_SERVER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * If we got back zero bytes, and then waited on the socket to be
			 * readable and got back zero bytes on a second read, then this is
			 * EOF and the client hung up on us.
			 *
			 * If we did get data here, then we can just fall through and
			 * handle it just as if we got data the first time.
			 *
			 * Otherwise loop back to the top and try again.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>secure_raw_read</name><argument_list>(<argument><expr><name>port</name></expr></argument>, <argument><expr><name>PqGSSRecvBuffer</name> <operator>+</operator> <name>PqGSSRecvLength</name></expr></argument>, <argument><expr><name>len</name> <operator>-</operator> <name>PqGSSRecvLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>PqGSSRecvLength</name> <operator>+=</operator> <name>ret</name></expr>;</expr_stmt>
	</block_content>}</block></while>

	<return>return <expr><name>len</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Start up a GSSAPI-encrypted connection.  This performs GSSAPI
 * authentication; after this function completes, it is safe to call
 * be_gssapi_read and be_gssapi_write.  Returns -1 and logs on failure;
 * otherwise, returns 0 and marks the connection as ready for GSSAPI
 * encryption.
 *
 * Note that unlike the be_gssapi_read/be_gssapi_write functions, this
 * function WILL block on the socket to be ready for read/write (using
 * WaitLatchOrSocket) as appropriate while establishing the GSSAPI
 * session.
 */</comment>
<function><type><name>ssize_t</name></type>
<name>secure_open_gssapi</name><parameter_list>(<parameter><decl><type><name>Port</name> <modifier>*</modifier></type><name>port</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>complete_next</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OM_uint32</name></type>	<name>major</name></decl>,
				<decl><type ref="prev"/><name>minor</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Allocate buffers and initialize state variables.  By malloc'ing the
	 * buffers at this point, we avoid wasting static data space in processes
	 * that will never use them, and we ensure that the buffers are
	 * sufficiently aligned for the length-word accesses that we do in some
	 * places in this file.
	 */</comment>
	<expr_stmt><expr><name>PqGSSSendBuffer</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><name>PQ_GSS_SEND_BUFFER_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>PqGSSRecvBuffer</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><name>PQ_GSS_RECV_BUFFER_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>PqGSSResultBuffer</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><name>PQ_GSS_RECV_BUFFER_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>PqGSSSendBuffer</name> <operator>||</operator> <operator>!</operator><name>PqGSSRecvBuffer</name> <operator>||</operator> <operator>!</operator><name>PqGSSResultBuffer</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>PqGSSSendLength</name> <operator>=</operator> <name>PqGSSSendNext</name> <operator>=</operator> <name>PqGSSSendConsumed</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>PqGSSRecvLength</name> <operator>=</operator> <name>PqGSSResultLength</name> <operator>=</operator> <name>PqGSSResultNext</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * Use the configured keytab, if there is one.  Unfortunately, Heimdal
	 * doesn't support the cred store extensions, so use the env var.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>pg_krb_server_keyfile</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>pg_krb_server_keyfile</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>setenv</name><argument_list>(<argument><expr><literal type="string">"KRB5_KTNAME"</literal></expr></argument>, <argument><expr><name>pg_krb_server_keyfile</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<while>while <condition>(<expr><name>true</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ssize_t</name></type>		<name>ret</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>gss_buffer_desc</name></type> <name>input</name></decl>,
					<decl><type ref="prev"/><name>output</name> <init>= <expr><name>GSS_C_EMPTY_BUFFER</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * The client always sends first, so try to go ahead and read the
		 * length and wait on the socket to be readable again if that fails.
		 */</comment>
		<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>read_or_wait</name><argument_list>(<argument><expr><name>port</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Get the length for this packet from the length header.
		 */</comment>
		<expr_stmt><expr><name><name>input</name><operator>.</operator><name>length</name></name> <operator>=</operator> <call><name>ntohl</name><argument_list>(<argument><expr><operator>*</operator><operator>(</operator><name>uint32</name> <operator>*</operator><operator>)</operator> <name>PqGSSRecvBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Done with the length, reset our buffer */</comment>
		<expr_stmt><expr><name>PqGSSRecvLength</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

		<comment type="block">/*
		 * During initialization, packets are always fully consumed and
		 * shouldn't ever be over PQ_GSS_RECV_BUFFER_SIZE in length.
		 *
		 * Verify on our side that the client doesn't do something funny.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>input</name><operator>.</operator><name>length</name></name> <operator>&gt;</operator> <name>PQ_GSS_RECV_BUFFER_SIZE</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"oversize GSSAPI packet sent by the client (%zu &gt; %d)"</literal></expr></argument>,
							<argument><expr><operator>(</operator><name>size_t</name><operator>)</operator> <name><name>input</name><operator>.</operator><name>length</name></name></expr></argument>,
							<argument><expr><name>PQ_GSS_RECV_BUFFER_SIZE</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Get the rest of the packet so we can pass it to GSSAPI to accept
		 * the context.
		 */</comment>
		<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>read_or_wait</name><argument_list>(<argument><expr><name>port</name></expr></argument>, <argument><expr><name><name>input</name><operator>.</operator><name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>input</name><operator>.</operator><name>value</name></name> <operator>=</operator> <name>PqGSSRecvBuffer</name></expr>;</expr_stmt>

		<comment type="block">/* Process incoming data.  (The client sends first.) */</comment>
		<expr_stmt><expr><name>major</name> <operator>=</operator> <call><name>gss_accept_sec_context</name><argument_list>(<argument><expr><operator>&amp;</operator><name>minor</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>port</name><operator>-&gt;</operator><name>gss</name><operator>-&gt;</operator><name>ctx</name></name></expr></argument>,
									   <argument><expr><name>GSS_C_NO_CREDENTIAL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>input</name></expr></argument>,
									   <argument><expr><name>GSS_C_NO_CHANNEL_BINDINGS</name></expr></argument>,
									   <argument><expr><operator>&amp;</operator><name><name>port</name><operator>-&gt;</operator><name>gss</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>output</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
									   <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>GSS_ERROR</name><argument_list>(<argument><expr><name>major</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pg_GSS_error_be</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"could not accept GSSAPI security context"</literal></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><name>major</name></expr></argument>, <argument><expr><name>minor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>gss_release_buffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>minor</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>output</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><operator>!</operator><operator>(</operator><name>major</name> <operator>&amp;</operator> <name>GSS_S_CONTINUE_NEEDED</name><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * rfc2744 technically permits context negotiation to be complete
			 * both with and without a packet to be sent.
			 */</comment>
			<expr_stmt><expr><name>complete_next</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Done handling the incoming packet, reset our buffer */</comment>
		<expr_stmt><expr><name>PqGSSRecvLength</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

		<comment type="block">/*
		 * Check if we have data to send and, if we do, make sure to send it
		 * all
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>output</name><operator>.</operator><name>length</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>uint32</name></type>		<name>netlen</name> <init>= <expr><call><name>htonl</name><argument_list>(<argument><expr><name><name>output</name><operator>.</operator><name>length</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>output</name><operator>.</operator><name>length</name></name> <operator>&gt;</operator> <name>PQ_GSS_SEND_BUFFER_SIZE</name> <operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"server tried to send oversize GSSAPI packet (%zu &gt; %zu)"</literal></expr></argument>,
								<argument><expr><operator>(</operator><name>size_t</name><operator>)</operator> <name><name>output</name><operator>.</operator><name>length</name></name></expr></argument>,
								<argument><expr><name>PQ_GSS_SEND_BUFFER_SIZE</name> <operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>PqGSSSendBuffer</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>netlen</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>PqGSSSendLength</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>PqGSSSendBuffer</name> <operator>+</operator> <name>PqGSSSendLength</name></expr></argument>, <argument><expr><name><name>output</name><operator>.</operator><name>value</name></name></expr></argument>, <argument><expr><name><name>output</name><operator>.</operator><name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>PqGSSSendLength</name> <operator>+=</operator> <name><name>output</name><operator>.</operator><name>length</name></name></expr>;</expr_stmt>

			<comment type="block">/* we don't bother with PqGSSSendConsumed here */</comment>

			<while>while <condition>(<expr><name>PqGSSSendNext</name> <operator>&lt;</operator> <name>PqGSSSendLength</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>secure_raw_write</name><argument_list>(<argument><expr><name>port</name></expr></argument>, <argument><expr><name>PqGSSSendBuffer</name> <operator>+</operator> <name>PqGSSSendNext</name></expr></argument>,
									   <argument><expr><name>PqGSSSendLength</name> <operator>-</operator> <name>PqGSSSendNext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * If we got back an error and it wasn't just
				 * EWOULDBLOCK/EAGAIN/EINTR, then give up.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
					<operator>!</operator><operator>(</operator><name>errno</name> <operator>==</operator> <name>EWOULDBLOCK</name> <operator>||</operator> <name>errno</name> <operator>==</operator> <name>EAGAIN</name> <operator>||</operator> <name>errno</name> <operator>==</operator> <name>EINTR</name><operator>)</operator></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>gss_release_buffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>minor</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>output</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/* Wait and retry if we couldn't write yet */</comment>
				<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>WaitLatchOrSocket</name><argument_list>(<argument><expr><name>MyLatch</name></expr></argument>,
									  <argument><expr><name>WL_SOCKET_WRITEABLE</name> <operator>|</operator> <name>WL_EXIT_ON_PM_DEATH</name></expr></argument>,
									  <argument><expr><name><name>port</name><operator>-&gt;</operator><name>sock</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>WAIT_EVENT_GSS_OPEN_SERVER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<continue>continue;</continue>
				</block_content>}</block></if></if_stmt>

				<expr_stmt><expr><name>PqGSSSendNext</name> <operator>+=</operator> <name>ret</name></expr>;</expr_stmt>
			</block_content>}</block></while>

			<comment type="block">/* Done sending the packet, reset our buffer */</comment>
			<expr_stmt><expr><name>PqGSSSendLength</name> <operator>=</operator> <name>PqGSSSendNext</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>gss_release_buffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>minor</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>output</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * If we got back that the connection is finished being set up, now
		 * that we've sent the last packet, exit our loop.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>complete_next</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
	</block_content>}</block></while>

	<comment type="block">/*
	 * Determine the max packet size which will fit in our buffer, after
	 * accounting for the length.  be_gssapi_write will need this.
	 */</comment>
	<expr_stmt><expr><name>major</name> <operator>=</operator> <call><name>gss_wrap_size_limit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>minor</name></expr></argument>, <argument><expr><name><name>port</name><operator>-&gt;</operator><name>gss</name><operator>-&gt;</operator><name>ctx</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>GSS_C_QOP_DEFAULT</name></expr></argument>,
								<argument><expr><name>PQ_GSS_SEND_BUFFER_SIZE</name> <operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof></expr></argument>,
								<argument><expr><operator>&amp;</operator><name>PqGSSMaxPktSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>GSS_ERROR</name><argument_list>(<argument><expr><name>major</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pg_GSS_error_be</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"GSSAPI size check error"</literal></expr></argument>)</argument_list></call></expr></argument>,
					 <argument><expr><name>major</name></expr></argument>, <argument><expr><name>minor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>port</name><operator>-&gt;</operator><name>gss</name><operator>-&gt;</operator><name>enc</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Return if GSSAPI authentication was used on this connection.
 */</comment>
<function><type><name>bool</name></type>
<name>be_gssapi_get_auth</name><parameter_list>(<parameter><decl><type><name>Port</name> <modifier>*</modifier></type><name>port</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>port</name> <operator>||</operator> <operator>!</operator><name><name>port</name><operator>-&gt;</operator><name>gss</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name><name>port</name><operator>-&gt;</operator><name>gss</name><operator>-&gt;</operator><name>auth</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Return if GSSAPI encryption is enabled and being used on this connection.
 */</comment>
<function><type><name>bool</name></type>
<name>be_gssapi_get_enc</name><parameter_list>(<parameter><decl><type><name>Port</name> <modifier>*</modifier></type><name>port</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>port</name> <operator>||</operator> <operator>!</operator><name><name>port</name><operator>-&gt;</operator><name>gss</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name><name>port</name><operator>-&gt;</operator><name>gss</name><operator>-&gt;</operator><name>enc</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Return the GSSAPI principal used for authentication on this connection.
 */</comment>
<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>be_gssapi_get_princ</name><parameter_list>(<parameter><decl><type><name>Port</name> <modifier>*</modifier></type><name>port</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>port</name> <operator>||</operator> <operator>!</operator><name><name>port</name><operator>-&gt;</operator><name>gss</name><operator>-&gt;</operator><name>auth</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name><name>port</name><operator>-&gt;</operator><name>gss</name><operator>-&gt;</operator><name>princ</name></name></expr>;</return>
</block_content>}</block></function>
</unit>
