<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/backend/libpq/pqcomm.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * pqcomm.c
 *	  Communication functions between the Frontend and the Backend
 *
 * These routines handle the low-level details of communication between
 * frontend and backend.  They just shove data across the communication
 * channel, and are ignorant of the semantics of the data --- or would be,
 * except for major brain damage in the design of the old COPY OUT protocol.
 * Unfortunately, COPY OUT was designed to commandeer the communication
 * channel (it just transfers data without wrapping it into messages).
 * No other messages can be sent while COPY OUT is in progress; and if the
 * copy is aborted by an ereport(ERROR), we need to close out the copy so that
 * the frontend gets back into sync.  Therefore, these routines have to be
 * aware of COPY OUT state.  (New COPY-OUT is message-based and does *not*
 * set the DoingCopyOut flag.)
 *
 * NOTE: generally, it's a bad idea to emit outgoing messages directly with
 * pq_putbytes(), especially if the message would require multiple calls
 * to send.  Instead, use the routines in pqformat.c to construct the message
 * in a buffer and then emit it in one call to pq_putmessage.  This ensures
 * that the channel will not be clogged by an incomplete message if execution
 * is aborted by ereport(ERROR) partway through the message.  The only
 * non-libpq code that should call pq_putbytes directly is old-style COPY OUT.
 *
 * At one time, libpq was shared between frontend and backend, but now
 * the backend's "backend/libpq" is quite separate from "interfaces/libpq".
 * All that remains is similarities of names to trap the unwary...
 *
 * Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *	src/backend/libpq/pqcomm.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<comment type="block">/*------------------------
 * INTERFACE ROUTINES
 *
 * setup/teardown:
 *		StreamServerPort	- Open postmaster's server port
 *		StreamConnection	- Create new connection with client
 *		StreamClose			- Close a client/backend connection
 *		TouchSocketFiles	- Protect socket files against /tmp cleaners
 *		pq_init			- initialize libpq at backend startup
 *		pq_comm_reset	- reset libpq during error recovery
 *		pq_close		- shutdown libpq at backend exit
 *
 * low-level I/O:
 *		pq_getbytes		- get a known number of bytes from connection
 *		pq_getstring	- get a null terminated string from connection
 *		pq_getmessage	- get a message with length word from connection
 *		pq_getbyte		- get next byte from connection
 *		pq_peekbyte		- peek at next byte from connection
 *		pq_putbytes		- send bytes to connection (not flushed until pq_flush)
 *		pq_flush		- flush pending output
 *		pq_flush_if_writable - flush pending output if writable without blocking
 *		pq_getbyte_if_available - get a byte if available without blocking
 *
 * message-level I/O (and old-style-COPY-OUT cruft):
 *		pq_putmessage	- send a normal message (suppressed in COPY OUT mode)
 *		pq_putmessage_noblock - buffer a normal message (suppressed in COPY OUT)
 *		pq_startcopyout - inform libpq that a COPY OUT transfer is beginning
 *		pq_endcopyout	- end a COPY OUT transfer
 *
 *------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;pthread.h&gt;</cpp:file></cpp:include>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_POLL_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;poll.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;signal.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fcntl.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;grp.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/file.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/socket.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/stat.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/time.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;netdb.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;netinet/in.h&gt;</cpp:file></cpp:include>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_NETINET_TCP_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;netinet/tcp.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_UTIME_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utime.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MSC_VER</name></cpp:ifdef>					<comment type="block">/* mstcpip.h is missing on mingw */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;mstcpip.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/ip.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq/libpq.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"port/pg_bswap.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/ipc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/guc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbvars.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tcop/tcopprot.h"</cpp:file></cpp:include>

<comment type="block">/*
 * Cope with the various platform-specific ways to spell TCP keepalive socket
 * options.  This doesn't cover Windows, which as usual does its own thing.
 */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>TCP_KEEPIDLE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block">/* TCP_KEEPIDLE is the name of this option on Linux and *BSD */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PG_TCP_KEEPALIVE_IDLE</name></cpp:macro> <cpp:value>TCP_KEEPIDLE</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PG_TCP_KEEPALIVE_IDLE_STR</name></cpp:macro> <cpp:value>"TCP_KEEPIDLE"</cpp:value></cpp:define>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>TCP_KEEPALIVE_THRESHOLD</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<comment type="block">/* TCP_KEEPALIVE_THRESHOLD is the name of this option on Solaris &gt;= 11 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PG_TCP_KEEPALIVE_IDLE</name></cpp:macro> <cpp:value>TCP_KEEPALIVE_THRESHOLD</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PG_TCP_KEEPALIVE_IDLE_STR</name></cpp:macro> <cpp:value>"TCP_KEEPALIVE_THRESHOLD"</cpp:value></cpp:define>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>TCP_KEEPALIVE</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__darwin__</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<comment type="block">/* TCP_KEEPALIVE is the name of this option on macOS */</comment>
<comment type="block">/* Caution: Solaris has this symbol but it means something different */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PG_TCP_KEEPALIVE_IDLE</name></cpp:macro> <cpp:value>TCP_KEEPALIVE</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PG_TCP_KEEPALIVE_IDLE_STR</name></cpp:macro> <cpp:value>"TCP_KEEPALIVE"</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * Cope with the various platform-specific ways to spell TCP keepalive socket
 * options.  This doesn't cover Windows, which as usual does its own thing.
 */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>TCP_KEEPIDLE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block">/* TCP_KEEPIDLE is the name of this option on Linux and *BSD */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PG_TCP_KEEPALIVE_IDLE</name></cpp:macro> <cpp:value>TCP_KEEPIDLE</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PG_TCP_KEEPALIVE_IDLE_STR</name></cpp:macro> <cpp:value>"TCP_KEEPIDLE"</cpp:value></cpp:define>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>TCP_KEEPALIVE_THRESHOLD</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<comment type="block">/* TCP_KEEPALIVE_THRESHOLD is the name of this option on Solaris &gt;= 11 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PG_TCP_KEEPALIVE_IDLE</name></cpp:macro> <cpp:value>TCP_KEEPALIVE_THRESHOLD</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PG_TCP_KEEPALIVE_IDLE_STR</name></cpp:macro> <cpp:value>"TCP_KEEPALIVE_THRESHOLD"</cpp:value></cpp:define>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>TCP_KEEPALIVE</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__darwin__</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<comment type="block">/* TCP_KEEPALIVE is the name of this option on macOS */</comment>
<comment type="block">/* Caution: Solaris has this symbol but it means something different */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PG_TCP_KEEPALIVE_IDLE</name></cpp:macro> <cpp:value>TCP_KEEPALIVE</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PG_TCP_KEEPALIVE_IDLE_STR</name></cpp:macro> <cpp:value>"TCP_KEEPALIVE"</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * Configuration options
 */</comment>
<decl_stmt><decl><type><name>int</name></type>			<name>Unix_socket_permissions</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>Unix_socket_group</name></decl>;</decl_stmt>

<comment type="block">/* Where the Unix socket files are (list of palloc'd strings) */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>sock_paths</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Buffers for low-level I/O.
 *
 * The receive buffer is fixed size. Send buffer is usually 8k, but can be
 * enlarged by pq_putmessage_noblock() if the message doesn't fit otherwise.
 */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PQ_SEND_BUFFER_SIZE</name></cpp:macro> <cpp:value>8192</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PQ_RECV_BUFFER_SIZE</name></cpp:macro> <cpp:value>8192</cpp:value></cpp:define>

<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>PqSendBuffer</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>PqSendBufferSize</name></decl>;</decl_stmt>	<comment type="block">/* Size send buffer */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>PqSendPointer</name></decl>;</decl_stmt>		<comment type="block">/* Next index to store a byte in PqSendBuffer */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>PqSendStart</name></decl>;</decl_stmt>		<comment type="block">/* Next index to send a byte in PqSendBuffer */</comment>

<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>PqRecvBuffer</name><index>[<expr><name>PQ_RECV_BUFFER_SIZE</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>PqRecvPointer</name></decl>;</decl_stmt>		<comment type="block">/* Next index to read a byte from PqRecvBuffer */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>PqRecvLength</name></decl>;</decl_stmt>		<comment type="block">/* End of data available in PqRecvBuffer */</comment>

<comment type="block">/*
 * Message status
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>PqCommBusy</name></decl>;</decl_stmt>			<comment type="block">/* busy sending data to the client */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>PqCommReadingMsg</name></decl>;</decl_stmt>	<comment type="block">/* in the middle of reading a message */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>DoingCopyOut</name></decl>;</decl_stmt>		<comment type="block">/* in old-protocol COPY OUT processing */</comment>


<comment type="block">/* Internal functions */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>socket_comm_reset</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>socket_close</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>code</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>socket_set_nonblocking</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>nonblocking</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>socket_flush</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>socket_flush_if_writable</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>socket_is_send_pending</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>socket_putmessage</name><parameter_list>(<parameter><decl><type><name>char</name></type> <name>msgtype</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>socket_putmessage_noblock</name><parameter_list>(<parameter><decl><type><name>char</name></type> <name>msgtype</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>socket_startcopyout</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>socket_endcopyout</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>errorAbort</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>internal_putbytes</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>internal_flush</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_UNIX_SOCKETS</name></cpp:ifdef>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>Lock_AF_UNIX</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>unixSocketDir</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>unixSocketPath</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>Setup_AF_UNIX</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>sock_path</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* HAVE_UNIX_SOCKETS */</comment>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>PQcommMethods</name></type> <name>PqCommSocketMethods</name> <init>= <expr><block>{
	<expr><name>socket_comm_reset</name></expr>,
	<expr><name>socket_flush</name></expr>,
	<expr><name>socket_flush_if_writable</name></expr>,
	<expr><name>socket_is_send_pending</name></expr>,
	<expr><name>socket_putmessage</name></expr>,
	<expr><name>socket_putmessage_noblock</name></expr>,
	<expr><name>socket_startcopyout</name></expr>,
	<expr><name>socket_endcopyout</name></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>PQcommMethods</name> <modifier>*</modifier></type><name>PqCommMethods</name> <init>= <expr><operator>&amp;</operator><name>PqCommSocketMethods</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>WaitEventSet</name> <modifier>*</modifier></type><name>FeBeWaitSet</name></decl>;</decl_stmt>


<comment type="block">/* --------------------------------
 *		pq_init - initialize libpq at backend startup
 * --------------------------------
 */</comment>
<function><type><name>void</name></type>
<name>pq_init</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* initialize state variables */</comment>
	<expr_stmt><expr><name>PqSendBufferSize</name> <operator>=</operator> <name>PQ_SEND_BUFFER_SIZE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>PqSendBuffer</name> <operator>=</operator> <call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>, <argument><expr><name>PqSendBufferSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>PqSendPointer</name> <operator>=</operator> <name>PqSendStart</name> <operator>=</operator> <name>PqRecvPointer</name> <operator>=</operator> <name>PqRecvLength</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>PqCommBusy</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>PqCommReadingMsg</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>DoingCopyOut</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/* set up process-exit hook to close the socket */</comment>
	<expr_stmt><expr><call><name>on_proc_exit</name><argument_list>(<argument><expr><name>socket_close</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * In backends (as soon as forked) we operate the underlying socket in
	 * nonblocking mode and use latches to implement blocking semantics if
	 * needed. That allows us to provide safely interruptible reads and
	 * writes.
	 *
	 * Use COMMERROR on failure, because ERROR would try to send the error to
	 * the client, which might require changing the mode again, leading to
	 * infinite recursion.
	 */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pg_set_noblock</name><argument_list>(<argument><expr><name><name>MyProcPort</name><operator>-&gt;</operator><name>sock</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>COMMERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not set socket to nonblocking mode: %m"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><name>FeBeWaitSet</name> <operator>=</operator> <call><name>CreateWaitEventSet</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AddWaitEventToSet</name><argument_list>(<argument><expr><name>FeBeWaitSet</name></expr></argument>, <argument><expr><name>WL_SOCKET_WRITEABLE</name></expr></argument>, <argument><expr><name><name>MyProcPort</name><operator>-&gt;</operator><name>sock</name></name></expr></argument>,
					  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AddWaitEventToSet</name><argument_list>(<argument><expr><name>FeBeWaitSet</name></expr></argument>, <argument><expr><name>WL_LATCH_SET</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>MyLatch</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AddWaitEventToSet</name><argument_list>(<argument><expr><name>FeBeWaitSet</name></expr></argument>, <argument><expr><name>WL_POSTMASTER_DEATH</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* --------------------------------
 *		socket_comm_reset - reset libpq during error recovery
 *
 * This is called from error recovery at the outer idle loop.  It's
 * just to get us out of trouble if we somehow manage to elog() from
 * inside a pqcomm.c routine (which ideally will never happen, but...)
 * --------------------------------
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>socket_comm_reset</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* We can abort any old-style COPY OUT, too */</comment>
	<expr_stmt><expr><call><name>pq_endcopyout</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* --------------------------------
 *		socket_close - shutdown libpq at backend exit
 *
 * This is the one pg_on_exit_callback in place during BackendInitialize().
 * That function's unusual signal handling constrains that this callback be
 * safe to run at any instant.
 * --------------------------------
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>socket_close</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>code</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Nothing to do in a standalone backend, where MyProcPort is NULL. */</comment>
	<if_stmt><if>if <condition>(<expr><name>MyProcPort</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ENABLE_GSS</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>ENABLE_SSPI</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ENABLE_GSS</name></cpp:ifdef>
		<decl_stmt><decl><type><name>OM_uint32</name></type>	<name>min_s</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Shutdown GSSAPI layer.  This section does nothing when interrupting
		 * BackendInitialize(), because pg_GSS_recvauth() makes first use of
		 * "ctx" and "cred".
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>MyProcPort</name><operator>-&gt;</operator><name>gss</name><operator>-&gt;</operator><name>ctx</name></name> <operator>!=</operator> <name>GSS_C_NO_CONTEXT</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>gss_delete_sec_context</name><argument_list>(<argument><expr><operator>&amp;</operator><name>min_s</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>MyProcPort</name><operator>-&gt;</operator><name>gss</name><operator>-&gt;</operator><name>ctx</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>MyProcPort</name><operator>-&gt;</operator><name>gss</name><operator>-&gt;</operator><name>cred</name></name> <operator>!=</operator> <name>GSS_C_NO_CREDENTIAL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>gss_release_cred</name><argument_list>(<argument><expr><operator>&amp;</operator><name>min_s</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>MyProcPort</name><operator>-&gt;</operator><name>gss</name><operator>-&gt;</operator><name>cred</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* ENABLE_GSS */</comment>

		<comment type="block">/*
		 * GSS and SSPI share the port-&gt;gss struct.  Since nowhere else does a
		 * postmaster child free this, doing so is safe when interrupting
		 * BackendInitialize().
		 */</comment>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>MyProcPort</name><operator>-&gt;</operator><name>gss</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* ENABLE_GSS || ENABLE_SSPI */</comment>

		<comment type="block">/*
		 * Cleanly shut down SSL layer.  Nowhere else does a postmaster child
		 * call this, so this is safe when interrupting BackendInitialize().
		 */</comment>
		<expr_stmt><expr><call><name>secure_close</name><argument_list>(<argument><expr><name>MyProcPort</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Formerly we did an explicit close() here, but it seems better to
		 * leave the socket open until the process dies.  This allows clients
		 * to perform a "synchronous close" if they care --- wait till the
		 * transport layer reports connection closure, and you can be sure the
		 * backend has exited.
		 *
		 * We do set sock to PGINVALID_SOCKET to prevent any further I/O,
		 * though.
		 */</comment>
		<expr_stmt><expr><name><name>MyProcPort</name><operator>-&gt;</operator><name>sock</name></name> <operator>=</operator> <name>PGINVALID_SOCKET</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* --------------------------------
 *		pq_comm_close_fatal - shutdown libpq at backend fatal error exit
 * --------------------------------
 */</comment>
<function><type><name>void</name></type>
<name>pq_comm_close_fatal</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>MyProcPort</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Cleanly shut down SSL layer */</comment>
		<expr_stmt><expr><call><name>secure_close</name><argument_list>(<argument><expr><name>MyProcPort</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>MyProcPort</name><operator>-&gt;</operator><name>sock</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>closesocket</name><argument_list>(<argument><expr><name><name>MyProcPort</name><operator>-&gt;</operator><name>sock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        
		<expr_stmt><expr><name><name>MyProcPort</name><operator>-&gt;</operator><name>sock</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>                               <comment type="block">/* pq_comm_close_fatal */</comment>


<comment type="block">/*
 * Streams -- wrapper around Unix socket system calls
 *
 *
 *		Stream functions are used for vanilla TCP connection protocol.
 */</comment>


<comment type="block">/*
 * StreamServerPort -- open a "listening" port to accept connections.
 *
 * family should be AF_UNIX or AF_UNSPEC; portNumber is the port number.
 * For AF_UNIX ports, hostName should be NULL and unixSocketDir must be
 * specified.  For TCP ports, hostName is either NULL for all interfaces or
 * the interface to listen on, and unixSocketDir is ignored (can be NULL).
 *
 * Successfully opened sockets are added to the ListenSocket[] array (of
 * length MaxListen), at the first position that isn't PGINVALID_SOCKET.
 *
 * RETURNS: STATUS_OK or STATUS_ERROR
 */</comment>

<function><type><name>int</name></type>
<name>StreamServerPort</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>family</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>hostName</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>short</name></type> <name>portNumber</name></decl></parameter>,
				 <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>unixSocketDir</name></decl></parameter>,
				 <parameter><decl><type><name>pgsocket</name></type> <name><name>ListenSocket</name><index>[]</index></name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>MaxListen</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>pgsocket</name></type>	<name>fd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>err</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>maxconn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ret</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>portNumberStr</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>familyDesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>familyDescBuf</name><index>[<expr><literal type="number">64</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>addrDesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>addrBuf</name><index>[<expr><name>NI_MAXHOST</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>service</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>addrinfo</name></name> <modifier>*</modifier></type><name>addrs</name> <init>= <expr><name>NULL</name></expr></init></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>addr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>addrinfo</name></name></type> <name>hint</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>listen_index</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>added</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_UNIX_SOCKETS</name></cpp:ifdef>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>unixSocketPath</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>WIN32</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>IPV6_V6ONLY</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<decl_stmt><decl><type><name>int</name></type>			<name>one</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/* Initialize hint structure */</comment>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hint</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>hint</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hint</name><operator>.</operator><name>ai_family</name></name> <operator>=</operator> <name>family</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hint</name><operator>.</operator><name>ai_flags</name></name> <operator>=</operator> <name>AI_PASSIVE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hint</name><operator>.</operator><name>ai_socktype</name></name> <operator>=</operator> <name>SOCK_STREAM</name></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_UNIX_SOCKETS</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><name>family</name> <operator>==</operator> <name>AF_UNIX</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Create unixSocketPath from portNumber and unixSocketDir and lock
		 * that file path
		 */</comment>
		<expr_stmt><expr><call><name>UNIXSOCK_PATH</name><argument_list>(<argument><expr><name>unixSocketPath</name></expr></argument>, <argument><expr><name>portNumber</name></expr></argument>, <argument><expr><name>unixSocketDir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>unixSocketPath</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <name>UNIXSOCK_PATH_BUFLEN</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Unix-domain socket path \"%s\" is too long (maximum %d bytes)"</literal></expr></argument>,
							<argument><expr><name>unixSocketPath</name></expr></argument>,
							<argument><expr><operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><name>UNIXSOCK_PATH_BUFLEN</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>STATUS_ERROR</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>Lock_AF_UNIX</name><argument_list>(<argument><expr><name>unixSocketDir</name></expr></argument>, <argument><expr><name>unixSocketPath</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>STATUS_OK</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>STATUS_ERROR</name></expr>;</return></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>service</name> <operator>=</operator> <name>unixSocketPath</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* HAVE_UNIX_SOCKETS */</comment>
	<block>{<block_content>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>portNumberStr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>portNumberStr</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><name>portNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>service</name> <operator>=</operator> <name>portNumberStr</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>pg_getaddrinfo_all</name><argument_list>(<argument><expr><name>hostName</name></expr></argument>, <argument><expr><name>service</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hint</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>addrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>||</operator> <operator>!</operator><name>addrs</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>hostName</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not translate host name \"%s\", service \"%s\" to address: %s"</literal></expr></argument>,
							<argument><expr><name>hostName</name></expr></argument>, <argument><expr><name>service</name></expr></argument>, <argument><expr><call><name>gai_strerror</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not translate service \"%s\" to address: %s"</literal></expr></argument>,
							<argument><expr><name>service</name></expr></argument>, <argument><expr><call><name>gai_strerror</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>addrs</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pg_freeaddrinfo_all</name><argument_list>(<argument><expr><name><name>hint</name><operator>.</operator><name>ai_family</name></name></expr></argument>, <argument><expr><name>addrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<return>return <expr><name>STATUS_ERROR</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<for>for <control>(<init><expr><name>addr</name> <operator>=</operator> <name>addrs</name></expr>;</init> <condition><expr><name>addr</name></expr>;</condition> <incr><expr><name>addr</name> <operator>=</operator> <name><name>addr</name><operator>-&gt;</operator><name>ai_next</name></name></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IS_AF_UNIX</name><argument_list>(<argument><expr><name>family</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>IS_AF_UNIX</name><argument_list>(<argument><expr><name><name>addr</name><operator>-&gt;</operator><name>ai_family</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Only set up a unix domain socket when they really asked for it.
			 * The service/port is different in that case.
			 */</comment>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* See if there is still room to add 1 more socket. */</comment>
		<for>for <control>(<init>;</init> <condition><expr><name>listen_index</name> <operator>&lt;</operator> <name>MaxListen</name></expr>;</condition> <incr><expr><name>listen_index</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>ListenSocket</name><index>[<expr><name>listen_index</name></expr>]</index></name> <operator>==</operator> <name>PGINVALID_SOCKET</name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
		</block_content>}</block></for>
		<if_stmt><if>if <condition>(<expr><name>listen_index</name> <operator>&gt;=</operator> <name>MaxListen</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not bind to all requested addresses: MAXLISTEN (%d) exceeded"</literal></expr></argument>,
							<argument><expr><name>MaxListen</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* set up address family name for log messages */</comment>
		<switch>switch <condition>(<expr><name><name>addr</name><operator>-&gt;</operator><name>ai_family</name></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>AF_INET</name></expr>:</case>
				<expr_stmt><expr><name>familyDesc</name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"IPv4"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_IPV6</name></cpp:ifdef>
			<case>case <expr><name>AF_INET6</name></expr>:</case>
				<expr_stmt><expr><name>familyDesc</name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"IPv6"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_UNIX_SOCKETS</name></cpp:ifdef>
			<case>case <expr><name>AF_UNIX</name></expr>:</case>
				<expr_stmt><expr><name>familyDesc</name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"Unix"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<default>default:</default>
				<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>familyDescBuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>familyDescBuf</name></expr></argument>)</argument_list></sizeof></expr></argument>,
						 <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"unrecognized address family %d"</literal></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><name><name>addr</name><operator>-&gt;</operator><name>ai_family</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>familyDesc</name> <operator>=</operator> <name>familyDescBuf</name></expr>;</expr_stmt>
				<break>break;</break>
		</block_content>}</block></switch>

		<comment type="block">/* set up text form of address for log messages */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_UNIX_SOCKETS</name></cpp:ifdef>
		<if_stmt><if>if <condition>(<expr><name><name>addr</name><operator>-&gt;</operator><name>ai_family</name></name> <operator>==</operator> <name>AF_UNIX</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>addrDesc</name> <operator>=</operator> <name>unixSocketPath</name></expr>;</expr_stmt></block_content></block></if>
		<else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pg_getnameinfo_all</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> struct <name>sockaddr_storage</name> <operator>*</operator><operator>)</operator> <name><name>addr</name><operator>-&gt;</operator><name>ai_addr</name></name></expr></argument>,
							   <argument><expr><name><name>addr</name><operator>-&gt;</operator><name>ai_addrlen</name></name></expr></argument>,
							   <argument><expr><name>addrBuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>addrBuf</name></expr></argument>)</argument_list></sizeof></expr></argument>,
							   <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
							   <argument><expr><name>NI_NUMERICHOST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>addrDesc</name> <operator>=</operator> <name>addrBuf</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>fd</name> <operator>=</operator> <call><name>socket</name><argument_list>(<argument><expr><name><name>addr</name><operator>-&gt;</operator><name>ai_family</name></name></expr></argument>, <argument><expr><name>SOCK_STREAM</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>PGINVALID_SOCKET</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_socket_access</name><argument_list>()</argument_list></call><operator>,</operator>
			<comment type="block">/* translator: first %s is IPv4, IPv6, or Unix */</comment>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not create %s socket for address \"%s\": %m"</literal></expr></argument>,
							<argument><expr><name>familyDesc</name></expr></argument>, <argument><expr><name>addrDesc</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>

		<comment type="block">/*
		 * Without the SO_REUSEADDR flag, a new postmaster can't be started
		 * right away after a stop or crash, giving "address already in use"
		 * error on TCP ports.
		 *
		 * On win32, however, this behavior only happens if the
		 * SO_EXLUSIVEADDRUSE is set. With SO_REUSEADDR, win32 allows multiple
		 * servers to listen on the same address, resulting in unpredictable
		 * behavior. With no flags at all, win32 behaves as Unix with
		 * SO_REUSEADDR.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IS_AF_UNIX</name><argument_list>(<argument><expr><name><name>addr</name><operator>-&gt;</operator><name>ai_family</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>setsockopt</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>SOL_SOCKET</name></expr></argument>, <argument><expr><name>SO_REUSEADDR</name></expr></argument>,
							<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>one</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>one</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode_for_socket_access</name><argument_list>()</argument_list></call><operator>,</operator>
				<comment type="block">/* translator: first %s is IPv4, IPv6, or Unix */</comment>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"setsockopt(SO_REUSEADDR) failed for %s address \"%s\": %m"</literal></expr></argument>,
								<argument><expr><name>familyDesc</name></expr></argument>, <argument><expr><name>addrDesc</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>closesocket</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>IPV6_V6ONLY</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>IPPROTO_IPV6</name></expr></argument>)</argument_list></call></expr></cpp:if>
		<if_stmt><if>if <condition>(<expr><name><name>addr</name><operator>-&gt;</operator><name>ai_family</name></name> <operator>==</operator> <name>AF_INET6</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>setsockopt</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>IPPROTO_IPV6</name></expr></argument>, <argument><expr><name>IPV6_V6ONLY</name></expr></argument>,
						   <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>one</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>one</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode_for_socket_access</name><argument_list>()</argument_list></call><operator>,</operator>
				<comment type="block">/* translator: first %s is IPv4, IPv6, or Unix */</comment>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"setsockopt(IPV6_V6ONLY) failed for %s address \"%s\": %m"</literal></expr></argument>,
								<argument><expr><name>familyDesc</name></expr></argument>, <argument><expr><name>addrDesc</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>closesocket</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

		<comment type="block">/*
		 * Note: This might fail on some OS's, like Linux older than
		 * 2.4.21-pre3, that don't have the IPV6_V6ONLY socket option, and map
		 * ipv4 addresses to ipv6.  It will show ::ffff:ipv4 for all ipv4
		 * connections.
		 */</comment>
		<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>bind</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name><name>addr</name><operator>-&gt;</operator><name>ai_addr</name></name></expr></argument>, <argument><expr><name><name>addr</name><operator>-&gt;</operator><name>ai_addrlen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>err</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_socket_access</name><argument_list>()</argument_list></call><operator>,</operator>
			<comment type="block">/* translator: first %s is IPv4, IPv6, or Unix */</comment>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not bind %s address \"%s\": %m"</literal></expr></argument>,
							<argument><expr><name>familyDesc</name></expr></argument>, <argument><expr><name>addrDesc</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <ternary><condition><expr><operator>(</operator><call><name>IS_AF_UNIX</name><argument_list>(<argument><expr><name><name>addr</name><operator>-&gt;</operator><name>ai_family</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr> ?</condition><then>
					 <expr><call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Is another postmaster already running on port %d?"</literal>
							 <literal type="string">" If not, remove socket file \"%s\" and retry."</literal></expr></argument>,
							 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>portNumber</name></expr></argument>, <argument><expr><name>service</name></expr></argument>)</argument_list></call></expr> </then><else>:
					 <expr><call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Is another postmaster already running on port %d?"</literal>
							 <literal type="string">" If not, wait a few seconds and retry."</literal></expr></argument>,
							 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>portNumber</name></expr></argument>)</argument_list></call></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>closesocket</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_UNIX_SOCKETS</name></cpp:ifdef>
		<if_stmt><if>if <condition>(<expr><name><name>addr</name><operator>-&gt;</operator><name>ai_family</name></name> <operator>==</operator> <name>AF_UNIX</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>Setup_AF_UNIX</name><argument_list>(<argument><expr><name>service</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>STATUS_OK</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>closesocket</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

		<comment type="block">/*
		 * Select appropriate accept-queue length limit.  PG_SOMAXCONN is only
		 * intended to provide a clamp on the request on platforms where an
		 * overly large request provokes a kernel error (are there any?).
		 */</comment>
		<expr_stmt><expr><name>maxconn</name> <operator>=</operator> <name>MaxBackends</name> <operator>*</operator> <literal type="number">2</literal></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>maxconn</name> <operator>&gt;</operator> <name>PG_SOMAXCONN</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>maxconn</name> <operator>=</operator> <name>PG_SOMAXCONN</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>listen</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>maxconn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>err</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_socket_access</name><argument_list>()</argument_list></call><operator>,</operator>
			<comment type="block">/* translator: first %s is IPv4, IPv6, or Unix */</comment>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not listen on %s address \"%s\": %m"</literal></expr></argument>,
							<argument><expr><name>familyDesc</name></expr></argument>, <argument><expr><name>addrDesc</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>closesocket</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_UNIX_SOCKETS</name></cpp:ifdef>
		<if_stmt><if>if <condition>(<expr><name><name>addr</name><operator>-&gt;</operator><name>ai_family</name></name> <operator>==</operator> <name>AF_UNIX</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"listening on Unix socket \"%s\""</literal></expr></argument>,
							<argument><expr><name>addrDesc</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
			<comment type="block">/* translator: first %s is IPv4 or IPv6 */</comment>
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"listening on %s address \"%s\", port %d"</literal></expr></argument>,
							<argument><expr><name>familyDesc</name></expr></argument>, <argument><expr><name>addrDesc</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>portNumber</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><name><name>ListenSocket</name><index>[<expr><name>listen_index</name></expr>]</index></name> <operator>=</operator> <name>fd</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>added</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>pg_freeaddrinfo_all</name><argument_list>(<argument><expr><name><name>hint</name><operator>.</operator><name>ai_family</name></name></expr></argument>, <argument><expr><name>addrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>added</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>STATUS_ERROR</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name>STATUS_OK</name></expr>;</return>
</block_content>}</block></function>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_UNIX_SOCKETS</name></cpp:ifdef>

<comment type="block">/*
 * Lock_AF_UNIX -- configure unix socket file path
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>Lock_AF_UNIX</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>unixSocketDir</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>unixSocketPath</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Grab an interlock file associated with the socket file.
	 *
	 * Note: there are two reasons for using a socket lock file, rather than
	 * trying to interlock directly on the socket itself.  First, it's a lot
	 * more portable, and second, it lets us remove any pre-existing socket
	 * file without race conditions.
	 */</comment>
	<expr_stmt><expr><call><name>CreateSocketLockFile</name><argument_list>(<argument><expr><name>unixSocketPath</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>unixSocketDir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Once we have the interlock, we can safely delete any pre-existing
	 * socket file to avoid failure at bind() time.
	 */</comment>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>unlink</name><argument_list>(<argument><expr><name>unixSocketPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Remember socket file pathnames for later maintenance.
	 */</comment>
	<expr_stmt><expr><name>sock_paths</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>sock_paths</name></expr></argument>, <argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><name>unixSocketPath</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>STATUS_OK</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Setup_AF_UNIX -- configure unix socket permissions
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>Setup_AF_UNIX</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>sock_path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Fix socket ownership/permission if requested.  Note we must do this
	 * before we listen() to avoid a window where unwanted connections could
	 * get accepted.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>Unix_socket_group</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>Unix_socket_group</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition>
	<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"configuration item unix_socket_group is not supported on this platform"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>endptr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>val</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>gid_t</name></type>		<name>gid</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>strtoul</name><argument_list>(<argument><expr><name>Unix_socket_group</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>endptr</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>endptr</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition>
		<block>{<block_content>						<comment type="block">/* numeric group id */</comment>
			<expr_stmt><expr><name>gid</name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>						<comment type="block">/* convert group name to id */</comment>
			<decl_stmt><decl><type><name><name>struct</name> <name>group</name></name> <modifier>*</modifier></type><name>gr</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>gr</name> <operator>=</operator> <call><name>getgrnam</name><argument_list>(<argument><expr><name>Unix_socket_group</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>gr</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"group \"%s\" does not exist"</literal></expr></argument>,
								<argument><expr><name>Unix_socket_group</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>STATUS_ERROR</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>gid</name> <operator>=</operator> <name><name>gr</name><operator>-&gt;</operator><name>gr_gid</name></name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>chown</name><argument_list>(<argument><expr><name>sock_path</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>gid</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not set group of file \"%s\": %m"</literal></expr></argument>,
							<argument><expr><name>sock_path</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>STATUS_ERROR</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>chmod</name><argument_list>(<argument><expr><name>sock_path</name></expr></argument>, <argument><expr><name>Unix_socket_permissions</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not set permissions of file \"%s\": %m"</literal></expr></argument>,
						<argument><expr><name>sock_path</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>STATUS_ERROR</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>STATUS_OK</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* HAVE_UNIX_SOCKETS */</comment>


<comment type="block">/*
 * StreamConnection -- create a new connection with client using
 *		server port.  Set port-&gt;sock to the FD of the new connection.
 *
 * ASSUME: that this doesn't need to be non-blocking because
 *		the Postmaster uses select() to tell when the server master
 *		socket is ready for accept().
 *
 * RETURNS: STATUS_OK or STATUS_ERROR
 */</comment>
<function><type><name>int</name></type>
<name>StreamConnection</name><parameter_list>(<parameter><decl><type><name>pgsocket</name></type> <name>server_fd</name></decl></parameter>, <parameter><decl><type><name>Port</name> <modifier>*</modifier></type><name>port</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* accept connection and fill in the client (remote) address */</comment>
	<expr_stmt><expr><name><name>port</name><operator>-&gt;</operator><name>raddr</name><operator>.</operator><name>salen</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>port</name><operator>-&gt;</operator><name>raddr</name><operator>.</operator><name>addr</name></name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>port</name><operator>-&gt;</operator><name>sock</name></name> <operator>=</operator> <call><name>accept</name><argument_list>(<argument><expr><name>server_fd</name></expr></argument>,
							 <argument><expr><operator>(</operator>struct <name>sockaddr</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>port</name><operator>-&gt;</operator><name>raddr</name><operator>.</operator><name>addr</name></name></expr></argument>,
							 <argument><expr><operator>&amp;</operator><name><name>port</name><operator>-&gt;</operator><name>raddr</name><operator>.</operator><name>salen</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>PGINVALID_SOCKET</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_socket_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not accept new connection: %m"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If accept() fails then postmaster.c will still see the server
		 * socket as read-ready, and will immediately try again.  To avoid
		 * uselessly sucking lots of CPU, delay a bit before trying again.
		 * (The most likely reason for failure is being out of kernel file
		 * table slots; we can do little except hope some will get freed up.)
		 */</comment>
		<expr_stmt><expr><call><name>pg_usleep</name><argument_list>(<argument><expr><literal type="number">100000L</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>		<comment type="block">/* wait 0.1 sec */</comment>
		<return>return <expr><name>STATUS_ERROR</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* fill in the server (local) address */</comment>
	<expr_stmt><expr><name><name>port</name><operator>-&gt;</operator><name>laddr</name><operator>.</operator><name>salen</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>port</name><operator>-&gt;</operator><name>laddr</name><operator>.</operator><name>addr</name></name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>getsockname</name><argument_list>(<argument><expr><name><name>port</name><operator>-&gt;</operator><name>sock</name></name></expr></argument>,
					<argument><expr><operator>(</operator>struct <name>sockaddr</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>port</name><operator>-&gt;</operator><name>laddr</name><operator>.</operator><name>addr</name></name></expr></argument>,
					<argument><expr><operator>&amp;</operator><name><name>port</name><operator>-&gt;</operator><name>laddr</name><operator>.</operator><name>salen</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"getsockname() failed: %m"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>STATUS_ERROR</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* 
	 * Set a send timeout on the socket if specified, on the master only
	 * Solaris doesn't support setting SO_SNDTIMEO, so setting this won't work on Solaris (MPP-22526) 
	 */</comment> 
	<if_stmt><if>if <condition>(<expr><call><name>IS_QUERY_DISPATCHER</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <name>gp_connection_send_timeout</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
	  <decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>timeout</name></decl>;</decl_stmt>
	  <expr_stmt><expr><name><name>timeout</name><operator>.</operator><name>tv_sec</name></name> <operator>=</operator> <name>gp_connection_send_timeout</name></expr>;</expr_stmt>
	  <expr_stmt><expr><name><name>timeout</name><operator>.</operator><name>tv_usec</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	  <if_stmt><if>if <condition>(<expr><call><name>setsockopt</name> <argument_list>(<argument><expr><name><name>port</name><operator>-&gt;</operator><name>sock</name></name></expr></argument>, <argument><expr><name>SOL_SOCKET</name></expr></argument>, <argument><expr><name>SO_SNDTIMEO</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>timeout</name></expr></argument>,
			  <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>timeout</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	    <block>{<block_content>
	      <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"setsockopt(SO_SNDTIMEO) failed: %m"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    </block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* select NODELAY and KEEPALIVE options if it's a TCP connection */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IS_AF_UNIX</name><argument_list>(<argument><expr><name><name>port</name><operator>-&gt;</operator><name>laddr</name><operator>.</operator><name>addr</name><operator>.</operator><name>ss_family</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>on</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
		<decl_stmt><decl><type><name>int</name></type>			<name>oldopt</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>optlen</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>newopt</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive>	<name>TCP_NODELAY</name></cpp:ifdef>
		<expr_stmt><expr><name>on</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>setsockopt</name><argument_list>(<argument><expr><name><name>port</name><operator>-&gt;</operator><name>sock</name></name></expr></argument>, <argument><expr><name>IPPROTO_TCP</name></expr></argument>, <argument><expr><name>TCP_NODELAY</name></expr></argument>,
					   <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>on</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>on</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"setsockopt(%s) failed: %m"</literal></expr></argument>, <argument><expr><literal type="string">"TCP_NODELAY"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>STATUS_ERROR</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<expr_stmt><expr><name>on</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>setsockopt</name><argument_list>(<argument><expr><name><name>port</name><operator>-&gt;</operator><name>sock</name></name></expr></argument>, <argument><expr><name>SOL_SOCKET</name></expr></argument>, <argument><expr><name>SO_KEEPALIVE</name></expr></argument>,
					   <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>on</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>on</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"setsockopt(%s) failed: %m"</literal></expr></argument>, <argument><expr><literal type="string">"SO_KEEPALIVE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>STATUS_ERROR</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>

		<comment type="block">/*
		 * This is a Win32 socket optimization.  The OS send buffer should be
		 * large enough to send the whole Postgres send buffer in one go, or
		 * performance suffers.  The Postgres send buffer can be enlarged if a
		 * very large message needs to be sent, but we won't attempt to
		 * enlarge the OS buffer if that happens, so somewhat arbitrarily
		 * ensure that the OS buffer is at least PQ_SEND_BUFFER_SIZE * 4.
		 * (That's 32kB with the current default).
		 *
		 * The default OS buffer size used to be 8kB in earlier Windows
		 * versions, but was raised to 64kB in Windows 2012.  So it shouldn't
		 * be necessary to change it in later versions anymore.  Changing it
		 * unnecessarily can even reduce performance, because setting
		 * SO_SNDBUF in the application disables the "dynamic send buffering"
		 * feature that was introduced in Windows 7.  So before fiddling with
		 * SO_SNDBUF, check if the current buffer size is already large enough
		 * and only increase it if necessary.
		 *
		 * See https://support.microsoft.com/kb/823764/EN-US/ and
		 * https://msdn.microsoft.com/en-us/library/bb736549%28v=vs.85%29.aspx
		 */</comment>
		<expr_stmt><expr><name>optlen</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>oldopt</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>getsockopt</name><argument_list>(<argument><expr><name><name>port</name><operator>-&gt;</operator><name>sock</name></name></expr></argument>, <argument><expr><name>SOL_SOCKET</name></expr></argument>, <argument><expr><name>SO_SNDBUF</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>oldopt</name></expr></argument>,
					   <argument><expr><operator>&amp;</operator><name>optlen</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"getsockopt(%s) failed: %m"</literal></expr></argument>, <argument><expr><literal type="string">"SO_SNDBUF"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>STATUS_ERROR</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>newopt</name> <operator>=</operator> <name>PQ_SEND_BUFFER_SIZE</name> <operator>*</operator> <literal type="number">4</literal></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>oldopt</name> <operator>&lt;</operator> <name>newopt</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>setsockopt</name><argument_list>(<argument><expr><name><name>port</name><operator>-&gt;</operator><name>sock</name></name></expr></argument>, <argument><expr><name>SOL_SOCKET</name></expr></argument>, <argument><expr><name>SO_SNDBUF</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>newopt</name></expr></argument>,
						   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>newopt</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"setsockopt(%s) failed: %m"</literal></expr></argument>, <argument><expr><literal type="string">"SO_SNDBUF"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>STATUS_ERROR</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

		<comment type="block">/*
		 * Also apply the current keepalive parameters.  If we fail to set a
		 * parameter, don't error out, because these aren't universally
		 * supported.  (Note: you might think we need to reset the GUC
		 * variables to 0 in such a case, but it's not necessary because the
		 * show hooks for these variables report the truth anyway.)
		 */</comment>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>pq_setkeepalivesidle</name><argument_list>(<argument><expr><name>tcp_keepalives_idle</name></expr></argument>, <argument><expr><name>port</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>pq_setkeepalivesinterval</name><argument_list>(<argument><expr><name>tcp_keepalives_interval</name></expr></argument>, <argument><expr><name>port</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>pq_setkeepalivescount</name><argument_list>(<argument><expr><name>tcp_keepalives_count</name></expr></argument>, <argument><expr><name>port</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>pq_settcpusertimeout</name><argument_list>(<argument><expr><name>tcp_user_timeout</name></expr></argument>, <argument><expr><name>port</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>STATUS_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * StreamClose -- close a client/backend connection
 *
 * NOTE: this is NOT used to terminate a session; it is just used to release
 * the file descriptor in a process that should no longer have the socket
 * open.  (For example, the postmaster calls this after passing ownership
 * of the connection to a child process.)  It is expected that someone else
 * still has the socket open.  So, we only want to close the descriptor,
 * we do NOT want to send anything to the far end.
 */</comment>
<function><type><name>void</name></type>
<name>StreamClose</name><parameter_list>(<parameter><decl><type><name>pgsocket</name></type> <name>sock</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>closesocket</name><argument_list>(<argument><expr><name>sock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * TouchSocketFiles -- mark socket files as recently accessed
 *
 * This routine should be called every so often to ensure that the socket
 * files have a recent mod date (ordinary operations on sockets usually won't
 * change the mod date).  That saves them from being removed by
 * overenthusiastic /tmp-directory-cleaner daemons.  (Another reason we should
 * never have put the socket file in /tmp...)
 */</comment>
<function><type><name>void</name></type>
<name>TouchSocketFiles</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<comment type="block">/* Loop through all created sockets... */</comment>
	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>sock_paths</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>sock_path</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * utime() is POSIX standard, utimes() is a common alternative. If we
		 * have neither, there's no way to affect the mod or access time of
		 * the socket :-(
		 *
		 * In either path, we ignore errors; there's no point in complaining.
		 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_UTIME</name></cpp:ifdef>
		<expr_stmt><expr><call><name>utime</name><argument_list>(<argument><expr><name>sock_path</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>							<comment type="block">/* !HAVE_UTIME */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_UTIMES</name></cpp:ifdef>
		<expr_stmt><expr><call><name>utimes</name><argument_list>(<argument><expr><name>sock_path</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* HAVE_UTIMES */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* HAVE_UTIME */</comment>
	</block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 * RemoveSocketFiles -- unlink socket files at postmaster shutdown
 */</comment>
<function><type><name>void</name></type>
<name>RemoveSocketFiles</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<comment type="block">/* Loop through all created sockets... */</comment>
	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>sock_paths</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>sock_path</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Ignore any error. */</comment>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>unlink</name><argument_list>(<argument><expr><name>sock_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<comment type="block">/* Since we're about to exit, no need to reclaim storage */</comment>
	<expr_stmt><expr><name>sock_paths</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* --------------------------------
 * Low-level I/O routines begin here.
 *
 * These routines communicate with a frontend client across a connection
 * already established by the preceding routines.
 * --------------------------------
 */</comment>

<comment type="block">/* --------------------------------
 *			  socket_set_nonblocking - set socket blocking/non-blocking
 *
 * Sets the socket non-blocking if nonblocking is true, or sets it
 * blocking otherwise.
 * --------------------------------
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>socket_set_nonblocking</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>nonblocking</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>MyProcPort</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CONNECTION_DOES_NOT_EXIST</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"there is no client connection"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>MyProcPort</name><operator>-&gt;</operator><name>noblock</name></name> <operator>=</operator> <name>nonblocking</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* --------------------------------
 *		pq_recvbuf - load some bytes into the input buffer
 *
 *		returns 0 if OK, EOF if trouble
 * --------------------------------
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>pq_recvbuf</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>PqRecvPointer</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>PqRecvLength</name> <operator>&gt;</operator> <name>PqRecvPointer</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* still some unread data, left-justify it in the buffer */</comment>
			<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>PqRecvBuffer</name></expr></argument>, <argument><expr><name>PqRecvBuffer</name> <operator>+</operator> <name>PqRecvPointer</name></expr></argument>,
					<argument><expr><name>PqRecvLength</name> <operator>-</operator> <name>PqRecvPointer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>PqRecvLength</name> <operator>-=</operator> <name>PqRecvPointer</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>PqRecvPointer</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>PqRecvLength</name> <operator>=</operator> <name>PqRecvPointer</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Ensure that we're in blocking mode */</comment>
	<expr_stmt><expr><call><name>socket_set_nonblocking</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Can fill buffer from PqRecvLength and upwards */</comment>
	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>r</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>secure_read</name><argument_list>(<argument><expr><name>MyProcPort</name></expr></argument>, <argument><expr><name>PqRecvBuffer</name> <operator>+</operator> <name>PqRecvLength</name></expr></argument>,
						<argument><expr><name>PQ_RECV_BUFFER_SIZE</name> <operator>-</operator> <name>PqRecvLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>r</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>EINTR</name> <operator>||</operator> <name>errno</name> <operator>==</operator> <name>EAGAIN</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>		<comment type="block">/* Ok if interrupted or timeout expired */</comment>

			<comment type="block">/*
			 * Careful: an ereport() that tries to write to the client would
			 * cause recursion to here, leading to stack overflow and core
			 * dump!  This message must go *only* to the postmaster log.
			 */</comment>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>COMMERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_socket_access</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not receive data from client: %m"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>EOF</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>r</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * EOF detected.  We used to write a log message here, but it's
			 * better to expect the ultimate caller to do that.
			 */</comment>
			<return>return <expr><name>EOF</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* r contains number of bytes read, so just incr length */</comment>
		<expr_stmt><expr><name>PqRecvLength</name> <operator>+=</operator> <name>r</name></expr>;</expr_stmt>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
 *
 * Can only be called for non-SSL connections (such as file replication connections).
 *
 * Wait for at least one byte of data to be available, or for the
 *   socket to be in error.
 *
 * return true if we have data or a socket error, false if the function
 *   call was interrupted
 */</comment>
<function><type><name>bool</name></type>
<name>pq_waitForDataUsingSelect</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>( <expr><name>PqRecvPointer</name> <operator>&lt;</operator> <name>PqRecvLength</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* we already have data in the buffer ... so done */</comment>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_SSL</name></cpp:ifdef>
	<if_stmt><if>if <condition>( <expr><name><name>MyProcPort</name><operator>-&gt;</operator><name>ssl</name></name></expr> )</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"SSL connection cannot be used with pq_waitForDataUsingSelect"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return> <comment type="block">/* unreachable */</comment>
	</block_content>}</block></if>
	<else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>sock</name> <init>= <expr><name><name>MyProcPort</name><operator>-&gt;</operator><name>sock</name></name></expr></init></decl>;</decl_stmt>
		<for>for <control>( <init>;</init><condition>;</condition> <incr/>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>fd_set</name></type> <name>toRead</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>fd_set</name></type> <name>haveError</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type> <name>numSockets</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>FD_ZERO</name><argument_list>(<argument><expr><operator>&amp;</operator><name>toRead</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>FD_ZERO</name><argument_list>(<argument><expr><operator>&amp;</operator><name>haveError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>FD_SET</name><argument_list>(<argument><expr><name>sock</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>toRead</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>FD_SET</name><argument_list>(<argument><expr><name>sock</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>haveError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>numSockets</name> <operator>=</operator> <call><name>select</name><argument_list>(<argument><expr><name>sock</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>toRead</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument> <comment type="block">/* toWrite */</comment>, <argument><expr><operator>&amp;</operator><name>haveError</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>( <expr><name>errno</name> <operator>==</operator> <name>EINTR</name></expr>)</condition>
			<block>{<block_content>
				<return>return <expr><name>false</name></expr>;</return>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name>errno</name> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"select failed: %m"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>( <expr><name>numSockets</name> <operator>&gt;</operator> <literal type="number">0</literal></expr> )</condition>
			<block>{<block_content>
				<comment type="block">/* the socket has data to read or is in error so break out */</comment>
				<return>return <expr><name>true</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* --------------------------------
 *		pq_getbyte	- get a single byte from connection, or return EOF
 * --------------------------------
 */</comment>
<function><type><name>int</name></type>
<name>pq_getbyte</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>PqCommReadingMsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><name>PqRecvPointer</name> <operator>&gt;=</operator> <name>PqRecvLength</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>pq_recvbuf</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>		<comment type="block">/* If nothing in buffer, then recv some */</comment>
			<return>return <expr><name>EOF</name></expr>;</return></block_content></block></if></if_stmt>			<comment type="block">/* Failed to recv data */</comment>
	</block_content>}</block></while>
	<return>return <expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <name><name>PqRecvBuffer</name><index>[<expr><name>PqRecvPointer</name><operator>++</operator></expr>]</index></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* --------------------------------
 *		pq_peekbyte		- peek at next byte from connection
 *
 *	 Same as pq_getbyte() except we don't advance the pointer.
 * --------------------------------
 */</comment>
<function><type><name>int</name></type>
<name>pq_peekbyte</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>PqCommReadingMsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><name>PqRecvPointer</name> <operator>&gt;=</operator> <name>PqRecvLength</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>pq_recvbuf</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>		<comment type="block">/* If nothing in buffer, then recv some */</comment>
			<return>return <expr><name>EOF</name></expr>;</return></block_content></block></if></if_stmt>			<comment type="block">/* Failed to recv data */</comment>
	</block_content>}</block></while>
	<return>return <expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <name><name>PqRecvBuffer</name><index>[<expr><name>PqRecvPointer</name></expr>]</index></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* --------------------------------
 *		pq_getbyte_if_available - get a single byte from connection,
 *			if available
 *
 * The received byte is stored in *c. Returns 1 if a byte was read,
 * 0 if no data was available, or EOF if trouble.
 * --------------------------------
 */</comment>
<function><type><name>int</name></type>
<name>pq_getbyte_if_available</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>r</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>PqCommReadingMsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>PqRecvPointer</name> <operator>&lt;</operator> <name>PqRecvLength</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>c</name> <operator>=</operator> <name><name>PqRecvBuffer</name><index>[<expr><name>PqRecvPointer</name><operator>++</operator></expr>]</index></name></expr>;</expr_stmt>
		<return>return <expr><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Put the socket into non-blocking mode */</comment>
	<expr_stmt><expr><call><name>socket_set_nonblocking</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>secure_read</name><argument_list>(<argument><expr><name>MyProcPort</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>r</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Ok if no data available without blocking or interrupted (though
		 * EINTR really shouldn't happen with a non-blocking socket). Report
		 * other errors.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>EAGAIN</name> <operator>||</operator> <name>errno</name> <operator>==</operator> <name>EWOULDBLOCK</name> <operator>||</operator> <name>errno</name> <operator>==</operator> <name>EINTR</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>r</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * Careful: an ereport() that tries to write to the client would
			 * cause recursion to here, leading to stack overflow and core
			 * dump!  This message must go *only* to the postmaster log.
			 */</comment>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>COMMERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_socket_access</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not receive data from client: %m"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>r</name> <operator>=</operator> <name>EOF</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>r</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* EOF detected */</comment>
		<expr_stmt><expr><name>r</name> <operator>=</operator> <name>EOF</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>r</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* --------------------------------
 *		pq_getbytes		- get a known number of bytes from connection
 *
 *		returns 0 if OK, EOF if trouble
 * --------------------------------
 */</comment>
<function><type><name>int</name></type>
<name>pq_getbytes</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>size_t</name></type>		<name>amount</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>PqCommReadingMsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<while>while <condition>(<expr><name>PqRecvPointer</name> <operator>&gt;=</operator> <name>PqRecvLength</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>pq_recvbuf</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>	<comment type="block">/* If nothing in buffer, then recv some */</comment>
				<return>return <expr><name>EOF</name></expr>;</return></block_content></block></if></if_stmt>		<comment type="block">/* Failed to recv data */</comment>
		</block_content>}</block></while>
		<expr_stmt><expr><name>amount</name> <operator>=</operator> <name>PqRecvLength</name> <operator>-</operator> <name>PqRecvPointer</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>amount</name> <operator>&gt;</operator> <name>len</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>amount</name> <operator>=</operator> <name>len</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>PqRecvBuffer</name> <operator>+</operator> <name>PqRecvPointer</name></expr></argument>, <argument><expr><name>amount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>PqRecvPointer</name> <operator>+=</operator> <name>amount</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>s</name> <operator>+=</operator> <name>amount</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>len</name> <operator>-=</operator> <name>amount</name></expr>;</expr_stmt>
	</block_content>}</block></while>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* --------------------------------
 *		pq_discardbytes		- throw away a known number of bytes
 *
 *		same as pq_getbytes except we do not copy the data to anyplace.
 *		this is used for resynchronizing after read errors.
 *
 *		returns 0 if OK, EOF if trouble
 * --------------------------------
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>pq_discardbytes</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>size_t</name></type>		<name>amount</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>PqCommReadingMsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<while>while <condition>(<expr><name>PqRecvPointer</name> <operator>&gt;=</operator> <name>PqRecvLength</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>pq_recvbuf</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>	<comment type="block">/* If nothing in buffer, then recv some */</comment>
				<return>return <expr><name>EOF</name></expr>;</return></block_content></block></if></if_stmt>		<comment type="block">/* Failed to recv data */</comment>
		</block_content>}</block></while>
		<expr_stmt><expr><name>amount</name> <operator>=</operator> <name>PqRecvLength</name> <operator>-</operator> <name>PqRecvPointer</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>amount</name> <operator>&gt;</operator> <name>len</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>amount</name> <operator>=</operator> <name>len</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>PqRecvPointer</name> <operator>+=</operator> <name>amount</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>len</name> <operator>-=</operator> <name>amount</name></expr>;</expr_stmt>
	</block_content>}</block></while>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* --------------------------------
 *		pq_getstring	- get a null terminated string from connection
 *
 *		The return value is placed in an expansible StringInfo, which has
 *		already been initialized by the caller.
 *
 *		This is used only for dealing with old-protocol clients.  The idea
 *		is to produce a StringInfo that looks the same as we would get from
 *		pq_getmessage() with a newer client; we will then process it with
 *		pq_getmsgstring.  Therefore, no character set conversion is done here,
 *		even though this is presumably useful only for text.
 *
 *		returns 0 if OK, EOF if trouble
 * --------------------------------
 */</comment>
<function><type><name>int</name></type>
<name>pq_getstring</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>PqCommReadingMsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>resetStringInfo</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Read until we get the terminating '\0' */</comment>
	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<while>while <condition>(<expr><name>PqRecvPointer</name> <operator>&gt;=</operator> <name>PqRecvLength</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>pq_recvbuf</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>	<comment type="block">/* If nothing in buffer, then recv some */</comment>
				<return>return <expr><name>EOF</name></expr>;</return></block_content></block></if></if_stmt>		<comment type="block">/* Failed to recv data */</comment>
		</block_content>}</block></while>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>PqRecvPointer</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>PqRecvLength</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>PqRecvBuffer</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* include the '\0' in the copy */</comment>
				<expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>PqRecvBuffer</name> <operator>+</operator> <name>PqRecvPointer</name></expr></argument>,
									   <argument><expr><name>i</name> <operator>-</operator> <name>PqRecvPointer</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>PqRecvPointer</name> <operator>=</operator> <name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>	<comment type="block">/* advance past \0 */</comment>
				<return>return <expr><literal type="number">0</literal></expr>;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>

		<comment type="block">/* If we're here we haven't got the \0 in the buffer yet. */</comment>
		<expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>PqRecvBuffer</name> <operator>+</operator> <name>PqRecvPointer</name></expr></argument>,
							   <argument><expr><name>PqRecvLength</name> <operator>-</operator> <name>PqRecvPointer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>PqRecvPointer</name> <operator>=</operator> <name>PqRecvLength</name></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>


<comment type="block">/* --------------------------------
 *		pq_startmsgread - begin reading a message from the client.
 *
 *		This must be called before any of the pq_get* functions.
 * --------------------------------
 */</comment>
<function><type><name>void</name></type>
<name>pq_startmsgread</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * There shouldn't be a read active already, but let's check just to be
	 * sure.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>PqCommReadingMsg</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROTOCOL_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"terminating connection because protocol synchronization was lost"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>PqCommReadingMsg</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* --------------------------------
 *		pq_endmsgread	- finish reading message.
 *
 *		This must be called after reading a V2 protocol message with
 *		pq_getstring() and friends, to indicate that we have read the whole
 *		message. In V3 protocol, pq_getmessage() does this implicitly.
 * --------------------------------
 */</comment>
<function><type><name>void</name></type>
<name>pq_endmsgread</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>PqCommReadingMsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>PqCommReadingMsg</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* --------------------------------
 *		pq_is_reading_msg - are we currently reading a message?
 *
 * This is used in error recovery at the outer idle loop to detect if we have
 * lost protocol sync, and need to terminate the connection. pq_startmsgread()
 * will check for that too, but it's nicer to detect it earlier.
 * --------------------------------
 */</comment>
<function><type><name>bool</name></type>
<name>pq_is_reading_msg</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name>PqCommReadingMsg</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* --------------------------------
 *		pq_getmessage	- get a message with length word from connection
 *
 *		The return value is placed in an expansible StringInfo, which has
 *		already been initialized by the caller.
 *		Only the message body is placed in the StringInfo; the length word
 *		is removed.  Also, s-&gt;cursor is initialized to zero for convenience
 *		in scanning the message contents.
 *
 *		If maxlen is not zero, it is an upper limit on the length of the
 *		message we are willing to accept.  We abort the connection (by
 *		returning EOF) if client tries to send more than that.
 *
 *		returns 0 if OK, EOF if trouble
 * --------------------------------
 */</comment>
<function><type><name>int</name></type>
<name>pq_getmessage</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>s</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>maxlen</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int32</name></type>		<name>len</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>PqCommReadingMsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>resetStringInfo</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Read message length word */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>pq_getbytes</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>len</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>EOF</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>COMMERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROTOCOL_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unexpected EOF within message length word"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>EOF</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>pg_ntoh32</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <literal type="number">4</literal> <operator>||</operator>
		<operator>(</operator><name>maxlen</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>len</name> <operator>&gt;</operator> <name>maxlen</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>COMMERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROTOCOL_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid message length"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>EOF</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>len</name> <operator>-=</operator> <literal type="number">4</literal></expr>;</expr_stmt>					<comment type="block">/* discount length itself */</comment>

	<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Allocate space for message.  If we run out of room (ridiculously
		 * large message), we will elog(ERROR), but we want to discard the
		 * message body so as not to lose communication sync.
		 */</comment>
		<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<block>{<block_content>
			<expr_stmt><expr><call><name>enlargeStringInfo</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
		<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>pq_discardbytes</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>EOF</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>COMMERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROTOCOL_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"incomplete message from client"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/* we discarded the rest of the message so we're back in sync. */</comment>
			<expr_stmt><expr><name>PqCommReadingMsg</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
		<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* And grab the message */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>pq_getbytes</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>EOF</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>COMMERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROTOCOL_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"incomplete message from client"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>EOF</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>len</name></name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>
		<comment type="block">/* Place a trailing null per StringInfo convention */</comment>
		<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>data</name><index>[<expr><name>len</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* finished reading the message. */</comment>
	<expr_stmt><expr><name>PqCommReadingMsg</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* --------------------------------
 *		pq_putbytes		- send bytes to connection (not flushed until pq_flush)
 *
 *		returns 0 if OK, EOF if trouble
 * --------------------------------
 */</comment>
<function><type><name>int</name></type>
<name>pq_putbytes</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>res</name></decl>;</decl_stmt>

	<comment type="block">/* Should only be called by old-style COPY OUT */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>DoingCopyOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* No-op if reentrant call */</comment>
	<if_stmt><if>if <condition>(<expr><name>PqCommBusy</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>PqCommBusy</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>internal_putbytes</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>PqCommBusy</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>internal_putbytes</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>size_t</name></type>		<name>amount</name></decl>;</decl_stmt>

	<while>while <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* If buffer is full, then flush it out */</comment>
		<if_stmt><if>if <condition>(<expr><name>PqSendPointer</name> <operator>&gt;=</operator> <name>PqSendBufferSize</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>socket_set_nonblocking</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>internal_flush</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>EOF</name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>amount</name> <operator>=</operator> <name>PqSendBufferSize</name> <operator>-</operator> <name>PqSendPointer</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>amount</name> <operator>&gt;</operator> <name>len</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>amount</name> <operator>=</operator> <name>len</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>PqSendBuffer</name> <operator>+</operator> <name>PqSendPointer</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>amount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>PqSendPointer</name> <operator>+=</operator> <name>amount</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>s</name> <operator>+=</operator> <name>amount</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>len</name> <operator>-=</operator> <name>amount</name></expr>;</expr_stmt>
	</block_content>}</block></while>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* --------------------------------
 *		socket_flush		- flush pending output
 *
 *		returns 0 if OK, EOF if trouble
 * --------------------------------
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>socket_flush</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>res</name></decl>;</decl_stmt>

	<comment type="block">/* No-op if reentrant call */</comment>
	<if_stmt><if>if <condition>(<expr><name>PqCommBusy</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>PqCommBusy</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>socket_set_nonblocking</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>internal_flush</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>PqCommBusy</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* --------------------------------
 *		internal_flush - flush pending output
 *
 * Returns 0 if OK (meaning everything was sent, or operation would block
 * and the socket is in non-blocking mode), or EOF if trouble.
 * --------------------------------
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>internal_flush</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>last_reported_send_errno</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>bufptr</name> <init>= <expr><name>PqSendBuffer</name> <operator>+</operator> <name>PqSendStart</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>bufend</name> <init>= <expr><name>PqSendBuffer</name> <operator>+</operator> <name>PqSendPointer</name></expr></init></decl>;</decl_stmt>

	<while>while <condition>(<expr><name>bufptr</name> <operator>&lt;</operator> <name>bufend</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>r</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>secure_write</name><argument_list>(<argument><expr><name>MyProcPort</name></expr></argument>, <argument><expr><name>bufptr</name></expr></argument>, <argument><expr><name>bufend</name> <operator>-</operator> <name>bufptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>r</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>EINTR</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>		<comment type="block">/* Ok if we were interrupted */</comment>

			<comment type="block">/*
			 * Ok if no data writable without blocking, and the socket is in
			 * non-blocking mode.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>EAGAIN</name> <operator>||</operator>
				<name>errno</name> <operator>==</operator> <name>EWOULDBLOCK</name></expr>)</condition>
			<block>{<block_content>
				<return>return <expr><literal type="number">0</literal></expr>;</return>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * Careful: an ereport() that tries to write to the client would
			 * cause recursion to here, leading to stack overflow and core
			 * dump!  This message must go *only* to the postmaster log.
			 *
			 * If a client disconnects while we're in the midst of output, we
			 * might write quite a bit of data before we get to a safe query
			 * abort point.  So, suppress duplicate log messages.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>!=</operator> <name>last_reported_send_errno</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>last_reported_send_errno</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>
				<comment type="block">/* TDOO: what's this? */</comment>
				<expr_stmt><expr><call><name>HOLD_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* we can use ereport here, for the protection of send mutex */</comment>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>COMMERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode_for_socket_access</name><argument_list>()</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not send data to client: %m"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>RESUME_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * We drop the buffered data anyway so that processing can
			 * continue, even though we'll probably quit soon. We also set a
			 * flag that'll cause the next CHECK_FOR_INTERRUPTS to terminate
			 * the connection.
			 */</comment>
			<expr_stmt><expr><name>PqSendStart</name> <operator>=</operator> <name>PqSendPointer</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>ClientConnectionLost</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>InterruptPending</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<return>return <expr><name>EOF</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>last_reported_send_errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>	<comment type="block">/* reset after any successful send */</comment>
		<expr_stmt><expr><name>bufptr</name> <operator>+=</operator> <name>r</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>PqSendStart</name> <operator>+=</operator> <name>r</name></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><name>PqSendStart</name> <operator>=</operator> <name>PqSendPointer</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* --------------------------------
 *		pq_flush_if_writable - flush pending output if writable without blocking
 *
 * Returns 0 if OK, or EOF if trouble.
 * --------------------------------
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>socket_flush_if_writable</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>res</name></decl>;</decl_stmt>

	<comment type="block">/* Quick exit if nothing to do */</comment>
	<if_stmt><if>if <condition>(<expr><name>PqSendPointer</name> <operator>==</operator> <name>PqSendStart</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* No-op if reentrant call */</comment>
	<if_stmt><if>if <condition>(<expr><name>PqCommBusy</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Temporarily put the socket into non-blocking mode */</comment>
	<expr_stmt><expr><call><name>socket_set_nonblocking</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>PqCommBusy</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>internal_flush</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>PqCommBusy</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* --------------------------------
 *	socket_is_send_pending	- is there any pending data in the output buffer?
 * --------------------------------
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>socket_is_send_pending</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><operator>(</operator><name>PqSendStart</name> <operator>&lt;</operator> <name>PqSendPointer</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* --------------------------------
 * Message-level I/O routines begin here.
 *
 * These routines understand about the old-style COPY OUT protocol.
 * --------------------------------
 */</comment>


<comment type="block">/* --------------------------------
 *		socket_putmessage - send a normal message (suppressed in COPY OUT mode)
 *
 *		If msgtype is not '\0', it is a message type code to place before
 *		the message body.  If msgtype is '\0', then the message has no type
 *		code (this is only valid in pre-3.0 protocols).
 *
 *		len is the length of the message body data at *s.  In protocol 3.0
 *		and later, a message length word (equal to len+4 because it counts
 *		itself too) is inserted by this routine.
 *
 *		All normal messages are suppressed while old-style COPY OUT is in
 *		progress.  (In practice only a few notice messages might get emitted
 *		then; dropping them is annoying, but at least they will still appear
 *		in the postmaster log.)
 *
 *		We also suppress messages generated while pqcomm.c is busy.  This
 *		avoids any possibility of messages being inserted within other
 *		messages.
 *
 *		returns 0 if OK, EOF if trouble
 * --------------------------------
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>socket_putmessage</name><parameter_list>(<parameter><decl><type><name>char</name></type> <name>msgtype</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>DoingCopyOut</name> <operator>||</operator> <name>PqCommBusy</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>EOF</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>PqCommBusy</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>msgtype</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>internal_putbytes</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msgtype</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>fail</name>;</goto></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>PG_PROTOCOL_MAJOR</name><argument_list>(<argument><expr><name>FrontendProtocol</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">3</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>uint32</name></type>		<name>n32</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>n32</name> <operator>=</operator> <call><name>pg_hton32</name><argument_list>(<argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>len</name> <operator>+</operator> <literal type="number">4</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>internal_putbytes</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>n32</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>fail</name>;</goto></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>internal_putbytes</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>fail</name>;</goto></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>PqCommBusy</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<return>return <expr><literal type="number">0</literal></expr>;</return>

<label><name>fail</name>:</label>
	<expr_stmt><expr><name>PqCommBusy</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<return>return <expr><name>EOF</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* --------------------------------
 *		pq_putmessage_noblock	- like pq_putmessage, but never blocks
 *
 *		If the output buffer is too small to hold the message, the buffer
 *		is enlarged.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>socket_putmessage_noblock</name><parameter_list>(<parameter><decl><type><name>char</name></type> <name>msgtype</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name>			<name>res</name></type> <name>PG_USED_FOR_ASSERTS_ONLY</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>required</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Ensure we have enough space in the output buffer for the message header
	 * as well as the message itself.
	 */</comment>
	<expr_stmt><expr><name>required</name> <operator>=</operator> <name>PqSendPointer</name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <literal type="number">4</literal> <operator>+</operator> <name>len</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>required</name> <operator>&gt;</operator> <name>PqSendBufferSize</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>PqSendBuffer</name> <operator>=</operator> <call><name>repalloc</name><argument_list>(<argument><expr><name>PqSendBuffer</name></expr></argument>, <argument><expr><name>required</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>PqSendBufferSize</name> <operator>=</operator> <name>required</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>pq_putmessage</name><argument_list>(<argument><expr><name>msgtype</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>res</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>			<comment type="block">/* should not fail when the message fits in
								 * buffer */</comment>
</block_content>}</block></function>


<comment type="block">/* --------------------------------
 *		socket_startcopyout - inform libpq that an old-style COPY OUT transfer
 *			is beginning
 * --------------------------------
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>socket_startcopyout</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name>DoingCopyOut</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* --------------------------------
 *		socket_endcopyout	- end an old-style COPY OUT transfer
 *
 *		If errorAbort is indicated, we are aborting a COPY OUT due to an error,
 *		and must send a terminator line.  Since a partial data line might have
 *		been emitted, send a couple of newlines first (the first one could
 *		get absorbed by a backslash...)  Note that old-style COPY OUT does
 *		not allow binary transfers, so a textual terminator is always correct.
 * --------------------------------
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>socket_endcopyout</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>errorAbort</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>DoingCopyOut</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>errorAbort</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pq_putbytes</name><argument_list>(<argument><expr><literal type="string">"\n\n\\.\n"</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<comment type="block">/* in non-error case, copy.c will have emitted the terminator line */</comment>
	<expr_stmt><expr><name>DoingCopyOut</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Support for TCP Keepalive parameters
 */</comment>

<comment type="block">/*
 * On Windows, we need to set both idle and interval at the same time.
 * We also cannot reset them to the default (setting to zero will
 * actually set them to zero, not default), therefore we fallback to
 * the out-of-the-box default instead.
 */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WIN32</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>SIO_KEEPALIVE_VALS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>pq_setkeepaliveswin32</name><parameter_list>(<parameter><decl><type><name>Port</name> <modifier>*</modifier></type><name>port</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>idle</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>interval</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>tcp_keepalive</name></name></type> <name>ka</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DWORD</name></type>		<name>retsize</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>idle</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>idle</name> <operator>=</operator> <literal type="number">2</literal> <operator>*</operator> <literal type="number">60</literal> <operator>*</operator> <literal type="number">60</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>		<comment type="block">/* default = 2 hours */</comment>
	<if_stmt><if>if <condition>(<expr><name>interval</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>interval</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>			<comment type="block">/* default = 1 second */</comment>

	<expr_stmt><expr><name><name>ka</name><operator>.</operator><name>onoff</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ka</name><operator>.</operator><name>keepalivetime</name></name> <operator>=</operator> <name>idle</name> <operator>*</operator> <literal type="number">1000</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ka</name><operator>.</operator><name>keepaliveinterval</name></name> <operator>=</operator> <name>interval</name> <operator>*</operator> <literal type="number">1000</literal></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>WSAIoctl</name><argument_list>(<argument><expr><name><name>port</name><operator>-&gt;</operator><name>sock</name></name></expr></argument>,
				 <argument><expr><name>SIO_KEEPALIVE_VALS</name></expr></argument>,
				 <argument><expr><operator>(</operator><name>LPVOID</name><operator>)</operator> <operator>&amp;</operator><name>ka</name></expr></argument>,
				 <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ka</name></expr></argument>)</argument_list></sizeof></expr></argument>,
				 <argument><expr><name>NULL</name></expr></argument>,
				 <argument><expr><literal type="number">0</literal></expr></argument>,
				 <argument><expr><operator>&amp;</operator><name>retsize</name></expr></argument>,
				 <argument><expr><name>NULL</name></expr></argument>,
				 <argument><expr><name>NULL</name></expr></argument>)</argument_list></call>
		<operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"WSAIoctl(SIO_KEEPALIVE_VALS) failed: %ui"</literal></expr></argument>,
			 <argument><expr><call><name>WSAGetLastError</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>STATUS_ERROR</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>port</name><operator>-&gt;</operator><name>keepalives_idle</name></name> <operator>!=</operator> <name>idle</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>port</name><operator>-&gt;</operator><name>keepalives_idle</name></name> <operator>=</operator> <name>idle</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>port</name><operator>-&gt;</operator><name>keepalives_interval</name></name> <operator>!=</operator> <name>interval</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>port</name><operator>-&gt;</operator><name>keepalives_interval</name></name> <operator>=</operator> <name>interval</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name>STATUS_OK</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>int</name></type>
<name>pq_getkeepalivesidle</name><parameter_list>(<parameter><decl><type><name>Port</name> <modifier>*</modifier></type><name>port</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PG_TCP_KEEPALIVE_IDLE</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>SIO_KEEPALIVE_VALS</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<if_stmt><if>if <condition>(<expr><name>port</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <call><name>IS_AF_UNIX</name><argument_list>(<argument><expr><name><name>port</name><operator>-&gt;</operator><name>laddr</name><operator>.</operator><name>addr</name><operator>.</operator><name>ss_family</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>port</name><operator>-&gt;</operator><name>keepalives_idle</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name><name>port</name><operator>-&gt;</operator><name>keepalives_idle</name></name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>port</name><operator>-&gt;</operator><name>default_keepalives_idle</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
		<decl_stmt><decl><type><name>ACCEPT_TYPE_ARG3</name></type> <name>size</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>port</name><operator>-&gt;</operator><name>default_keepalives_idle</name></name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>getsockopt</name><argument_list>(<argument><expr><name><name>port</name><operator>-&gt;</operator><name>sock</name></name></expr></argument>, <argument><expr><name>IPPROTO_TCP</name></expr></argument>, <argument><expr><name>PG_TCP_KEEPALIVE_IDLE</name></expr></argument>,
					   <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>port</name><operator>-&gt;</operator><name>default_keepalives_idle</name></name></expr></argument>,
					   <argument><expr><operator>&amp;</operator><name>size</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"getsockopt(%s) failed: %m"</literal></expr></argument>, <argument><expr><name>PG_TCP_KEEPALIVE_IDLE_STR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>port</name><operator>-&gt;</operator><name>default_keepalives_idle</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt> <comment type="block">/* don't know */</comment>
		</block_content>}</block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>							<comment type="block">/* WIN32 */</comment>
		<comment type="block">/* We can't get the defaults on Windows, so return "don't know" */</comment>
		<expr_stmt><expr><name><name>port</name><operator>-&gt;</operator><name>default_keepalives_idle</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* WIN32 */</comment>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name><name>port</name><operator>-&gt;</operator><name>default_keepalives_idle</name></name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>pq_setkeepalivesidle</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>idle</name></decl></parameter>, <parameter><decl><type><name>Port</name> <modifier>*</modifier></type><name>port</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>port</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <call><name>IS_AF_UNIX</name><argument_list>(<argument><expr><name><name>port</name><operator>-&gt;</operator><name>laddr</name><operator>.</operator><name>addr</name><operator>.</operator><name>ss_family</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>STATUS_OK</name></expr>;</return></block_content></block></if></if_stmt>

<comment type="block">/* check SIO_KEEPALIVE_VALS here, not just WIN32, as some toolchains lack it */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PG_TCP_KEEPALIVE_IDLE</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>SIO_KEEPALIVE_VALS</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<if_stmt><if>if <condition>(<expr><name>idle</name> <operator>==</operator> <name><name>port</name><operator>-&gt;</operator><name>keepalives_idle</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>STATUS_OK</name></expr>;</return></block_content></block></if></if_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
	<if_stmt><if>if <condition>(<expr><name><name>port</name><operator>-&gt;</operator><name>default_keepalives_idle</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>pq_getkeepalivesidle</name><argument_list>(<argument><expr><name>port</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>idle</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>STATUS_OK</name></expr>;</return></block_content></block></if>	<comment type="block">/* default is set but unknown */</comment>
			<else>else<block type="pseudo"><block_content>
				<return>return <expr><name>STATUS_ERROR</name></expr>;</return></block_content></block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>idle</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>idle</name> <operator>=</operator> <name><name>port</name><operator>-&gt;</operator><name>default_keepalives_idle</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>setsockopt</name><argument_list>(<argument><expr><name><name>port</name><operator>-&gt;</operator><name>sock</name></name></expr></argument>, <argument><expr><name>IPPROTO_TCP</name></expr></argument>, <argument><expr><name>PG_TCP_KEEPALIVE_IDLE</name></expr></argument>,
				   <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>idle</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>idle</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"setsockopt(%s) failed: %m"</literal></expr></argument>, <argument><expr><name>PG_TCP_KEEPALIVE_IDLE_STR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>STATUS_ERROR</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>port</name><operator>-&gt;</operator><name>keepalives_idle</name></name> <operator>=</operator> <name>idle</name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>							<comment type="block">/* WIN32 */</comment>
	<return>return <expr><call><name>pq_setkeepaliveswin32</name><argument_list>(<argument><expr><name>port</name></expr></argument>, <argument><expr><name>idle</name></expr></argument>, <argument><expr><name><name>port</name><operator>-&gt;</operator><name>keepalives_interval</name></name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<if_stmt><if>if <condition>(<expr><name>idle</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"setting the keepalive idle time is not supported"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>STATUS_ERROR</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<return>return <expr><name>STATUS_OK</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>pq_getkeepalivesinterval</name><parameter_list>(<parameter><decl><type><name>Port</name> <modifier>*</modifier></type><name>port</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>TCP_KEEPINTVL</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>SIO_KEEPALIVE_VALS</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<if_stmt><if>if <condition>(<expr><name>port</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <call><name>IS_AF_UNIX</name><argument_list>(<argument><expr><name><name>port</name><operator>-&gt;</operator><name>laddr</name><operator>.</operator><name>addr</name><operator>.</operator><name>ss_family</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>port</name><operator>-&gt;</operator><name>keepalives_interval</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name><name>port</name><operator>-&gt;</operator><name>keepalives_interval</name></name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>port</name><operator>-&gt;</operator><name>default_keepalives_interval</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
		<decl_stmt><decl><type><name>ACCEPT_TYPE_ARG3</name></type> <name>size</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>port</name><operator>-&gt;</operator><name>default_keepalives_interval</name></name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>getsockopt</name><argument_list>(<argument><expr><name><name>port</name><operator>-&gt;</operator><name>sock</name></name></expr></argument>, <argument><expr><name>IPPROTO_TCP</name></expr></argument>, <argument><expr><name>TCP_KEEPINTVL</name></expr></argument>,
					   <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>port</name><operator>-&gt;</operator><name>default_keepalives_interval</name></name></expr></argument>,
					   <argument><expr><operator>&amp;</operator><name>size</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"getsockopt(%s) failed: %m"</literal></expr></argument>, <argument><expr><literal type="string">"TCP_KEEPINTVL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>port</name><operator>-&gt;</operator><name>default_keepalives_interval</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt> <comment type="block">/* don't know */</comment>
		</block_content>}</block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		<comment type="block">/* We can't get the defaults on Windows, so return "don't know" */</comment>
		<expr_stmt><expr><name><name>port</name><operator>-&gt;</operator><name>default_keepalives_interval</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* WIN32 */</comment>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name><name>port</name><operator>-&gt;</operator><name>default_keepalives_interval</name></name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>pq_setkeepalivesinterval</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>interval</name></decl></parameter>, <parameter><decl><type><name>Port</name> <modifier>*</modifier></type><name>port</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>port</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <call><name>IS_AF_UNIX</name><argument_list>(<argument><expr><name><name>port</name><operator>-&gt;</operator><name>laddr</name><operator>.</operator><name>addr</name><operator>.</operator><name>ss_family</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>STATUS_OK</name></expr>;</return></block_content></block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>TCP_KEEPINTVL</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>SIO_KEEPALIVE_VALS</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<if_stmt><if>if <condition>(<expr><name>interval</name> <operator>==</operator> <name><name>port</name><operator>-&gt;</operator><name>keepalives_interval</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>STATUS_OK</name></expr>;</return></block_content></block></if></if_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
	<if_stmt><if>if <condition>(<expr><name><name>port</name><operator>-&gt;</operator><name>default_keepalives_interval</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>pq_getkeepalivesinterval</name><argument_list>(<argument><expr><name>port</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>interval</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>STATUS_OK</name></expr>;</return></block_content></block></if>	<comment type="block">/* default is set but unknown */</comment>
			<else>else<block type="pseudo"><block_content>
				<return>return <expr><name>STATUS_ERROR</name></expr>;</return></block_content></block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>interval</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>interval</name> <operator>=</operator> <name><name>port</name><operator>-&gt;</operator><name>default_keepalives_interval</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>setsockopt</name><argument_list>(<argument><expr><name><name>port</name><operator>-&gt;</operator><name>sock</name></name></expr></argument>, <argument><expr><name>IPPROTO_TCP</name></expr></argument>, <argument><expr><name>TCP_KEEPINTVL</name></expr></argument>,
				   <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>interval</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>interval</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"setsockopt(%s) failed: %m"</literal></expr></argument>, <argument><expr><literal type="string">"TCP_KEEPINTVL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>STATUS_ERROR</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>port</name><operator>-&gt;</operator><name>keepalives_interval</name></name> <operator>=</operator> <name>interval</name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>							<comment type="block">/* WIN32 */</comment>
	<return>return <expr><call><name>pq_setkeepaliveswin32</name><argument_list>(<argument><expr><name>port</name></expr></argument>, <argument><expr><name><name>port</name><operator>-&gt;</operator><name>keepalives_idle</name></name></expr></argument>, <argument><expr><name>interval</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<if_stmt><if>if <condition>(<expr><name>interval</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"setsockopt(%s) not supported"</literal></expr></argument>, <argument><expr><literal type="string">"TCP_KEEPINTVL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>STATUS_ERROR</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<return>return <expr><name>STATUS_OK</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>pq_getkeepalivescount</name><parameter_list>(<parameter><decl><type><name>Port</name> <modifier>*</modifier></type><name>port</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TCP_KEEPCNT</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><name>port</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <call><name>IS_AF_UNIX</name><argument_list>(<argument><expr><name><name>port</name><operator>-&gt;</operator><name>laddr</name><operator>.</operator><name>addr</name><operator>.</operator><name>ss_family</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>port</name><operator>-&gt;</operator><name>keepalives_count</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name><name>port</name><operator>-&gt;</operator><name>keepalives_count</name></name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>port</name><operator>-&gt;</operator><name>default_keepalives_count</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>socklen_t</name></type> <name>size</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>port</name><operator>-&gt;</operator><name>default_keepalives_count</name></name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>getsockopt</name><argument_list>(<argument><expr><name><name>port</name><operator>-&gt;</operator><name>sock</name></name></expr></argument>, <argument><expr><name>IPPROTO_TCP</name></expr></argument>, <argument><expr><name>TCP_KEEPCNT</name></expr></argument>,
					   <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>port</name><operator>-&gt;</operator><name>default_keepalives_count</name></name></expr></argument>,
					   <argument><expr><operator>&amp;</operator><name>size</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"getsockopt(%s) failed: %m"</literal></expr></argument>, <argument><expr><literal type="string">"TCP_KEEPCNT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>port</name><operator>-&gt;</operator><name>default_keepalives_count</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>	<comment type="block">/* don't know */</comment>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name><name>port</name><operator>-&gt;</operator><name>default_keepalives_count</name></name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>pq_setkeepalivescount</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>count</name></decl></parameter>, <parameter><decl><type><name>Port</name> <modifier>*</modifier></type><name>port</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>port</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <call><name>IS_AF_UNIX</name><argument_list>(<argument><expr><name><name>port</name><operator>-&gt;</operator><name>laddr</name><operator>.</operator><name>addr</name><operator>.</operator><name>ss_family</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>STATUS_OK</name></expr>;</return></block_content></block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TCP_KEEPCNT</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><name>count</name> <operator>==</operator> <name><name>port</name><operator>-&gt;</operator><name>keepalives_count</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>STATUS_OK</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>port</name><operator>-&gt;</operator><name>default_keepalives_count</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>pq_getkeepalivescount</name><argument_list>(<argument><expr><name>port</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>count</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>STATUS_OK</name></expr>;</return></block_content></block></if>	<comment type="block">/* default is set but unknown */</comment>
			<else>else<block type="pseudo"><block_content>
				<return>return <expr><name>STATUS_ERROR</name></expr>;</return></block_content></block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>count</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>count</name> <operator>=</operator> <name><name>port</name><operator>-&gt;</operator><name>default_keepalives_count</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>setsockopt</name><argument_list>(<argument><expr><name><name>port</name><operator>-&gt;</operator><name>sock</name></name></expr></argument>, <argument><expr><name>IPPROTO_TCP</name></expr></argument>, <argument><expr><name>TCP_KEEPCNT</name></expr></argument>,
				   <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>count</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>count</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"setsockopt(%s) failed: %m"</literal></expr></argument>, <argument><expr><literal type="string">"TCP_KEEPCNT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>STATUS_ERROR</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>port</name><operator>-&gt;</operator><name>keepalives_count</name></name> <operator>=</operator> <name>count</name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<if_stmt><if>if <condition>(<expr><name>count</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"setsockopt(%s) not supported"</literal></expr></argument>, <argument><expr><literal type="string">"TCP_KEEPCNT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>STATUS_ERROR</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<return>return <expr><name>STATUS_OK</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>pq_gettcpusertimeout</name><parameter_list>(<parameter><decl><type><name>Port</name> <modifier>*</modifier></type><name>port</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TCP_USER_TIMEOUT</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><name>port</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <call><name>IS_AF_UNIX</name><argument_list>(<argument><expr><name><name>port</name><operator>-&gt;</operator><name>laddr</name><operator>.</operator><name>addr</name><operator>.</operator><name>ss_family</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>port</name><operator>-&gt;</operator><name>tcp_user_timeout</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name><name>port</name><operator>-&gt;</operator><name>tcp_user_timeout</name></name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>port</name><operator>-&gt;</operator><name>default_tcp_user_timeout</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ACCEPT_TYPE_ARG3</name></type> <name>size</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>port</name><operator>-&gt;</operator><name>default_tcp_user_timeout</name></name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>getsockopt</name><argument_list>(<argument><expr><name><name>port</name><operator>-&gt;</operator><name>sock</name></name></expr></argument>, <argument><expr><name>IPPROTO_TCP</name></expr></argument>, <argument><expr><name>TCP_USER_TIMEOUT</name></expr></argument>,
					   <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>port</name><operator>-&gt;</operator><name>default_tcp_user_timeout</name></name></expr></argument>,
					   <argument><expr><operator>&amp;</operator><name>size</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"getsockopt(%s) failed: %m"</literal></expr></argument>, <argument><expr><literal type="string">"TCP_USER_TIMEOUT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>port</name><operator>-&gt;</operator><name>default_tcp_user_timeout</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>	<comment type="block">/* don't know */</comment>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name><name>port</name><operator>-&gt;</operator><name>default_tcp_user_timeout</name></name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>pq_settcpusertimeout</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>timeout</name></decl></parameter>, <parameter><decl><type><name>Port</name> <modifier>*</modifier></type><name>port</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>port</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <call><name>IS_AF_UNIX</name><argument_list>(<argument><expr><name><name>port</name><operator>-&gt;</operator><name>laddr</name><operator>.</operator><name>addr</name><operator>.</operator><name>ss_family</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>STATUS_OK</name></expr>;</return></block_content></block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TCP_USER_TIMEOUT</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><name>timeout</name> <operator>==</operator> <name><name>port</name><operator>-&gt;</operator><name>tcp_user_timeout</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>STATUS_OK</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>port</name><operator>-&gt;</operator><name>default_tcp_user_timeout</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>pq_gettcpusertimeout</name><argument_list>(<argument><expr><name>port</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>timeout</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>STATUS_OK</name></expr>;</return></block_content></block></if>	<comment type="block">/* default is set but unknown */</comment>
			<else>else<block type="pseudo"><block_content>
				<return>return <expr><name>STATUS_ERROR</name></expr>;</return></block_content></block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>timeout</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>timeout</name> <operator>=</operator> <name><name>port</name><operator>-&gt;</operator><name>default_tcp_user_timeout</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>setsockopt</name><argument_list>(<argument><expr><name><name>port</name><operator>-&gt;</operator><name>sock</name></name></expr></argument>, <argument><expr><name>IPPROTO_TCP</name></expr></argument>, <argument><expr><name>TCP_USER_TIMEOUT</name></expr></argument>,
				   <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>timeout</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>timeout</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"setsockopt(%s) failed: %m"</literal></expr></argument>, <argument><expr><literal type="string">"TCP_USER_TIMEOUT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>STATUS_ERROR</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>port</name><operator>-&gt;</operator><name>tcp_user_timeout</name></name> <operator>=</operator> <name>timeout</name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<if_stmt><if>if <condition>(<expr><name>timeout</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"setsockopt(%s) not supported"</literal></expr></argument>, <argument><expr><literal type="string">"TCP_USER_TIMEOUT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>STATUS_ERROR</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<return>return <expr><name>STATUS_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Check if the client is still connected.
 */</comment>
<function><type><name>bool</name></type>
<name>pq_check_connection</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>pollfd</name></name></type> <name>pollfd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>         <name>rc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>short</name></type>		<name>poll_ev_aux</name></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>POLLRDHUP</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<comment type="block">/*
	 * POLLRDHUP is a Linux extension to poll(2) to detect sockets closed by the
	 * other end.
	 * We don't have a portable way to do that without actually trying to read
	 * or write data on other systems. We don't want to read because that would
	 * be confused by pipelined queries and COPY data. Perhaps in future we'll
	 * try to write a heartbeat message instead.
	 */</comment>
	<expr_stmt><expr><name>poll_ev_aux</name> <operator>=</operator> <name>POLLRDHUP</name></expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__darwin__</name></expr></argument>)</argument_list></call></expr></cpp:elif>
	<comment type="block">/*
	 * OSX is able to detect closed sockets via single POSIX-compliant POLLHUP
	 * option
	 */</comment>
	<expr_stmt><expr><name>poll_ev_aux</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<return>return <expr><name>true</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><name><name>pollfd</name><operator>.</operator><name>fd</name></name> <operator>=</operator> <name><name>MyProcPort</name><operator>-&gt;</operator><name>sock</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pollfd</name><operator>.</operator><name>events</name></name> <operator>=</operator> <name>POLLOUT</name> <operator>|</operator> <name>POLLIN</name> <operator>|</operator> <name>poll_ev_aux</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>pollfd</name><operator>.</operator><name>revents</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>poll</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pollfd</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>rc</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>COMMERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_socket_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not poll socket: %m"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>rc</name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pollfd</name><operator>.</operator><name>revents</name></name> <operator>&amp;</operator> <operator>(</operator><name>POLLHUP</name> <operator>|</operator> <name>poll_ev_aux</name><operator>)</operator><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>
</unit>
